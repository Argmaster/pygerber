{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Home","text":"PyGerber  <p>PyGerber is a Python implementation of Gerber X3/X2 format. It is based on Ucamco's <code>The Gerber Layer Format Specification. Revision 2023.03</code> (Available on Ucamco's webpage and in this repository). The goal of this project is to provide support for wide variety of Gerber-like syntaxes, with support for most of deprecated features along with support for modern ones.</p>"},{"location":"index.html#target-set-of-tools","title":"Target set of tools:","text":"<ul> <li> Tokenizer</li> <li> Parser</li> <li> Rasterized 2D rendering engine (With       Pillow)</li> <li> Vector 2D rendering engine (With drawsvg)</li> <li> Model 3D rendering engine (With Blender)</li> <li> Formatter</li> <li> Linter (eg. deprecated syntax detection)</li> </ul> <p>You can view progress of development in Gerber features support section down below. All Gerber source files which can be redistributed under MIT license and included in this repository for testing purposes will be greatly appreciated.</p>"},{"location":"index.html#syntax-feature-requests","title":"Syntax feature requests","text":"<p>All deprecated features (Mainly those from X2 format) are considered optional and priority to implement them will be assigned based on number of requests form community.</p> <p>If You needs support for syntax features which are not mentioned in <code>The Gerber Layer Format Specification. Revision 2023.03</code> (Available on Ucamco's webpage and in this repository) and this feature is not already listed in Support paragraph, please open a new Feature request issue.</p> <p>Feature request Issue should contain:</p> <ul> <li>detailed description how requested feature works,</li> <li>code samples for testing the feature,</li> <li>reference images (only applies to features changing image look).</li> </ul> <p>Requests which don't comply with those guidelines will be considered low priority.</p>"},{"location":"index.html#installation","title":"Installation","text":"<p>PyGerber can be installed with <code>pip</code> from PyPI:</p> <pre><code>pip install pygerber\n</code></pre> <p>Alternatively, it is also possible to install it directly from repository:</p> <pre><code>pip install git+https://github.com/Argmaster/pygerber\n</code></pre>"},{"location":"index.html#usage","title":"Usage","text":"<p>PyGerber offers a high-level API that simplifies the process of rendering Gerber files. Whether you're looking to save the rendered output to a file or directly into a buffer, PyGerber has got you covered.</p> <ul> <li>The <code>Layer</code> Class: At its core, the <code>Layer</code> class stands for a single Gerber   source file, complete with its associated PyGerber configuration.</li> </ul> <p>Important <code>Layer</code> class represents any Gerber file, not layer of PCB. For   example, silkscreen Gerber file will require one instance of <code>Layer</code>, paste mask will   require another one, copper top yet another, etc.</p> <ul> <li> <p>Configuration Flexibility: The configuration possibilities you get with a <code>Layer</code>   are driven by the backend you choose to render your source file.</p> </li> <li> <p>Selecting a Backend: PyGerber provides specialized subclasses of the <code>Layer</code> class   each tied to one rendering backend. For instance, if you're aiming for 2D rasterized   images, <code>Rasterized2DLayer</code> is your go-to choice.</p> </li> <li> <p>Output Types: Keep in mind, the type of your output file is closely tied to the   backend you select.For 2D rasterized rendering   all formats supported by Pillow   are accepted.</p> </li> </ul>"},{"location":"index.html#rasterized-render-from-file","title":"Rasterized render from file","text":"render_file.py<pre><code>from pygerber.gerberx3.api import (\nColorScheme,\nRasterized2DLayer,\nRasterized2DLayerParams,\n)\n# Path to Gerber source file.\nsource_path = \"main_cu.grb\"\nRasterized2DLayer(\noptions=Rasterized2DLayerParams(\nsource_path=source_path,\ncolors=ColorScheme.COPPER_ALPHA,\n),\n).render().save(\"output.png\")\n</code></pre> <p>Example code above creates <code>Rasterized2DLayer</code> object, renders it with rasterized 2D backend and saves it as <code>PNG</code> image. Use of <code>Rasterized2DLayer</code> and <code>Rasterized2DLayerOptions</code> classes implicitly use 2D rasterized backend. To use different rendering backend with high level API, user must pick different <code>Layer</code> and <code>LayerOptions</code> subclasses. For other backends see Target set of tools section, note that only checked ones are available.</p> <p><code>source_path</code> option accepts <code>str</code> or <code>Path</code> pointing to local Gerber file. No special file extension is required, content is blindly loaded from specified file, so it's user responsibility to provide correct path. There are also <code>source_code</code> and <code>source_buffer</code> parameters which allow for use of raw <code>str</code> or <code>bytes</code> objects (first one) and <code>StringIO</code> and <code>BytesIO</code> or file descriptors (second one). <code>source_code</code>, <code>source_buffer</code> and <code>source_path</code> are mutually exclusive.</p> <p><code>ColorScheme</code> is a class which describes what colors should be used for rendering different parts of image. Additionally it has a few static members which contain predefined colors schemes for frequently used layer types. It is not required to use predefined schemes, creating and passing custom <code>ColorScheme</code> object should work perfectly fine.</p> <p>Pattern of using <code>&lt;Class&gt;</code> and <code>&lt;Class&gt;Options</code>, like above, is used in many places in PyGerber. When initializing object like <code>Rasterized2DLayer</code> it is only valid to pass <code>Rasterized2DLayerOptions</code> to constructor. Passing <code>LayerOptions</code> or <code>Vectorized2DLayer</code> will cause undefined behavior, most likely yielding no result or raising exception.</p>"},{"location":"index.html#rasterized-render-from-string","title":"Rasterized render from string","text":"render_string.py<pre><code>from pygerber.gerberx3.api import (\nColorScheme,\nRasterized2DLayer,\nRasterized2DLayerParams,\n)\nsource_code = \"\"\"\n%FSLAX26Y26*%\n%MOMM*%\n%ADD100R,1.5X1.0X0.5*%\n%ADD200C,1.5X1.0*%\n%ADD300O,1.5X1.0X0.6*%\n%ADD400P,1.5X3X5.0*%\nD100*\nX0Y0D03*\nD200*\nX0Y2000000D03*\nD300*\nX2000000Y0D03*\nD400*\nX2000000Y2000000D03*\nM02*\n\"\"\"\nRasterized2DLayer(\noptions=Rasterized2DLayerParams(\nsource_code=source_code,\ncolors=ColorScheme.SILK,\ndpi=3000,\n),\n).render().save(\"output.png\")\n</code></pre> <p>Code above renders following image:</p> <p> </p>"},{"location":"index.html#documentation","title":"Documentation","text":"<p>Official documentations is hosted on Github Pages and can be found here.</p>"},{"location":"index.html#gerber-features-support","title":"Gerber features support","text":"<p>This section outlines the support for various Gerber format features in PyGerber's core components: Tokenizer, Parser, and Rasterized2DBackend. We use checkboxes to indicate which features are currently implemented. Checked boxes represent supported features, while unchecked boxes denote features still under development or not available.</p>"},{"location":"index.html#tokenizer","title":"Tokenizer","text":"<p>Supported Gerber X3 features:</p> <ul> <li> G04 - Comment - A human readable comment, does not affect the image.</li> <li> MO - Mode - Sets the unit to mm or inch.</li> <li> FS - Format specification - Sets the coordinate format, e.g. the number of       decimals.</li> <li> FS (Deprecated modes)</li> <li> AD - Aperture define - Defines a template-based aperture, assigns a D code to it.</li> <li> AM - Aperture macro - Defines a macro aperture template.</li> <li> Dnn (nn\u226510) - Sets the current aperture to D code nn.</li> <li> D01 - Plot operation - Outside a region statement D01 creates a draw or arc object       with the current aperture. Inside it adds a draw/arc segment to the contour under       construction. The current point is moved to draw/arc end point after the creation       of the draw/arc.</li> <li> D02 - Move operation - D02 moves the current point to the coordinate in the       command. It does not create an object.</li> <li> D03 - Flash operation - Creates a flash object with the current aperture. The       current point is moved to the flash point.</li> <li> G01 - Sets linear/circular mode to linear.</li> <li> G02 - Sets linear/circular mode to clockwise circular.</li> <li> G03 - Sets linear/circular mode to counterclockwise circular.</li> <li> G75 - A G75 must be called before creating the first arc.</li> <li> LP - Load polarity - Loads the polarity object transformation parameter.</li> <li> LM - Load mirroring - Loads the mirror object transformation parameter.</li> <li> LR - Load rotation - Loads the rotation object transformation parameter.</li> <li> LS - Load scaling - Loads the scale object transformation parameter.</li> <li> G36 - Starts a region statement which creates a region by defining its contours.</li> <li> G37 - Ends the region statement.</li> <li> AB - Aperture block - Opens a block aperture statement and assigns its aperture       number or closes a block aperture statement.</li> <li> SR - Step and repeat - Open or closes a step and repeat statement.</li> <li> TF - Attribute on file - Set a file attribute.</li> <li> TA - Attribute on aperture - Add an aperture attribute to the dictionary or modify       it.</li> <li> TO - Attribute on object - Add an object attribute to the dictionary or modify it.</li> <li> TD - Attribute delete - Delete one or all attributes in the dictionary.</li> <li> M02 - End of file.</li> </ul> <p>Supported DEPRECATED Gerber features:</p> <ul> <li> G54 - Select aperture - This historic code optionally precedes an aperture       selection Dnn command. It has no effect. Sometimes used. Deprecated in 2012.</li> <li> G55 - Prepare for flash - This historic code optionally precedes D03 code. It has       no effect. Very rarely used nowadays. Deprecated in 2012.</li> <li> G70 - Set the 'Unit' to inch - These historic codes perform a function handled by       the MO command. See 4.2.1. Sometimes used. Deprecated in 2012.</li> <li> G71 - Set the 'Unit' to mm - This is part of the historic codes that perform a       function handled by the MO command.</li> <li> G90 - Set the 'Coordinate format' to 'Absolute notation' - These historic codes       perform a function handled by the FS command. Very rarely used nowadays.       Deprecated in 2012.</li> <li> <p> G91 - Set the 'Coordinate format' to 'Incremental notation' - Part of the historic       codes handled by the FS command.</p> </li> <li> <p>Important: Incremental notation itself is not supported and is not planned due     to lack of test assets and expected complications during implementation.</p> </li> <li> <p> G74 - Sets single quadrant mode - Rarely used, and then typically without effect.       Deprecated in 2020. (Spec. 8.1.10)</p> </li> <li> M00 - Program stop - This historic code has the same effect as M02. Very rarely,       if ever, used nowadays. Deprecated in 2012.</li> <li> M01 - Optional stop - This historic code has no effect. Very rarely, if ever, used       nowadays. Deprecated in 2012.</li> <li> IP - Sets the 'Image polarity' graphics state parameter - This command has no       effect in CAD to CAM workflows. Sometimes used, and then usually as %IPPOS*% to       confirm the default and then it then has no effect. Deprecated in 2013. (Spec.       8.1.4)</li> <li> AS - Sets the 'Axes correspondence' graphics state parameter - Deprecated in 2013.       Rarely used nowadays. (Spec. 8.1.2)</li> <li> IR - Sets 'Image rotation' graphics state parameter - Deprecated in 2013. Rarely       used nowadays. (Spec. 8.1.5)</li> <li> MI - Sets 'Image mirroring' graphics state parameter (Spec. 8.1.7)</li> <li> OF - Sets 'Image offset' graphics state parameter (Spec. 8.1.8)</li> <li> SF - Sets 'Scale factor' graphics state parameter (Spec. 8.1.9)</li> <li> IN - Sets the name of the file image. Has no effect. It is comment. Sometimes       used. Deprecated in 2013. (Spec. 8.1.3)</li> <li> LN - Loads a name. Has no effect. It is a comment. Sometimes used. Deprecated       in 2013. (Spec. 8.1.6)</li> <li> Combining G01/G02/G03 and D01 in a single command. (Spec 8.3.1)</li> <li> Coordinate Data without Operation Code. (Spec 8.3.2)</li> <li> Style Variations in Command Codes. (Spec 8.3.3)</li> <li> Deprecated usage of SR. (Spec 8.3.4)</li> <li> Deprecated Attribute Values. (Spec 8.4)</li> <li> <p> Format Specification (FS) Options (Trailing Zero Omission, Incremental Notation).       (Spec. 8.2)</p> </li> <li> <p>Important: Incremental notation itself is not supported and is not planned due     to lack of test assets and expected complications during implementation.</p> </li> <li> <p> Rectangular Hole in Standard Apertures (Spec. 8.2.2)</p> </li> <li> Draws and Arcs with Rectangular Apertures (Spec. 8.2.3)</li> <li> Macro Primitive Code 2, Vector Line (Spec. 8.2.4)</li> <li> Macro Primitive Code 22, Lower Left Line (Spec. 8.2.5)</li> <li> Macro Primitive Code 6, Moir\u00e9 (Spec. 8.2.6)</li> </ul>"},{"location":"index.html#parser","title":"Parser","text":"<p>Supported Gerber X3 features:</p> <ul> <li> MO - Mode - Sets the unit to mm or inch.</li> <li> FS - Format specification - Sets the coordinate format, e.g. the number of       decimals.</li> <li> AD - Aperture define - Defines a template-based aperture, assigns a D code to it.</li> <li> Define circle.</li> <li> Define rectangle.</li> <li> Define obround.</li> <li> Define polygon.</li> <li> Define macro.</li> <li> AM - Aperture macro - Defines a macro aperture template.</li> <li> Dnn (nn\u226510) - Sets the current aperture to D code nn.</li> <li> D01 - Plot operation - Outside a region statement D01 creates a draw or arc object       with the current aperture.</li> <li> D01 - Plot operation - Inside region statement adds a draw/arc segment to the       contour under construction. The current point is moved to draw/arc end point after       the creation of the draw/arc.</li> <li> D02 - Move operation - D02 moves the current point to the coordinate in the       command. It does not create an object.</li> <li> D03 - Flash operation - Creates a flash object with the current aperture. The       current point is moved to the flash point.</li> <li> G01 - Sets linear/circular mode to linear.</li> <li> G02 - Sets linear/circular mode to clockwise circular.</li> <li> G03 - Sets linear/circular mode to counterclockwise circular.</li> <li> LP - Load polarity - Loads the polarity object transformation parameter.</li> <li> LM - Load mirroring - Loads the mirror object transformation parameter.</li> <li> LR - Load rotation - Loads the rotation object transformation parameter.</li> <li> LS - Load scaling - Loads the scale object transformation parameter.</li> <li> G36 - Starts a region statement which creates a region by defining its contours.</li> <li> G37 - Ends the region statement.</li> <li> AB - Aperture block - Opens a block aperture statement and assigns its aperture       number or closes a block aperture statement.</li> <li> SR - Step and repeat - Open or closes a step and repeat statement.</li> <li> TF - Attribute on file - Set a file attribute.</li> <li> TA - Attribute on aperture - Add an aperture attribute to the dictionary or modify       it.</li> <li> TO - Attribute on object - Add an object attribute to the dictionary or modify it.</li> <li> TD - Attribute delete - Delete one or all attributes in the dictionary.</li> <li> M02 - End of file.</li> </ul> <p>Supported DEPRECATED Gerber features:</p> <ul> <li> G54 - Select aperture - This historic code optionally precedes an aperture       selection Dnn command. It has no effect. Sometimes used. Deprecated in 2012.</li> <li> G55 - Prepare for flash - This historic code optionally precedes D03 code. It has       no effect. Very rarely used nowadays. Deprecated in 2012.</li> <li> G70 - Set the 'Unit' to inch - These historic codes perform a function handled by       the MO command. See 4.2.1. Sometimes used. Deprecated in 2012.</li> <li> G71 - Set the 'Unit' to mm - This is part of the historic codes that perform a       function handled by the MO command.</li> <li> G90 - Set the 'Coordinate format' to 'Absolute notation' - These historic codes       perform a function handled by the FS command. Very rarely used nowadays.       Deprecated in 2012.</li> <li> <p> G91 - Set the 'Coordinate format' to 'Incremental notation' - Part of the historic       codes handled by the FS command.</p> </li> <li> <p>Important: Incremental notation itself is not supported and is not planned due     to lack of test assets and expected complications during implementation.</p> </li> <li> <p> G74 - Sets single quadrant mode - Rarely used, and then typically without effect.       Deprecated in 2020. (Spec. 8.1.10)</p> </li> <li> M00 - Program stop - This historic code has the same effect as M02. Very rarely,       if ever, used nowadays. Deprecated in 2012.</li> <li> M01 - Optional stop - This historic code has no effect. Very rarely, if ever, used       nowadays. Deprecated in 2012.</li> <li> IP - Sets the 'Image polarity' graphics state parameter - This command has no       effect in CAD to CAM workflows. Sometimes used, and then usually as %IPPOS*% to       confirm the default and then it then has no effect. Deprecated in 2013. (Spec.       8.1.4)</li> <li> AS - Sets the 'Axes correspondence' graphics state parameter - Deprecated in 2013.       Rarely used nowadays. (Spec. 8.1.2)</li> <li> IR - Sets 'Image rotation' graphics state parameter - Deprecated in 2013. Rarely       used nowadays. (Spec. 8.1.5)</li> <li> MI - Sets 'Image mirroring' graphics state parameter (Spec. 8.1.7)</li> <li> OF - Sets 'Image offset' graphics state parameter (Spec. 8.1.8)</li> <li> SF - Sets 'Scale factor' graphics state parameter (Spec. 8.1.9)</li> <li> IN - Sets the name of the file image. Has no effect. It is comment. Sometimes       used. Deprecated in 2013. (Spec. 8.1.3)</li> <li> LN - Loads a name. Has no effect. It is a comment. Sometimes used. Deprecated       in 2013. (Spec. 8.1.6)</li> <li> Combining G01/G02/G03/G70/G71 and D01 in a single command. (Spec 8.3.1)</li> <li> Combining G01/G02/G03/G70/G71 and D02 in a single command.</li> <li> Combining G01/G02/G03/G70/G71 and D03 in a single command.</li> <li> Coordinate Data without Operation Code. (Spec 8.3.2)</li> <li> Style Variations in Command Codes. (Spec 8.3.3)</li> <li> Deprecated usage of SR. (Spec 8.3.4)</li> <li> Deprecated Attribute Values. (Spec 8.4)</li> <li> <p> Format Specification (FS) Options (Trailing Zero Omission, Incremental Notation).       (Spec. 8.2)</p> </li> <li> <p>Important: Incremental notation itself is not supported and is not planned due     to lack of test assets and expected complications during implementation.</p> </li> <li> <p> Rectangular Hole in Standard Apertures (Spec. 8.2.2)</p> </li> <li> Draws and Arcs with Rectangular Apertures (Spec. 8.2.3)</li> <li> Macro Primitive Code 2, Vector Line (Spec. 8.2.4)</li> <li> Macro Primitive Code 22, Lower Left Line (Spec. 8.2.5)</li> <li> Macro Primitive Code 6, Moir\u00e9 (Spec. 8.2.6)</li> </ul>"},{"location":"index.html#rasterized2dbackend","title":"Rasterized2DBackend","text":"<p>Supported Gerber X3 features:</p> <ul> <li> Aperture definition with circle</li> <li> Aperture definition with rectangle</li> <li> Aperture definition with obround</li> <li> Aperture definition with polygon</li> <li> Aperture definition with macro</li> <li> Block aperture definition</li> <li> Draw flash with circle aperture</li> <li> Draw flash with rectangle aperture</li> <li> Draw flash with obround aperture</li> <li> Draw flash with polygon aperture</li> <li> Draw flash with macro aperture</li> <li> Draw flash with block aperture</li> <li> Draw line</li> <li> Draw clockwise arc</li> <li> Draw counterclockwise arc</li> <li> Global mirroring</li> <li> Global rotation</li> <li> Global scaling</li> <li> Create region</li> </ul> <p>Supported DEPRECATED Gerber features:</p> <ul> <li> Image polarity</li> <li> Image rotation</li> <li> Image mirroring</li> </ul> <p>IMPORTANT This feature list is incomplete, it will get longer over time ...</p>"},{"location":"index.html#development","title":"Development","text":"<p>To quickly set up development environment, first you have to install <code>poetry</code> globally:</p> <pre><code>pip install poetry\n</code></pre> <p>Afterwards you will be able to create development virtual environment:</p> <pre><code>poetry shell\n</code></pre> <p>Then You have to install dependencies into this environment:</p> <pre><code>poetry install\n</code></pre> <p>And pre-commit hooks:</p> <pre><code>poe install-hooks\n</code></pre> <p>Now you are good to go. Whenever you commit changes, pre-commit hooks will be invoked. If they fail or change files, you will have to re-add changes and commit again.</p>"},{"location":"index.html#build-from-source","title":"Build from source","text":"<p>To build PyGerber from source You have to set up Development environment first. Make sure you have <code>poetry</code> environment activated with:</p> <pre><code>poetry shell\n</code></pre> <p>With environment active it should be possible to build wheel and source distribution with:</p> <pre><code>poetry build\n</code></pre> <p>Check <code>dist</code> directory within current working directory, <code>pygerber-x.y.z.tar.gz</code> and <code>pygerber-x.y.z-py3-none-any.whl</code> should be there.</p>"},{"location":"Changelog.html","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Calendar Versioning.</p>"},{"location":"Changelog.html#release-202","title":"Release 2.0.2","text":"<ul> <li>Fixed incorrect bounding box prediction for displaced drawings (#105).</li> <li>Added 3.12 as supported in package tags.</li> <li>Fixed documentation links in <code>README.md</code> and <code>pyproject.toml</code>.</li> </ul>"},{"location":"Changelog.html#release-201","title":"Release 2.0.1","text":"<ul> <li>Fixed names of Gerber specification files (<code>.pdf.pdf</code> extension replaced with <code>.pdf</code>)</li> <li>Added <code>draw_region_outlines</code> option (disabled by default) which controls whether lines   which make up a region boundary should be drawn after region is filled. KiCAD seem to   assume that those boundaries are not drawn and region outline is 1px instead of   thickness of aperture.</li> <li>Changed <code>Decimal</code> precision to 60 decimal places.</li> <li>Changed precision of <code>INCH_TO_MM_MULTIPLIER</code> (now its 25.4) and   <code>MM_TO_INCH_MULTIPLIER</code> (dynamically calculated with <code>Decimal</code>).</li> <li>Changed circle aperture to make result better match expectations and <code>KiCAD</code>   reference.</li> <li>Fixed warning message logged every time a valid region was created to show up only   when region is not valid.</li> <li>Added warnings for zero surface aperture draws.</li> </ul>"},{"location":"Changelog.html#release-200","title":"Release 2.0.0","text":"<ul> <li> <p>Added Gerber X3 format tokenizer with support for selective feature support:</p> </li> <li> <p>Supported Gerber X3 features: <code>G04</code>, <code>MO</code>, <code>FS</code>, <code>AD</code>, <code>AM</code>, <code>Dnn</code> (nn\u226510), <code>D01</code>,     <code>D02</code>, <code>D03</code>, <code>G01</code>, <code>G02</code>, <code>G03</code>, <code>G75</code>, <code>LP</code>, <code>LM</code>, <code>LR</code>, <code>LS</code>, <code>G36</code>, <code>G37</code>,     <code>AB</code>, <code>SR</code>, <code>TF</code>, <code>TA</code>, <code>TO</code>,<code>TD</code>, <code>M02</code>.</p> </li> <li> <p>Supported DEPRECATED Gerber features: <code>G54</code>, <code>G70</code>, <code>G71</code>, <code>G90</code>, <code>G91</code>, <code>G74</code>,     <code>M00</code>, <code>M01</code>, <code>IP</code>, <code>LN</code>,     <code>Combining G01/G02/G03 and D01/D02/D03 in a single command</code>,     <code>Coordinate Data without Operation Code</code>, <code>Style Variations in Command Codes</code>, <code>FS</code>,     <code>Draws and Arcs with Rectangular Apertures</code>.</p> </li> </ul> <p>For more detailed descriptions of supported features please refer to documentation or   README.md.</p> <ul> <li> <p>Added Gerber X3 format parser with support for selective feature support:</p> </li> <li> <p>Supported Gerber X3 features: <code>G04</code>, <code>MO</code>, <code>FS</code>, <code>AD</code>, <code>AM</code>, <code>Dnn</code> (nn\u226510), <code>D01</code>,     <code>D02</code>, <code>D03</code>, <code>G01</code>, <code>G02</code>, <code>G03</code>, <code>G75</code>, <code>LP</code>, <code>LM</code>, <code>LR</code>, <code>LS</code>, <code>G36</code>, <code>G37</code>,     <code>M02</code>.</p> </li> <li> <p>Supported DEPRECATED Gerber features: <code>G54</code>, <code>G70</code>, <code>G71</code>, <code>G90</code>, <code>G91</code>, <code>G74</code>,     <code>M00</code>, <code>M01</code>, <code>IP</code>, <code>LN</code>, <code>Combining G01/G02/G03 and D01 in a single command</code>,     <code>Coordinate Data without Operation Code</code>, <code>Style Variations in Command Codes</code>,     <code>Draws and Arcs with Rectangular Apertures</code>.</p> </li> </ul> <p>For more detailed descriptions of supported features please refer to documentation or   README.md.</p> <ul> <li>Added rendering backend capable of producing 2D rasterized images based on parser   instructions. Supported drawing elements:</li> <li>Aperture definition with circle</li> <li>Aperture definition with rectangle</li> <li>Aperture definition with obround</li> <li>Aperture definition with polygon</li> <li>Draw flash with circle aperture</li> <li>Draw flash with rectangle aperture</li> <li>Draw flash with obround aperture</li> <li>Draw flash with polygon aperture</li> <li>Draw line</li> <li>Draw clockwise arc</li> <li>Draw counterclockwise arc</li> </ul>"},{"location":"LICENSE.html","title":"License","text":"<p>Copyright 2023 Krzysztof Wi\u015bniewski</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \u201cSoftware\u201d), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \u201cAS IS\u201d, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"gerber/advanced_api.html","title":"Advanced API","text":""},{"location":"gerber/advanced_api.html#stability","title":"Stability","text":"<p>PyGerber's Gerber advanced API is not as stable as high level API. This is because the implementation of subsequent functionalities may force changes in the structure of the code. However, our goal is to guarantee advanced API stability between patch releases.</p> <p>Security</p> <p>In case of security vulnerability, patch update may introduce API break to guarantee safety of users. Such case will be mentioned in Changelog. If it was not mentioned in Changelog, please report it.</p> <p>When comes to minor releases, it will depend on features implemented. We will explicitly note weather subsequent minor release is considered compatible with previous one, but it would be unsafe to assume that all releases will be compatible. Therefore we recommend to our users to configure their automatic updates to only automatically suggest patches while leaving minor releases for manual review.</p> <p>Incompatible patches</p> <p>Please report API breaks introduced in patches, unless they were mentioned in Changelog with justification.</p>"},{"location":"gerber/advanced_api.html#internal-execution-model","title":"Internal execution model","text":"<p>PyGerber divides the processing of a Gerber file into three stages. In this chapter we will discuss what are those stages and how each of them work. As a starting point, to make it easier to get a general idea on PyGerber's internal structure we have provided simplified flowchart of it:</p> <pre><code>flowchart TD\n    source_code([Gerber source code])\n\n    tokenizer([Tokenizer])\n\n    token_stream(\"\n    TokenStream\n    [\n    CoordinateFormat(...)\n    Comment(...)\n    Comment(...)\n    UnitMode(...)\n    LoadPolarity(...)\n    Comment(...)\n    ApertureAttribute(...)\n    ...\n    ]\n    \")\n\n    parser([Parser])\n\n    draw_commands(\"\n    DrawCommands\n    [\n    Rasterized2DDrawPaste(...)\n    Rasterized2DDrawVectorLine(...)\n    Rasterized2DDrawPaste(...)\n    Rasterized2DDrawPaste(...)\n    Rasterized2DDrawVectorLine(...)\n    Rasterized2DDrawPaste(...)\n    Rasterized2DDrawPaste(...)\n    Rasterized2DDrawVectorLine(...)\n    Rasterized2DDrawPaste(...)\n    Rasterized2DDrawPaste(...)\n    Rasterized2DDrawVectorLine(...)\n    ...\n    ]\n    \")\n\n    backend([\"Backend, eg. Rasterized2DBackend\"])\n\n    output([Output image/model])\n\n    handle([ResultHandle])\n\n    source_code --&gt; tokenizer\n\n    subgraph \"Tokenization\"\n    tokenizer:::tokenizer_cls -- \"tokenizer.tokenize()\" --&gt; token_stream\n    end\n\n    token_stream --&gt; parser\n\n    subgraph \"Parsing\"\n    parser -- \"parser.parse()\" --&gt; draw_commands\n    end\n\n    draw_commands --&gt; backend\n\n    subgraph \"Rendering\"\n    backend -- \"draw_commands.draw()\" --&gt; handle\n    end\n\n    handle -- \"handle.save()\" --&gt; output\n\n    click tokenizer \"/reference/pygerber/gerberx3/tokenizer/tokenizer.html\" \"Tokenization\"\n    click parser \"/reference/pygerber/gerberx3/parser/parser.html\" \"Parser\"\n    click backend \"/reference/pygerber/backend/abstract/backend_cls.html\" \"Backend\"</code></pre>"},{"location":"gerber/advanced_api.html#stages","title":"Stages","text":""},{"location":"gerber/advanced_api.html#tokenization","title":"Tokenization","text":"<p>Tokenization is a fundamental process in the field of formal language processing. It involves breaking down a sequence of characters (like a source code) into smaller chunks, known as tokens. Each token represents a coherent sequence of characters that symbolize a fundamental entity in the language, like keywords, operators, or identifiers.</p>"},{"location":"gerber/advanced_api.html#pygerbers-tokenization-framework","title":"PyGerber's Tokenization Framework","text":"<p>In the PyGerber library, the tokenization process is tailored to parse the Gerber X3/X2 format, which is a widely used standard for PCB (Printed Circuit Board) data files. The library uses a combination of predefined grammar rules and token classes to achieve this.</p> <p>Core Components:</p> <ol> <li> <p>Tokenizer Class: The main driver behind the tokenization process. It offers    methods like <code>tokenize</code> and <code>tokenize_expressions</code> to convert source code into a    stack of tokens.</p> </li> <li> <p>Grammar Definitions: Housed in <code>grammar.py</code>, these provide the rules to recognize    various constructs in the Gerber X3/X2 format. The library employs the <code>pyparsing</code>    module to facilitate this.</p> </li> <li> <p>Token Class: An abstract base class in <code>token.py</code>, which serves as the foundation    for all token types in the library. It provides methods for wrapping parsing    expressions, initializing tokens from parsed results, and offers basic string    representations for debugging.</p> </li> <li> <p>Concrete Token Classes: These are implementations of the abstract <code>Token</code> class.    Each of these corresponds to a specific construct in the Gerber X3/X2 format. For    instance, <code>DNNSelectAperture</code> in <code>dnn_select_aperture.py</code> is a token representing the    aperture select command in the format.</p> </li> </ol>"},{"location":"gerber/advanced_api.html#tokenization-flow","title":"Tokenization Flow:","text":"<p>Tokenization in PyGerber follows a sequence of steps visualized in the mermaid graph present in this document. Here's a high-level overview:</p> <ol> <li>The source code of a Gerber file is fed into the <code>Tokenizer</code>.</li> <li>Using the grammar rules, the <code>Tokenizer</code> breaks down the source into meaningful    chunks.</li> <li>Each chunk is matched against a specific token class based on the grammar.</li> <li>The matched tokens are then collected into a <code>TokenStack</code>.</li> <li>Post-tokenization, this stack of tokens can be used for various purposes, like    rendering, linting, or further parsing.</li> </ol>"},{"location":"gerber/advanced_api.html#parsing","title":"Parsing","text":"<p>Once the Gerber X3/X2 source code has been tokenized, the next crucial step is parsing. The <code>Parser</code> class plays a pivotal role in this phase, ensuring the sequence of tokens is processed to generate meaningful and actionable structures.</p>"},{"location":"gerber/advanced_api.html#the-process","title":"The Process:","text":"<ol> <li> <p>Parsing the Token Stack: The <code>Parser</code> class processes the token stack produced by    the tokenizer. It ensures that the token sequence conforms to the grammar rules of    the Gerber X3/X2 format. As it progresses through the stack, it translates the tokens    into a set of drawing commands that encapsulate the instructions embedded within the    source code.</p> </li> <li> <p>State Management: An integral aspect of the parsing process is the management of    the drawing state. The <code>State</code> class, found in <code>state.py</code>, maintains the current    state of the drawing. Each token parsed potentially updates this state by    implementing <code>update_drawing_state()</code> method. This method returns two things:</p> </li> <li> <p>New instance of state if state modification was necessary or old one if it was not.</p> </li> <li> <p>Iterable of drawing commands which apply visual changes to rendering target.</p> </li> <li> <p>Error Handling: Robust error handling mechanisms are embedded within the parser.    It's equipped to detect discrepancies or violations in the token sequence. If the    sequence doesn't adhere to the expected grammar or if certain tokens are missing, the    parser raises specific exceptions to flag these issues.</p> </li> <li> <p>Generating Drawing Commands: Post-parsing, a sequence of drawing commands is    produced. These commands serve as a bridge between the Gerber X3/X2 format and the    rendering engines or other components of the PyGerber library. They are primed for    further processing or visualization.</p> </li> </ol>"},{"location":"gerber/advanced_api.html#rendering","title":"Rendering","text":"<p>After the GerberX3 source code has been tokenized into individual units and subsequently parsed into meaningful structures, the next pivotal step is rendering. This step visualizes the abstract representation of the Gerber file.</p>"},{"location":"gerber/advanced_api.html#backend-infrastructure","title":"Backend Infrastructure:","text":"<p>The essence of the rendering process in PyGerber is encapsulated within its backend infrastructure. This subsystem bridges the gap between the abstract parsed structures and their visual representations.</p> <ol> <li> <p>BackendOptions:</p> </li> <li> <p>Description: A utility class furnishing additional configurations that can      influence the rendering process, such as paths for dumping aperture data or other      specific render settings.</p> </li> <li> <p>Backend:</p> </li> <li> <p>Description: This abstract base class stands as the linchpin of the rendering      process. It amalgamates the essential attributes and methods imperative for      visualization.</p> </li> <li> <p>Key Features:</p> <ul> <li>Aperture Management: It safeguards a list of aperture handles and proffers    methods to both generate and access these handles.</li> <li>Drawing Execution: This core feature takes a suite of drawing commands and    metamorphoses them into their respective visual forms.</li> <li>Bounding Area: By preserving a bounding box, the backend delineates the    spatial constraints of the drawing.</li> <li>Coordinate Management: Orchestrating the coordinate system's origin, it    ensures the precise alignment and placement of visual elements.</li> </ul> </li> <li> <p>Extensions &amp; Implementations:</p> </li> <li>The generic interface provided by <code>Backend</code> lays the foundation. Concrete      implementations, tailored to particular rendering techniques\u2014whether rasterized 2D      visuals via Pillow, vector illustrations using drawsvg, or 3D models with      Blender\u2014build upon this foundation. They take the drawing commands and adapt them      to their unique visualization mediums.</li> </ol>"},{"location":"gerber/high_level_api.html","title":"High Level API","text":"<p>PyGerber offers simple high-level API for rendering Gerber files. All necessary tools can be imported from <code>pygerber.gerberx3.api</code> module. See module reference for full object list.</p> <p>Important</p> <p>API of <code>pygerber.gerberx3.api</code> module is guaranteed to remain unchanged between patches and minor releases of PyGerber, whereas other modules, even those contained deeper in <code>pygerber.gerberx3.api</code> like <code>gerber.gerberx3.api._layers</code>, may change at any time.</p> <p>Bug</p> <p>Please report any objects which have to be imported from other places than <code>pygerber.gerberx3.api</code> for high level API, it's typechecking or error handling to work. Such situations are considered a bug.</p>"},{"location":"gerber/high_level_api.html#overview","title":"Overview","text":"<ul> <li> <p><code>Layer</code> class and it's subclasses in PyGerber API represent a Gerber file. It's   completely different meaning than in PCB design, much closer to what a image layer is   in image manipulation software, like Gimp. <code>Layer</code> class   itself it not a functional, only it's subclasses can be used to instruct PyGerber how   to render Gerber file. Based on what <code>Layer</code> subclass is used, different output image   types can be obtained. For example <code>Rasterized2DLayer</code> will allow for generating   rasterized images and saving them as JPEG, PNG, TIFF and other image formats.</p> </li> <li> <p><code>LayerParams</code> class and its subclasses are intended to be used to configure the   corresponding <code>Layer</code> classes. For example, when using <code>Rasterized2DLayer</code> for   rendering, it is only valid to pass <code>Rasterized2DLayerParams</code> to constructor. Passing   incorrect <code>LayerParams</code> subclass will result in <code>TypeError</code>.</p> </li> <li> <p><code>RenderingResult</code> class is returned from <code>render()</code> method of <code>Layer</code> instance. It   provides simple interface for saving rendering output. Different output formats will   be available depending on the layer type used. For <code>Rasterized2DLayer</code> list of   supported output formats is equivalent to list of formats supported by Pillow library.   It can be found in   Pillow documentation.</p> </li> </ul>"},{"location":"gerber/high_level_api.html#usage","title":"Usage","text":"<p>Below we provided an example of simple API use.</p> <p>We have following Gerber file:</p> render_copper_from_path.grb<pre><code>%FSLAX26Y26*%\n%MOMM*%\n%ADD10C,10X5*%\n%ADD11C,1*%\nG01*\n%LPD*%\nD11*\nX-25000000Y-1000000D02*\nX25000000Y1000000D01*\nD10*\nX0Y0D03*\nM02*\n</code></pre> <p>Which should result in simple image:</p> <p></p> <p>To achieve such result with PyGerber, first we have to import all necessary classes from <code>pygerber.gerberx3.api</code> module:</p> <pre><code>from pygerber.gerberx3.api import (\nColorScheme,\nRasterized2DLayer,\nRasterized2DLayerParams,\n)\n</code></pre> <p>We will be using <code>Rasterized2DLayer</code>, as we want to create a PNG image. <code>Rasterized2DLayerParams</code> will be necessary to specify path to source file and image color scheme, declared with <code>ColorScheme</code>:</p> <pre><code>options = Rasterized2DLayerParams(\nsource_path=\"render_copper_from_path.grb\",\ncolors=ColorScheme.COPPER_ALPHA,\n)\n</code></pre> <p><code>ColorScheme</code> creation.</p> <p><code>ColorScheme.COPPER_ALPHA</code> is a predefined color scheme, equivalent can be created manually:</p> <pre><code>ColorScheme.COPPER_ALPHA = ColorScheme(\nbackground_color=RGBA.from_rgba(0, 0, 0, 0),\nclear_color=RGBA.from_rgba(60, 181, 60, 255),\nsolid_color=RGBA.from_rgba(40, 143, 40, 255),\nclear_region_color=RGBA.from_rgba(60, 181, 60, 255),\nsolid_region_color=RGBA.from_rgba(40, 143, 40, 255),\n)\n</code></pre> <p>See reference for all possible ways of creating <code>RGBA</code> color objects and <code>ColorSchema</code> color schema objects.</p> <p>Afterwards we can create a <code>Rasterized2DLayer</code> object. Remember to provide previously constructed <code>Rasterized2DLayerParams</code> instance to constructor:</p> <pre><code>layer = Rasterized2DLayer(options=options)\n</code></pre> <p>Now we can use <code>render()</code> method of <code>Rasterized2DLayer</code> instance to create <code>RenderingResult</code>:</p> <pre><code>result = layer.render()\n</code></pre> <p>Then we can call <code>save()</code> method on <code>RenderingResult</code> to save rendered image to drive:</p> <pre><code>result = layer.save(\"output.png\")\n</code></pre> <p>Alternatively you can save image to BytesIO:</p> <pre><code>from io import BytesIO\nbuffer = BytesIO()\nresult = layer.save(buffer, format=\"PNG)\n</code></pre>"},{"location":"gerber/high_level_api.html#more-examples","title":"More examples","text":"<p>Below are few more examples showing how to provide Gerber code to <code>Layer</code> by different ways, however they are all equivalent.</p>"},{"location":"gerber/high_level_api.html#load-from-file-path","title":"Load from file path","text":"test/examples/render_copper_from_path.py<pre><code>from __future__ import annotations\nfrom pathlib import Path\nfrom pygerber.gerberx3.api import (\nColorScheme,\nRasterized2DLayer,\nRasterized2DLayerParams,\n)\ndef render() -&gt; None:\nsource_path = Path(__file__).parent / \"render_copper_from_path.grb\"\nRasterized2DLayer(\noptions=Rasterized2DLayerParams(\nsource_path=source_path,\ncolors=ColorScheme.COPPER_ALPHA,\n),\n).render().save(\"output.png\")\nif __name__ == \"__main__\":\nrender()\n</code></pre>"},{"location":"gerber/high_level_api.html#read-from-buffer","title":"Read from buffer","text":"test/examples/render_copper_from_buffer.py<pre><code>from __future__ import annotations\nfrom io import BytesIO\nfrom pygerber.gerberx3.api import (\nColorScheme,\nRasterized2DLayer,\nRasterized2DLayerParams,\n)\ndef render() -&gt; None:\nsource_buffer = BytesIO(\nb\"\"\"\n    %FSLAX26Y26*%\n    %MOMM*%\n    %ADD100R,1.5X1.0X0.5*%\n    %ADD200C,1.5X1.0*%\n    %ADD300O,1.5X1.0X0.6*%\n    %ADD400P,1.5X3X5.0*%\n    D100*\n    X0Y0D03*\n    D200*\n    X0Y2000000D03*\n    D300*\n    X2000000Y0D03*\n    D400*\n    X2000000Y2000000D03*\n    M02*\n    \"\"\",\n)\nRasterized2DLayer(\noptions=Rasterized2DLayerParams(\nsource_buffer=source_buffer,\ncolors=ColorScheme.COPPER_ALPHA,\n),\n).render().save(\"output.png\")\nif __name__ == \"__main__\":\nrender()\n</code></pre>"},{"location":"gerber/high_level_api.html#read-from-string","title":"Read from string","text":"test/examples/render_copper_from_string.py<pre><code>from __future__ import annotations\nfrom pygerber.gerberx3.api import (\nColorScheme,\nRasterized2DLayer,\nRasterized2DLayerParams,\n)\ndef render() -&gt; None:\nsource_code = \"\"\"\n%FSLAX26Y26*%\n    %MOMM*%\n    %ADD100C,1.5*%\n    D100*\n    X0Y0D03*\n    M02*\n    \"\"\"\nRasterized2DLayer(\noptions=Rasterized2DLayerParams(\nsource_code=source_code,\ncolors=ColorScheme.COPPER_ALPHA,\n),\n).render().save(\"output.png\")\nif __name__ == \"__main__\":\nrender()\n</code></pre>"},{"location":"gerber/high_level_api.html#obtaining-layer-properties","title":"Obtaining layer properties","text":"<p>I some cases it may be useful to obtain information about layer which was rendered. For example origin of coordinate system of image can be useful for aligning multiple layers on top of each other, or for other similar transformations.</p> <p>Those information can be extracted from <code>RenderingResult</code> object, returned from <code>Layer.render()</code> method. <code>RenderingResult</code> object has <code>get_properties()</code> method which returns <code>LayerProperties</code> object which contains all the necessary data to determine coordinate origins and bounding boxes of layer.</p>"},{"location":"gerber/high_level_api.html#further-reading","title":"Further reading","text":"<p>To further extend your knowledge about how to use PyGerber you could read <code>pygerber.gerberx3.api</code> module reference or see Gerber Advanced API</p>"},{"location":"gerber_specification/RS-274X.html","title":"RS-274X 2001-03","text":""},{"location":"gerber_specification/revision_2013_J1.html","title":"Revision 2013-J1","text":""},{"location":"gerber_specification/revision_2016_01.html","title":"Revision 2016-01","text":""},{"location":"gerber_specification/revision_2017_05.html","title":"Revision 2017-05","text":""},{"location":"gerber_specification/revision_2020_09.html","title":"Revision 2020-09","text":""},{"location":"gerber_specification/revision_2021_11.html","title":"Revision 2021-11","text":""},{"location":"gerber_specification/revision_2022_02.html","title":"Revision 2022-02","text":""},{"location":"gerber_specification/revision_2023_03.html","title":"Revision 2023-03","text":""},{"location":"reference/SUMMARY.html","title":"SUMMARY","text":"<ul> <li>pygerber<ul> <li>backend<ul> <li>abstract<ul> <li>aperture_handle</li> <li>backend_cls</li> <li>draw_commands<ul> <li>draw_arc</li> <li>draw_bounding_box</li> <li>draw_circle</li> <li>draw_command</li> <li>draw_paste</li> <li>draw_polygon</li> <li>draw_rectangle</li> <li>draw_region</li> <li>draw_vector_line</li> </ul> </li> <li>draw_commands_handle</li> <li>drawing_target</li> <li>errors</li> <li>result_handle</li> </ul> </li> <li>rasterized_2d<ul> <li>aperture_handle</li> <li>backend_cls</li> <li>color_scheme</li> <li>draw_commands<ul> <li>draw_arc</li> <li>draw_bounding_box</li> <li>draw_circle</li> <li>draw_paste</li> <li>draw_polygon</li> <li>draw_rectangle</li> <li>draw_region</li> <li>draw_vector_line</li> </ul> </li> <li>draw_commands_handle</li> <li>drawing_target</li> <li>errors</li> <li>image_tools</li> <li>result_handle</li> </ul> </li> </ul> </li> <li>common<ul> <li>frozen_general_model</li> <li>rgba</li> </ul> </li> <li>console</li> <li>gerberx3<ul> <li>api<ul> <li>_errors</li> <li>_layers</li> </ul> </li> <li>math<ul> <li>bounding_box</li> <li>offset</li> <li>rotate_point</li> <li>vector_2d</li> </ul> </li> <li>parser<ul> <li>errors</li> <li>parser</li> <li>state</li> </ul> </li> <li>state_enums</li> <li>tokenizer<ul> <li>errors</li> <li>grammar</li> <li>tokenizer</li> <li>tokens<ul> <li>ab_block_aperture</li> <li>ad_define_aperture</li> <li>coordinate</li> <li>d01_draw</li> <li>d02_move</li> <li>d03_flash</li> <li>dnn_select_aperture</li> <li>fs_coordinate_format</li> <li>g01_set_linear</li> <li>g02_set_clockwise_circular</li> <li>g03_set_counterclockwise_circular</li> <li>g04_comment</li> <li>g3n_region</li> <li>g54_select_aperture</li> <li>g70_set_unit_inch</li> <li>g71_set_unit_mm</li> <li>g74_single_quadrant</li> <li>g75_multi_quadrant</li> <li>g90_set_coordinate_absolute</li> <li>g91_set_coordinate_incremental</li> <li>ip_image_polarity</li> <li>lm_load_mirroring</li> <li>ln_load_name</li> <li>lp_load_polarity</li> <li>lr_load_rotation</li> <li>ls_load_scaling</li> <li>m00_program_stop</li> <li>m01_optional_stop</li> <li>m02_end_of_file</li> <li>macro<ul> <li>am_macro</li> <li>arithmetic_expression</li> <li>comment</li> <li>expression</li> <li>macro_context</li> <li>numeric_expression</li> <li>point</li> <li>primitives</li> <li>variable_definition</li> <li>variable_name</li> </ul> </li> <li>mo_unit_mode</li> <li>sr_step_repeat</li> <li>token</li> <li>tx_attributes</li> </ul> </li> </ul> </li> </ul> </li> <li>sequence_tools</li> </ul> </li> </ul>"},{"location":"reference/pygerber/__init__.html","title":"init","text":""},{"location":"reference/pygerber/__init__.html#pygerber","title":"pygerber","text":"<p>Package for PCB formats visualization.</p>"},{"location":"reference/pygerber/__init__.html#pygerber.__version__","title":"__version__  <code>module-attribute</code>","text":"<pre><code>__version__ = '2.0.2'\n</code></pre>"},{"location":"reference/pygerber/sequence_tools.html","title":"sequence_tools","text":""},{"location":"reference/pygerber/sequence_tools.html#pygerber.sequence_tools","title":"sequence_tools","text":"<p>Convenience tools for operating on sequences.</p>"},{"location":"reference/pygerber/sequence_tools.html#pygerber.sequence_tools.T","title":"T  <code>module-attribute</code>","text":"<pre><code>T = TypeVar('T')\n</code></pre>"},{"location":"reference/pygerber/sequence_tools.html#pygerber.sequence_tools.flatten_list","title":"flatten_list","text":"<pre><code>flatten_list(sequence: list[T]) -&gt; list[T]\n</code></pre> <p>Flatten a sequence.</p> Source code in <code>src/pygerber/sequence_tools.py</code> <pre><code>def flatten_list(sequence: list[T]) -&gt; list[T]:\n\"\"\"Flatten a sequence.\"\"\"\nout = []\nfor item in sequence:\nif isinstance(item, list):\nout.extend(flatten_list(item))\nelse:\nout.append(item)\nreturn out\n</code></pre>"},{"location":"reference/pygerber/sequence_tools.html#pygerber.sequence_tools.flatten","title":"flatten","text":"<pre><code>flatten(sequence: Iterable[T]) -&gt; Iterable[T]\n</code></pre> <p>Flatten a sequence.</p> Source code in <code>src/pygerber/sequence_tools.py</code> <pre><code>def flatten(sequence: Iterable[T]) -&gt; Iterable[T]:\n\"\"\"Flatten a sequence.\"\"\"\nfor item in sequence:\nif isinstance(item, (list, tuple)):\nyield from flatten(item)\nelse:\nyield item\n</code></pre>"},{"location":"reference/pygerber/sequence_tools.html#pygerber.sequence_tools.unwrap","title":"unwrap","text":"<pre><code>unwrap(item: T) -&gt; T\n</code></pre> <p>Unwrap item wrapped in sequences.</p> Source code in <code>src/pygerber/sequence_tools.py</code> <pre><code>def unwrap(item: T) -&gt; T:\n\"\"\"Unwrap item wrapped in sequences.\"\"\"\ntry:\nwhile isinstance(item, (list, tuple, ParseResults)):  # type: ignore[index]\nitem = item[0]  # type: ignore[unreachable, return-value]\nexcept (TypeError, IndexError):\npass\nreturn item  # type: ignore[unreachable, return-value]\n</code></pre>"},{"location":"reference/pygerber/backend/__init__.html","title":"init","text":""},{"location":"reference/pygerber/backend/__init__.html#pygerber.backend","title":"backend","text":"<p>Drawing backends for Gerber files rendering.</p>"},{"location":"reference/pygerber/backend/__init__.html#pygerber.backend.BackendName","title":"BackendName","text":"<p>             Bases: <code>Enum</code></p> <p>Available rendering modes.</p> Source code in <code>src/pygerber/backend/__init__.py</code> <pre><code>class BackendName(Enum):\n\"\"\"Available rendering modes.\"\"\"\nRasterized2D = \"rasterized_2d\"\nVector2D = \"vector_2d\"\nModel3D = \"model_3d\"\n@staticmethod\ndef get_backend_class(backend: str | BackendName) -&gt; type[Backend]:\n\"\"\"Return backend class.\"\"\"\nif str(backend) == BackendName.Rasterized2D.value:\nreturn Rasterized2DBackend\nraise BackendNotSupportedError(str(backend))\ndef __str__(self) -&gt; str:\nreturn self.value\n</code></pre>"},{"location":"reference/pygerber/backend/__init__.html#pygerber.backend.BackendName.get_backend_class","title":"get_backend_class  <code>staticmethod</code>","text":"<pre><code>get_backend_class(\nbackend: str | BackendName,\n) -&gt; type[Backend]\n</code></pre> <p>Return backend class.</p> Source code in <code>src/pygerber/backend/__init__.py</code> <pre><code>@staticmethod\ndef get_backend_class(backend: str | BackendName) -&gt; type[Backend]:\n\"\"\"Return backend class.\"\"\"\nif str(backend) == BackendName.Rasterized2D.value:\nreturn Rasterized2DBackend\nraise BackendNotSupportedError(str(backend))\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/__init__.html","title":"init","text":""},{"location":"reference/pygerber/backend/abstract/__init__.html#pygerber.backend.abstract","title":"abstract","text":"<p>Abstract classes for building drawing implementations.</p>"},{"location":"reference/pygerber/backend/abstract/aperture_handle.html","title":"aperture_handle","text":""},{"location":"reference/pygerber/backend/abstract/aperture_handle.html#pygerber.backend.abstract.aperture_handle","title":"aperture_handle","text":"<p>Module contains classes-handles to drawing apertures.</p>"},{"location":"reference/pygerber/backend/abstract/aperture_handle.html#pygerber.backend.abstract.aperture_handle.ExcType","title":"ExcType  <code>module-attribute</code>","text":"<pre><code>ExcType = TypeVar('ExcType', bound=BaseException)\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/aperture_handle.html#pygerber.backend.abstract.aperture_handle.PrivateApertureHandle","title":"PrivateApertureHandle","text":"<p>Base class for creating Gerber X3 apertures.</p> Source code in <code>src/pygerber/backend/abstract/aperture_handle.py</code> <pre><code>class PrivateApertureHandle:\n\"\"\"Base class for creating Gerber X3 apertures.\"\"\"\ndrawing_target: DrawingTarget\nbounding_box: BoundingBox\ndef __init__(\nself,\naperture_id: ApertureID,\nprivate_id: int,\nbackend: Backend,\n) -&gt; None:\n\"\"\"Initialize aperture handle.\"\"\"\nself.aperture_id = aperture_id\nself.private_id = private_id\nself.backend = backend\nself.aperture_draws: list[DrawCommand] = []\nself.is_plain_circle = True\ndef add_draw(self, draw: DrawCommand) -&gt; None:\n\"\"\"Add circle to aperture.\"\"\"\nif self.is_plain_circle and (\nnot isinstance(draw, DrawCircle) or len(self.aperture_draws) &gt; 1\n):\nself.is_plain_circle = False\nself.aperture_draws.append(draw)\ndef __enter__(self) -&gt; None:\npass\ndef __exit__(\nself,\nexc_type: Optional[type[ExcType]],\nexc_value: Optional[ExcType],\ntraceback: Optional[TracebackType],\n) -&gt; None:\nif exc_type is None:\nself.bounding_box = self.get_bounding_box()\nself.coordinate_origin = self._get_coordinate_origin()\nself.drawing_target = self._create_drawing_target()\ndef finalize_aperture_creation(self) -&gt; None:\n\"\"\"Draw aperture and store result.\"\"\"\nwith self.drawing_target:\nfor aperture_draw in self.aperture_draws:\naperture_draw.draw(self.drawing_target)\nself._post_drawing_hook()\ndef get_bounding_box(self) -&gt; BoundingBox:\n\"\"\"Return bounding box of draw operation.\"\"\"\nreturn self._bounding_box\n@cached_property\ndef _bounding_box(self) -&gt; BoundingBox:\nbbox: Optional[BoundingBox] = None\nfor aperture_draw in self.aperture_draws:\nif bbox is not None:\nbbox += aperture_draw.get_bounding_box()\nelse:\nbbox = aperture_draw.get_bounding_box()\nif bbox is not None:\nreturn bbox\nreturn BoundingBox.NULL\ndef _get_coordinate_origin(self) -&gt; Vector2D:\nreturn self.bounding_box.get_min_vector()\n@abstractmethod\ndef _create_drawing_target(self) -&gt; DrawingTarget:\n\"\"\"Create drawing target object.\"\"\"\ndef _post_drawing_hook(self) -&gt; None:\n\"\"\"Perform custom actions after drawing.\"\"\"\ndef get_public_handle(self) -&gt; PublicApertureHandle:\n\"\"\"Return immutable aperture handle.\"\"\"\nreturn PublicApertureHandle(\naperture_id=self.aperture_id,\nprivate_id=self.private_id,\n)\ndef get_line_width(self) -&gt; Offset:\n\"\"\"Width of line made with this aperture.\"\"\"\nbox = self.get_bounding_box()\nreturn (box.height + box.width) / 2\n@abstractmethod\ndef dump_aperture(self, dest: Path) -&gt; None:\n\"\"\"Save aperture to local file, mainly for debugging purposes.\"\"\"\ndef __str__(self) -&gt; str:\nreturn (\nf\"{self.__class__.__qualname__}(aperture_id={self.aperture_id}, \"\nf\"private_id={self.private_id})\"\n)\n__repr__ = __str__\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/aperture_handle.html#pygerber.backend.abstract.aperture_handle.PrivateApertureHandle.__init__","title":"__init__","text":"<pre><code>__init__(\naperture_id: ApertureID,\nprivate_id: int,\nbackend: Backend,\n) -&gt; None\n</code></pre> <p>Initialize aperture handle.</p> Source code in <code>src/pygerber/backend/abstract/aperture_handle.py</code> <pre><code>def __init__(\nself,\naperture_id: ApertureID,\nprivate_id: int,\nbackend: Backend,\n) -&gt; None:\n\"\"\"Initialize aperture handle.\"\"\"\nself.aperture_id = aperture_id\nself.private_id = private_id\nself.backend = backend\nself.aperture_draws: list[DrawCommand] = []\nself.is_plain_circle = True\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/aperture_handle.html#pygerber.backend.abstract.aperture_handle.PrivateApertureHandle.add_draw","title":"add_draw","text":"<pre><code>add_draw(draw: DrawCommand) -&gt; None\n</code></pre> <p>Add circle to aperture.</p> Source code in <code>src/pygerber/backend/abstract/aperture_handle.py</code> <pre><code>def add_draw(self, draw: DrawCommand) -&gt; None:\n\"\"\"Add circle to aperture.\"\"\"\nif self.is_plain_circle and (\nnot isinstance(draw, DrawCircle) or len(self.aperture_draws) &gt; 1\n):\nself.is_plain_circle = False\nself.aperture_draws.append(draw)\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/aperture_handle.html#pygerber.backend.abstract.aperture_handle.PrivateApertureHandle.finalize_aperture_creation","title":"finalize_aperture_creation","text":"<pre><code>finalize_aperture_creation() -&gt; None\n</code></pre> <p>Draw aperture and store result.</p> Source code in <code>src/pygerber/backend/abstract/aperture_handle.py</code> <pre><code>def finalize_aperture_creation(self) -&gt; None:\n\"\"\"Draw aperture and store result.\"\"\"\nwith self.drawing_target:\nfor aperture_draw in self.aperture_draws:\naperture_draw.draw(self.drawing_target)\nself._post_drawing_hook()\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/aperture_handle.html#pygerber.backend.abstract.aperture_handle.PrivateApertureHandle.get_bounding_box","title":"get_bounding_box","text":"<pre><code>get_bounding_box() -&gt; BoundingBox\n</code></pre> <p>Return bounding box of draw operation.</p> Source code in <code>src/pygerber/backend/abstract/aperture_handle.py</code> <pre><code>def get_bounding_box(self) -&gt; BoundingBox:\n\"\"\"Return bounding box of draw operation.\"\"\"\nreturn self._bounding_box\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/aperture_handle.html#pygerber.backend.abstract.aperture_handle.PrivateApertureHandle.get_public_handle","title":"get_public_handle","text":"<pre><code>get_public_handle() -&gt; PublicApertureHandle\n</code></pre> <p>Return immutable aperture handle.</p> Source code in <code>src/pygerber/backend/abstract/aperture_handle.py</code> <pre><code>def get_public_handle(self) -&gt; PublicApertureHandle:\n\"\"\"Return immutable aperture handle.\"\"\"\nreturn PublicApertureHandle(\naperture_id=self.aperture_id,\nprivate_id=self.private_id,\n)\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/aperture_handle.html#pygerber.backend.abstract.aperture_handle.PrivateApertureHandle.get_line_width","title":"get_line_width","text":"<pre><code>get_line_width() -&gt; Offset\n</code></pre> <p>Width of line made with this aperture.</p> Source code in <code>src/pygerber/backend/abstract/aperture_handle.py</code> <pre><code>def get_line_width(self) -&gt; Offset:\n\"\"\"Width of line made with this aperture.\"\"\"\nbox = self.get_bounding_box()\nreturn (box.height + box.width) / 2\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/aperture_handle.html#pygerber.backend.abstract.aperture_handle.PrivateApertureHandle.dump_aperture","title":"dump_aperture  <code>abstractmethod</code>","text":"<pre><code>dump_aperture(dest: Path) -&gt; None\n</code></pre> <p>Save aperture to local file, mainly for debugging purposes.</p> Source code in <code>src/pygerber/backend/abstract/aperture_handle.py</code> <pre><code>@abstractmethod\ndef dump_aperture(self, dest: Path) -&gt; None:\n\"\"\"Save aperture to local file, mainly for debugging purposes.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/aperture_handle.html#pygerber.backend.abstract.aperture_handle.PublicApertureHandle","title":"PublicApertureHandle","text":"<p>             Bases: <code>FrozenGeneralModel</code></p> <p>Immutable handle to drawing aperture.</p> Source code in <code>src/pygerber/backend/abstract/aperture_handle.py</code> <pre><code>class PublicApertureHandle(FrozenGeneralModel):\n\"\"\"Immutable handle to drawing aperture.\"\"\"\naperture_id: ApertureID\nprivate_id: int\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/backend_cls.html","title":"backend_cls","text":""},{"location":"reference/pygerber/backend/abstract/backend_cls.html#pygerber.backend.abstract.backend_cls","title":"backend_cls","text":"<p>Class interface for visualizing gerber files.</p>"},{"location":"reference/pygerber/backend/abstract/backend_cls.html#pygerber.backend.abstract.backend_cls.BackendOptions","title":"BackendOptions","text":"<p>Additional configuration which can be passed to backend.</p> Source code in <code>src/pygerber/backend/abstract/backend_cls.py</code> <pre><code>class BackendOptions:\n\"\"\"Additional configuration which can be passed to backend.\"\"\"\ndef __init__(\nself,\ndump_apertures: Optional[Path] = None,\n*,\ndraw_region_outlines: bool = False,\n) -&gt; None:\n\"\"\"Initialize options.\"\"\"\nself.dump_apertures = dump_apertures\nself.draw_region_outlines = draw_region_outlines\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/backend_cls.html#pygerber.backend.abstract.backend_cls.BackendOptions.__init__","title":"__init__","text":"<pre><code>__init__(\ndump_apertures: Optional[Path] = None,\n*,\ndraw_region_outlines: bool = False\n) -&gt; None\n</code></pre> <p>Initialize options.</p> Source code in <code>src/pygerber/backend/abstract/backend_cls.py</code> <pre><code>def __init__(\nself,\ndump_apertures: Optional[Path] = None,\n*,\ndraw_region_outlines: bool = False,\n) -&gt; None:\n\"\"\"Initialize options.\"\"\"\nself.dump_apertures = dump_apertures\nself.draw_region_outlines = draw_region_outlines\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/backend_cls.html#pygerber.backend.abstract.backend_cls.Backend","title":"Backend","text":"<p>             Bases: <code>ABC</code></p> <p>Drawing backend interface.</p> Source code in <code>src/pygerber/backend/abstract/backend_cls.py</code> <pre><code>class Backend(ABC):\n\"\"\"Drawing backend interface.\"\"\"\nhandles: list[PrivateApertureHandle]\ndrawing_target: DrawingTarget\nbounding_box: BoundingBox\ncoordinate_origin: Vector2D\noptions_class: ClassVar[type[BackendOptions]] = BackendOptions\ndef __init__(self, options: Optional[BackendOptions] = None) -&gt; None:\n\"\"\"Initialize backend.\"\"\"\nself.options = self.options_class() if options is None else options\nself.handles = []\ndef create_aperture_handle(self, aperture_id: ApertureID) -&gt; PrivateApertureHandle:\n\"\"\"Create new aperture handle.\"\"\"\nhandle = self.get_aperture_handle_cls()(\naperture_id=aperture_id,\nprivate_id=len(self.handles),\nbackend=self,\n)\nself.handles.append(handle)\nreturn handle\ndef get_private_aperture_handle(\nself,\npublic_aperture_handle: PublicApertureHandle,\n) -&gt; PrivateApertureHandle:\n\"\"\"Get private aperture handle.\"\"\"\nreturn self.handles[public_aperture_handle.private_id]\ndef draw(self, draws: List[DrawCommand]) -&gt; ResultHandle:\n\"\"\"Execute all draw actions to create visualization.\"\"\"\nself.draws = draws\nself.finalize_aperture_creation()\nself.bounding_box = self._get_draws_bounding_box(draws)\nself.coordinate_origin = self._get_coordinate_origin()\nself.drawing_target = self._create_drawing_target()\nself._pre_drawing_hook()\nwith self.drawing_target:\nfor draw_action in draws:\ndraw_action.draw(self.drawing_target)\nself._post_drawing_hook()\nreturn self.get_result_handle()\ndef finalize_aperture_creation(self) -&gt; None:\n\"\"\"Apply draw operations to aperture handles.\"\"\"\nfor handle in self.handles:\nhandle.finalize_aperture_creation()\ndef _get_draws_bounding_box(self, draws: List[DrawCommand]) -&gt; BoundingBox:\nbbox: Optional[BoundingBox] = None\nfor draw in draws:\nif bbox is not None:\nbbox += draw.get_bounding_box()\nelse:\nbbox = draw.get_bounding_box()\nif bbox is not None:\nreturn bbox\nreturn BoundingBox.NULL\ndef _get_coordinate_origin(self) -&gt; Vector2D:\nreturn self.bounding_box.get_min_vector()\n@abstractmethod\ndef _create_drawing_target(self) -&gt; DrawingTarget:\n\"\"\"Create drawing target object.\"\"\"\ndef _pre_drawing_hook(self) -&gt; None:  # noqa: B027\n\"\"\"Perform custom actions before drawing.\"\"\"\ndef _post_drawing_hook(self) -&gt; None:  # noqa: B027\n\"\"\"Perform custom actions after drawing.\"\"\"\n@abstractmethod\ndef get_result_handle(self) -&gt; ResultHandle:\n\"\"\"Return result handle to visualization.\"\"\"\n@abstractmethod\ndef get_aperture_handle_cls(self) -&gt; Type[PrivateApertureHandle]:\n\"\"\"Get backend-specific implementation of aperture handle class.\"\"\"\n@abstractmethod\ndef get_draw_circle_cls(self) -&gt; Type[DrawCircle]:\n\"\"\"Get backend-specific implementation of aperture circle component class.\"\"\"\n@abstractmethod\ndef get_draw_rectangle_cls(self) -&gt; Type[DrawRectangle]:\n\"\"\"Get backend-specific implementation of aperture rectangle component class.\"\"\"\n@abstractmethod\ndef get_draw_polygon_cls(self) -&gt; Type[DrawPolygon]:\n\"\"\"Get backend-specific implementation of aperture polygon component class.\"\"\"\n@abstractmethod\ndef get_draw_commands_handle_cls(self) -&gt; type[DrawCommandsHandle]:\n\"\"\"Return backend-specific implementation of draw actions handle.\"\"\"\n@abstractmethod\ndef get_draw_paste_cls(self) -&gt; type[DrawPaste]:\n\"\"\"Return backend-specific implementation of draw paste.\"\"\"\n@abstractmethod\ndef get_draw_region_cls(self) -&gt; type[DrawRegion]:\n\"\"\"Return backend-specific implementation of draw action region.\"\"\"\n@abstractmethod\ndef get_draw_vector_line_cls(self) -&gt; type[DrawVectorLine]:\n\"\"\"Return backend-specific implementation of draw action line.\"\"\"\n@abstractmethod\ndef get_draw_arc_cls(self) -&gt; type[DrawArc]:\n\"\"\"Return backend-specific implementation of draw action arc.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/backend_cls.html#pygerber.backend.abstract.backend_cls.Backend.__init__","title":"__init__","text":"<pre><code>__init__(options: Optional[BackendOptions] = None) -&gt; None\n</code></pre> <p>Initialize backend.</p> Source code in <code>src/pygerber/backend/abstract/backend_cls.py</code> <pre><code>def __init__(self, options: Optional[BackendOptions] = None) -&gt; None:\n\"\"\"Initialize backend.\"\"\"\nself.options = self.options_class() if options is None else options\nself.handles = []\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/backend_cls.html#pygerber.backend.abstract.backend_cls.Backend.create_aperture_handle","title":"create_aperture_handle","text":"<pre><code>create_aperture_handle(\naperture_id: ApertureID,\n) -&gt; PrivateApertureHandle\n</code></pre> <p>Create new aperture handle.</p> Source code in <code>src/pygerber/backend/abstract/backend_cls.py</code> <pre><code>def create_aperture_handle(self, aperture_id: ApertureID) -&gt; PrivateApertureHandle:\n\"\"\"Create new aperture handle.\"\"\"\nhandle = self.get_aperture_handle_cls()(\naperture_id=aperture_id,\nprivate_id=len(self.handles),\nbackend=self,\n)\nself.handles.append(handle)\nreturn handle\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/backend_cls.html#pygerber.backend.abstract.backend_cls.Backend.get_private_aperture_handle","title":"get_private_aperture_handle","text":"<pre><code>get_private_aperture_handle(\npublic_aperture_handle: PublicApertureHandle,\n) -&gt; PrivateApertureHandle\n</code></pre> <p>Get private aperture handle.</p> Source code in <code>src/pygerber/backend/abstract/backend_cls.py</code> <pre><code>def get_private_aperture_handle(\nself,\npublic_aperture_handle: PublicApertureHandle,\n) -&gt; PrivateApertureHandle:\n\"\"\"Get private aperture handle.\"\"\"\nreturn self.handles[public_aperture_handle.private_id]\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/backend_cls.html#pygerber.backend.abstract.backend_cls.Backend.draw","title":"draw","text":"<pre><code>draw(draws: List[DrawCommand]) -&gt; ResultHandle\n</code></pre> <p>Execute all draw actions to create visualization.</p> Source code in <code>src/pygerber/backend/abstract/backend_cls.py</code> <pre><code>def draw(self, draws: List[DrawCommand]) -&gt; ResultHandle:\n\"\"\"Execute all draw actions to create visualization.\"\"\"\nself.draws = draws\nself.finalize_aperture_creation()\nself.bounding_box = self._get_draws_bounding_box(draws)\nself.coordinate_origin = self._get_coordinate_origin()\nself.drawing_target = self._create_drawing_target()\nself._pre_drawing_hook()\nwith self.drawing_target:\nfor draw_action in draws:\ndraw_action.draw(self.drawing_target)\nself._post_drawing_hook()\nreturn self.get_result_handle()\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/backend_cls.html#pygerber.backend.abstract.backend_cls.Backend.finalize_aperture_creation","title":"finalize_aperture_creation","text":"<pre><code>finalize_aperture_creation() -&gt; None\n</code></pre> <p>Apply draw operations to aperture handles.</p> Source code in <code>src/pygerber/backend/abstract/backend_cls.py</code> <pre><code>def finalize_aperture_creation(self) -&gt; None:\n\"\"\"Apply draw operations to aperture handles.\"\"\"\nfor handle in self.handles:\nhandle.finalize_aperture_creation()\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/backend_cls.html#pygerber.backend.abstract.backend_cls.Backend.get_result_handle","title":"get_result_handle  <code>abstractmethod</code>","text":"<pre><code>get_result_handle() -&gt; ResultHandle\n</code></pre> <p>Return result handle to visualization.</p> Source code in <code>src/pygerber/backend/abstract/backend_cls.py</code> <pre><code>@abstractmethod\ndef get_result_handle(self) -&gt; ResultHandle:\n\"\"\"Return result handle to visualization.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/backend_cls.html#pygerber.backend.abstract.backend_cls.Backend.get_aperture_handle_cls","title":"get_aperture_handle_cls  <code>abstractmethod</code>","text":"<pre><code>get_aperture_handle_cls() -&gt; Type[PrivateApertureHandle]\n</code></pre> <p>Get backend-specific implementation of aperture handle class.</p> Source code in <code>src/pygerber/backend/abstract/backend_cls.py</code> <pre><code>@abstractmethod\ndef get_aperture_handle_cls(self) -&gt; Type[PrivateApertureHandle]:\n\"\"\"Get backend-specific implementation of aperture handle class.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/backend_cls.html#pygerber.backend.abstract.backend_cls.Backend.get_draw_circle_cls","title":"get_draw_circle_cls  <code>abstractmethod</code>","text":"<pre><code>get_draw_circle_cls() -&gt; Type[DrawCircle]\n</code></pre> <p>Get backend-specific implementation of aperture circle component class.</p> Source code in <code>src/pygerber/backend/abstract/backend_cls.py</code> <pre><code>@abstractmethod\ndef get_draw_circle_cls(self) -&gt; Type[DrawCircle]:\n\"\"\"Get backend-specific implementation of aperture circle component class.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/backend_cls.html#pygerber.backend.abstract.backend_cls.Backend.get_draw_rectangle_cls","title":"get_draw_rectangle_cls  <code>abstractmethod</code>","text":"<pre><code>get_draw_rectangle_cls() -&gt; Type[DrawRectangle]\n</code></pre> <p>Get backend-specific implementation of aperture rectangle component class.</p> Source code in <code>src/pygerber/backend/abstract/backend_cls.py</code> <pre><code>@abstractmethod\ndef get_draw_rectangle_cls(self) -&gt; Type[DrawRectangle]:\n\"\"\"Get backend-specific implementation of aperture rectangle component class.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/backend_cls.html#pygerber.backend.abstract.backend_cls.Backend.get_draw_polygon_cls","title":"get_draw_polygon_cls  <code>abstractmethod</code>","text":"<pre><code>get_draw_polygon_cls() -&gt; Type[DrawPolygon]\n</code></pre> <p>Get backend-specific implementation of aperture polygon component class.</p> Source code in <code>src/pygerber/backend/abstract/backend_cls.py</code> <pre><code>@abstractmethod\ndef get_draw_polygon_cls(self) -&gt; Type[DrawPolygon]:\n\"\"\"Get backend-specific implementation of aperture polygon component class.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/backend_cls.html#pygerber.backend.abstract.backend_cls.Backend.get_draw_commands_handle_cls","title":"get_draw_commands_handle_cls  <code>abstractmethod</code>","text":"<pre><code>get_draw_commands_handle_cls() -&gt; type[DrawCommandsHandle]\n</code></pre> <p>Return backend-specific implementation of draw actions handle.</p> Source code in <code>src/pygerber/backend/abstract/backend_cls.py</code> <pre><code>@abstractmethod\ndef get_draw_commands_handle_cls(self) -&gt; type[DrawCommandsHandle]:\n\"\"\"Return backend-specific implementation of draw actions handle.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/backend_cls.html#pygerber.backend.abstract.backend_cls.Backend.get_draw_paste_cls","title":"get_draw_paste_cls  <code>abstractmethod</code>","text":"<pre><code>get_draw_paste_cls() -&gt; type[DrawPaste]\n</code></pre> <p>Return backend-specific implementation of draw paste.</p> Source code in <code>src/pygerber/backend/abstract/backend_cls.py</code> <pre><code>@abstractmethod\ndef get_draw_paste_cls(self) -&gt; type[DrawPaste]:\n\"\"\"Return backend-specific implementation of draw paste.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/backend_cls.html#pygerber.backend.abstract.backend_cls.Backend.get_draw_region_cls","title":"get_draw_region_cls  <code>abstractmethod</code>","text":"<pre><code>get_draw_region_cls() -&gt; type[DrawRegion]\n</code></pre> <p>Return backend-specific implementation of draw action region.</p> Source code in <code>src/pygerber/backend/abstract/backend_cls.py</code> <pre><code>@abstractmethod\ndef get_draw_region_cls(self) -&gt; type[DrawRegion]:\n\"\"\"Return backend-specific implementation of draw action region.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/backend_cls.html#pygerber.backend.abstract.backend_cls.Backend.get_draw_vector_line_cls","title":"get_draw_vector_line_cls  <code>abstractmethod</code>","text":"<pre><code>get_draw_vector_line_cls() -&gt; type[DrawVectorLine]\n</code></pre> <p>Return backend-specific implementation of draw action line.</p> Source code in <code>src/pygerber/backend/abstract/backend_cls.py</code> <pre><code>@abstractmethod\ndef get_draw_vector_line_cls(self) -&gt; type[DrawVectorLine]:\n\"\"\"Return backend-specific implementation of draw action line.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/backend_cls.html#pygerber.backend.abstract.backend_cls.Backend.get_draw_arc_cls","title":"get_draw_arc_cls  <code>abstractmethod</code>","text":"<pre><code>get_draw_arc_cls() -&gt; type[DrawArc]\n</code></pre> <p>Return backend-specific implementation of draw action arc.</p> Source code in <code>src/pygerber/backend/abstract/backend_cls.py</code> <pre><code>@abstractmethod\ndef get_draw_arc_cls(self) -&gt; type[DrawArc]:\n\"\"\"Return backend-specific implementation of draw action arc.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/draw_commands_handle.html","title":"draw_commands_handle","text":""},{"location":"reference/pygerber/backend/abstract/draw_commands_handle.html#pygerber.backend.abstract.draw_commands_handle","title":"draw_commands_handle","text":"<p>Contains class wrapping list of draw operations created by Gerber parser.</p>"},{"location":"reference/pygerber/backend/abstract/draw_commands_handle.html#pygerber.backend.abstract.draw_commands_handle.DrawCommandsHandle","title":"DrawCommandsHandle","text":"<p>List of drawing operations produced by Gerber parser.</p> Source code in <code>src/pygerber/backend/abstract/draw_commands_handle.py</code> <pre><code>class DrawCommandsHandle:\n\"\"\"List of drawing operations produced by Gerber parser.\"\"\"\ndef __init__(self, draw_actions: List[DrawCommand], backend: Backend) -&gt; None:\n\"\"\"Initialize drawing instructions.\"\"\"\nself.draw_commands = draw_actions\nself.backend = backend\ndef draw(self) -&gt; ResultHandle:\n\"\"\"Create visualization based on drawing instructions.\"\"\"\nreturn self.backend.draw(self.draw_commands)\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/draw_commands_handle.html#pygerber.backend.abstract.draw_commands_handle.DrawCommandsHandle.__init__","title":"__init__","text":"<pre><code>__init__(\ndraw_actions: List[DrawCommand], backend: Backend\n) -&gt; None\n</code></pre> <p>Initialize drawing instructions.</p> Source code in <code>src/pygerber/backend/abstract/draw_commands_handle.py</code> <pre><code>def __init__(self, draw_actions: List[DrawCommand], backend: Backend) -&gt; None:\n\"\"\"Initialize drawing instructions.\"\"\"\nself.draw_commands = draw_actions\nself.backend = backend\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/draw_commands_handle.html#pygerber.backend.abstract.draw_commands_handle.DrawCommandsHandle.draw","title":"draw","text":"<pre><code>draw() -&gt; ResultHandle\n</code></pre> <p>Create visualization based on drawing instructions.</p> Source code in <code>src/pygerber/backend/abstract/draw_commands_handle.py</code> <pre><code>def draw(self) -&gt; ResultHandle:\n\"\"\"Create visualization based on drawing instructions.\"\"\"\nreturn self.backend.draw(self.draw_commands)\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/drawing_target.html","title":"drawing_target","text":""},{"location":"reference/pygerber/backend/abstract/drawing_target.html#pygerber.backend.abstract.drawing_target","title":"drawing_target","text":"<p>Target for Draw commands to draw into.</p>"},{"location":"reference/pygerber/backend/abstract/drawing_target.html#pygerber.backend.abstract.drawing_target.ExcType","title":"ExcType  <code>module-attribute</code>","text":"<pre><code>ExcType = TypeVar('ExcType', bound=BaseException)\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/drawing_target.html#pygerber.backend.abstract.drawing_target.DrawingTarget","title":"DrawingTarget","text":"<p>Target for Draw commands to draw into.</p> Source code in <code>src/pygerber/backend/abstract/drawing_target.py</code> <pre><code>class DrawingTarget:\n\"\"\"Target for Draw commands to draw into.\"\"\"\ncoordinate_origin: Vector2D\nbounding_box: BoundingBox\ndef __init__(self, coordinate_origin: Vector2D, bounding_box: BoundingBox) -&gt; None:\n\"\"\"Initialize drawing target.\"\"\"\nself.coordinate_origin = coordinate_origin\nself.bounding_box = bounding_box\ndef __enter__(self) -&gt; None:\npass\ndef __exit__(\nself,\nexc_type: Optional[type[ExcType]],\nexc_value: Optional[ExcType],\ntraceback: Optional[TracebackType],\n) -&gt; None:\nif exc_type is None:\nself._finalize()\ndef _finalize(self) -&gt; None:\n\"\"\"Call at the end of image modification.\n        After this call no modifications to image are allowed.\n        \"\"\"\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/drawing_target.html#pygerber.backend.abstract.drawing_target.DrawingTarget.__init__","title":"__init__","text":"<pre><code>__init__(\ncoordinate_origin: Vector2D, bounding_box: BoundingBox\n) -&gt; None\n</code></pre> <p>Initialize drawing target.</p> Source code in <code>src/pygerber/backend/abstract/drawing_target.py</code> <pre><code>def __init__(self, coordinate_origin: Vector2D, bounding_box: BoundingBox) -&gt; None:\n\"\"\"Initialize drawing target.\"\"\"\nself.coordinate_origin = coordinate_origin\nself.bounding_box = bounding_box\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/errors.html","title":"errors","text":""},{"location":"reference/pygerber/backend/abstract/errors.html#pygerber.backend.abstract.errors","title":"errors","text":"<p>Base error classes used in this module.</p>"},{"location":"reference/pygerber/backend/abstract/errors.html#pygerber.backend.abstract.errors.BackendError","title":"BackendError","text":"<p>             Bases: <code>ValueError</code></p> <p>Base class for backend errors.</p> Source code in <code>src/pygerber/backend/abstract/errors.py</code> <pre><code>class BackendError(ValueError):\n\"\"\"Base class for backend errors.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/errors.html#pygerber.backend.abstract.errors.BackendNotSupportedError","title":"BackendNotSupportedError","text":"<p>             Bases: <code>BackendError</code></p> <p>Raised when requesting backend which is not officially supported.</p> Source code in <code>src/pygerber/backend/abstract/errors.py</code> <pre><code>class BackendNotSupportedError(BackendError):\n\"\"\"Raised when requesting backend which is not officially supported.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/result_handle.html","title":"result_handle","text":""},{"location":"reference/pygerber/backend/abstract/result_handle.html#pygerber.backend.abstract.result_handle","title":"result_handle","text":"<p>Module contains handle class to drawing instructions visualization.</p>"},{"location":"reference/pygerber/backend/abstract/result_handle.html#pygerber.backend.abstract.result_handle.ResultHandle","title":"ResultHandle","text":"<p>             Bases: <code>ABC</code></p> <p>Handle to drawing instructions visualization.</p> Source code in <code>src/pygerber/backend/abstract/result_handle.py</code> <pre><code>class ResultHandle(ABC):\n\"\"\"Handle to drawing instructions visualization.\"\"\"\n@abstractmethod\ndef save(\nself,\ndest: Path | str | BytesIO,\n**kwargs: Any,\n) -&gt; None:\n\"\"\"Save result to destination.\n        All additional parameters are passed to underlying saving system.\n        For more details see documentation of concrete implementations.\n        \"\"\"\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/result_handle.html#pygerber.backend.abstract.result_handle.ResultHandle.save","title":"save  <code>abstractmethod</code>","text":"<pre><code>save(dest: Path | str | BytesIO, **kwargs: Any) -&gt; None\n</code></pre> <p>Save result to destination.</p> <p>All additional parameters are passed to underlying saving system. For more details see documentation of concrete implementations.</p> Source code in <code>src/pygerber/backend/abstract/result_handle.py</code> <pre><code>@abstractmethod\ndef save(\nself,\ndest: Path | str | BytesIO,\n**kwargs: Any,\n) -&gt; None:\n\"\"\"Save result to destination.\n    All additional parameters are passed to underlying saving system.\n    For more details see documentation of concrete implementations.\n    \"\"\"\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/draw_commands/__init__.html","title":"init","text":""},{"location":"reference/pygerber/backend/abstract/draw_commands/__init__.html#pygerber.backend.abstract.draw_commands","title":"draw_commands","text":"<p>Draw operations for constructing apertures.</p>"},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_arc.html","title":"draw_arc","text":""},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_arc.html#pygerber.backend.abstract.draw_commands.draw_arc","title":"draw_arc","text":"<p>Base class for creating components for aperture creation.</p>"},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_arc.html#pygerber.backend.abstract.draw_commands.draw_arc.DrawArc","title":"DrawArc","text":"<p>             Bases: <code>DrawCommand</code></p> <p>Description of aperture component.</p> Source code in <code>src/pygerber/backend/abstract/draw_commands/draw_arc.py</code> <pre><code>class DrawArc(DrawCommand):\n\"\"\"Description of aperture component.\"\"\"\nstart_position: Vector2D\ndx_dy_center: Vector2D\nend_position: Vector2D\nwidth: Offset\nis_clockwise: bool\nis_multi_quadrant: bool\ndef __init__(  # noqa: PLR0913\nself,\nbackend: Backend,\npolarity: Polarity,\nstart_position: Vector2D,\ndx_dy_center: Vector2D,\nend_position: Vector2D,\nwidth: Offset,\n*,\nis_clockwise: bool,\nis_multi_quadrant: bool,\n) -&gt; None:\n\"\"\"Initialize draw command.\"\"\"\nsuper().__init__(backend, polarity)\nself.start_position = start_position\nself.dx_dy_center = dx_dy_center\nself.end_position = end_position\nself.width = width\nself.is_clockwise = is_clockwise\nself.is_multi_quadrant = is_multi_quadrant\n@property\ndef arc_center_absolute(self) -&gt; Vector2D:\n\"\"\"Return absolute coordinates of arc center point.\"\"\"\nreturn self.start_position + self.dx_dy_center\n@property\ndef arc_space_arc_center(self) -&gt; Vector2D:\n\"\"\"Return arc center coordinates relative to arc center.\"\"\"\nreturn self.arc_center_absolute - self.arc_center_absolute\n@property\ndef arc_space_start_position(self) -&gt; Vector2D:\n\"\"\"Return arc start coordinates relative to arc center.\"\"\"\nreturn self.start_position - self.arc_center_absolute\n@property\ndef arc_space_end_position(self) -&gt; Vector2D:\n\"\"\"Return arc end coordinates relative to arc center.\"\"\"\nreturn self.end_position - self.arc_center_absolute\n@property\ndef arc_radius(self) -&gt; Offset:\n\"\"\"Return arc radius.\"\"\"\nreturn self.dx_dy_center.length()\ndef get_bounding_box(self) -&gt; BoundingBox:\n\"\"\"Return bounding box of draw operation.\"\"\"\nreturn self._bounding_box\n@cached_property\ndef _bounding_box(self) -&gt; BoundingBox:\nvertex_box = BoundingBox.from_diameter(self.width)\nradius = self.arc_radius\nreturn (vertex_box + (self.arc_center_absolute + radius)) + (\nvertex_box + (self.arc_center_absolute - radius)\n)\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_arc.html#pygerber.backend.abstract.draw_commands.draw_arc.DrawArc.arc_center_absolute","title":"arc_center_absolute  <code>property</code>","text":"<pre><code>arc_center_absolute: Vector2D\n</code></pre> <p>Return absolute coordinates of arc center point.</p>"},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_arc.html#pygerber.backend.abstract.draw_commands.draw_arc.DrawArc.arc_space_arc_center","title":"arc_space_arc_center  <code>property</code>","text":"<pre><code>arc_space_arc_center: Vector2D\n</code></pre> <p>Return arc center coordinates relative to arc center.</p>"},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_arc.html#pygerber.backend.abstract.draw_commands.draw_arc.DrawArc.arc_space_start_position","title":"arc_space_start_position  <code>property</code>","text":"<pre><code>arc_space_start_position: Vector2D\n</code></pre> <p>Return arc start coordinates relative to arc center.</p>"},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_arc.html#pygerber.backend.abstract.draw_commands.draw_arc.DrawArc.arc_space_end_position","title":"arc_space_end_position  <code>property</code>","text":"<pre><code>arc_space_end_position: Vector2D\n</code></pre> <p>Return arc end coordinates relative to arc center.</p>"},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_arc.html#pygerber.backend.abstract.draw_commands.draw_arc.DrawArc.arc_radius","title":"arc_radius  <code>property</code>","text":"<pre><code>arc_radius: Offset\n</code></pre> <p>Return arc radius.</p>"},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_arc.html#pygerber.backend.abstract.draw_commands.draw_arc.DrawArc.__init__","title":"__init__","text":"<pre><code>__init__(\nbackend: Backend,\npolarity: Polarity,\nstart_position: Vector2D,\ndx_dy_center: Vector2D,\nend_position: Vector2D,\nwidth: Offset,\n*,\nis_clockwise: bool,\nis_multi_quadrant: bool\n) -&gt; None\n</code></pre> <p>Initialize draw command.</p> Source code in <code>src/pygerber/backend/abstract/draw_commands/draw_arc.py</code> <pre><code>def __init__(  # noqa: PLR0913\nself,\nbackend: Backend,\npolarity: Polarity,\nstart_position: Vector2D,\ndx_dy_center: Vector2D,\nend_position: Vector2D,\nwidth: Offset,\n*,\nis_clockwise: bool,\nis_multi_quadrant: bool,\n) -&gt; None:\n\"\"\"Initialize draw command.\"\"\"\nsuper().__init__(backend, polarity)\nself.start_position = start_position\nself.dx_dy_center = dx_dy_center\nself.end_position = end_position\nself.width = width\nself.is_clockwise = is_clockwise\nself.is_multi_quadrant = is_multi_quadrant\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_arc.html#pygerber.backend.abstract.draw_commands.draw_arc.DrawArc.get_bounding_box","title":"get_bounding_box","text":"<pre><code>get_bounding_box() -&gt; BoundingBox\n</code></pre> <p>Return bounding box of draw operation.</p> Source code in <code>src/pygerber/backend/abstract/draw_commands/draw_arc.py</code> <pre><code>def get_bounding_box(self) -&gt; BoundingBox:\n\"\"\"Return bounding box of draw operation.\"\"\"\nreturn self._bounding_box\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_bounding_box.html","title":"draw_bounding_box","text":""},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_bounding_box.html#pygerber.backend.abstract.draw_commands.draw_bounding_box","title":"draw_bounding_box","text":"<p>BoundingBox component for creating apertures.</p>"},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_bounding_box.html#pygerber.backend.abstract.draw_commands.draw_bounding_box.DrawBoundingBox","title":"DrawBoundingBox","text":"<p>             Bases: <code>DrawCommand</code></p> <p>Description of BoundingBox component.</p> Source code in <code>src/pygerber/backend/abstract/draw_commands/draw_bounding_box.py</code> <pre><code>class DrawBoundingBox(DrawCommand):\n\"\"\"Description of BoundingBox component.\"\"\"\nbounding_box: BoundingBox\noutline_padding: Offset\ndef __init__(\nself,\nbackend: Backend,\npolarity: Polarity,\nbounding_box: BoundingBox,\noutline_padding: Offset,\n) -&gt; None:\n\"\"\"Initialize draw command.\"\"\"\nsuper().__init__(backend, polarity)\nself.bounding_box = bounding_box\nself.outline_padding = outline_padding\ndef get_bounding_box(self) -&gt; BoundingBox:\n\"\"\"Return bounding box of draw operation.\"\"\"\nreturn self._bounding_box\n@cached_property\ndef _bounding_box(self) -&gt; BoundingBox:\nreturn self.bounding_box + self.outline_padding\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_bounding_box.html#pygerber.backend.abstract.draw_commands.draw_bounding_box.DrawBoundingBox.__init__","title":"__init__","text":"<pre><code>__init__(\nbackend: Backend,\npolarity: Polarity,\nbounding_box: BoundingBox,\noutline_padding: Offset,\n) -&gt; None\n</code></pre> <p>Initialize draw command.</p> Source code in <code>src/pygerber/backend/abstract/draw_commands/draw_bounding_box.py</code> <pre><code>def __init__(\nself,\nbackend: Backend,\npolarity: Polarity,\nbounding_box: BoundingBox,\noutline_padding: Offset,\n) -&gt; None:\n\"\"\"Initialize draw command.\"\"\"\nsuper().__init__(backend, polarity)\nself.bounding_box = bounding_box\nself.outline_padding = outline_padding\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_bounding_box.html#pygerber.backend.abstract.draw_commands.draw_bounding_box.DrawBoundingBox.get_bounding_box","title":"get_bounding_box","text":"<pre><code>get_bounding_box() -&gt; BoundingBox\n</code></pre> <p>Return bounding box of draw operation.</p> Source code in <code>src/pygerber/backend/abstract/draw_commands/draw_bounding_box.py</code> <pre><code>def get_bounding_box(self) -&gt; BoundingBox:\n\"\"\"Return bounding box of draw operation.\"\"\"\nreturn self._bounding_box\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_circle.html","title":"draw_circle","text":""},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_circle.html#pygerber.backend.abstract.draw_commands.draw_circle","title":"draw_circle","text":"<p>Circle component for creating apertures.</p>"},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_circle.html#pygerber.backend.abstract.draw_commands.draw_circle.DrawCircle","title":"DrawCircle","text":"<p>             Bases: <code>DrawCommand</code></p> <p>Description of circle aperture component.</p> Source code in <code>src/pygerber/backend/abstract/draw_commands/draw_circle.py</code> <pre><code>class DrawCircle(DrawCommand):\n\"\"\"Description of circle aperture component.\"\"\"\ncenter_position: Vector2D\ndiameter: Offset\ndef __init__(\nself,\nbackend: Backend,\npolarity: Polarity,\ncenter_position: Vector2D,\ndiameter: Offset,\n) -&gt; None:\n\"\"\"Initialize draw command.\"\"\"\nsuper().__init__(backend, polarity)\nself.center_position = center_position\nself.diameter = diameter\ndef get_bounding_box(self) -&gt; BoundingBox:\n\"\"\"Return bounding box of draw operation.\"\"\"\nreturn self._bounding_box\n@cached_property\ndef _bounding_box(self) -&gt; BoundingBox:\nreturn BoundingBox.from_diameter(self.diameter) + self.center_position\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_circle.html#pygerber.backend.abstract.draw_commands.draw_circle.DrawCircle.__init__","title":"__init__","text":"<pre><code>__init__(\nbackend: Backend,\npolarity: Polarity,\ncenter_position: Vector2D,\ndiameter: Offset,\n) -&gt; None\n</code></pre> <p>Initialize draw command.</p> Source code in <code>src/pygerber/backend/abstract/draw_commands/draw_circle.py</code> <pre><code>def __init__(\nself,\nbackend: Backend,\npolarity: Polarity,\ncenter_position: Vector2D,\ndiameter: Offset,\n) -&gt; None:\n\"\"\"Initialize draw command.\"\"\"\nsuper().__init__(backend, polarity)\nself.center_position = center_position\nself.diameter = diameter\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_circle.html#pygerber.backend.abstract.draw_commands.draw_circle.DrawCircle.get_bounding_box","title":"get_bounding_box","text":"<pre><code>get_bounding_box() -&gt; BoundingBox\n</code></pre> <p>Return bounding box of draw operation.</p> Source code in <code>src/pygerber/backend/abstract/draw_commands/draw_circle.py</code> <pre><code>def get_bounding_box(self) -&gt; BoundingBox:\n\"\"\"Return bounding box of draw operation.\"\"\"\nreturn self._bounding_box\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_command.html","title":"draw_command","text":""},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_command.html#pygerber.backend.abstract.draw_commands.draw_command","title":"draw_command","text":"<p>Base class for creating components for aperture creation.</p>"},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_command.html#pygerber.backend.abstract.draw_commands.draw_command.DrawCommand","title":"DrawCommand","text":"<p>             Bases: <code>ABC</code></p> <p>Description of aperture component.</p> Source code in <code>src/pygerber/backend/abstract/draw_commands/draw_command.py</code> <pre><code>class DrawCommand(ABC):\n\"\"\"Description of aperture component.\"\"\"\nbackend: Backend\npolarity: Polarity\ndef __init__(self, backend: Backend, polarity: Polarity) -&gt; None:\n\"\"\"Initialize draw command.\"\"\"\nself.backend = backend\nself.polarity = polarity\n@abstractmethod\ndef draw(self, target: DrawingTarget) -&gt; None:\n\"\"\"Apply aperture draw component to handle.\"\"\"\n@abstractmethod\ndef get_bounding_box(self) -&gt; BoundingBox:\n\"\"\"Return bounding box of draw operation.\"\"\"\ndef __str__(self) -&gt; str:\nreturn f\"{self.__class__.__qualname__}({self.polarity})\"\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_command.html#pygerber.backend.abstract.draw_commands.draw_command.DrawCommand.__init__","title":"__init__","text":"<pre><code>__init__(backend: Backend, polarity: Polarity) -&gt; None\n</code></pre> <p>Initialize draw command.</p> Source code in <code>src/pygerber/backend/abstract/draw_commands/draw_command.py</code> <pre><code>def __init__(self, backend: Backend, polarity: Polarity) -&gt; None:\n\"\"\"Initialize draw command.\"\"\"\nself.backend = backend\nself.polarity = polarity\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_command.html#pygerber.backend.abstract.draw_commands.draw_command.DrawCommand.draw","title":"draw  <code>abstractmethod</code>","text":"<pre><code>draw(target: DrawingTarget) -&gt; None\n</code></pre> <p>Apply aperture draw component to handle.</p> Source code in <code>src/pygerber/backend/abstract/draw_commands/draw_command.py</code> <pre><code>@abstractmethod\ndef draw(self, target: DrawingTarget) -&gt; None:\n\"\"\"Apply aperture draw component to handle.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_command.html#pygerber.backend.abstract.draw_commands.draw_command.DrawCommand.get_bounding_box","title":"get_bounding_box  <code>abstractmethod</code>","text":"<pre><code>get_bounding_box() -&gt; BoundingBox\n</code></pre> <p>Return bounding box of draw operation.</p> Source code in <code>src/pygerber/backend/abstract/draw_commands/draw_command.py</code> <pre><code>@abstractmethod\ndef get_bounding_box(self) -&gt; BoundingBox:\n\"\"\"Return bounding box of draw operation.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_paste.html","title":"draw_paste","text":""},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_paste.html#pygerber.backend.abstract.draw_commands.draw_paste","title":"draw_paste","text":"<p>Base class for creating components for aperture creation.</p>"},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_paste.html#pygerber.backend.abstract.draw_commands.draw_paste.DrawPaste","title":"DrawPaste","text":"<p>             Bases: <code>DrawCommand</code></p> <p>Description of aperture component.</p> Source code in <code>src/pygerber/backend/abstract/draw_commands/draw_paste.py</code> <pre><code>class DrawPaste(DrawCommand):\n\"\"\"Description of aperture component.\"\"\"\nother: DrawingTarget\ncenter_position: Vector2D\ndef __init__(\nself,\nbackend: Backend,\npolarity: Polarity,\nother: DrawingTarget,\ncenter_position: Vector2D,\n) -&gt; None:\n\"\"\"Initialize draw command.\"\"\"\nsuper().__init__(backend, polarity)\nself.other = other\nself.center_position = center_position\ndef get_bounding_box(self) -&gt; BoundingBox:\n\"\"\"Return bounding box of draw operation.\"\"\"\nreturn self._bounding_box\n@cached_property\ndef _bounding_box(self) -&gt; BoundingBox:\nreturn self.other.bounding_box + self.center_position\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_paste.html#pygerber.backend.abstract.draw_commands.draw_paste.DrawPaste.__init__","title":"__init__","text":"<pre><code>__init__(\nbackend: Backend,\npolarity: Polarity,\nother: DrawingTarget,\ncenter_position: Vector2D,\n) -&gt; None\n</code></pre> <p>Initialize draw command.</p> Source code in <code>src/pygerber/backend/abstract/draw_commands/draw_paste.py</code> <pre><code>def __init__(\nself,\nbackend: Backend,\npolarity: Polarity,\nother: DrawingTarget,\ncenter_position: Vector2D,\n) -&gt; None:\n\"\"\"Initialize draw command.\"\"\"\nsuper().__init__(backend, polarity)\nself.other = other\nself.center_position = center_position\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_paste.html#pygerber.backend.abstract.draw_commands.draw_paste.DrawPaste.get_bounding_box","title":"get_bounding_box","text":"<pre><code>get_bounding_box() -&gt; BoundingBox\n</code></pre> <p>Return bounding box of draw operation.</p> Source code in <code>src/pygerber/backend/abstract/draw_commands/draw_paste.py</code> <pre><code>def get_bounding_box(self) -&gt; BoundingBox:\n\"\"\"Return bounding box of draw operation.\"\"\"\nreturn self._bounding_box\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_polygon.html","title":"draw_polygon","text":""},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_polygon.html#pygerber.backend.abstract.draw_commands.draw_polygon","title":"draw_polygon","text":"<p>Polygon component for creating apertures.</p>"},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_polygon.html#pygerber.backend.abstract.draw_commands.draw_polygon.DrawPolygon","title":"DrawPolygon","text":"<p>             Bases: <code>DrawCommand</code></p> <p>Description of polygon aperture component.</p> Source code in <code>src/pygerber/backend/abstract/draw_commands/draw_polygon.py</code> <pre><code>class DrawPolygon(DrawCommand):\n\"\"\"Description of polygon aperture component.\"\"\"\ncenter_position: Vector2D\nouter_diameter: Offset\nnumber_of_vertices: int\nrotation: Decimal\ndef __init__(  # noqa: PLR0913\nself,\nbackend: Backend,\npolarity: Polarity,\ncenter_position: Vector2D,\nouter_diameter: Offset,\nnumber_of_vertices: int,\nrotation: Decimal,\n) -&gt; None:\n\"\"\"Initialize draw command.\"\"\"\nsuper().__init__(backend, polarity)\nself.center_position = center_position\nself.outer_diameter = outer_diameter\nself.number_of_vertices = number_of_vertices\nself.rotation = rotation\ndef get_bounding_box(self) -&gt; BoundingBox:\n\"\"\"Return bounding box of draw operation.\"\"\"\nreturn self._bounding_box\n@cached_property\ndef _bounding_box(self) -&gt; BoundingBox:\nreturn BoundingBox.from_diameter(self.outer_diameter) + self.center_position\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_polygon.html#pygerber.backend.abstract.draw_commands.draw_polygon.DrawPolygon.__init__","title":"__init__","text":"<pre><code>__init__(\nbackend: Backend,\npolarity: Polarity,\ncenter_position: Vector2D,\nouter_diameter: Offset,\nnumber_of_vertices: int,\nrotation: Decimal,\n) -&gt; None\n</code></pre> <p>Initialize draw command.</p> Source code in <code>src/pygerber/backend/abstract/draw_commands/draw_polygon.py</code> <pre><code>def __init__(  # noqa: PLR0913\nself,\nbackend: Backend,\npolarity: Polarity,\ncenter_position: Vector2D,\nouter_diameter: Offset,\nnumber_of_vertices: int,\nrotation: Decimal,\n) -&gt; None:\n\"\"\"Initialize draw command.\"\"\"\nsuper().__init__(backend, polarity)\nself.center_position = center_position\nself.outer_diameter = outer_diameter\nself.number_of_vertices = number_of_vertices\nself.rotation = rotation\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_polygon.html#pygerber.backend.abstract.draw_commands.draw_polygon.DrawPolygon.get_bounding_box","title":"get_bounding_box","text":"<pre><code>get_bounding_box() -&gt; BoundingBox\n</code></pre> <p>Return bounding box of draw operation.</p> Source code in <code>src/pygerber/backend/abstract/draw_commands/draw_polygon.py</code> <pre><code>def get_bounding_box(self) -&gt; BoundingBox:\n\"\"\"Return bounding box of draw operation.\"\"\"\nreturn self._bounding_box\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_rectangle.html","title":"draw_rectangle","text":""},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_rectangle.html#pygerber.backend.abstract.draw_commands.draw_rectangle","title":"draw_rectangle","text":"<p>Rectangle component for creating apertures.</p>"},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_rectangle.html#pygerber.backend.abstract.draw_commands.draw_rectangle.DrawRectangle","title":"DrawRectangle","text":"<p>             Bases: <code>DrawCommand</code></p> <p>Description of rectangle aperture component.</p> Source code in <code>src/pygerber/backend/abstract/draw_commands/draw_rectangle.py</code> <pre><code>class DrawRectangle(DrawCommand):\n\"\"\"Description of rectangle aperture component.\"\"\"\ncenter_position: Vector2D\nx_size: Offset\ny_size: Offset\ndef __init__(  # noqa: PLR0913\nself,\nbackend: Backend,\npolarity: Polarity,\ncenter_position: Vector2D,\nx_size: Offset,\ny_size: Offset,\n) -&gt; None:\n\"\"\"Initialize draw command.\"\"\"\nsuper().__init__(backend, polarity)\nself.center_position = center_position\nself.x_size = x_size\nself.y_size = y_size\ndef get_bounding_box(self) -&gt; BoundingBox:\n\"\"\"Return bounding box of draw operation.\"\"\"\nreturn self._bounding_box\n@cached_property\ndef _bounding_box(self) -&gt; BoundingBox:\nreturn (\nBoundingBox.from_rectangle(self.x_size, self.y_size) + self.center_position\n)\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_rectangle.html#pygerber.backend.abstract.draw_commands.draw_rectangle.DrawRectangle.__init__","title":"__init__","text":"<pre><code>__init__(\nbackend: Backend,\npolarity: Polarity,\ncenter_position: Vector2D,\nx_size: Offset,\ny_size: Offset,\n) -&gt; None\n</code></pre> <p>Initialize draw command.</p> Source code in <code>src/pygerber/backend/abstract/draw_commands/draw_rectangle.py</code> <pre><code>def __init__(  # noqa: PLR0913\nself,\nbackend: Backend,\npolarity: Polarity,\ncenter_position: Vector2D,\nx_size: Offset,\ny_size: Offset,\n) -&gt; None:\n\"\"\"Initialize draw command.\"\"\"\nsuper().__init__(backend, polarity)\nself.center_position = center_position\nself.x_size = x_size\nself.y_size = y_size\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_rectangle.html#pygerber.backend.abstract.draw_commands.draw_rectangle.DrawRectangle.get_bounding_box","title":"get_bounding_box","text":"<pre><code>get_bounding_box() -&gt; BoundingBox\n</code></pre> <p>Return bounding box of draw operation.</p> Source code in <code>src/pygerber/backend/abstract/draw_commands/draw_rectangle.py</code> <pre><code>def get_bounding_box(self) -&gt; BoundingBox:\n\"\"\"Return bounding box of draw operation.\"\"\"\nreturn self._bounding_box\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_region.html","title":"draw_region","text":""},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_region.html#pygerber.backend.abstract.draw_commands.draw_region","title":"draw_region","text":"<p>Region component for creating apertures.</p>"},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_region.html#pygerber.backend.abstract.draw_commands.draw_region.DrawRegion","title":"DrawRegion","text":"<p>             Bases: <code>DrawCommand</code></p> <p>Description of Region aperture component.</p> Source code in <code>src/pygerber/backend/abstract/draw_commands/draw_region.py</code> <pre><code>class DrawRegion(DrawCommand):\n\"\"\"Description of Region aperture component.\"\"\"\nregion_boundary_points: list[Vector2D]\ndef __init__(\nself,\nbackend: Backend,\npolarity: Polarity,\nregion_boundary_points: list[Vector2D],\n) -&gt; None:\n\"\"\"Initialize draw command.\"\"\"\nsuper().__init__(backend, polarity)\nself.region_boundary_points = region_boundary_points\ndef get_bounding_box(self) -&gt; BoundingBox:\n\"\"\"Return bounding box of draw operation.\"\"\"\nreturn self._bounding_box\n@cached_property\ndef _bounding_box(self) -&gt; BoundingBox:\nbox: Optional[BoundingBox] = None\nfor point in self.region_boundary_points:\nif box is not None:\nbox = box.include_point(point)\nelse:\nbox = BoundingBox.NULL + point\nif box is not None:\nreturn box\nreturn BoundingBox.NULL\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_region.html#pygerber.backend.abstract.draw_commands.draw_region.DrawRegion.__init__","title":"__init__","text":"<pre><code>__init__(\nbackend: Backend,\npolarity: Polarity,\nregion_boundary_points: list[Vector2D],\n) -&gt; None\n</code></pre> <p>Initialize draw command.</p> Source code in <code>src/pygerber/backend/abstract/draw_commands/draw_region.py</code> <pre><code>def __init__(\nself,\nbackend: Backend,\npolarity: Polarity,\nregion_boundary_points: list[Vector2D],\n) -&gt; None:\n\"\"\"Initialize draw command.\"\"\"\nsuper().__init__(backend, polarity)\nself.region_boundary_points = region_boundary_points\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_region.html#pygerber.backend.abstract.draw_commands.draw_region.DrawRegion.get_bounding_box","title":"get_bounding_box","text":"<pre><code>get_bounding_box() -&gt; BoundingBox\n</code></pre> <p>Return bounding box of draw operation.</p> Source code in <code>src/pygerber/backend/abstract/draw_commands/draw_region.py</code> <pre><code>def get_bounding_box(self) -&gt; BoundingBox:\n\"\"\"Return bounding box of draw operation.\"\"\"\nreturn self._bounding_box\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_vector_line.html","title":"draw_vector_line","text":""},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_vector_line.html#pygerber.backend.abstract.draw_commands.draw_vector_line","title":"draw_vector_line","text":""},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_vector_line.html#pygerber.backend.abstract.draw_commands.draw_vector_line--drawvectorline-module","title":"DrawVectorLine Module.","text":"<p>This module defines the base class for creating vector line components used in drawing creation. The main class, <code>DrawVectorLine</code>, represents a vector line defined by its start and end positions and width.</p>"},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_vector_line.html#pygerber.backend.abstract.draw_commands.draw_vector_line.DrawVectorLine","title":"DrawVectorLine","text":"<p>             Bases: <code>DrawCommand</code></p> <p>Represents a vector line component used in drawing creation. This class is defined by its start position, end position, and width.</p> Source code in <code>src/pygerber/backend/abstract/draw_commands/draw_vector_line.py</code> <pre><code>class DrawVectorLine(DrawCommand):\n\"\"\"Represents a vector line component used in drawing creation.\n    This class is defined by its start position, end position, and width.\n    \"\"\"\nstart_position: Vector2D\nend_position: Vector2D\nwidth: Offset\ndef __init__(  # noqa: PLR0913\nself,\nbackend: Backend,\npolarity: Polarity,\nstart_position: Vector2D,\nend_position: Vector2D,\nwidth: Offset,\n) -&gt; None:\n\"\"\"Initialize draw command.\"\"\"\nsuper().__init__(backend, polarity)\nself.start_position = start_position\nself.end_position = end_position\nself.width = width\ndef get_bounding_box(self) -&gt; BoundingBox:\n\"\"\"Return bounding box of draw operation.\"\"\"\nvertex_box = BoundingBox.from_diameter(self.width)\nreturn (vertex_box + self.start_position) + (vertex_box + self.end_position)\ndef __str__(self) -&gt; str:\nreturn (\nf\"{self.__class__.__qualname__}({self.polarity}) start: \"\n\"{self.start_position} end: {self.end_position}\"\n)\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_vector_line.html#pygerber.backend.abstract.draw_commands.draw_vector_line.DrawVectorLine.__init__","title":"__init__","text":"<pre><code>__init__(\nbackend: Backend,\npolarity: Polarity,\nstart_position: Vector2D,\nend_position: Vector2D,\nwidth: Offset,\n) -&gt; None\n</code></pre> <p>Initialize draw command.</p> Source code in <code>src/pygerber/backend/abstract/draw_commands/draw_vector_line.py</code> <pre><code>def __init__(  # noqa: PLR0913\nself,\nbackend: Backend,\npolarity: Polarity,\nstart_position: Vector2D,\nend_position: Vector2D,\nwidth: Offset,\n) -&gt; None:\n\"\"\"Initialize draw command.\"\"\"\nsuper().__init__(backend, polarity)\nself.start_position = start_position\nself.end_position = end_position\nself.width = width\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_vector_line.html#pygerber.backend.abstract.draw_commands.draw_vector_line.DrawVectorLine.get_bounding_box","title":"get_bounding_box","text":"<pre><code>get_bounding_box() -&gt; BoundingBox\n</code></pre> <p>Return bounding box of draw operation.</p> Source code in <code>src/pygerber/backend/abstract/draw_commands/draw_vector_line.py</code> <pre><code>def get_bounding_box(self) -&gt; BoundingBox:\n\"\"\"Return bounding box of draw operation.\"\"\"\nvertex_box = BoundingBox.from_diameter(self.width)\nreturn (vertex_box + self.start_position) + (vertex_box + self.end_position)\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/__init__.html","title":"init","text":""},{"location":"reference/pygerber/backend/rasterized_2d/__init__.html#pygerber.backend.rasterized_2d","title":"rasterized_2d","text":"<p>Backend implementation for rendering 2D rasterized images.</p>"},{"location":"reference/pygerber/backend/rasterized_2d/aperture_handle.html","title":"aperture_handle","text":""},{"location":"reference/pygerber/backend/rasterized_2d/aperture_handle.html#pygerber.backend.rasterized_2d.aperture_handle","title":"aperture_handle","text":"<p>Aperture Handle class which represents Gerber X3 aperture.</p>"},{"location":"reference/pygerber/backend/rasterized_2d/aperture_handle.html#pygerber.backend.rasterized_2d.aperture_handle.Rasterized2DPrivateApertureHandle","title":"Rasterized2DPrivateApertureHandle","text":"<p>             Bases: <code>PrivateApertureHandle</code></p> <p>Base class for creating Gerber X3 apertures.</p> Source code in <code>src/pygerber/backend/rasterized_2d/aperture_handle.py</code> <pre><code>class Rasterized2DPrivateApertureHandle(PrivateApertureHandle):\n\"\"\"Base class for creating Gerber X3 apertures.\"\"\"\nbackend: Rasterized2DBackend\ndrawing_target: Rasterized2DDrawingTarget\ndef _create_drawing_target(self) -&gt; DrawingTarget:\n\"\"\"Draw aperture and store result.\"\"\"\nbbox = self.bounding_box\nsize = bbox.get_size().as_pixels(self.backend.dpi)\n# Image must be at least 1x1, otherwise Pillow crashes while saving.\nx, y = size\nsize = (max(x, 0) + 1, max(y, 0) + 1)\nreturn Rasterized2DDrawingTarget(\ncoordinate_origin=self.coordinate_origin,\nbounding_box=self.bounding_box,\ntarget_image=Image.new(\nmode=\"L\",\nsize=size,\ncolor=Polarity.Background.get_2d_rasterized_color(),\n),\n)\ndef _post_drawing_hook(self) -&gt; None:\ndest = self.backend.options.dump_apertures\nif dest is not None:\ndest_aperture_subdir = dest / f\"{self.aperture_id}_{self.private_id}\"\ndest_aperture_subdir.mkdir(0o777, parents=True, exist_ok=True)\nself.drawing_target.target_image.save(\ndest_aperture_subdir / \"target.png\",\n)\nself.drawing_target.mask_image.save(\ndest_aperture_subdir / \"mask.png\",\n)\nself.drawing_target.image_polarity_clear.save(\ndest_aperture_subdir / \"clear.png\",\n)\nself.drawing_target.image_polarity_dark.save(\ndest_aperture_subdir / \"dark.png\",\n)\nself.drawing_target.image_polarity_region_clear.save(\ndest_aperture_subdir / \"clear_region.png\",\n)\nself.drawing_target.image_polarity_region_dark.save(\ndest_aperture_subdir / \"dark_region.png\",\n)\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/backend_cls.html","title":"backend_cls","text":""},{"location":"reference/pygerber/backend/rasterized_2d/backend_cls.html#pygerber.backend.rasterized_2d.backend_cls","title":"backend_cls","text":"<p>Backend for rasterized rendering of Gerber files.</p>"},{"location":"reference/pygerber/backend/rasterized_2d/backend_cls.html#pygerber.backend.rasterized_2d.backend_cls.ColorMode","title":"ColorMode","text":"<p>             Bases: <code>Enum</code></p> <p>Enum which can be used to specify color mode.</p> Source code in <code>src/pygerber/backend/rasterized_2d/backend_cls.py</code> <pre><code>class ColorMode(Enum):\n\"\"\"Enum which can be used to specify color mode.\"\"\"\nRGBA = \"RGBA\"\nRGB = \"RGB\"\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/backend_cls.html#pygerber.backend.rasterized_2d.backend_cls.Rasterized2DBackendOptions","title":"Rasterized2DBackendOptions","text":"<p>             Bases: <code>BackendOptions</code></p> <p>Additional configuration which can be passed to backend.</p> Source code in <code>src/pygerber/backend/rasterized_2d/backend_cls.py</code> <pre><code>class Rasterized2DBackendOptions(BackendOptions):\n\"\"\"Additional configuration which can be passed to backend.\"\"\"\ndef __init__(  # noqa: PLR0913\nself,\ndpi: int = 300,\ncolor_scheme: ColorScheme = ColorScheme.DEFAULT_GRAYSCALE,\ncolor_mode: ColorMode = ColorMode.RGBA,\ndump_apertures: Optional[Path] = None,\n*,\ninclude_debug_padding: bool = False,\ninclude_bounding_boxes: bool = False,\ndraw_region_outlines: bool = False,\n) -&gt; None:\n\"\"\"Initialize options.\"\"\"\nself.dpi = dpi\nself.color_scheme = color_scheme\nself.color_mode = color_mode\nself.include_debug_padding = include_debug_padding\nself.include_bounding_boxes = include_bounding_boxes\nsuper().__init__(\ndump_apertures=dump_apertures,\ndraw_region_outlines=draw_region_outlines,\n)\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/backend_cls.html#pygerber.backend.rasterized_2d.backend_cls.Rasterized2DBackendOptions.__init__","title":"__init__","text":"<pre><code>__init__(\ndpi: int = 300,\ncolor_scheme: ColorScheme = ColorScheme.DEFAULT_GRAYSCALE,\ncolor_mode: ColorMode = ColorMode.RGBA,\ndump_apertures: Optional[Path] = None,\n*,\ninclude_debug_padding: bool = False,\ninclude_bounding_boxes: bool = False,\ndraw_region_outlines: bool = False\n) -&gt; None\n</code></pre> <p>Initialize options.</p> Source code in <code>src/pygerber/backend/rasterized_2d/backend_cls.py</code> <pre><code>def __init__(  # noqa: PLR0913\nself,\ndpi: int = 300,\ncolor_scheme: ColorScheme = ColorScheme.DEFAULT_GRAYSCALE,\ncolor_mode: ColorMode = ColorMode.RGBA,\ndump_apertures: Optional[Path] = None,\n*,\ninclude_debug_padding: bool = False,\ninclude_bounding_boxes: bool = False,\ndraw_region_outlines: bool = False,\n) -&gt; None:\n\"\"\"Initialize options.\"\"\"\nself.dpi = dpi\nself.color_scheme = color_scheme\nself.color_mode = color_mode\nself.include_debug_padding = include_debug_padding\nself.include_bounding_boxes = include_bounding_boxes\nsuper().__init__(\ndump_apertures=dump_apertures,\ndraw_region_outlines=draw_region_outlines,\n)\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/backend_cls.html#pygerber.backend.rasterized_2d.backend_cls.Rasterized2DBackend","title":"Rasterized2DBackend","text":"<p>             Bases: <code>Backend</code></p> <p>Drawing backend interface.</p> Source code in <code>src/pygerber/backend/rasterized_2d/backend_cls.py</code> <pre><code>class Rasterized2DBackend(Backend):\n\"\"\"Drawing backend interface.\"\"\"\noptions: Rasterized2DBackendOptions\ndrawing_target: Rasterized2DDrawingTarget\noptions_class: ClassVar[type[BackendOptions]] = Rasterized2DBackendOptions\ndef __init__(self, options: Rasterized2DBackendOptions | None = None) -&gt; None:\n\"\"\"Initialize backend.\"\"\"\nif options is not None and not isinstance(options, Rasterized2DBackendOptions):\nmsg = (  # type: ignore[unreachable]\n\"Expected Rasterized2DBackendOptions or None as options, got \"\n+ str(type(options))\n)\nraise TypeError(msg)\nsuper().__init__(options)\n@property\ndef dpi(self) -&gt; int:\n\"\"\"Return image DPI.\"\"\"\nreturn self.options.dpi\ndef _create_drawing_target(self) -&gt; DrawingTarget:\n\"\"\"Execute all draw actions to create visualization.\"\"\"\nraw_bbox = self.bounding_box\nif self.options.include_debug_padding:\nbbox = raw_bbox + Decimal(1.0)\nelse:\nbbox = raw_bbox\nsize = bbox.get_size()\ncoordinate_origin = bbox.get_min_vector()\nimage_size = size.as_pixels(self.dpi)\n# Image must be at least 1x1, otherwise Pillow crashes while saving.\nx, y = image_size\nimage_size = (max(x, 0) + 1, max(y, 0) + 1)\nreturn Rasterized2DDrawingTarget(\ncoordinate_origin=coordinate_origin,\nbounding_box=bbox,\ntarget_image=Image.new(\nmode=\"L\",\nsize=image_size,\ncolor=Polarity.Background.get_2d_rasterized_color(),\n),\n)\ndef _pre_drawing_hook(self) -&gt; None:\n\"\"\"Perform custom actions after drawing.\"\"\"\nif self.options.include_bounding_boxes:\nself.draws.append(\nRasterized2DApertureDrawBoundingBox(\nbackend=self,\npolarity=Polarity.DEBUG,\nbounding_box=self.bounding_box,\noutline_padding=Offset.from_pixels(1, self.dpi),\n),\n)\ndef _post_drawing_hook(self) -&gt; None:\nself._replace_image_colors()\ndef _replace_image_colors(self) -&gt; None:\nimg = self.drawing_target.target_image\ncolor_map = self.options.color_scheme.get_grayscale_to_rgba_color_map()\nnp_img = np.array(img)\n# Create an empty RGBA image with the same size as the original image\nrgba_img: npt.NDArray[np.uint8] = np.zeros(\n(img.height, img.width, 4),\ndtype=np.uint8,\n)\n# For each grayscale value, set the corresponding RGBA value in the new image\nfor gray_value, rgba in color_map.items():\nrgba_img[np_img == gray_value] = rgba\n# Convert the resulting NumPy array back to a Pillow image\nself.drawing_target.target_image = Image.fromarray(rgba_img, \"RGBA\")\ndef get_result_handle(self) -&gt; ResultHandle:\n\"\"\"Return result handle to visualization.\"\"\"\nreturn Rasterized2DResultHandle(self.drawing_target.target_image)\ndef get_aperture_handle_cls(self) -&gt; type[PrivateApertureHandle]:\n\"\"\"Get backend-specific implementation of aperture handle class.\"\"\"\nreturn Rasterized2DPrivateApertureHandle\ndef get_draw_circle_cls(self) -&gt; type[DrawCircle]:\n\"\"\"Get backend-specific implementation of aperture circle component class.\"\"\"\nreturn Rasterized2DApertureDrawCircle\ndef get_draw_rectangle_cls(self) -&gt; type[DrawRectangle]:\n\"\"\"Get backend-specific implementation of aperture rectangle component class.\"\"\"\nreturn Rasterized2DApertureDrawRectangle\ndef get_draw_polygon_cls(self) -&gt; type[DrawPolygon]:\n\"\"\"Get backend-specific implementation of aperture polygon component class.\"\"\"\nreturn Rasterized2DApertureDrawPolygon\ndef get_draw_commands_handle_cls(self) -&gt; type[DrawCommandsHandle]:\n\"\"\"Return backend-specific implementation of draw actions handle.\"\"\"\nreturn Rasterized2DDrawActionsHandle\ndef get_draw_paste_cls(self) -&gt; type[DrawPaste]:\n\"\"\"Return backend-specific implementation of draw action flash.\"\"\"\nreturn Rasterized2DDrawPaste\ndef get_draw_region_cls(self) -&gt; type[DrawRegion]:\n\"\"\"Return backend-specific implementation of draw action region.\"\"\"\nreturn Rasterized2DDrawRegion\ndef get_draw_vector_line_cls(self) -&gt; type[DrawVectorLine]:\n\"\"\"Return backend-specific implementation of draw action line.\"\"\"\nreturn Rasterized2DDrawVectorLine\ndef get_draw_arc_cls(self) -&gt; type[DrawArc]:\n\"\"\"Return backend-specific implementation of draw action arc.\"\"\"\nreturn Rasterized2DDrawArc\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/backend_cls.html#pygerber.backend.rasterized_2d.backend_cls.Rasterized2DBackend.dpi","title":"dpi  <code>property</code>","text":"<pre><code>dpi: int\n</code></pre> <p>Return image DPI.</p>"},{"location":"reference/pygerber/backend/rasterized_2d/backend_cls.html#pygerber.backend.rasterized_2d.backend_cls.Rasterized2DBackend.__init__","title":"__init__","text":"<pre><code>__init__(\noptions: Rasterized2DBackendOptions | None = None,\n) -&gt; None\n</code></pre> <p>Initialize backend.</p> Source code in <code>src/pygerber/backend/rasterized_2d/backend_cls.py</code> <pre><code>def __init__(self, options: Rasterized2DBackendOptions | None = None) -&gt; None:\n\"\"\"Initialize backend.\"\"\"\nif options is not None and not isinstance(options, Rasterized2DBackendOptions):\nmsg = (  # type: ignore[unreachable]\n\"Expected Rasterized2DBackendOptions or None as options, got \"\n+ str(type(options))\n)\nraise TypeError(msg)\nsuper().__init__(options)\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/backend_cls.html#pygerber.backend.rasterized_2d.backend_cls.Rasterized2DBackend.get_result_handle","title":"get_result_handle","text":"<pre><code>get_result_handle() -&gt; ResultHandle\n</code></pre> <p>Return result handle to visualization.</p> Source code in <code>src/pygerber/backend/rasterized_2d/backend_cls.py</code> <pre><code>def get_result_handle(self) -&gt; ResultHandle:\n\"\"\"Return result handle to visualization.\"\"\"\nreturn Rasterized2DResultHandle(self.drawing_target.target_image)\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/backend_cls.html#pygerber.backend.rasterized_2d.backend_cls.Rasterized2DBackend.get_aperture_handle_cls","title":"get_aperture_handle_cls","text":"<pre><code>get_aperture_handle_cls() -&gt; type[PrivateApertureHandle]\n</code></pre> <p>Get backend-specific implementation of aperture handle class.</p> Source code in <code>src/pygerber/backend/rasterized_2d/backend_cls.py</code> <pre><code>def get_aperture_handle_cls(self) -&gt; type[PrivateApertureHandle]:\n\"\"\"Get backend-specific implementation of aperture handle class.\"\"\"\nreturn Rasterized2DPrivateApertureHandle\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/backend_cls.html#pygerber.backend.rasterized_2d.backend_cls.Rasterized2DBackend.get_draw_circle_cls","title":"get_draw_circle_cls","text":"<pre><code>get_draw_circle_cls() -&gt; type[DrawCircle]\n</code></pre> <p>Get backend-specific implementation of aperture circle component class.</p> Source code in <code>src/pygerber/backend/rasterized_2d/backend_cls.py</code> <pre><code>def get_draw_circle_cls(self) -&gt; type[DrawCircle]:\n\"\"\"Get backend-specific implementation of aperture circle component class.\"\"\"\nreturn Rasterized2DApertureDrawCircle\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/backend_cls.html#pygerber.backend.rasterized_2d.backend_cls.Rasterized2DBackend.get_draw_rectangle_cls","title":"get_draw_rectangle_cls","text":"<pre><code>get_draw_rectangle_cls() -&gt; type[DrawRectangle]\n</code></pre> <p>Get backend-specific implementation of aperture rectangle component class.</p> Source code in <code>src/pygerber/backend/rasterized_2d/backend_cls.py</code> <pre><code>def get_draw_rectangle_cls(self) -&gt; type[DrawRectangle]:\n\"\"\"Get backend-specific implementation of aperture rectangle component class.\"\"\"\nreturn Rasterized2DApertureDrawRectangle\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/backend_cls.html#pygerber.backend.rasterized_2d.backend_cls.Rasterized2DBackend.get_draw_polygon_cls","title":"get_draw_polygon_cls","text":"<pre><code>get_draw_polygon_cls() -&gt; type[DrawPolygon]\n</code></pre> <p>Get backend-specific implementation of aperture polygon component class.</p> Source code in <code>src/pygerber/backend/rasterized_2d/backend_cls.py</code> <pre><code>def get_draw_polygon_cls(self) -&gt; type[DrawPolygon]:\n\"\"\"Get backend-specific implementation of aperture polygon component class.\"\"\"\nreturn Rasterized2DApertureDrawPolygon\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/backend_cls.html#pygerber.backend.rasterized_2d.backend_cls.Rasterized2DBackend.get_draw_commands_handle_cls","title":"get_draw_commands_handle_cls","text":"<pre><code>get_draw_commands_handle_cls() -&gt; type[DrawCommandsHandle]\n</code></pre> <p>Return backend-specific implementation of draw actions handle.</p> Source code in <code>src/pygerber/backend/rasterized_2d/backend_cls.py</code> <pre><code>def get_draw_commands_handle_cls(self) -&gt; type[DrawCommandsHandle]:\n\"\"\"Return backend-specific implementation of draw actions handle.\"\"\"\nreturn Rasterized2DDrawActionsHandle\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/backend_cls.html#pygerber.backend.rasterized_2d.backend_cls.Rasterized2DBackend.get_draw_paste_cls","title":"get_draw_paste_cls","text":"<pre><code>get_draw_paste_cls() -&gt; type[DrawPaste]\n</code></pre> <p>Return backend-specific implementation of draw action flash.</p> Source code in <code>src/pygerber/backend/rasterized_2d/backend_cls.py</code> <pre><code>def get_draw_paste_cls(self) -&gt; type[DrawPaste]:\n\"\"\"Return backend-specific implementation of draw action flash.\"\"\"\nreturn Rasterized2DDrawPaste\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/backend_cls.html#pygerber.backend.rasterized_2d.backend_cls.Rasterized2DBackend.get_draw_region_cls","title":"get_draw_region_cls","text":"<pre><code>get_draw_region_cls() -&gt; type[DrawRegion]\n</code></pre> <p>Return backend-specific implementation of draw action region.</p> Source code in <code>src/pygerber/backend/rasterized_2d/backend_cls.py</code> <pre><code>def get_draw_region_cls(self) -&gt; type[DrawRegion]:\n\"\"\"Return backend-specific implementation of draw action region.\"\"\"\nreturn Rasterized2DDrawRegion\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/backend_cls.html#pygerber.backend.rasterized_2d.backend_cls.Rasterized2DBackend.get_draw_vector_line_cls","title":"get_draw_vector_line_cls","text":"<pre><code>get_draw_vector_line_cls() -&gt; type[DrawVectorLine]\n</code></pre> <p>Return backend-specific implementation of draw action line.</p> Source code in <code>src/pygerber/backend/rasterized_2d/backend_cls.py</code> <pre><code>def get_draw_vector_line_cls(self) -&gt; type[DrawVectorLine]:\n\"\"\"Return backend-specific implementation of draw action line.\"\"\"\nreturn Rasterized2DDrawVectorLine\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/backend_cls.html#pygerber.backend.rasterized_2d.backend_cls.Rasterized2DBackend.get_draw_arc_cls","title":"get_draw_arc_cls","text":"<pre><code>get_draw_arc_cls() -&gt; type[DrawArc]\n</code></pre> <p>Return backend-specific implementation of draw action arc.</p> Source code in <code>src/pygerber/backend/rasterized_2d/backend_cls.py</code> <pre><code>def get_draw_arc_cls(self) -&gt; type[DrawArc]:\n\"\"\"Return backend-specific implementation of draw action arc.\"\"\"\nreturn Rasterized2DDrawArc\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/color_scheme.html","title":"color_scheme","text":""},{"location":"reference/pygerber/backend/rasterized_2d/color_scheme.html#pygerber.backend.rasterized_2d.color_scheme","title":"color_scheme","text":"<p>ColorScheme class - utility for describing color schemes.</p>"},{"location":"reference/pygerber/backend/rasterized_2d/color_scheme.html#pygerber.backend.rasterized_2d.color_scheme.ColorScheme","title":"ColorScheme","text":"<p>             Bases: <code>FrozenGeneralModel</code></p> <p>Set of colors which should be used for rendering.</p> <p>ColorScheme class contains set of colors which should be used for different parts of rendered image. At the same time it also works as a container for predefined color schemes commonly used for parts of PCB.</p> <p>Predefined colors</p> <p>All predefined colors have two variants - normal one and one with \"*_ALPHA\" suffix. Those without suffix have solid background and are not intended for constructing multi-layer images out of them ie. they are not suitable for rendering a project consisting of separate copper, silk, pase mask and composing them into single image. For cases when rendered images are intended for stacking \"*_ALPHA\" schemes should be used, as background and transparent parts of image will be truly transparent.</p> Source code in <code>src/pygerber/backend/rasterized_2d/color_scheme.py</code> <pre><code>class ColorScheme(FrozenGeneralModel):\nr\"\"\"Set of colors which should be used for rendering.\n    ColorScheme class contains set of colors which should be used for different parts\n    of rendered image. At the same time it also works as a container for predefined\n    color schemes commonly used for parts of PCB.\n    !!! info \"Predefined colors\"\n        All predefined colors have two variants - normal one and one with \"\\*_ALPHA\"\n        suffix. Those without suffix have solid background and are not intended for\n        constructing multi-layer images out of them ie. they are not suitable for\n        rendering a project consisting of separate copper, silk, pase mask and composing\n        them into single image. For cases when rendered images are intended for stacking\n        \"\\*_ALPHA\" schemes should be used, as background and transparent parts of image\n        will be truly transparent.\n    \"\"\"\nSILK: ClassVar[ColorScheme]\n\"\"\"Default color of silk layer.\n    This schema provided non-transparent background, which results in images which\n    can not be used for stacking on top of other layers, as they would completely\n    obscure them.\"\"\"\nSILK_ALPHA: ClassVar[ColorScheme]\n\"\"\"Default color of silk layer with alpha channel.\n    This schema provides transparent background. Images using this schema can be\n    stacked on top of each other without obscuring layers below.\"\"\"\nCOPPER: ClassVar[ColorScheme]\n\"\"\"Default color of copper layer.\n    This schema provided non-transparent background, which results in images which\n    can not be used for stacking on top of other layers, as they would completely\n    obscure them.\"\"\"\nCOPPER_ALPHA: ClassVar[ColorScheme]\n\"\"\"Default color of copper layer with alpha channel.\n    This schema provides transparent background. Images using this schema can be\n    stacked on top of each other without obscuring layers below.\"\"\"\nPASTE_MASK: ClassVar[ColorScheme]\n\"\"\"Default color of paste mask layer.\n    This schema provided non-transparent background, which results in images which\n    can not be used for stacking on top of other layers, as they would completely\n    obscure them.\"\"\"\nPASTE_MASK_ALPHA: ClassVar[ColorScheme]\n\"\"\"Default color of paste mask layer with alpha channel.\n    This schema provides transparent background. Images using this schema can be\n    stacked on top of each other without obscuring layers below.\"\"\"\nSOLDER_MASK: ClassVar[ColorScheme]\n\"\"\"Default color of solder mask layer.\n    This schema provided non-transparent background, which results in images which\n    can not be used for stacking on top of other layers, as they would completely\n    obscure them.\"\"\"\nSOLDER_MASK_ALPHA: ClassVar[ColorScheme]\n\"\"\"Default color of solder mask layer with alpha channel.\n    This schema provides transparent background. Images using this schema can be\n    stacked on top of each other without obscuring layers below.\"\"\"\nDEFAULT_GRAYSCALE: ClassVar[ColorScheme]\n\"\"\"Default color scheme for files which were not assigned other color scheme.\"\"\"\nDEBUG_1: ClassVar[ColorScheme]\n\"\"\"Debug color scheme.\"\"\"\nDEBUG_1_ALPHA: ClassVar[ColorScheme]\n\"\"\"Debug color scheme with alpha channel.\"\"\"\nbackground_color: RGBA\n\"\"\"Color used as empty image background.\"\"\"\nclear_color: RGBA\n\"\"\"Color used for clear draws.\"\"\"\nsolid_color: RGBA\n\"\"\"Color used for solid draws.\"\"\"\nclear_region_color: RGBA\n\"\"\"Color used for clear region draws.\"\"\"\nsolid_region_color: RGBA\n\"\"\"Color used for solid region draws.\"\"\"\ndebug_1_color: RGBA = RGBA.from_hex(\"#ababab\")\n\"\"\"Color used for debug elements.\"\"\"\ndebug_2_color: RGBA = RGBA.from_hex(\"#7d7d7d\")\n\"\"\"Color used for debug elements.\"\"\"\ndef get_grayscale_to_rgba_color_map(self) -&gt; dict[int, tuple[int, int, int, int]]:\n\"\"\"Return grayscale to RGBA color map.\"\"\"\nreturn {\nPolarity.Dark.get_2d_rasterized_color(): self.solid_color.as_rgba_int(),\nPolarity.Clear.get_2d_rasterized_color(): self.clear_color.as_rgba_int(),  # noqa: E501\nPolarity.DarkRegion.get_2d_rasterized_color(): self.solid_region_color.as_rgba_int(),  # noqa: E501\nPolarity.ClearRegion.get_2d_rasterized_color(): self.clear_region_color.as_rgba_int(),  # noqa: E501\nPolarity.Background.get_2d_rasterized_color(): self.background_color.as_rgba_int(),  # noqa: E501\nPolarity.DEBUG.get_2d_rasterized_color(): self.debug_1_color.as_rgba_int(),  # noqa: E501\nPolarity.DEBUG2.get_2d_rasterized_color(): self.debug_2_color.as_rgba_int(),  # noqa: E501\n}\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/color_scheme.html#pygerber.backend.rasterized_2d.color_scheme.ColorScheme.SILK","title":"SILK  <code>class-attribute</code>","text":"<pre><code>SILK: ColorScheme\n</code></pre> <p>Default color of silk layer.</p> <p>This schema provided non-transparent background, which results in images which can not be used for stacking on top of other layers, as they would completely obscure them.</p>"},{"location":"reference/pygerber/backend/rasterized_2d/color_scheme.html#pygerber.backend.rasterized_2d.color_scheme.ColorScheme.SILK_ALPHA","title":"SILK_ALPHA  <code>class-attribute</code>","text":"<pre><code>SILK_ALPHA: ColorScheme\n</code></pre> <p>Default color of silk layer with alpha channel.</p> <p>This schema provides transparent background. Images using this schema can be stacked on top of each other without obscuring layers below.</p>"},{"location":"reference/pygerber/backend/rasterized_2d/color_scheme.html#pygerber.backend.rasterized_2d.color_scheme.ColorScheme.COPPER","title":"COPPER  <code>class-attribute</code>","text":"<pre><code>COPPER: ColorScheme\n</code></pre> <p>Default color of copper layer.</p> <p>This schema provided non-transparent background, which results in images which can not be used for stacking on top of other layers, as they would completely obscure them.</p>"},{"location":"reference/pygerber/backend/rasterized_2d/color_scheme.html#pygerber.backend.rasterized_2d.color_scheme.ColorScheme.COPPER_ALPHA","title":"COPPER_ALPHA  <code>class-attribute</code>","text":"<pre><code>COPPER_ALPHA: ColorScheme\n</code></pre> <p>Default color of copper layer with alpha channel.</p> <p>This schema provides transparent background. Images using this schema can be stacked on top of each other without obscuring layers below.</p>"},{"location":"reference/pygerber/backend/rasterized_2d/color_scheme.html#pygerber.backend.rasterized_2d.color_scheme.ColorScheme.PASTE_MASK","title":"PASTE_MASK  <code>class-attribute</code>","text":"<pre><code>PASTE_MASK: ColorScheme\n</code></pre> <p>Default color of paste mask layer.</p> <p>This schema provided non-transparent background, which results in images which can not be used for stacking on top of other layers, as they would completely obscure them.</p>"},{"location":"reference/pygerber/backend/rasterized_2d/color_scheme.html#pygerber.backend.rasterized_2d.color_scheme.ColorScheme.PASTE_MASK_ALPHA","title":"PASTE_MASK_ALPHA  <code>class-attribute</code>","text":"<pre><code>PASTE_MASK_ALPHA: ColorScheme\n</code></pre> <p>Default color of paste mask layer with alpha channel.</p> <p>This schema provides transparent background. Images using this schema can be stacked on top of each other without obscuring layers below.</p>"},{"location":"reference/pygerber/backend/rasterized_2d/color_scheme.html#pygerber.backend.rasterized_2d.color_scheme.ColorScheme.SOLDER_MASK","title":"SOLDER_MASK  <code>class-attribute</code>","text":"<pre><code>SOLDER_MASK: ColorScheme\n</code></pre> <p>Default color of solder mask layer.</p> <p>This schema provided non-transparent background, which results in images which can not be used for stacking on top of other layers, as they would completely obscure them.</p>"},{"location":"reference/pygerber/backend/rasterized_2d/color_scheme.html#pygerber.backend.rasterized_2d.color_scheme.ColorScheme.SOLDER_MASK_ALPHA","title":"SOLDER_MASK_ALPHA  <code>class-attribute</code>","text":"<pre><code>SOLDER_MASK_ALPHA: ColorScheme\n</code></pre> <p>Default color of solder mask layer with alpha channel.</p> <p>This schema provides transparent background. Images using this schema can be stacked on top of each other without obscuring layers below.</p>"},{"location":"reference/pygerber/backend/rasterized_2d/color_scheme.html#pygerber.backend.rasterized_2d.color_scheme.ColorScheme.DEFAULT_GRAYSCALE","title":"DEFAULT_GRAYSCALE  <code>class-attribute</code>","text":"<pre><code>DEFAULT_GRAYSCALE: ColorScheme\n</code></pre> <p>Default color scheme for files which were not assigned other color scheme.</p>"},{"location":"reference/pygerber/backend/rasterized_2d/color_scheme.html#pygerber.backend.rasterized_2d.color_scheme.ColorScheme.DEBUG_1","title":"DEBUG_1  <code>class-attribute</code>","text":"<pre><code>DEBUG_1: ColorScheme\n</code></pre> <p>Debug color scheme.</p>"},{"location":"reference/pygerber/backend/rasterized_2d/color_scheme.html#pygerber.backend.rasterized_2d.color_scheme.ColorScheme.DEBUG_1_ALPHA","title":"DEBUG_1_ALPHA  <code>class-attribute</code>","text":"<pre><code>DEBUG_1_ALPHA: ColorScheme\n</code></pre> <p>Debug color scheme with alpha channel.</p>"},{"location":"reference/pygerber/backend/rasterized_2d/color_scheme.html#pygerber.backend.rasterized_2d.color_scheme.ColorScheme.background_color","title":"background_color  <code>instance-attribute</code>","text":"<pre><code>background_color: RGBA\n</code></pre> <p>Color used as empty image background.</p>"},{"location":"reference/pygerber/backend/rasterized_2d/color_scheme.html#pygerber.backend.rasterized_2d.color_scheme.ColorScheme.clear_color","title":"clear_color  <code>instance-attribute</code>","text":"<pre><code>clear_color: RGBA\n</code></pre> <p>Color used for clear draws.</p>"},{"location":"reference/pygerber/backend/rasterized_2d/color_scheme.html#pygerber.backend.rasterized_2d.color_scheme.ColorScheme.solid_color","title":"solid_color  <code>instance-attribute</code>","text":"<pre><code>solid_color: RGBA\n</code></pre> <p>Color used for solid draws.</p>"},{"location":"reference/pygerber/backend/rasterized_2d/color_scheme.html#pygerber.backend.rasterized_2d.color_scheme.ColorScheme.clear_region_color","title":"clear_region_color  <code>instance-attribute</code>","text":"<pre><code>clear_region_color: RGBA\n</code></pre> <p>Color used for clear region draws.</p>"},{"location":"reference/pygerber/backend/rasterized_2d/color_scheme.html#pygerber.backend.rasterized_2d.color_scheme.ColorScheme.solid_region_color","title":"solid_region_color  <code>instance-attribute</code>","text":"<pre><code>solid_region_color: RGBA\n</code></pre> <p>Color used for solid region draws.</p>"},{"location":"reference/pygerber/backend/rasterized_2d/color_scheme.html#pygerber.backend.rasterized_2d.color_scheme.ColorScheme.debug_1_color","title":"debug_1_color  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>debug_1_color: RGBA = RGBA.from_hex('#ababab')\n</code></pre> <p>Color used for debug elements.</p>"},{"location":"reference/pygerber/backend/rasterized_2d/color_scheme.html#pygerber.backend.rasterized_2d.color_scheme.ColorScheme.debug_2_color","title":"debug_2_color  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>debug_2_color: RGBA = RGBA.from_hex('#7d7d7d')\n</code></pre> <p>Color used for debug elements.</p>"},{"location":"reference/pygerber/backend/rasterized_2d/color_scheme.html#pygerber.backend.rasterized_2d.color_scheme.ColorScheme.get_grayscale_to_rgba_color_map","title":"get_grayscale_to_rgba_color_map","text":"<pre><code>get_grayscale_to_rgba_color_map() -&gt; (\ndict[int, tuple[int, int, int, int]]\n)\n</code></pre> <p>Return grayscale to RGBA color map.</p> Source code in <code>src/pygerber/backend/rasterized_2d/color_scheme.py</code> <pre><code>def get_grayscale_to_rgba_color_map(self) -&gt; dict[int, tuple[int, int, int, int]]:\n\"\"\"Return grayscale to RGBA color map.\"\"\"\nreturn {\nPolarity.Dark.get_2d_rasterized_color(): self.solid_color.as_rgba_int(),\nPolarity.Clear.get_2d_rasterized_color(): self.clear_color.as_rgba_int(),  # noqa: E501\nPolarity.DarkRegion.get_2d_rasterized_color(): self.solid_region_color.as_rgba_int(),  # noqa: E501\nPolarity.ClearRegion.get_2d_rasterized_color(): self.clear_region_color.as_rgba_int(),  # noqa: E501\nPolarity.Background.get_2d_rasterized_color(): self.background_color.as_rgba_int(),  # noqa: E501\nPolarity.DEBUG.get_2d_rasterized_color(): self.debug_1_color.as_rgba_int(),  # noqa: E501\nPolarity.DEBUG2.get_2d_rasterized_color(): self.debug_2_color.as_rgba_int(),  # noqa: E501\n}\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/draw_commands_handle.html","title":"draw_commands_handle","text":""},{"location":"reference/pygerber/backend/rasterized_2d/draw_commands_handle.html#pygerber.backend.rasterized_2d.draw_commands_handle","title":"draw_commands_handle","text":"<p>Contains class wrapping list of draw operations created by Gerber parser.</p>"},{"location":"reference/pygerber/backend/rasterized_2d/draw_commands_handle.html#pygerber.backend.rasterized_2d.draw_commands_handle.Rasterized2DDrawActionsHandle","title":"Rasterized2DDrawActionsHandle","text":"<p>             Bases: <code>DrawCommandsHandle</code></p> <p>List of drawing operations produced by Gerber parser.</p> Source code in <code>src/pygerber/backend/rasterized_2d/draw_commands_handle.py</code> <pre><code>class Rasterized2DDrawActionsHandle(DrawCommandsHandle):\n\"\"\"List of drawing operations produced by Gerber parser.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/drawing_target.html","title":"drawing_target","text":""},{"location":"reference/pygerber/backend/rasterized_2d/drawing_target.html#pygerber.backend.rasterized_2d.drawing_target","title":"drawing_target","text":"<p>Target for Draw commands to draw into.</p>"},{"location":"reference/pygerber/backend/rasterized_2d/drawing_target.html#pygerber.backend.rasterized_2d.drawing_target.GRAYSCALE_CENTER_VALUE","title":"GRAYSCALE_CENTER_VALUE  <code>module-attribute</code>","text":"<pre><code>GRAYSCALE_CENTER_VALUE: int = 127\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/drawing_target.html#pygerber.backend.rasterized_2d.drawing_target.Rasterized2DDrawingTarget","title":"Rasterized2DDrawingTarget","text":"<p>             Bases: <code>DrawingTarget</code></p> <p>Target for Draw commands to draw into.</p> Source code in <code>src/pygerber/backend/rasterized_2d/drawing_target.py</code> <pre><code>class Rasterized2DDrawingTarget(DrawingTarget):\n\"\"\"Target for Draw commands to draw into.\"\"\"\ntarget_image: Image.Image\n_target_image_polarity_dark: Optional[Image.Image] = None\n_target_image_polarity_clear: Optional[Image.Image] = None\n_target_image_polarity_region_dark: Optional[Image.Image] = None\n_target_image_polarity_region_clear: Optional[Image.Image] = None\n_mask_image: Optional[Image.Image] = None\ndef __init__(\nself,\ncoordinate_origin: Vector2D,\nbounding_box: BoundingBox,\ntarget_image: Image.Image,\n) -&gt; None:\n\"\"\"Initialize drawing target.\"\"\"\nsuper().__init__(coordinate_origin, bounding_box)\nself.target_image = target_image\nself._target_image_polarity_dark = None\nself._target_image_polarity_clear = None\nself._target_image_polarity_region_dark = None\nself._target_image_polarity_region_clear = None\nself._mask_image = None\nself._is_finalized = False\n@property\ndef image_draw(self) -&gt; ImageDraw.ImageDraw:\n\"\"\"Acquire drawing interface.\"\"\"\nreturn ImageDraw.Draw(self.target_image)\ndef _finalize(self) -&gt; None:\nself._is_finalized = True\n@property\ndef mask_image(self) -&gt; Image.Image:\n\"\"\"Inverted aperture image.\"\"\"\nif not self._is_finalized:\nraise ApertureImageNotInitializedError\nif self._mask_image is None:\nself._mask_image = self.target_image.point(\nlambda p: 255 if p &gt; GRAYSCALE_CENTER_VALUE else 0,\n)\nreturn self._mask_image\n@property\ndef image_polarity_dark(self) -&gt; Image.Image:\n\"\"\"Inverted aperture image.\"\"\"\nif not self._is_finalized:\nraise ApertureImageNotInitializedError\nif self._target_image_polarity_dark is None:\ncolor = Polarity.Dark.get_2d_rasterized_color()\nself._target_image_polarity_dark = self.mask_image.point(\nlambda p: color if p else 0,\n)\nreturn self._target_image_polarity_dark\n@property\ndef image_polarity_clear(self) -&gt; Image.Image:\n\"\"\"Inverted aperture image.\"\"\"\nif not self._is_finalized:\nraise ApertureImageNotInitializedError\nif self._target_image_polarity_clear is None:\ncolor = Polarity.Clear.get_2d_rasterized_color()\nself._target_image_polarity_clear = self.mask_image.point(\nlambda p: color if p else 0,\n)\nreturn self._target_image_polarity_clear\n@property\ndef image_polarity_region_dark(self) -&gt; Image.Image:\n\"\"\"Inverted aperture image.\"\"\"\nif not self._is_finalized:\nraise ApertureImageNotInitializedError\nif self._target_image_polarity_region_dark is None:\ncolor = Polarity.DarkRegion.get_2d_rasterized_color()\nself._target_image_polarity_region_dark = self.mask_image.point(\nlambda p: color if p else 0,\n)\nreturn self._target_image_polarity_region_dark\n@property\ndef image_polarity_region_clear(self) -&gt; Image.Image:\n\"\"\"Inverted aperture image.\"\"\"\nif not self._is_finalized:\nraise ApertureImageNotInitializedError\nif self._target_image_polarity_region_clear is None:\ncolor = Polarity.ClearRegion.get_2d_rasterized_color()\nself._target_image_polarity_region_clear = self.mask_image.point(\nlambda p: color if p else 0,\n)\nreturn self._target_image_polarity_region_clear\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/drawing_target.html#pygerber.backend.rasterized_2d.drawing_target.Rasterized2DDrawingTarget.image_draw","title":"image_draw  <code>property</code>","text":"<pre><code>image_draw: ImageDraw.ImageDraw\n</code></pre> <p>Acquire drawing interface.</p>"},{"location":"reference/pygerber/backend/rasterized_2d/drawing_target.html#pygerber.backend.rasterized_2d.drawing_target.Rasterized2DDrawingTarget.mask_image","title":"mask_image  <code>property</code>","text":"<pre><code>mask_image: Image.Image\n</code></pre> <p>Inverted aperture image.</p>"},{"location":"reference/pygerber/backend/rasterized_2d/drawing_target.html#pygerber.backend.rasterized_2d.drawing_target.Rasterized2DDrawingTarget.image_polarity_dark","title":"image_polarity_dark  <code>property</code>","text":"<pre><code>image_polarity_dark: Image.Image\n</code></pre> <p>Inverted aperture image.</p>"},{"location":"reference/pygerber/backend/rasterized_2d/drawing_target.html#pygerber.backend.rasterized_2d.drawing_target.Rasterized2DDrawingTarget.image_polarity_clear","title":"image_polarity_clear  <code>property</code>","text":"<pre><code>image_polarity_clear: Image.Image\n</code></pre> <p>Inverted aperture image.</p>"},{"location":"reference/pygerber/backend/rasterized_2d/drawing_target.html#pygerber.backend.rasterized_2d.drawing_target.Rasterized2DDrawingTarget.image_polarity_region_dark","title":"image_polarity_region_dark  <code>property</code>","text":"<pre><code>image_polarity_region_dark: Image.Image\n</code></pre> <p>Inverted aperture image.</p>"},{"location":"reference/pygerber/backend/rasterized_2d/drawing_target.html#pygerber.backend.rasterized_2d.drawing_target.Rasterized2DDrawingTarget.image_polarity_region_clear","title":"image_polarity_region_clear  <code>property</code>","text":"<pre><code>image_polarity_region_clear: Image.Image\n</code></pre> <p>Inverted aperture image.</p>"},{"location":"reference/pygerber/backend/rasterized_2d/drawing_target.html#pygerber.backend.rasterized_2d.drawing_target.Rasterized2DDrawingTarget.__init__","title":"__init__","text":"<pre><code>__init__(\ncoordinate_origin: Vector2D,\nbounding_box: BoundingBox,\ntarget_image: Image.Image,\n) -&gt; None\n</code></pre> <p>Initialize drawing target.</p> Source code in <code>src/pygerber/backend/rasterized_2d/drawing_target.py</code> <pre><code>def __init__(\nself,\ncoordinate_origin: Vector2D,\nbounding_box: BoundingBox,\ntarget_image: Image.Image,\n) -&gt; None:\n\"\"\"Initialize drawing target.\"\"\"\nsuper().__init__(coordinate_origin, bounding_box)\nself.target_image = target_image\nself._target_image_polarity_dark = None\nself._target_image_polarity_clear = None\nself._target_image_polarity_region_dark = None\nself._target_image_polarity_region_clear = None\nself._mask_image = None\nself._is_finalized = False\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/errors.html","title":"errors","text":""},{"location":"reference/pygerber/backend/rasterized_2d/errors.html#pygerber.backend.rasterized_2d.errors","title":"errors","text":"<p>Base error classes used in this module.</p>"},{"location":"reference/pygerber/backend/rasterized_2d/errors.html#pygerber.backend.rasterized_2d.errors.Rasterized2DBackendError","title":"Rasterized2DBackendError","text":"<p>             Bases: <code>BackendError</code></p> <p>Base class for backend errors.</p> Source code in <code>src/pygerber/backend/rasterized_2d/errors.py</code> <pre><code>class Rasterized2DBackendError(BackendError):\n\"\"\"Base class for backend errors.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/errors.html#pygerber.backend.rasterized_2d.errors.ApertureImageNotInitializedError","title":"ApertureImageNotInitializedError","text":"<p>             Bases: <code>Rasterized2DBackendError</code></p> <p>Raised when aperture image is requested before it was initialized.</p> Source code in <code>src/pygerber/backend/rasterized_2d/errors.py</code> <pre><code>class ApertureImageNotInitializedError(Rasterized2DBackendError):\n\"\"\"Raised when aperture image is requested before it was initialized.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/errors.html#pygerber.backend.rasterized_2d.errors.BackendImageNotInitializedError","title":"BackendImageNotInitializedError","text":"<p>             Bases: <code>Rasterized2DBackendError</code></p> <p>Raised when backend canvas image is requested before initialization.</p> Source code in <code>src/pygerber/backend/rasterized_2d/errors.py</code> <pre><code>class BackendImageNotInitializedError(Rasterized2DBackendError):\n\"\"\"Raised when backend canvas image is requested before initialization.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/image_tools.html","title":"image_tools","text":""},{"location":"reference/pygerber/backend/rasterized_2d/image_tools.html#pygerber.backend.rasterized_2d.image_tools","title":"image_tools","text":"<p>Utils for image operations.</p>"},{"location":"reference/pygerber/backend/rasterized_2d/image_tools.html#pygerber.backend.rasterized_2d.image_tools.replace_color","title":"replace_color","text":"<pre><code>replace_color(\ninput_image: Image.Image,\noriginal: tuple[int, ...] | int,\nreplacement: tuple[int, ...] | int,\n*,\noutput_image_mode: str = \"RGBA\"\n) -&gt; Image.Image\n</code></pre> <p>Replace <code>original</code> color from input image with <code>replacement</code> color.</p> Source code in <code>src/pygerber/backend/rasterized_2d/image_tools.py</code> <pre><code>def replace_color(\ninput_image: Image.Image,\noriginal: tuple[int, ...] | int,\nreplacement: tuple[int, ...] | int,\n*,\noutput_image_mode: str = \"RGBA\",\n) -&gt; Image.Image:\n\"\"\"Replace `original` color from input image with `replacement` color.\"\"\"\nif input_image.mode != output_image_mode:\noutput_image = input_image.convert(output_image_mode)\nelse:\noutput_image = input_image.copy()\nfor x in range(input_image.width):\nfor y in range(input_image.height):\nif input_image.getpixel((x, y)) == original:\noutput_image.putpixel((x, y), replacement)\nreturn output_image\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/result_handle.html","title":"result_handle","text":""},{"location":"reference/pygerber/backend/rasterized_2d/result_handle.html#pygerber.backend.rasterized_2d.result_handle","title":"result_handle","text":"<p>Module contains handle class to drawing instructions visualization.</p>"},{"location":"reference/pygerber/backend/rasterized_2d/result_handle.html#pygerber.backend.rasterized_2d.result_handle.Rasterized2DResultHandle","title":"Rasterized2DResultHandle","text":"<p>             Bases: <code>ResultHandle</code></p> <p>Handle to drawing instructions visualization.</p> Source code in <code>src/pygerber/backend/rasterized_2d/result_handle.py</code> <pre><code>class Rasterized2DResultHandle(ResultHandle):\n\"\"\"Handle to drawing instructions visualization.\"\"\"\ndef __init__(self, result: Image.Image) -&gt; None:\n\"\"\"Initialize result handle.\n        Parameters\n        ----------\n        result : Image.Image\n            Image object containing finished Gerber image.\n        \"\"\"\nsuper().__init__()\nself.result = result\ndef save(\nself,\ndest: Path | str | BytesIO,\n**kwargs: Any,\n) -&gt; None:\n\"\"\"Save result to destination.\n        Parameters\n        ----------\n        dest : Path | str | BytesIO\n            Write target.\n        **kwargs: Any\n            Extra parameters which will be passed to `Image.save()`.\n            For details see [Pillow documentation](https://pillow.readthedocs.io/en/stable/reference/Image.html#PIL.Image.Image.save).\n        \"\"\"\nself.get_image().save(dest, **kwargs)\ndef get_image(self) -&gt; Image.Image:\n\"\"\"Get result image object.\"\"\"\nreturn self.result.transpose(Image.FLIP_TOP_BOTTOM)\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/result_handle.html#pygerber.backend.rasterized_2d.result_handle.Rasterized2DResultHandle.__init__","title":"__init__","text":"<pre><code>__init__(result: Image.Image) -&gt; None\n</code></pre> <p>Initialize result handle.</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>Image.Image</code> <p>Image object containing finished Gerber image.</p> required Source code in <code>src/pygerber/backend/rasterized_2d/result_handle.py</code> <pre><code>def __init__(self, result: Image.Image) -&gt; None:\n\"\"\"Initialize result handle.\n    Parameters\n    ----------\n    result : Image.Image\n        Image object containing finished Gerber image.\n    \"\"\"\nsuper().__init__()\nself.result = result\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/result_handle.html#pygerber.backend.rasterized_2d.result_handle.Rasterized2DResultHandle.save","title":"save","text":"<pre><code>save(dest: Path | str | BytesIO, **kwargs: Any) -&gt; None\n</code></pre> <p>Save result to destination.</p> <p>Parameters:</p> Name Type Description Default <code>dest</code> <code>Path | str | BytesIO</code> <p>Write target.</p> required <code>**kwargs</code> <code>Any</code> <p>Extra parameters which will be passed to <code>Image.save()</code>. For details see Pillow documentation.</p> <code>{}</code> Source code in <code>src/pygerber/backend/rasterized_2d/result_handle.py</code> <pre><code>def save(\nself,\ndest: Path | str | BytesIO,\n**kwargs: Any,\n) -&gt; None:\n\"\"\"Save result to destination.\n    Parameters\n    ----------\n    dest : Path | str | BytesIO\n        Write target.\n    **kwargs: Any\n        Extra parameters which will be passed to `Image.save()`.\n        For details see [Pillow documentation](https://pillow.readthedocs.io/en/stable/reference/Image.html#PIL.Image.Image.save).\n    \"\"\"\nself.get_image().save(dest, **kwargs)\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/result_handle.html#pygerber.backend.rasterized_2d.result_handle.Rasterized2DResultHandle.get_image","title":"get_image","text":"<pre><code>get_image() -&gt; Image.Image\n</code></pre> <p>Get result image object.</p> Source code in <code>src/pygerber/backend/rasterized_2d/result_handle.py</code> <pre><code>def get_image(self) -&gt; Image.Image:\n\"\"\"Get result image object.\"\"\"\nreturn self.result.transpose(Image.FLIP_TOP_BOTTOM)\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/draw_commands/__init__.html","title":"init","text":""},{"location":"reference/pygerber/backend/rasterized_2d/draw_commands/__init__.html#pygerber.backend.rasterized_2d.draw_commands","title":"draw_commands","text":"<p>Specialized implementations of draw operations for constructing apertures.</p>"},{"location":"reference/pygerber/backend/rasterized_2d/draw_commands/draw_arc.html","title":"draw_arc","text":""},{"location":"reference/pygerber/backend/rasterized_2d/draw_commands/draw_arc.html#pygerber.backend.rasterized_2d.draw_commands.draw_arc","title":"draw_arc","text":"<p>Class for drawing 2D rasterized vector lines.</p>"},{"location":"reference/pygerber/backend/rasterized_2d/draw_commands/draw_arc.html#pygerber.backend.rasterized_2d.draw_commands.draw_arc.Rasterized2DDrawArc","title":"Rasterized2DDrawArc","text":"<p>             Bases: <code>DrawArc</code></p> <p>Draw 2D rasterized vector line.</p> Source code in <code>src/pygerber/backend/rasterized_2d/draw_commands/draw_arc.py</code> <pre><code>class Rasterized2DDrawArc(DrawArc):\n\"\"\"Draw 2D rasterized vector line.\"\"\"\nbackend: Rasterized2DBackend\ndef draw(self, target: DrawingTarget) -&gt; None:\n\"\"\"Apply aperture draw component to handle.\"\"\"\nif not isinstance(target, Rasterized2DDrawingTarget):\nmsg = f\"Expected Rasterized2DDrawingTarget got {type(target)}\"\nraise TypeError(msg)\nbbox = self.get_bounding_box() - target.coordinate_origin\npixel_box = bbox.as_pixel_box(self.backend.dpi)\nangle_start = self.arc_space_start_position.angle_between_clockwise(\nVector2D.UNIT_Y,\n)\nangle_end = self.arc_space_end_position.angle_between_clockwise(Vector2D.UNIT_Y)\nif self.is_multi_quadrant and angle_start == angle_end:\nangle_start = 0\nangle_end = 360\nelif self.is_clockwise:\nangle_start, angle_end = angle_end, angle_start\nwidth = self.width.as_pixels(self.backend.dpi)\ntarget.image_draw.arc(\nxy=pixel_box,\nstart=angle_start,\nend=angle_end,\nfill=self.polarity.get_2d_rasterized_color(),\nwidth=width,\n)\nlogging.debug(\"Adding %s to %s\", self.__class__.__qualname__, target)\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/draw_commands/draw_arc.html#pygerber.backend.rasterized_2d.draw_commands.draw_arc.Rasterized2DDrawArc.draw","title":"draw","text":"<pre><code>draw(target: DrawingTarget) -&gt; None\n</code></pre> <p>Apply aperture draw component to handle.</p> Source code in <code>src/pygerber/backend/rasterized_2d/draw_commands/draw_arc.py</code> <pre><code>def draw(self, target: DrawingTarget) -&gt; None:\n\"\"\"Apply aperture draw component to handle.\"\"\"\nif not isinstance(target, Rasterized2DDrawingTarget):\nmsg = f\"Expected Rasterized2DDrawingTarget got {type(target)}\"\nraise TypeError(msg)\nbbox = self.get_bounding_box() - target.coordinate_origin\npixel_box = bbox.as_pixel_box(self.backend.dpi)\nangle_start = self.arc_space_start_position.angle_between_clockwise(\nVector2D.UNIT_Y,\n)\nangle_end = self.arc_space_end_position.angle_between_clockwise(Vector2D.UNIT_Y)\nif self.is_multi_quadrant and angle_start == angle_end:\nangle_start = 0\nangle_end = 360\nelif self.is_clockwise:\nangle_start, angle_end = angle_end, angle_start\nwidth = self.width.as_pixels(self.backend.dpi)\ntarget.image_draw.arc(\nxy=pixel_box,\nstart=angle_start,\nend=angle_end,\nfill=self.polarity.get_2d_rasterized_color(),\nwidth=width,\n)\nlogging.debug(\"Adding %s to %s\", self.__class__.__qualname__, target)\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/draw_commands/draw_bounding_box.html","title":"draw_bounding_box","text":""},{"location":"reference/pygerber/backend/rasterized_2d/draw_commands/draw_bounding_box.html#pygerber.backend.rasterized_2d.draw_commands.draw_bounding_box","title":"draw_bounding_box","text":"<p>BoundingBox component for creating apertures.</p>"},{"location":"reference/pygerber/backend/rasterized_2d/draw_commands/draw_bounding_box.html#pygerber.backend.rasterized_2d.draw_commands.draw_bounding_box.Rasterized2DApertureDrawBoundingBox","title":"Rasterized2DApertureDrawBoundingBox","text":"<p>             Bases: <code>DrawBoundingBox</code></p> <p>Concrete implementation of DrawBoundingBox for rasterized 2D drawing.</p> Source code in <code>src/pygerber/backend/rasterized_2d/draw_commands/draw_bounding_box.py</code> <pre><code>class Rasterized2DApertureDrawBoundingBox(DrawBoundingBox):\n\"\"\"Concrete implementation of DrawBoundingBox for rasterized 2D drawing.\"\"\"\nbackend: Rasterized2DBackend\ndef draw(self, target: DrawingTarget) -&gt; None:\n\"\"\"Apply bounding box draw component to handle.\"\"\"\nif not isinstance(target, Rasterized2DDrawingTarget):\nmsg = f\"Expected Rasterized2DDrawingTarget got {type(target)}\"\nraise TypeError(msg)\nbox = self.get_bounding_box()\nimage_space_box = box - target.coordinate_origin\npixel_box = image_space_box.as_pixel_box(self.backend.dpi, dx_max=-1, dy_max=-1)\n(min_x, min_y, max_x, max_y) = pixel_box\nif (max_x - min_x &lt;= 0) or (max_y - min_y &lt;= 0):\nlogging.warning(\"Drawing zero surface bounding box. DPI may be too low.\")\nreturn\ntarget.image_draw.rectangle(\nxy=pixel_box,\nfill=None,\noutline=self.polarity.get_2d_rasterized_color(),\nwidth=1,\n)\nlogging.debug(\"Adding %s to %s\", self.__class__.__qualname__, target)\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/draw_commands/draw_bounding_box.html#pygerber.backend.rasterized_2d.draw_commands.draw_bounding_box.Rasterized2DApertureDrawBoundingBox.draw","title":"draw","text":"<pre><code>draw(target: DrawingTarget) -&gt; None\n</code></pre> <p>Apply bounding box draw component to handle.</p> Source code in <code>src/pygerber/backend/rasterized_2d/draw_commands/draw_bounding_box.py</code> <pre><code>def draw(self, target: DrawingTarget) -&gt; None:\n\"\"\"Apply bounding box draw component to handle.\"\"\"\nif not isinstance(target, Rasterized2DDrawingTarget):\nmsg = f\"Expected Rasterized2DDrawingTarget got {type(target)}\"\nraise TypeError(msg)\nbox = self.get_bounding_box()\nimage_space_box = box - target.coordinate_origin\npixel_box = image_space_box.as_pixel_box(self.backend.dpi, dx_max=-1, dy_max=-1)\n(min_x, min_y, max_x, max_y) = pixel_box\nif (max_x - min_x &lt;= 0) or (max_y - min_y &lt;= 0):\nlogging.warning(\"Drawing zero surface bounding box. DPI may be too low.\")\nreturn\ntarget.image_draw.rectangle(\nxy=pixel_box,\nfill=None,\noutline=self.polarity.get_2d_rasterized_color(),\nwidth=1,\n)\nlogging.debug(\"Adding %s to %s\", self.__class__.__qualname__, target)\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/draw_commands/draw_circle.html","title":"draw_circle","text":""},{"location":"reference/pygerber/backend/rasterized_2d/draw_commands/draw_circle.html#pygerber.backend.rasterized_2d.draw_commands.draw_circle","title":"draw_circle","text":"<p>Circle component for creating apertures.</p>"},{"location":"reference/pygerber/backend/rasterized_2d/draw_commands/draw_circle.html#pygerber.backend.rasterized_2d.draw_commands.draw_circle.Rasterized2DApertureDrawCircle","title":"Rasterized2DApertureDrawCircle","text":"<p>             Bases: <code>DrawCircle</code></p> <p>Description of circle aperture component.</p> Source code in <code>src/pygerber/backend/rasterized_2d/draw_commands/draw_circle.py</code> <pre><code>class Rasterized2DApertureDrawCircle(DrawCircle):\n\"\"\"Description of circle aperture component.\"\"\"\nbackend: Rasterized2DBackend\ndef draw(self, target: DrawingTarget) -&gt; None:\n\"\"\"Apply aperture draw component to handle.\"\"\"\nif not isinstance(target, Rasterized2DDrawingTarget):\nmsg = f\"Expected Rasterized2DDrawingTarget got {type(target)}\"\nraise TypeError(msg)\nbox = self.get_bounding_box()\nimage_space_box = box - target.coordinate_origin\npixel_box = image_space_box.as_pixel_box(\nself.backend.dpi,\ndx_max=-2,\ndy_max=-2,\ndx_min=+1,\ndy_min=+1,\n)\n(min_x, min_y, max_x, max_y) = pixel_box\nif (max_x - min_x &lt;= 0) or (max_y - min_y &lt;= 0):\nlogging.warning(\n\"Drawing zero surface circle. DPI may be too low. %s\",\npixel_box,\n)\nelse:\ntarget.image_draw.ellipse(\nxy=pixel_box,\nfill=self.polarity.get_2d_rasterized_color(),\noutline=None,\nwidth=0,\n)\nlogging.debug(\"Adding %s to %s\", self.__class__.__qualname__, target)\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/draw_commands/draw_circle.html#pygerber.backend.rasterized_2d.draw_commands.draw_circle.Rasterized2DApertureDrawCircle.draw","title":"draw","text":"<pre><code>draw(target: DrawingTarget) -&gt; None\n</code></pre> <p>Apply aperture draw component to handle.</p> Source code in <code>src/pygerber/backend/rasterized_2d/draw_commands/draw_circle.py</code> <pre><code>def draw(self, target: DrawingTarget) -&gt; None:\n\"\"\"Apply aperture draw component to handle.\"\"\"\nif not isinstance(target, Rasterized2DDrawingTarget):\nmsg = f\"Expected Rasterized2DDrawingTarget got {type(target)}\"\nraise TypeError(msg)\nbox = self.get_bounding_box()\nimage_space_box = box - target.coordinate_origin\npixel_box = image_space_box.as_pixel_box(\nself.backend.dpi,\ndx_max=-2,\ndy_max=-2,\ndx_min=+1,\ndy_min=+1,\n)\n(min_x, min_y, max_x, max_y) = pixel_box\nif (max_x - min_x &lt;= 0) or (max_y - min_y &lt;= 0):\nlogging.warning(\n\"Drawing zero surface circle. DPI may be too low. %s\",\npixel_box,\n)\nelse:\ntarget.image_draw.ellipse(\nxy=pixel_box,\nfill=self.polarity.get_2d_rasterized_color(),\noutline=None,\nwidth=0,\n)\nlogging.debug(\"Adding %s to %s\", self.__class__.__qualname__, target)\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/draw_commands/draw_paste.html","title":"draw_paste","text":""},{"location":"reference/pygerber/backend/rasterized_2d/draw_commands/draw_paste.html#pygerber.backend.rasterized_2d.draw_commands.draw_paste","title":"draw_paste","text":"<p>Base class for creating components for aperture creation.</p>"},{"location":"reference/pygerber/backend/rasterized_2d/draw_commands/draw_paste.html#pygerber.backend.rasterized_2d.draw_commands.draw_paste.Rasterized2DDrawPaste","title":"Rasterized2DDrawPaste","text":"<p>             Bases: <code>DrawPaste</code></p> <p>Description of aperture component.</p> Source code in <code>src/pygerber/backend/rasterized_2d/draw_commands/draw_paste.py</code> <pre><code>class Rasterized2DDrawPaste(DrawPaste):\n\"\"\"Description of aperture component.\"\"\"\nother: Rasterized2DDrawingTarget\nbackend: Rasterized2DBackend\ndef draw(self, target: DrawingTarget) -&gt; None:\n\"\"\"Apply aperture draw component to handle.\"\"\"\nif not isinstance(target, Rasterized2DDrawingTarget):\nmsg = f\"Expected Rasterized2DDrawingTarget got {type(target)}\"\nraise TypeError(msg)\nbox = self.get_bounding_box()\nimage_space_box = box - target.coordinate_origin\npixel_box = image_space_box.get_min_vector().as_pixels(self.backend.dpi)\nif self.polarity == Polarity.Dark:\nim = self.other.image_polarity_dark\nelif self.polarity == Polarity.Clear:\nim = self.other.image_polarity_clear\nelif self.polarity == Polarity.DarkRegion:\nim = self.other.image_polarity_region_dark\nelif self.polarity == Polarity.ClearRegion:\nim = self.other.image_polarity_region_clear\nelse:\nim = replace_color(\nself.other.target_image,\nPolarity.Dark.get_2d_rasterized_color(),\nself.polarity.get_2d_rasterized_color(),\noutput_image_mode=\"L\",\n)\ntarget.target_image.paste(\nim=im,\nbox=pixel_box,\nmask=self.other.mask_image,\n)\nlogging.debug(\"Adding %s to %s\", self.__class__.__qualname__, target)\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/draw_commands/draw_paste.html#pygerber.backend.rasterized_2d.draw_commands.draw_paste.Rasterized2DDrawPaste.draw","title":"draw","text":"<pre><code>draw(target: DrawingTarget) -&gt; None\n</code></pre> <p>Apply aperture draw component to handle.</p> Source code in <code>src/pygerber/backend/rasterized_2d/draw_commands/draw_paste.py</code> <pre><code>def draw(self, target: DrawingTarget) -&gt; None:\n\"\"\"Apply aperture draw component to handle.\"\"\"\nif not isinstance(target, Rasterized2DDrawingTarget):\nmsg = f\"Expected Rasterized2DDrawingTarget got {type(target)}\"\nraise TypeError(msg)\nbox = self.get_bounding_box()\nimage_space_box = box - target.coordinate_origin\npixel_box = image_space_box.get_min_vector().as_pixels(self.backend.dpi)\nif self.polarity == Polarity.Dark:\nim = self.other.image_polarity_dark\nelif self.polarity == Polarity.Clear:\nim = self.other.image_polarity_clear\nelif self.polarity == Polarity.DarkRegion:\nim = self.other.image_polarity_region_dark\nelif self.polarity == Polarity.ClearRegion:\nim = self.other.image_polarity_region_clear\nelse:\nim = replace_color(\nself.other.target_image,\nPolarity.Dark.get_2d_rasterized_color(),\nself.polarity.get_2d_rasterized_color(),\noutput_image_mode=\"L\",\n)\ntarget.target_image.paste(\nim=im,\nbox=pixel_box,\nmask=self.other.mask_image,\n)\nlogging.debug(\"Adding %s to %s\", self.__class__.__qualname__, target)\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/draw_commands/draw_polygon.html","title":"draw_polygon","text":""},{"location":"reference/pygerber/backend/rasterized_2d/draw_commands/draw_polygon.html#pygerber.backend.rasterized_2d.draw_commands.draw_polygon","title":"draw_polygon","text":"<p>Polygon component for creating apertures.</p>"},{"location":"reference/pygerber/backend/rasterized_2d/draw_commands/draw_polygon.html#pygerber.backend.rasterized_2d.draw_commands.draw_polygon.NUMBER_OF_VERTICES_IN_TRIANGLE","title":"NUMBER_OF_VERTICES_IN_TRIANGLE  <code>module-attribute</code>","text":"<pre><code>NUMBER_OF_VERTICES_IN_TRIANGLE = 3\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/draw_commands/draw_polygon.html#pygerber.backend.rasterized_2d.draw_commands.draw_polygon.Rasterized2DApertureDrawPolygon","title":"Rasterized2DApertureDrawPolygon","text":"<p>             Bases: <code>DrawPolygon</code></p> <p>Description of polygon aperture component.</p> Source code in <code>src/pygerber/backend/rasterized_2d/draw_commands/draw_polygon.py</code> <pre><code>class Rasterized2DApertureDrawPolygon(DrawPolygon):\n\"\"\"Description of polygon aperture component.\"\"\"\nbackend: Rasterized2DBackend\ndef draw(self, target: DrawingTarget) -&gt; None:\n\"\"\"Apply aperture draw component to handle.\"\"\"\nif not isinstance(target, Rasterized2DDrawingTarget):\nmsg = f\"Expected Rasterized2DDrawingTarget got {type(target)}\"\nraise TypeError(msg)\nbox = self.get_bounding_box()\nimage_space_box = box - target.coordinate_origin\ncenter = image_space_box.center.as_pixels(self.backend.dpi)\nbounding_circle = (\n*center,\n(self.outer_diameter / 2).as_pixels(self.backend.dpi),\n)\nrotation = float(-self.rotation + Decimal(\"-90.0\"))\nif self.number_of_vertices &lt; NUMBER_OF_VERTICES_IN_TRIANGLE:\nlogging.warning(\n\"Drawing invalid polygon, number of vertices &lt; 3 (%s)\",\nself.number_of_vertices,\n)\nreturn\n(_, __, radius) = bounding_circle\nif radius == 0:\nlogging.warning(\n\"Drawing zero surface polygon. DPI may be too low. %s\",\nbounding_circle,\n)\nreturn\ntarget.image_draw.regular_polygon(\nbounding_circle=bounding_circle,\nn_sides=self.number_of_vertices,\nrotation=rotation,\nfill=self.polarity.get_2d_rasterized_color(),\noutline=None,\nwidth=0,\n)\nlogging.debug(\"Adding %s to %s\", self.__class__.__qualname__, target)\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/draw_commands/draw_polygon.html#pygerber.backend.rasterized_2d.draw_commands.draw_polygon.Rasterized2DApertureDrawPolygon.draw","title":"draw","text":"<pre><code>draw(target: DrawingTarget) -&gt; None\n</code></pre> <p>Apply aperture draw component to handle.</p> Source code in <code>src/pygerber/backend/rasterized_2d/draw_commands/draw_polygon.py</code> <pre><code>def draw(self, target: DrawingTarget) -&gt; None:\n\"\"\"Apply aperture draw component to handle.\"\"\"\nif not isinstance(target, Rasterized2DDrawingTarget):\nmsg = f\"Expected Rasterized2DDrawingTarget got {type(target)}\"\nraise TypeError(msg)\nbox = self.get_bounding_box()\nimage_space_box = box - target.coordinate_origin\ncenter = image_space_box.center.as_pixels(self.backend.dpi)\nbounding_circle = (\n*center,\n(self.outer_diameter / 2).as_pixels(self.backend.dpi),\n)\nrotation = float(-self.rotation + Decimal(\"-90.0\"))\nif self.number_of_vertices &lt; NUMBER_OF_VERTICES_IN_TRIANGLE:\nlogging.warning(\n\"Drawing invalid polygon, number of vertices &lt; 3 (%s)\",\nself.number_of_vertices,\n)\nreturn\n(_, __, radius) = bounding_circle\nif radius == 0:\nlogging.warning(\n\"Drawing zero surface polygon. DPI may be too low. %s\",\nbounding_circle,\n)\nreturn\ntarget.image_draw.regular_polygon(\nbounding_circle=bounding_circle,\nn_sides=self.number_of_vertices,\nrotation=rotation,\nfill=self.polarity.get_2d_rasterized_color(),\noutline=None,\nwidth=0,\n)\nlogging.debug(\"Adding %s to %s\", self.__class__.__qualname__, target)\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/draw_commands/draw_rectangle.html","title":"draw_rectangle","text":""},{"location":"reference/pygerber/backend/rasterized_2d/draw_commands/draw_rectangle.html#pygerber.backend.rasterized_2d.draw_commands.draw_rectangle","title":"draw_rectangle","text":"<p>Rectangle component for creating apertures.</p>"},{"location":"reference/pygerber/backend/rasterized_2d/draw_commands/draw_rectangle.html#pygerber.backend.rasterized_2d.draw_commands.draw_rectangle.Rasterized2DApertureDrawRectangle","title":"Rasterized2DApertureDrawRectangle","text":"<p>             Bases: <code>DrawRectangle</code></p> <p>Description of rectangle aperture component.</p> Source code in <code>src/pygerber/backend/rasterized_2d/draw_commands/draw_rectangle.py</code> <pre><code>class Rasterized2DApertureDrawRectangle(DrawRectangle):\n\"\"\"Description of rectangle aperture component.\"\"\"\nbackend: Rasterized2DBackend\ndef draw(self, target: DrawingTarget) -&gt; None:\n\"\"\"Apply aperture draw component to handle.\"\"\"\nif not isinstance(target, Rasterized2DDrawingTarget):\nmsg = f\"Expected Rasterized2DDrawingTarget got {type(target)}\"\nraise TypeError(msg)\nbox = self.get_bounding_box()\nimage_space_box = box - target.coordinate_origin\npixel_box = image_space_box.as_pixel_box(\nself.backend.dpi,\n)\n(min_x, min_y, max_x, max_y) = pixel_box\nif (max_x - min_x &lt;= 0) or (max_y - min_y &lt;= 0):\nlogging.warning(\n\"Drawing zero surface rectangle. DPI may be too low. %s\",\npixel_box,\n)\nelse:\ntarget.image_draw.rectangle(\nxy=pixel_box,\nfill=self.polarity.get_2d_rasterized_color(),\noutline=None,\nwidth=0,\n)\nlogging.debug(\"Adding %s to %s\", self.__class__.__qualname__, target)\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/draw_commands/draw_rectangle.html#pygerber.backend.rasterized_2d.draw_commands.draw_rectangle.Rasterized2DApertureDrawRectangle.draw","title":"draw","text":"<pre><code>draw(target: DrawingTarget) -&gt; None\n</code></pre> <p>Apply aperture draw component to handle.</p> Source code in <code>src/pygerber/backend/rasterized_2d/draw_commands/draw_rectangle.py</code> <pre><code>def draw(self, target: DrawingTarget) -&gt; None:\n\"\"\"Apply aperture draw component to handle.\"\"\"\nif not isinstance(target, Rasterized2DDrawingTarget):\nmsg = f\"Expected Rasterized2DDrawingTarget got {type(target)}\"\nraise TypeError(msg)\nbox = self.get_bounding_box()\nimage_space_box = box - target.coordinate_origin\npixel_box = image_space_box.as_pixel_box(\nself.backend.dpi,\n)\n(min_x, min_y, max_x, max_y) = pixel_box\nif (max_x - min_x &lt;= 0) or (max_y - min_y &lt;= 0):\nlogging.warning(\n\"Drawing zero surface rectangle. DPI may be too low. %s\",\npixel_box,\n)\nelse:\ntarget.image_draw.rectangle(\nxy=pixel_box,\nfill=self.polarity.get_2d_rasterized_color(),\noutline=None,\nwidth=0,\n)\nlogging.debug(\"Adding %s to %s\", self.__class__.__qualname__, target)\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/draw_commands/draw_region.html","title":"draw_region","text":""},{"location":"reference/pygerber/backend/rasterized_2d/draw_commands/draw_region.html#pygerber.backend.rasterized_2d.draw_commands.draw_region","title":"draw_region","text":"<p>Class for drawing 2D rasterized vector lines.</p>"},{"location":"reference/pygerber/backend/rasterized_2d/draw_commands/draw_region.html#pygerber.backend.rasterized_2d.draw_commands.draw_region.NUMBER_OF_VERTICES_IN_TRIANGLE","title":"NUMBER_OF_VERTICES_IN_TRIANGLE  <code>module-attribute</code>","text":"<pre><code>NUMBER_OF_VERTICES_IN_TRIANGLE = 3\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/draw_commands/draw_region.html#pygerber.backend.rasterized_2d.draw_commands.draw_region.Rasterized2DDrawRegion","title":"Rasterized2DDrawRegion","text":"<p>             Bases: <code>DrawRegion</code></p> <p>Draw 2D rasterized vector line.</p> Source code in <code>src/pygerber/backend/rasterized_2d/draw_commands/draw_region.py</code> <pre><code>class Rasterized2DDrawRegion(DrawRegion):\n\"\"\"Draw 2D rasterized vector line.\"\"\"\nbackend: Rasterized2DBackend\ndef draw(self, target: DrawingTarget) -&gt; None:\n\"\"\"Apply aperture draw component to handle.\"\"\"\nif not isinstance(target, Rasterized2DDrawingTarget):\nmsg = f\"Expected Rasterized2DDrawingTarget got {type(target)}\"\nraise TypeError(msg)\nboundary_points: list[tuple[int, int]] = []\nfor point in self.region_boundary_points:\npixel_point = (point - target.coordinate_origin).as_pixels(\nself.backend.dpi,\n)\nboundary_points.append(pixel_point)\nif len(boundary_points) &lt; NUMBER_OF_VERTICES_IN_TRIANGLE:\nlogging.warning(\n\"Drawing invalid region, number of vertices &lt; 3 (%s)\",\nlen(boundary_points),\n)\nreturn\ntarget.image_draw.polygon(\nboundary_points,\nfill=self.polarity.get_2d_rasterized_color(),\n)\nlogging.debug(\"Adding %s to %s\", self.__class__.__qualname__, target)\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/draw_commands/draw_region.html#pygerber.backend.rasterized_2d.draw_commands.draw_region.Rasterized2DDrawRegion.draw","title":"draw","text":"<pre><code>draw(target: DrawingTarget) -&gt; None\n</code></pre> <p>Apply aperture draw component to handle.</p> Source code in <code>src/pygerber/backend/rasterized_2d/draw_commands/draw_region.py</code> <pre><code>def draw(self, target: DrawingTarget) -&gt; None:\n\"\"\"Apply aperture draw component to handle.\"\"\"\nif not isinstance(target, Rasterized2DDrawingTarget):\nmsg = f\"Expected Rasterized2DDrawingTarget got {type(target)}\"\nraise TypeError(msg)\nboundary_points: list[tuple[int, int]] = []\nfor point in self.region_boundary_points:\npixel_point = (point - target.coordinate_origin).as_pixels(\nself.backend.dpi,\n)\nboundary_points.append(pixel_point)\nif len(boundary_points) &lt; NUMBER_OF_VERTICES_IN_TRIANGLE:\nlogging.warning(\n\"Drawing invalid region, number of vertices &lt; 3 (%s)\",\nlen(boundary_points),\n)\nreturn\ntarget.image_draw.polygon(\nboundary_points,\nfill=self.polarity.get_2d_rasterized_color(),\n)\nlogging.debug(\"Adding %s to %s\", self.__class__.__qualname__, target)\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/draw_commands/draw_vector_line.html","title":"draw_vector_line","text":""},{"location":"reference/pygerber/backend/rasterized_2d/draw_commands/draw_vector_line.html#pygerber.backend.rasterized_2d.draw_commands.draw_vector_line","title":"draw_vector_line","text":"<p>Class for drawing 2D rasterized vector lines.</p>"},{"location":"reference/pygerber/backend/rasterized_2d/draw_commands/draw_vector_line.html#pygerber.backend.rasterized_2d.draw_commands.draw_vector_line.Rasterized2DDrawVectorLine","title":"Rasterized2DDrawVectorLine","text":"<p>             Bases: <code>DrawVectorLine</code></p> <p>Draw 2D rasterized vector line.</p> Source code in <code>src/pygerber/backend/rasterized_2d/draw_commands/draw_vector_line.py</code> <pre><code>class Rasterized2DDrawVectorLine(DrawVectorLine):\n\"\"\"Draw 2D rasterized vector line.\"\"\"\nbackend: Rasterized2DBackend\ndef draw(self, target: DrawingTarget) -&gt; None:\n\"\"\"Apply aperture draw component to handle.\"\"\"\nif not isinstance(target, Rasterized2DDrawingTarget):\nmsg = f\"Expected Rasterized2DDrawingTarget got {type(target)}\"\nraise TypeError(msg)\nstart = (self.start_position - target.coordinate_origin).as_pixels(\nself.backend.dpi,\n)\nend = (self.end_position - target.coordinate_origin).as_pixels(\nself.backend.dpi,\n)\nwidth = self.width.as_pixels(self.backend.dpi)\ntarget.image_draw.line(\n(start, end),\nfill=self.polarity.get_2d_rasterized_color(),\nwidth=width,\n)\nlogging.debug(\"Adding %s to %s\", self.__class__.__qualname__, target)\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/draw_commands/draw_vector_line.html#pygerber.backend.rasterized_2d.draw_commands.draw_vector_line.Rasterized2DDrawVectorLine.draw","title":"draw","text":"<pre><code>draw(target: DrawingTarget) -&gt; None\n</code></pre> <p>Apply aperture draw component to handle.</p> Source code in <code>src/pygerber/backend/rasterized_2d/draw_commands/draw_vector_line.py</code> <pre><code>def draw(self, target: DrawingTarget) -&gt; None:\n\"\"\"Apply aperture draw component to handle.\"\"\"\nif not isinstance(target, Rasterized2DDrawingTarget):\nmsg = f\"Expected Rasterized2DDrawingTarget got {type(target)}\"\nraise TypeError(msg)\nstart = (self.start_position - target.coordinate_origin).as_pixels(\nself.backend.dpi,\n)\nend = (self.end_position - target.coordinate_origin).as_pixels(\nself.backend.dpi,\n)\nwidth = self.width.as_pixels(self.backend.dpi)\ntarget.image_draw.line(\n(start, end),\nfill=self.polarity.get_2d_rasterized_color(),\nwidth=width,\n)\nlogging.debug(\"Adding %s to %s\", self.__class__.__qualname__, target)\n</code></pre>"},{"location":"reference/pygerber/common/__init__.html","title":"init","text":""},{"location":"reference/pygerber/common/__init__.html#pygerber.common","title":"common","text":"<p>Common internal utilities of PyGerber library.</p>"},{"location":"reference/pygerber/common/frozen_general_model.html","title":"frozen_general_model","text":""},{"location":"reference/pygerber/common/frozen_general_model.html#pygerber.common.frozen_general_model","title":"frozen_general_model","text":"<p>Class based on pydantic BaseModel with common set of features.</p>"},{"location":"reference/pygerber/common/frozen_general_model.html#pygerber.common.frozen_general_model.FrozenGeneralModel","title":"FrozenGeneralModel","text":"<p>             Bases: <code>BaseModel</code></p> <p>Model with common set of general purpose features.</p> Source code in <code>src/pygerber/common/frozen_general_model.py</code> <pre><code>class FrozenGeneralModel(BaseModel):\n\"\"\"Model with common set of general purpose features.\"\"\"\nmodel_config = ConfigDict(\nextra=\"forbid\",\nfrozen=True,\narbitrary_types_allowed=True,\n)\n</code></pre>"},{"location":"reference/pygerber/common/rgba.html","title":"rgba","text":""},{"location":"reference/pygerber/common/rgba.html#pygerber.common.rgba","title":"rgba","text":"<p>RGBA colors are used for declaring visuals of rendering output.</p> <p>This module contains RGBA class which can be used to provide such color.</p>"},{"location":"reference/pygerber/common/rgba.html#pygerber.common.rgba.ColorField","title":"ColorField  <code>module-attribute</code>","text":"<pre><code>ColorField = pydantic.Field(ge=0, le=255)\n</code></pre>"},{"location":"reference/pygerber/common/rgba.html#pygerber.common.rgba.Color","title":"Color  <code>module-attribute</code>","text":"<pre><code>Color = int\n</code></pre>"},{"location":"reference/pygerber/common/rgba.html#pygerber.common.rgba.HSV_Q0_MAX_ANGLE_DEGREES","title":"HSV_Q0_MAX_ANGLE_DEGREES  <code>module-attribute</code>","text":"<pre><code>HSV_Q0_MAX_ANGLE_DEGREES = 60\n</code></pre>"},{"location":"reference/pygerber/common/rgba.html#pygerber.common.rgba.HSV_Q1_MAX_ANGLE_DEGREES","title":"HSV_Q1_MAX_ANGLE_DEGREES  <code>module-attribute</code>","text":"<pre><code>HSV_Q1_MAX_ANGLE_DEGREES = 120\n</code></pre>"},{"location":"reference/pygerber/common/rgba.html#pygerber.common.rgba.HSV_Q2_MAX_ANGLE_DEGREES","title":"HSV_Q2_MAX_ANGLE_DEGREES  <code>module-attribute</code>","text":"<pre><code>HSV_Q2_MAX_ANGLE_DEGREES = 180\n</code></pre>"},{"location":"reference/pygerber/common/rgba.html#pygerber.common.rgba.HSV_Q3_MAX_ANGLE_DEGREES","title":"HSV_Q3_MAX_ANGLE_DEGREES  <code>module-attribute</code>","text":"<pre><code>HSV_Q3_MAX_ANGLE_DEGREES = 240\n</code></pre>"},{"location":"reference/pygerber/common/rgba.html#pygerber.common.rgba.HSV_Q4_MAX_ANGLE_DEGREES","title":"HSV_Q4_MAX_ANGLE_DEGREES  <code>module-attribute</code>","text":"<pre><code>HSV_Q4_MAX_ANGLE_DEGREES = 300\n</code></pre>"},{"location":"reference/pygerber/common/rgba.html#pygerber.common.rgba.HSV_Q5_MAX_ANGLE_DEGREES","title":"HSV_Q5_MAX_ANGLE_DEGREES  <code>module-attribute</code>","text":"<pre><code>HSV_Q5_MAX_ANGLE_DEGREES = 360\n</code></pre>"},{"location":"reference/pygerber/common/rgba.html#pygerber.common.rgba.RGBA","title":"RGBA","text":"<p>             Bases: <code>FrozenGeneralModel</code></p> <p>Representation of RGBA color.</p> Source code in <code>src/pygerber/common/rgba.py</code> <pre><code>class RGBA(FrozenGeneralModel):\n\"\"\"Representation of RGBA color.\"\"\"\nr: Color = ColorField\ng: Color = ColorField\nb: Color = ColorField\na: Color = ColorField\n@classmethod\ndef from_hex(cls, string: str) -&gt; Self:\n\"\"\"Build RGBA color object from hexadecimal string.\n        Parameters\n        ----------\n        string : str\n            String containing color value. Accepted formats are `RRGGBBAA` and `RRGGBB`.\n            For latter, alpha value is assumed to be 0xFF. Formats are case insensitive.\n            `#` symbol prefix for hex string is accepted.\n        Returns\n        -------\n        RGBA\n            Color built from hexadecimal values.\n        \"\"\"\nif string[0] == \"#\":\nstring = string[1:]\nr, g, b, a = string[:2], string[2:4], string[4:6], string[6:]\nif len(a) == 0:\na = \"FF\"\nreturn cls(\nr=int(r, base=16),\ng=int(g, base=16),\nb=int(b, base=16),\na=int(a, base=16),\n)\n@classmethod\ndef from_rgba(cls, r: int, g: int, b: int, a: int = 0xFF) -&gt; Self:\n\"\"\"Build RGBA color object from reg, green, blue and alpha integer values.\n        Parameters\n        ----------\n        r : int\n            Red chanel value as integer from 0 to 255, inclusive.\n        g : int\n            Green chanel value as integer from 0 to 255, inclusive.\n        b : int\n            Blue chanel value as integer from 0 to 255, inclusive.\n        a : int, optional\n            Alpha chanel value as integer from 0 to 255, inclusive., by default 0xFF\n        Returns\n        -------\n        Self\n            Color built from r, g, b, a values.\n        \"\"\"\nreturn cls(r=r, g=g, b=b, a=a)\n@classmethod\ndef from_hsv(\ncls,\nh: int,\ns: float,\nv: float,\na: int = 255,\n) -&gt; Self:\n\"\"\"Build RGBA color object from hue, saturation, value and alpha.\n        For extended information refer to Wikipedia: https://en.wikipedia.org/wiki/HSL_and_HSV\n        Parameters\n        ----------\n        h : int\n            Hue of color, integer in range 0 to 360 inclusive.\n        s : float\n            Saturation of color, float in range 0.0 to 100.0 inclusive.\n        v : float\n            Value of color, float in range 0.0 to 100.0 inclusive.\n        a : int\n            Alpha of color, int in range 0 to 255 inclusive.\n        Returns\n        -------\n        Self\n            Color built from h, s, v, a values.\n        \"\"\"\nh %= 360\ns /= 100\nv /= 100\nc = v * s\nx = c * (1 - abs(((h / 60) % 2) - 1))\nm = v - c\nif 0 &lt;= h &lt; HSV_Q0_MAX_ANGLE_DEGREES:\nr_, g_, b_ = c, x, 0.0\nelif HSV_Q0_MAX_ANGLE_DEGREES &lt;= h &lt; HSV_Q1_MAX_ANGLE_DEGREES:\nr_, g_, b_ = x, c, 0.0\nelif HSV_Q1_MAX_ANGLE_DEGREES &lt;= h &lt; HSV_Q2_MAX_ANGLE_DEGREES:\nr_, g_, b_ = 0.0, c, x\nelif HSV_Q2_MAX_ANGLE_DEGREES &lt;= h &lt; HSV_Q3_MAX_ANGLE_DEGREES:\nr_, g_, b_ = 0.0, x, c\nelif HSV_Q3_MAX_ANGLE_DEGREES &lt;= h &lt; HSV_Q4_MAX_ANGLE_DEGREES:\nr_, g_, b_ = x, 0.0, c\nelif HSV_Q4_MAX_ANGLE_DEGREES &lt;= h &lt;= HSV_Q5_MAX_ANGLE_DEGREES:\nr_, g_, b_ = c, 0.0, x\nelse:\nraise ValueError(h)\nreturn cls(\nr=round((r_ + m) * 255),\ng=round((g_ + m) * 255),\nb=round((b_ + m) * 255),\na=a,\n)\ndef as_rgba_int(self) -&gt; tuple[int, int, int, int]:\n\"\"\"Return RGBA color as tuple of integers in range 0 to 255 inclusive.\"\"\"\nreturn self.r, self.g, self.b, self.a\ndef as_rgba_float(self) -&gt; tuple[float, float, float, float]:\n\"\"\"Return RGBA color as tuple of floats in range 0.0 to 1.0 inclusive.\"\"\"\nreturn (\nfloat(Decimal(self.r) / Decimal(255)),\nfloat(Decimal(self.g) / Decimal(255)),\nfloat(Decimal(self.b) / Decimal(255)),\nfloat(Decimal(self.a) / Decimal(255)),\n)\n</code></pre>"},{"location":"reference/pygerber/common/rgba.html#pygerber.common.rgba.RGBA.from_hex","title":"from_hex  <code>classmethod</code>","text":"<pre><code>from_hex(string: str) -&gt; Self\n</code></pre> <p>Build RGBA color object from hexadecimal string.</p> <p>Parameters:</p> Name Type Description Default <code>string</code> <code>str</code> <p>String containing color value. Accepted formats are <code>RRGGBBAA</code> and <code>RRGGBB</code>. For latter, alpha value is assumed to be 0xFF. Formats are case insensitive. <code>#</code> symbol prefix for hex string is accepted.</p> required <p>Returns:</p> Type Description <code>RGBA</code> <p>Color built from hexadecimal values.</p> Source code in <code>src/pygerber/common/rgba.py</code> <pre><code>@classmethod\ndef from_hex(cls, string: str) -&gt; Self:\n\"\"\"Build RGBA color object from hexadecimal string.\n    Parameters\n    ----------\n    string : str\n        String containing color value. Accepted formats are `RRGGBBAA` and `RRGGBB`.\n        For latter, alpha value is assumed to be 0xFF. Formats are case insensitive.\n        `#` symbol prefix for hex string is accepted.\n    Returns\n    -------\n    RGBA\n        Color built from hexadecimal values.\n    \"\"\"\nif string[0] == \"#\":\nstring = string[1:]\nr, g, b, a = string[:2], string[2:4], string[4:6], string[6:]\nif len(a) == 0:\na = \"FF\"\nreturn cls(\nr=int(r, base=16),\ng=int(g, base=16),\nb=int(b, base=16),\na=int(a, base=16),\n)\n</code></pre>"},{"location":"reference/pygerber/common/rgba.html#pygerber.common.rgba.RGBA.from_rgba","title":"from_rgba  <code>classmethod</code>","text":"<pre><code>from_rgba(r: int, g: int, b: int, a: int = 255) -&gt; Self\n</code></pre> <p>Build RGBA color object from reg, green, blue and alpha integer values.</p> <p>Parameters:</p> Name Type Description Default <code>r</code> <code>int</code> <p>Red chanel value as integer from 0 to 255, inclusive.</p> required <code>g</code> <code>int</code> <p>Green chanel value as integer from 0 to 255, inclusive.</p> required <code>b</code> <code>int</code> <p>Blue chanel value as integer from 0 to 255, inclusive.</p> required <code>a</code> <code>int</code> <p>Alpha chanel value as integer from 0 to 255, inclusive., by default 0xFF</p> <code>255</code> <p>Returns:</p> Type Description <code>Self</code> <p>Color built from r, g, b, a values.</p> Source code in <code>src/pygerber/common/rgba.py</code> <pre><code>@classmethod\ndef from_rgba(cls, r: int, g: int, b: int, a: int = 0xFF) -&gt; Self:\n\"\"\"Build RGBA color object from reg, green, blue and alpha integer values.\n    Parameters\n    ----------\n    r : int\n        Red chanel value as integer from 0 to 255, inclusive.\n    g : int\n        Green chanel value as integer from 0 to 255, inclusive.\n    b : int\n        Blue chanel value as integer from 0 to 255, inclusive.\n    a : int, optional\n        Alpha chanel value as integer from 0 to 255, inclusive., by default 0xFF\n    Returns\n    -------\n    Self\n        Color built from r, g, b, a values.\n    \"\"\"\nreturn cls(r=r, g=g, b=b, a=a)\n</code></pre>"},{"location":"reference/pygerber/common/rgba.html#pygerber.common.rgba.RGBA.from_hsv","title":"from_hsv  <code>classmethod</code>","text":"<pre><code>from_hsv(h: int, s: float, v: float, a: int = 255) -&gt; Self\n</code></pre> <p>Build RGBA color object from hue, saturation, value and alpha.</p> <p>For extended information refer to Wikipedia: https://en.wikipedia.org/wiki/HSL_and_HSV</p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>int</code> <p>Hue of color, integer in range 0 to 360 inclusive.</p> required <code>s</code> <code>float</code> <p>Saturation of color, float in range 0.0 to 100.0 inclusive.</p> required <code>v</code> <code>float</code> <p>Value of color, float in range 0.0 to 100.0 inclusive.</p> required <code>a</code> <code>int</code> <p>Alpha of color, int in range 0 to 255 inclusive.</p> <code>255</code> <p>Returns:</p> Type Description <code>Self</code> <p>Color built from h, s, v, a values.</p> Source code in <code>src/pygerber/common/rgba.py</code> <pre><code>@classmethod\ndef from_hsv(\ncls,\nh: int,\ns: float,\nv: float,\na: int = 255,\n) -&gt; Self:\n\"\"\"Build RGBA color object from hue, saturation, value and alpha.\n    For extended information refer to Wikipedia: https://en.wikipedia.org/wiki/HSL_and_HSV\n    Parameters\n    ----------\n    h : int\n        Hue of color, integer in range 0 to 360 inclusive.\n    s : float\n        Saturation of color, float in range 0.0 to 100.0 inclusive.\n    v : float\n        Value of color, float in range 0.0 to 100.0 inclusive.\n    a : int\n        Alpha of color, int in range 0 to 255 inclusive.\n    Returns\n    -------\n    Self\n        Color built from h, s, v, a values.\n    \"\"\"\nh %= 360\ns /= 100\nv /= 100\nc = v * s\nx = c * (1 - abs(((h / 60) % 2) - 1))\nm = v - c\nif 0 &lt;= h &lt; HSV_Q0_MAX_ANGLE_DEGREES:\nr_, g_, b_ = c, x, 0.0\nelif HSV_Q0_MAX_ANGLE_DEGREES &lt;= h &lt; HSV_Q1_MAX_ANGLE_DEGREES:\nr_, g_, b_ = x, c, 0.0\nelif HSV_Q1_MAX_ANGLE_DEGREES &lt;= h &lt; HSV_Q2_MAX_ANGLE_DEGREES:\nr_, g_, b_ = 0.0, c, x\nelif HSV_Q2_MAX_ANGLE_DEGREES &lt;= h &lt; HSV_Q3_MAX_ANGLE_DEGREES:\nr_, g_, b_ = 0.0, x, c\nelif HSV_Q3_MAX_ANGLE_DEGREES &lt;= h &lt; HSV_Q4_MAX_ANGLE_DEGREES:\nr_, g_, b_ = x, 0.0, c\nelif HSV_Q4_MAX_ANGLE_DEGREES &lt;= h &lt;= HSV_Q5_MAX_ANGLE_DEGREES:\nr_, g_, b_ = c, 0.0, x\nelse:\nraise ValueError(h)\nreturn cls(\nr=round((r_ + m) * 255),\ng=round((g_ + m) * 255),\nb=round((b_ + m) * 255),\na=a,\n)\n</code></pre>"},{"location":"reference/pygerber/common/rgba.html#pygerber.common.rgba.RGBA.as_rgba_int","title":"as_rgba_int","text":"<pre><code>as_rgba_int() -&gt; tuple[int, int, int, int]\n</code></pre> <p>Return RGBA color as tuple of integers in range 0 to 255 inclusive.</p> Source code in <code>src/pygerber/common/rgba.py</code> <pre><code>def as_rgba_int(self) -&gt; tuple[int, int, int, int]:\n\"\"\"Return RGBA color as tuple of integers in range 0 to 255 inclusive.\"\"\"\nreturn self.r, self.g, self.b, self.a\n</code></pre>"},{"location":"reference/pygerber/common/rgba.html#pygerber.common.rgba.RGBA.as_rgba_float","title":"as_rgba_float","text":"<pre><code>as_rgba_float() -&gt; tuple[float, float, float, float]\n</code></pre> <p>Return RGBA color as tuple of floats in range 0.0 to 1.0 inclusive.</p> Source code in <code>src/pygerber/common/rgba.py</code> <pre><code>def as_rgba_float(self) -&gt; tuple[float, float, float, float]:\n\"\"\"Return RGBA color as tuple of floats in range 0.0 to 1.0 inclusive.\"\"\"\nreturn (\nfloat(Decimal(self.r) / Decimal(255)),\nfloat(Decimal(self.g) / Decimal(255)),\nfloat(Decimal(self.b) / Decimal(255)),\nfloat(Decimal(self.a) / Decimal(255)),\n)\n</code></pre>"},{"location":"reference/pygerber/console/__init__.html","title":"console","text":""},{"location":"reference/pygerber/console/__init__.html#pygerber.console","title":"console","text":"<p>Console interface of PyGerber.</p>"},{"location":"reference/pygerber/gerberx3/__init__.html","title":"init","text":""},{"location":"reference/pygerber/gerberx3/__init__.html#pygerber.gerberx3","title":"gerberx3","text":"<p>Package for Gerber X3 format visualization.</p>"},{"location":"reference/pygerber/gerberx3/state_enums.html","title":"state_enums","text":""},{"location":"reference/pygerber/gerberx3/state_enums.html#pygerber.gerberx3.state_enums","title":"state_enums","text":"<p>All state-defining enumerations.</p>"},{"location":"reference/pygerber/gerberx3/state_enums.html#pygerber.gerberx3.state_enums._to_region_variant_map","title":"_to_region_variant_map  <code>module-attribute</code>","text":"<pre><code>_to_region_variant_map = {\nPolarity.Clear: Polarity.ClearRegion,\nPolarity.Dark: Polarity.DarkRegion,\n}\n</code></pre>"},{"location":"reference/pygerber/gerberx3/state_enums.html#pygerber.gerberx3.state_enums._polarity_invert_map","title":"_polarity_invert_map  <code>module-attribute</code>","text":"<pre><code>_polarity_invert_map = {\nPolarity.Clear: Polarity.Dark,\nPolarity.Dark: Polarity.Clear,\nPolarity.ClearRegion: Polarity.DarkRegion,\nPolarity.DarkRegion: Polarity.ClearRegion,\nPolarity.DEBUG: Polarity.DEBUG2,\nPolarity.DEBUG2: Polarity.DEBUG,\n}\n</code></pre>"},{"location":"reference/pygerber/gerberx3/state_enums.html#pygerber.gerberx3.state_enums._2d_rasterized_color_map","title":"_2d_rasterized_color_map  <code>module-attribute</code>","text":"<pre><code>_2d_rasterized_color_map = {\n\"RESERVED_BLACK\": 0,\n\"RESERVED_WHITE\": 255,\nPolarity.Dark: 240,\nPolarity.Clear: 15,\nPolarity.DarkRegion: 230,\nPolarity.ClearRegion: 30,\nPolarity.Background: 0,\nPolarity.DEBUG: 127,\nPolarity.DEBUG2: 75,\n}\n</code></pre>"},{"location":"reference/pygerber/gerberx3/state_enums.html#pygerber.gerberx3.state_enums.EnumFormatValue","title":"EnumFormatValue","text":"<p>             Bases: <code>Enum</code></p> <p>Enum subclass which when stringified shows its value.</p> Source code in <code>src/pygerber/gerberx3/state_enums.py</code> <pre><code>class EnumFormatValue(Enum):\n\"\"\"Enum subclass which when stringified shows its value.\"\"\"\ndef __str__(self) -&gt; str:\nreturn str(self.value)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/state_enums.html#pygerber.gerberx3.state_enums.DrawMode","title":"DrawMode","text":"<p>             Bases: <code>EnumFormatValue</code></p> <p>Drawing mode.</p> Source code in <code>src/pygerber/gerberx3/state_enums.py</code> <pre><code>class DrawMode(EnumFormatValue):\n\"\"\"Drawing mode.\"\"\"\nLinear = \"G01\"\n\"\"\"In linear plot mode a D01 operation generates a linear segment, from the current\n    point to the (X, Y) coordinates in the command. The current point is then set to the\n    (X, Y) coordinates.Outside a region statement the segment is stroked with the\n    current aperture to create a draw graphical object. In a region statement the\n    segment is added to the contour under construction.\"\"\"\nClockwiseCircular = \"G02\"\n\"\"\"In circular plot mode a D01 operation generates an arc segment, from the current\n    point to the (X, Y) coordinates in the command. The current point is then set to the\n    (X, Y) coordinates. Outside a region statement the segment is stroked with the\n    current aperture to create an arc graphical object. In a region statement the\n    segment is added to the contour under construction. For compatibility with older\n    versions of the Gerber format, a G75* must be issued before the first D01 in\n    circular mode.\"\"\"\nCounterclockwiseCircular = \"G03\"\n\"\"\"In circular plot mode a D01 operation generates an arc segment, from the current\n    point to the (X, Y) coordinates in the command. The current point is then set to the\n    (X, Y) coordinates. Outside a region statement the segment is stroked with the\n    current aperture to create an arc graphical object. In a region statement the\n    segment is added to the contour under construction. For compatibility with older\n    versions of the Gerber format, a G75* must be issued before the first D01 in\n    circular mode.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/state_enums.html#pygerber.gerberx3.state_enums.DrawMode.Linear","title":"Linear  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Linear = 'G01'\n</code></pre> <p>In linear plot mode a D01 operation generates a linear segment, from the current point to the (X, Y) coordinates in the command. The current point is then set to the (X, Y) coordinates.Outside a region statement the segment is stroked with the current aperture to create a draw graphical object. In a region statement the segment is added to the contour under construction.</p>"},{"location":"reference/pygerber/gerberx3/state_enums.html#pygerber.gerberx3.state_enums.DrawMode.ClockwiseCircular","title":"ClockwiseCircular  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ClockwiseCircular = 'G02'\n</code></pre> <p>In circular plot mode a D01 operation generates an arc segment, from the current point to the (X, Y) coordinates in the command. The current point is then set to the (X, Y) coordinates. Outside a region statement the segment is stroked with the current aperture to create an arc graphical object. In a region statement the segment is added to the contour under construction. For compatibility with older versions of the Gerber format, a G75* must be issued before the first D01 in circular mode.</p>"},{"location":"reference/pygerber/gerberx3/state_enums.html#pygerber.gerberx3.state_enums.DrawMode.CounterclockwiseCircular","title":"CounterclockwiseCircular  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CounterclockwiseCircular = 'G03'\n</code></pre> <p>In circular plot mode a D01 operation generates an arc segment, from the current point to the (X, Y) coordinates in the command. The current point is then set to the (X, Y) coordinates. Outside a region statement the segment is stroked with the current aperture to create an arc graphical object. In a region statement the segment is added to the contour under construction. For compatibility with older versions of the Gerber format, a G75* must be issued before the first D01 in circular mode.</p>"},{"location":"reference/pygerber/gerberx3/state_enums.html#pygerber.gerberx3.state_enums.Polarity","title":"Polarity","text":"<p>             Bases: <code>EnumFormatValue</code></p> <p>Aperture polarity.</p> Source code in <code>src/pygerber/gerberx3/state_enums.py</code> <pre><code>class Polarity(EnumFormatValue):\n\"\"\"Aperture polarity.\"\"\"\nClear = \"C\"\nDark = \"D\"\nClearRegion = \"ClearRegion\"\nDarkRegion = \"DarkRegion\"\nBackground = \"Background\"\nDEBUG = \"DBG\"\nDEBUG2 = \"DBG2\"\ndef invert(self) -&gt; Polarity:\n\"\"\"Return opposite polarity.\"\"\"\nreturn _polarity_invert_map[self]\ndef to_region_variant(self) -&gt; Polarity:\n\"\"\"Return region variant of polarity.\"\"\"\nreturn _to_region_variant_map[self]\ndef get_2d_rasterized_color(self) -&gt; int:\n\"\"\"Get color for \"1\" mode image.\"\"\"\nreturn _2d_rasterized_color_map[self]\n</code></pre>"},{"location":"reference/pygerber/gerberx3/state_enums.html#pygerber.gerberx3.state_enums.Polarity.invert","title":"invert","text":"<pre><code>invert() -&gt; Polarity\n</code></pre> <p>Return opposite polarity.</p> Source code in <code>src/pygerber/gerberx3/state_enums.py</code> <pre><code>def invert(self) -&gt; Polarity:\n\"\"\"Return opposite polarity.\"\"\"\nreturn _polarity_invert_map[self]\n</code></pre>"},{"location":"reference/pygerber/gerberx3/state_enums.html#pygerber.gerberx3.state_enums.Polarity.to_region_variant","title":"to_region_variant","text":"<pre><code>to_region_variant() -&gt; Polarity\n</code></pre> <p>Return region variant of polarity.</p> Source code in <code>src/pygerber/gerberx3/state_enums.py</code> <pre><code>def to_region_variant(self) -&gt; Polarity:\n\"\"\"Return region variant of polarity.\"\"\"\nreturn _to_region_variant_map[self]\n</code></pre>"},{"location":"reference/pygerber/gerberx3/state_enums.html#pygerber.gerberx3.state_enums.Polarity.get_2d_rasterized_color","title":"get_2d_rasterized_color","text":"<pre><code>get_2d_rasterized_color() -&gt; int\n</code></pre> <p>Get color for \"1\" mode image.</p> Source code in <code>src/pygerber/gerberx3/state_enums.py</code> <pre><code>def get_2d_rasterized_color(self) -&gt; int:\n\"\"\"Get color for \"1\" mode image.\"\"\"\nreturn _2d_rasterized_color_map[self]\n</code></pre>"},{"location":"reference/pygerber/gerberx3/state_enums.html#pygerber.gerberx3.state_enums.Mirroring","title":"Mirroring","text":"<p>             Bases: <code>EnumFormatValue</code></p> <p>Aperture mirroring.</p> Source code in <code>src/pygerber/gerberx3/state_enums.py</code> <pre><code>class Mirroring(EnumFormatValue):\n\"\"\"Aperture mirroring.\"\"\"\nNoMirroring = \"N\"\nXY = \"XY\"\nX = \"X\"\nY = \"Y\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/state_enums.html#pygerber.gerberx3.state_enums.Unit","title":"Unit","text":"<p>             Bases: <code>EnumFormatValue</code></p> <p>Aperture unit.</p> Source code in <code>src/pygerber/gerberx3/state_enums.py</code> <pre><code>class Unit(EnumFormatValue):\n\"\"\"Aperture unit.\"\"\"\nMillimeters = \"MM\"\nInches = \"IN\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/state_enums.html#pygerber.gerberx3.state_enums.ImagePolarityEnum","title":"ImagePolarityEnum","text":"<p>             Bases: <code>EnumFormatValue</code></p> <p>Image polarity.</p>"},{"location":"reference/pygerber/gerberx3/state_enums.html#pygerber.gerberx3.state_enums.ImagePolarityEnum--image-polarity-ip","title":"Image Polarity (IP)","text":"<p>Note: The IP command is deprecated.</p> <p>The <code>IP</code> command is responsible for setting the polarity for the entire image. It is designed to be used only once, preferably at the very beginning of the file.</p>"},{"location":"reference/pygerber/gerberx3/state_enums.html#pygerber.gerberx3.state_enums.ImagePolarityEnum--7131-positive-image-polarity","title":"7.1.3.1 Positive Image Polarity","text":"<p>Under the positive image polarity: - The image is generated in accordance with the specifications provided elsewhere in     this document. - It's worth noting that, by default, image generation has always assumed a positive     image polarity.</p>"},{"location":"reference/pygerber/gerberx3/state_enums.html#pygerber.gerberx3.state_enums.ImagePolarityEnum--7132-negative-image-polarity","title":"7.1.3.2 Negative Image Polarity","text":"<p>When the negative image polarity is in use: - The intent is to produce an image that portrays clear areas against a dark     backdrop. - The initial state of the entire image plane is dark, as opposed to being clear. - The polarity effects between dark and clear regions are interchanged. Essentially,     what was dark becomes white and vice-versa. - For negative image polarity, the very first graphics object that gets produced     must possess a dark polarity. As a result, it takes on the role of clearing the     dark backdrop.</p> Source code in <code>src/pygerber/gerberx3/state_enums.py</code> <pre><code>class ImagePolarityEnum(EnumFormatValue):\n\"\"\"Image polarity.\n    ### Image Polarity (IP)\n    Note: The IP command is deprecated.\n    The `IP` command is responsible for setting the polarity for the entire image. It is\n    designed to be used only once, preferably at the very beginning of the file.\n    #### 7.1.3.1 Positive Image Polarity\n    Under the positive image polarity:\n    - The image is generated in accordance with the specifications provided elsewhere in\n        this document.\n    - It's worth noting that, by default, image generation has always assumed a positive\n        image polarity.\n    #### 7.1.3.2 Negative Image Polarity\n    When the negative image polarity is in use:\n    - The intent is to produce an image that portrays clear areas against a dark\n        backdrop.\n    - The initial state of the entire image plane is dark, as opposed to being clear.\n    - The polarity effects between dark and clear regions are interchanged. Essentially,\n        what was dark becomes white and vice-versa.\n    - For negative image polarity, the very first graphics object that gets produced\n        must possess a dark polarity. As a result, it takes on the role of clearing the\n        dark backdrop.\n    \"\"\"\nPOSITIVE = \"POS\"\nNEGATIVE = \"NEG\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/__init__.html","title":"init","text":""},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api","title":"api","text":"<p><code>pygerber.gerberx3.api</code> module provides simple, high-level API for rendering Gerber X3/X2 files.</p> <p>Supported features</p> <p>For list of supported Gerber format features please see Gerber features support section.</p> <p>Tutorial</p> <p>For tutorial on how to use high level API see Gerber X3 High Level API section.</p>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = [\n\"RGBA\",\n\"ColorScheme\",\n\"Layer\",\n\"LayerParams\",\n\"Rasterized2DLayer\",\n\"Rasterized2DLayerParams\",\n\"LayerProperties\",\n\"RenderingResult\",\n\"ParserOnErrorAction\",\n\"GerberX3APIError\",\n\"RenderingResultNotReadyError\",\n\"MutuallyExclusiveViolationError\",\n\"ParserError\",\n\"ZeroOmissionNotSupportedError\",\n\"IncrementalCoordinatesNotSupportedError\",\n\"UnsupportedCoordinateTypeError\",\n\"InvalidCoordinateLengthError\",\n\"ParserFatalError\",\n\"OnUpdateDrawingStateError\",\n\"UnitNotSetError\",\n\"ApertureNotDefinedError\",\n\"CoordinateFormatNotSetError\",\n\"ApertureNotSelectedError\",\n\"ExitParsingProcessInterrupt\",\n]\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.GerberX3APIError","title":"GerberX3APIError","text":"<p>             Bases: <code>Exception</code></p> <p>Base class for API errors.</p> <p>Exceptions derived from this exception are exclusively raised in PyGerber's Gerber X3 high level API. This exception can be used in <code>try: ... except GerberX3APIError: ...</code> block to catch all exceptions raised by this API while allowing other exceptions to interrupt execution.</p> Source code in <code>src/pygerber/gerberx3/api/_errors.py</code> <pre><code>class GerberX3APIError(Exception):\n\"\"\"Base class for API errors.\n    Exceptions derived from this exception are exclusively raised in PyGerber's Gerber\n    X3 high level API. This exception can be used in\n    `#!python try: ... except GerberX3APIError: ...` block to catch all exceptions\n    raised by this API while allowing other exceptions to interrupt execution.\n    \"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.ParserError","title":"ParserError","text":"<p>             Bases: <code>ValueError</code></p> <p>Base class for parser errors.</p> <p>Exceptions derived from this exception are exclusively raised in PyGerber's Gerber X3 Parser. This exception can be used in <code>try: ... except ParserError: ...</code> block to catch all exceptions raised by Parser while allowing other exceptions to interrupt execution.</p> Source code in <code>src/pygerber/gerberx3/parser/errors.py</code> <pre><code>class ParserError(ValueError):\n\"\"\"Base class for parser errors.\n    Exceptions derived from this exception are exclusively raised in PyGerber's Gerber\n    X3 Parser. This exception can be used in\n    `#!python try: ... except ParserError: ...` block to catch all exceptions\n    raised by Parser while allowing other exceptions to interrupt execution.\n    \"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.ColorScheme","title":"ColorScheme","text":"<p>             Bases: <code>FrozenGeneralModel</code></p> <p>Set of colors which should be used for rendering.</p> <p>ColorScheme class contains set of colors which should be used for different parts of rendered image. At the same time it also works as a container for predefined color schemes commonly used for parts of PCB.</p> <p>Predefined colors</p> <p>All predefined colors have two variants - normal one and one with \"*_ALPHA\" suffix. Those without suffix have solid background and are not intended for constructing multi-layer images out of them ie. they are not suitable for rendering a project consisting of separate copper, silk, pase mask and composing them into single image. For cases when rendered images are intended for stacking \"*_ALPHA\" schemes should be used, as background and transparent parts of image will be truly transparent.</p> Source code in <code>src/pygerber/backend/rasterized_2d/color_scheme.py</code> <pre><code>class ColorScheme(FrozenGeneralModel):\nr\"\"\"Set of colors which should be used for rendering.\n    ColorScheme class contains set of colors which should be used for different parts\n    of rendered image. At the same time it also works as a container for predefined\n    color schemes commonly used for parts of PCB.\n    !!! info \"Predefined colors\"\n        All predefined colors have two variants - normal one and one with \"\\*_ALPHA\"\n        suffix. Those without suffix have solid background and are not intended for\n        constructing multi-layer images out of them ie. they are not suitable for\n        rendering a project consisting of separate copper, silk, pase mask and composing\n        them into single image. For cases when rendered images are intended for stacking\n        \"\\*_ALPHA\" schemes should be used, as background and transparent parts of image\n        will be truly transparent.\n    \"\"\"\nSILK: ClassVar[ColorScheme]\n\"\"\"Default color of silk layer.\n    This schema provided non-transparent background, which results in images which\n    can not be used for stacking on top of other layers, as they would completely\n    obscure them.\"\"\"\nSILK_ALPHA: ClassVar[ColorScheme]\n\"\"\"Default color of silk layer with alpha channel.\n    This schema provides transparent background. Images using this schema can be\n    stacked on top of each other without obscuring layers below.\"\"\"\nCOPPER: ClassVar[ColorScheme]\n\"\"\"Default color of copper layer.\n    This schema provided non-transparent background, which results in images which\n    can not be used for stacking on top of other layers, as they would completely\n    obscure them.\"\"\"\nCOPPER_ALPHA: ClassVar[ColorScheme]\n\"\"\"Default color of copper layer with alpha channel.\n    This schema provides transparent background. Images using this schema can be\n    stacked on top of each other without obscuring layers below.\"\"\"\nPASTE_MASK: ClassVar[ColorScheme]\n\"\"\"Default color of paste mask layer.\n    This schema provided non-transparent background, which results in images which\n    can not be used for stacking on top of other layers, as they would completely\n    obscure them.\"\"\"\nPASTE_MASK_ALPHA: ClassVar[ColorScheme]\n\"\"\"Default color of paste mask layer with alpha channel.\n    This schema provides transparent background. Images using this schema can be\n    stacked on top of each other without obscuring layers below.\"\"\"\nSOLDER_MASK: ClassVar[ColorScheme]\n\"\"\"Default color of solder mask layer.\n    This schema provided non-transparent background, which results in images which\n    can not be used for stacking on top of other layers, as they would completely\n    obscure them.\"\"\"\nSOLDER_MASK_ALPHA: ClassVar[ColorScheme]\n\"\"\"Default color of solder mask layer with alpha channel.\n    This schema provides transparent background. Images using this schema can be\n    stacked on top of each other without obscuring layers below.\"\"\"\nDEFAULT_GRAYSCALE: ClassVar[ColorScheme]\n\"\"\"Default color scheme for files which were not assigned other color scheme.\"\"\"\nDEBUG_1: ClassVar[ColorScheme]\n\"\"\"Debug color scheme.\"\"\"\nDEBUG_1_ALPHA: ClassVar[ColorScheme]\n\"\"\"Debug color scheme with alpha channel.\"\"\"\nbackground_color: RGBA\n\"\"\"Color used as empty image background.\"\"\"\nclear_color: RGBA\n\"\"\"Color used for clear draws.\"\"\"\nsolid_color: RGBA\n\"\"\"Color used for solid draws.\"\"\"\nclear_region_color: RGBA\n\"\"\"Color used for clear region draws.\"\"\"\nsolid_region_color: RGBA\n\"\"\"Color used for solid region draws.\"\"\"\ndebug_1_color: RGBA = RGBA.from_hex(\"#ababab\")\n\"\"\"Color used for debug elements.\"\"\"\ndebug_2_color: RGBA = RGBA.from_hex(\"#7d7d7d\")\n\"\"\"Color used for debug elements.\"\"\"\ndef get_grayscale_to_rgba_color_map(self) -&gt; dict[int, tuple[int, int, int, int]]:\n\"\"\"Return grayscale to RGBA color map.\"\"\"\nreturn {\nPolarity.Dark.get_2d_rasterized_color(): self.solid_color.as_rgba_int(),\nPolarity.Clear.get_2d_rasterized_color(): self.clear_color.as_rgba_int(),  # noqa: E501\nPolarity.DarkRegion.get_2d_rasterized_color(): self.solid_region_color.as_rgba_int(),  # noqa: E501\nPolarity.ClearRegion.get_2d_rasterized_color(): self.clear_region_color.as_rgba_int(),  # noqa: E501\nPolarity.Background.get_2d_rasterized_color(): self.background_color.as_rgba_int(),  # noqa: E501\nPolarity.DEBUG.get_2d_rasterized_color(): self.debug_1_color.as_rgba_int(),  # noqa: E501\nPolarity.DEBUG2.get_2d_rasterized_color(): self.debug_2_color.as_rgba_int(),  # noqa: E501\n}\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.backend.rasterized_2d.color_scheme.ColorScheme.SILK","title":"SILK  <code>class-attribute</code>","text":"<pre><code>SILK: ColorScheme\n</code></pre> <p>Default color of silk layer.</p> <p>This schema provided non-transparent background, which results in images which can not be used for stacking on top of other layers, as they would completely obscure them.</p>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.backend.rasterized_2d.color_scheme.ColorScheme.SILK_ALPHA","title":"SILK_ALPHA  <code>class-attribute</code>","text":"<pre><code>SILK_ALPHA: ColorScheme\n</code></pre> <p>Default color of silk layer with alpha channel.</p> <p>This schema provides transparent background. Images using this schema can be stacked on top of each other without obscuring layers below.</p>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.backend.rasterized_2d.color_scheme.ColorScheme.COPPER","title":"COPPER  <code>class-attribute</code>","text":"<pre><code>COPPER: ColorScheme\n</code></pre> <p>Default color of copper layer.</p> <p>This schema provided non-transparent background, which results in images which can not be used for stacking on top of other layers, as they would completely obscure them.</p>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.backend.rasterized_2d.color_scheme.ColorScheme.COPPER_ALPHA","title":"COPPER_ALPHA  <code>class-attribute</code>","text":"<pre><code>COPPER_ALPHA: ColorScheme\n</code></pre> <p>Default color of copper layer with alpha channel.</p> <p>This schema provides transparent background. Images using this schema can be stacked on top of each other without obscuring layers below.</p>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.backend.rasterized_2d.color_scheme.ColorScheme.PASTE_MASK","title":"PASTE_MASK  <code>class-attribute</code>","text":"<pre><code>PASTE_MASK: ColorScheme\n</code></pre> <p>Default color of paste mask layer.</p> <p>This schema provided non-transparent background, which results in images which can not be used for stacking on top of other layers, as they would completely obscure them.</p>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.backend.rasterized_2d.color_scheme.ColorScheme.PASTE_MASK_ALPHA","title":"PASTE_MASK_ALPHA  <code>class-attribute</code>","text":"<pre><code>PASTE_MASK_ALPHA: ColorScheme\n</code></pre> <p>Default color of paste mask layer with alpha channel.</p> <p>This schema provides transparent background. Images using this schema can be stacked on top of each other without obscuring layers below.</p>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.backend.rasterized_2d.color_scheme.ColorScheme.SOLDER_MASK","title":"SOLDER_MASK  <code>class-attribute</code>","text":"<pre><code>SOLDER_MASK: ColorScheme\n</code></pre> <p>Default color of solder mask layer.</p> <p>This schema provided non-transparent background, which results in images which can not be used for stacking on top of other layers, as they would completely obscure them.</p>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.backend.rasterized_2d.color_scheme.ColorScheme.SOLDER_MASK_ALPHA","title":"SOLDER_MASK_ALPHA  <code>class-attribute</code>","text":"<pre><code>SOLDER_MASK_ALPHA: ColorScheme\n</code></pre> <p>Default color of solder mask layer with alpha channel.</p> <p>This schema provides transparent background. Images using this schema can be stacked on top of each other without obscuring layers below.</p>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.backend.rasterized_2d.color_scheme.ColorScheme.DEFAULT_GRAYSCALE","title":"DEFAULT_GRAYSCALE  <code>class-attribute</code>","text":"<pre><code>DEFAULT_GRAYSCALE: ColorScheme\n</code></pre> <p>Default color scheme for files which were not assigned other color scheme.</p>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.backend.rasterized_2d.color_scheme.ColorScheme.DEBUG_1","title":"DEBUG_1  <code>class-attribute</code>","text":"<pre><code>DEBUG_1: ColorScheme\n</code></pre> <p>Debug color scheme.</p>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.backend.rasterized_2d.color_scheme.ColorScheme.DEBUG_1_ALPHA","title":"DEBUG_1_ALPHA  <code>class-attribute</code>","text":"<pre><code>DEBUG_1_ALPHA: ColorScheme\n</code></pre> <p>Debug color scheme with alpha channel.</p>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.backend.rasterized_2d.color_scheme.ColorScheme.background_color","title":"background_color  <code>instance-attribute</code>","text":"<pre><code>background_color: RGBA\n</code></pre> <p>Color used as empty image background.</p>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.backend.rasterized_2d.color_scheme.ColorScheme.clear_color","title":"clear_color  <code>instance-attribute</code>","text":"<pre><code>clear_color: RGBA\n</code></pre> <p>Color used for clear draws.</p>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.backend.rasterized_2d.color_scheme.ColorScheme.solid_color","title":"solid_color  <code>instance-attribute</code>","text":"<pre><code>solid_color: RGBA\n</code></pre> <p>Color used for solid draws.</p>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.backend.rasterized_2d.color_scheme.ColorScheme.clear_region_color","title":"clear_region_color  <code>instance-attribute</code>","text":"<pre><code>clear_region_color: RGBA\n</code></pre> <p>Color used for clear region draws.</p>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.backend.rasterized_2d.color_scheme.ColorScheme.solid_region_color","title":"solid_region_color  <code>instance-attribute</code>","text":"<pre><code>solid_region_color: RGBA\n</code></pre> <p>Color used for solid region draws.</p>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.backend.rasterized_2d.color_scheme.ColorScheme.debug_1_color","title":"debug_1_color  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>debug_1_color: RGBA = RGBA.from_hex('#ababab')\n</code></pre> <p>Color used for debug elements.</p>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.backend.rasterized_2d.color_scheme.ColorScheme.debug_2_color","title":"debug_2_color  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>debug_2_color: RGBA = RGBA.from_hex('#7d7d7d')\n</code></pre> <p>Color used for debug elements.</p>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.backend.rasterized_2d.color_scheme.ColorScheme.get_grayscale_to_rgba_color_map","title":"get_grayscale_to_rgba_color_map","text":"<pre><code>get_grayscale_to_rgba_color_map() -&gt; (\ndict[int, tuple[int, int, int, int]]\n)\n</code></pre> <p>Return grayscale to RGBA color map.</p> Source code in <code>src/pygerber/backend/rasterized_2d/color_scheme.py</code> <pre><code>def get_grayscale_to_rgba_color_map(self) -&gt; dict[int, tuple[int, int, int, int]]:\n\"\"\"Return grayscale to RGBA color map.\"\"\"\nreturn {\nPolarity.Dark.get_2d_rasterized_color(): self.solid_color.as_rgba_int(),\nPolarity.Clear.get_2d_rasterized_color(): self.clear_color.as_rgba_int(),  # noqa: E501\nPolarity.DarkRegion.get_2d_rasterized_color(): self.solid_region_color.as_rgba_int(),  # noqa: E501\nPolarity.ClearRegion.get_2d_rasterized_color(): self.clear_region_color.as_rgba_int(),  # noqa: E501\nPolarity.Background.get_2d_rasterized_color(): self.background_color.as_rgba_int(),  # noqa: E501\nPolarity.DEBUG.get_2d_rasterized_color(): self.debug_1_color.as_rgba_int(),  # noqa: E501\nPolarity.DEBUG2.get_2d_rasterized_color(): self.debug_2_color.as_rgba_int(),  # noqa: E501\n}\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.RenderingResultNotReadyError","title":"RenderingResultNotReadyError","text":"<p>             Bases: <code>GerberX3APIError</code></p> <p>Raised when RenderingResult is requested before it was rendered.</p> <p><code>Layer.get_rendering_result()</code> method can only be called after <code>Layer.render()</code>. Breaking this rule will cause this exception to be raised.</p> Source code in <code>src/pygerber/gerberx3/api/_errors.py</code> <pre><code>class RenderingResultNotReadyError(GerberX3APIError):\n\"\"\"Raised when RenderingResult is requested before it was rendered.\n    `Layer.get_rendering_result()` method can only be called after `Layer.render()`.\n    Breaking this rule will cause this exception to be raised.\n    \"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.ZeroOmissionNotSupportedError","title":"ZeroOmissionNotSupportedError","text":"<p>             Bases: <code>ParserError</code></p> <p>Raised when incremental coordinates are selected. (Spec. 8.2.1.2).</p> Source code in <code>src/pygerber/gerberx3/parser/errors.py</code> <pre><code>class ZeroOmissionNotSupportedError(ParserError):\n\"\"\"Raised when incremental coordinates are selected. (Spec. 8.2.1.2).\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.IncrementalCoordinatesNotSupportedError","title":"IncrementalCoordinatesNotSupportedError","text":"<p>             Bases: <code>ParserError</code></p> <p>Raised when incremental coordinates are selected. (Spec. 8.2.1.2).</p> Source code in <code>src/pygerber/gerberx3/parser/errors.py</code> <pre><code>class IncrementalCoordinatesNotSupportedError(ParserError):\n\"\"\"Raised when incremental coordinates are selected. (Spec. 8.2.1.2).\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.MutuallyExclusiveViolationError","title":"MutuallyExclusiveViolationError","text":"<p>             Bases: <code>GerberX3APIError</code></p> <p>Raised when two or more of mutually exclusive parameters are provided.</p> <p><code>LayerParams</code> class accepts three mutually exclusive fields, <code>source_path</code>, <code>source_code</code> and <code>source_buffer</code> for providing source code to <code>Layer</code>. When more than one of those options is set, this exception will be raised.</p> Source code in <code>src/pygerber/gerberx3/api/_errors.py</code> <pre><code>class MutuallyExclusiveViolationError(GerberX3APIError):\n\"\"\"Raised when two or more of mutually exclusive parameters are provided.\n    `LayerParams` class accepts three mutually exclusive fields, `source_path`,\n    `source_code` and `source_buffer` for providing source code to `Layer`.\n    When more than one of those options is set, this exception will be raised.\n    \"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.UnsupportedCoordinateTypeError","title":"UnsupportedCoordinateTypeError","text":"<p>             Bases: <code>ParserError</code></p> <p>Raised for unsupported coordinate types.</p> Source code in <code>src/pygerber/gerberx3/parser/errors.py</code> <pre><code>class UnsupportedCoordinateTypeError(ParserError):\n\"\"\"Raised for unsupported coordinate types.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.RGBA","title":"RGBA","text":"<p>             Bases: <code>FrozenGeneralModel</code></p> <p>Representation of RGBA color.</p> Source code in <code>src/pygerber/common/rgba.py</code> <pre><code>class RGBA(FrozenGeneralModel):\n\"\"\"Representation of RGBA color.\"\"\"\nr: Color = ColorField\ng: Color = ColorField\nb: Color = ColorField\na: Color = ColorField\n@classmethod\ndef from_hex(cls, string: str) -&gt; Self:\n\"\"\"Build RGBA color object from hexadecimal string.\n        Parameters\n        ----------\n        string : str\n            String containing color value. Accepted formats are `RRGGBBAA` and `RRGGBB`.\n            For latter, alpha value is assumed to be 0xFF. Formats are case insensitive.\n            `#` symbol prefix for hex string is accepted.\n        Returns\n        -------\n        RGBA\n            Color built from hexadecimal values.\n        \"\"\"\nif string[0] == \"#\":\nstring = string[1:]\nr, g, b, a = string[:2], string[2:4], string[4:6], string[6:]\nif len(a) == 0:\na = \"FF\"\nreturn cls(\nr=int(r, base=16),\ng=int(g, base=16),\nb=int(b, base=16),\na=int(a, base=16),\n)\n@classmethod\ndef from_rgba(cls, r: int, g: int, b: int, a: int = 0xFF) -&gt; Self:\n\"\"\"Build RGBA color object from reg, green, blue and alpha integer values.\n        Parameters\n        ----------\n        r : int\n            Red chanel value as integer from 0 to 255, inclusive.\n        g : int\n            Green chanel value as integer from 0 to 255, inclusive.\n        b : int\n            Blue chanel value as integer from 0 to 255, inclusive.\n        a : int, optional\n            Alpha chanel value as integer from 0 to 255, inclusive., by default 0xFF\n        Returns\n        -------\n        Self\n            Color built from r, g, b, a values.\n        \"\"\"\nreturn cls(r=r, g=g, b=b, a=a)\n@classmethod\ndef from_hsv(\ncls,\nh: int,\ns: float,\nv: float,\na: int = 255,\n) -&gt; Self:\n\"\"\"Build RGBA color object from hue, saturation, value and alpha.\n        For extended information refer to Wikipedia: https://en.wikipedia.org/wiki/HSL_and_HSV\n        Parameters\n        ----------\n        h : int\n            Hue of color, integer in range 0 to 360 inclusive.\n        s : float\n            Saturation of color, float in range 0.0 to 100.0 inclusive.\n        v : float\n            Value of color, float in range 0.0 to 100.0 inclusive.\n        a : int\n            Alpha of color, int in range 0 to 255 inclusive.\n        Returns\n        -------\n        Self\n            Color built from h, s, v, a values.\n        \"\"\"\nh %= 360\ns /= 100\nv /= 100\nc = v * s\nx = c * (1 - abs(((h / 60) % 2) - 1))\nm = v - c\nif 0 &lt;= h &lt; HSV_Q0_MAX_ANGLE_DEGREES:\nr_, g_, b_ = c, x, 0.0\nelif HSV_Q0_MAX_ANGLE_DEGREES &lt;= h &lt; HSV_Q1_MAX_ANGLE_DEGREES:\nr_, g_, b_ = x, c, 0.0\nelif HSV_Q1_MAX_ANGLE_DEGREES &lt;= h &lt; HSV_Q2_MAX_ANGLE_DEGREES:\nr_, g_, b_ = 0.0, c, x\nelif HSV_Q2_MAX_ANGLE_DEGREES &lt;= h &lt; HSV_Q3_MAX_ANGLE_DEGREES:\nr_, g_, b_ = 0.0, x, c\nelif HSV_Q3_MAX_ANGLE_DEGREES &lt;= h &lt; HSV_Q4_MAX_ANGLE_DEGREES:\nr_, g_, b_ = x, 0.0, c\nelif HSV_Q4_MAX_ANGLE_DEGREES &lt;= h &lt;= HSV_Q5_MAX_ANGLE_DEGREES:\nr_, g_, b_ = c, 0.0, x\nelse:\nraise ValueError(h)\nreturn cls(\nr=round((r_ + m) * 255),\ng=round((g_ + m) * 255),\nb=round((b_ + m) * 255),\na=a,\n)\ndef as_rgba_int(self) -&gt; tuple[int, int, int, int]:\n\"\"\"Return RGBA color as tuple of integers in range 0 to 255 inclusive.\"\"\"\nreturn self.r, self.g, self.b, self.a\ndef as_rgba_float(self) -&gt; tuple[float, float, float, float]:\n\"\"\"Return RGBA color as tuple of floats in range 0.0 to 1.0 inclusive.\"\"\"\nreturn (\nfloat(Decimal(self.r) / Decimal(255)),\nfloat(Decimal(self.g) / Decimal(255)),\nfloat(Decimal(self.b) / Decimal(255)),\nfloat(Decimal(self.a) / Decimal(255)),\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.common.rgba.RGBA.from_hex","title":"from_hex  <code>classmethod</code>","text":"<pre><code>from_hex(string: str) -&gt; Self\n</code></pre> <p>Build RGBA color object from hexadecimal string.</p> <p>Parameters:</p> Name Type Description Default <code>string</code> <code>str</code> <p>String containing color value. Accepted formats are <code>RRGGBBAA</code> and <code>RRGGBB</code>. For latter, alpha value is assumed to be 0xFF. Formats are case insensitive. <code>#</code> symbol prefix for hex string is accepted.</p> required <p>Returns:</p> Type Description <code>RGBA</code> <p>Color built from hexadecimal values.</p> Source code in <code>src/pygerber/common/rgba.py</code> <pre><code>@classmethod\ndef from_hex(cls, string: str) -&gt; Self:\n\"\"\"Build RGBA color object from hexadecimal string.\n    Parameters\n    ----------\n    string : str\n        String containing color value. Accepted formats are `RRGGBBAA` and `RRGGBB`.\n        For latter, alpha value is assumed to be 0xFF. Formats are case insensitive.\n        `#` symbol prefix for hex string is accepted.\n    Returns\n    -------\n    RGBA\n        Color built from hexadecimal values.\n    \"\"\"\nif string[0] == \"#\":\nstring = string[1:]\nr, g, b, a = string[:2], string[2:4], string[4:6], string[6:]\nif len(a) == 0:\na = \"FF\"\nreturn cls(\nr=int(r, base=16),\ng=int(g, base=16),\nb=int(b, base=16),\na=int(a, base=16),\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.common.rgba.RGBA.from_rgba","title":"from_rgba  <code>classmethod</code>","text":"<pre><code>from_rgba(r: int, g: int, b: int, a: int = 255) -&gt; Self\n</code></pre> <p>Build RGBA color object from reg, green, blue and alpha integer values.</p> <p>Parameters:</p> Name Type Description Default <code>r</code> <code>int</code> <p>Red chanel value as integer from 0 to 255, inclusive.</p> required <code>g</code> <code>int</code> <p>Green chanel value as integer from 0 to 255, inclusive.</p> required <code>b</code> <code>int</code> <p>Blue chanel value as integer from 0 to 255, inclusive.</p> required <code>a</code> <code>int</code> <p>Alpha chanel value as integer from 0 to 255, inclusive., by default 0xFF</p> <code>255</code> <p>Returns:</p> Type Description <code>Self</code> <p>Color built from r, g, b, a values.</p> Source code in <code>src/pygerber/common/rgba.py</code> <pre><code>@classmethod\ndef from_rgba(cls, r: int, g: int, b: int, a: int = 0xFF) -&gt; Self:\n\"\"\"Build RGBA color object from reg, green, blue and alpha integer values.\n    Parameters\n    ----------\n    r : int\n        Red chanel value as integer from 0 to 255, inclusive.\n    g : int\n        Green chanel value as integer from 0 to 255, inclusive.\n    b : int\n        Blue chanel value as integer from 0 to 255, inclusive.\n    a : int, optional\n        Alpha chanel value as integer from 0 to 255, inclusive., by default 0xFF\n    Returns\n    -------\n    Self\n        Color built from r, g, b, a values.\n    \"\"\"\nreturn cls(r=r, g=g, b=b, a=a)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.common.rgba.RGBA.from_hsv","title":"from_hsv  <code>classmethod</code>","text":"<pre><code>from_hsv(h: int, s: float, v: float, a: int = 255) -&gt; Self\n</code></pre> <p>Build RGBA color object from hue, saturation, value and alpha.</p> <p>For extended information refer to Wikipedia: https://en.wikipedia.org/wiki/HSL_and_HSV</p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>int</code> <p>Hue of color, integer in range 0 to 360 inclusive.</p> required <code>s</code> <code>float</code> <p>Saturation of color, float in range 0.0 to 100.0 inclusive.</p> required <code>v</code> <code>float</code> <p>Value of color, float in range 0.0 to 100.0 inclusive.</p> required <code>a</code> <code>int</code> <p>Alpha of color, int in range 0 to 255 inclusive.</p> <code>255</code> <p>Returns:</p> Type Description <code>Self</code> <p>Color built from h, s, v, a values.</p> Source code in <code>src/pygerber/common/rgba.py</code> <pre><code>@classmethod\ndef from_hsv(\ncls,\nh: int,\ns: float,\nv: float,\na: int = 255,\n) -&gt; Self:\n\"\"\"Build RGBA color object from hue, saturation, value and alpha.\n    For extended information refer to Wikipedia: https://en.wikipedia.org/wiki/HSL_and_HSV\n    Parameters\n    ----------\n    h : int\n        Hue of color, integer in range 0 to 360 inclusive.\n    s : float\n        Saturation of color, float in range 0.0 to 100.0 inclusive.\n    v : float\n        Value of color, float in range 0.0 to 100.0 inclusive.\n    a : int\n        Alpha of color, int in range 0 to 255 inclusive.\n    Returns\n    -------\n    Self\n        Color built from h, s, v, a values.\n    \"\"\"\nh %= 360\ns /= 100\nv /= 100\nc = v * s\nx = c * (1 - abs(((h / 60) % 2) - 1))\nm = v - c\nif 0 &lt;= h &lt; HSV_Q0_MAX_ANGLE_DEGREES:\nr_, g_, b_ = c, x, 0.0\nelif HSV_Q0_MAX_ANGLE_DEGREES &lt;= h &lt; HSV_Q1_MAX_ANGLE_DEGREES:\nr_, g_, b_ = x, c, 0.0\nelif HSV_Q1_MAX_ANGLE_DEGREES &lt;= h &lt; HSV_Q2_MAX_ANGLE_DEGREES:\nr_, g_, b_ = 0.0, c, x\nelif HSV_Q2_MAX_ANGLE_DEGREES &lt;= h &lt; HSV_Q3_MAX_ANGLE_DEGREES:\nr_, g_, b_ = 0.0, x, c\nelif HSV_Q3_MAX_ANGLE_DEGREES &lt;= h &lt; HSV_Q4_MAX_ANGLE_DEGREES:\nr_, g_, b_ = x, 0.0, c\nelif HSV_Q4_MAX_ANGLE_DEGREES &lt;= h &lt;= HSV_Q5_MAX_ANGLE_DEGREES:\nr_, g_, b_ = c, 0.0, x\nelse:\nraise ValueError(h)\nreturn cls(\nr=round((r_ + m) * 255),\ng=round((g_ + m) * 255),\nb=round((b_ + m) * 255),\na=a,\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.common.rgba.RGBA.as_rgba_int","title":"as_rgba_int","text":"<pre><code>as_rgba_int() -&gt; tuple[int, int, int, int]\n</code></pre> <p>Return RGBA color as tuple of integers in range 0 to 255 inclusive.</p> Source code in <code>src/pygerber/common/rgba.py</code> <pre><code>def as_rgba_int(self) -&gt; tuple[int, int, int, int]:\n\"\"\"Return RGBA color as tuple of integers in range 0 to 255 inclusive.\"\"\"\nreturn self.r, self.g, self.b, self.a\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.common.rgba.RGBA.as_rgba_float","title":"as_rgba_float","text":"<pre><code>as_rgba_float() -&gt; tuple[float, float, float, float]\n</code></pre> <p>Return RGBA color as tuple of floats in range 0.0 to 1.0 inclusive.</p> Source code in <code>src/pygerber/common/rgba.py</code> <pre><code>def as_rgba_float(self) -&gt; tuple[float, float, float, float]:\n\"\"\"Return RGBA color as tuple of floats in range 0.0 to 1.0 inclusive.\"\"\"\nreturn (\nfloat(Decimal(self.r) / Decimal(255)),\nfloat(Decimal(self.g) / Decimal(255)),\nfloat(Decimal(self.b) / Decimal(255)),\nfloat(Decimal(self.a) / Decimal(255)),\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.InvalidCoordinateLengthError","title":"InvalidCoordinateLengthError","text":"<p>             Bases: <code>ParserError</code></p> <p>Raised when coordinate string is too long.</p> Source code in <code>src/pygerber/gerberx3/parser/errors.py</code> <pre><code>class InvalidCoordinateLengthError(ParserError):\n\"\"\"Raised when coordinate string is too long.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.ParserFatalError","title":"ParserFatalError","text":"<p>             Bases: <code>ParserError</code></p> <p>Raised when parser encounters fatal failure from non-parser specific exception.</p> Source code in <code>src/pygerber/gerberx3/parser/errors.py</code> <pre><code>class ParserFatalError(ParserError):\n\"\"\"Raised when parser encounters fatal failure from non-parser specific\n    exception.\n    \"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.LayerParams","title":"LayerParams","text":"<p>             Bases: <code>BaseModel</code></p> <p>Parameters for Layer object.</p> <p><code>source_path</code>, <code>source_code</code> and <code>source_buffer</code> are mutually exclusive. When more than one of them is provided to constructor, MutuallyExclusiveViolationError will be raised.</p> Source code in <code>src/pygerber/gerberx3/api/_layers.py</code> <pre><code>class LayerParams(BaseModel):\n\"\"\"Parameters for Layer object.\n    `source_path`, `source_code` and `source_buffer` are mutually exclusive.\n    When more than one of them is provided to constructor,\n    MutuallyExclusiveViolationError will be raised.\n    \"\"\"\nmodel_config = ConfigDict(arbitrary_types_allowed=True, extra=\"forbid\")\nsource_path: Optional[Union[Path, str]] = None\n\"\"\"Path to source file containing Gerber code. It will be automatically loaded\n    from local storage, when provided. Mutually exclusive with `source_code` and\n    `source_buffer`.\n    \"\"\"\nsource_code: Optional[Union[str, bytes]] = None\n\"\"\"Gerber source code. Mutually exclusive with `source_path` and `source_buffer`.\"\"\"\nsource_buffer: Optional[Union[StringIO, BytesIO]] = None\n\"\"\"Buffer containing Gerber source code. Buffer pointer should be at the\n    beginning of the buffer. Mutually exclusive with `source_path` and\n    `source_code`.\"\"\"\nparser_error: Union[\nCallable[[Exception, Parser, Token], None],\nParserOnErrorAction,\n] = ParserOnErrorAction.Raise\n\"\"\"Callback function or rule describing how to treat errors during parsing.\"\"\"\nencoding: str = \"utf-8\"\n\"\"\"Encoding of code, used when loading from file, decoding `source_code`\n    provided as bytes and reading `source_buffer` provided as BytesIO.\"\"\"\ndraw_region_outlines: bool = False\n\"\"\"When drawing regions, after filling region, draw also outline of region with\n    apertures used for region outlines. This behavior is not expected by KiCAD by\n    default but may be useful in some scenarios.\"\"\"\n@model_validator(mode=\"after\")\ndef _load_source_code(self) -&gt; Self:\n\"\"\"Load source code.\n        Raises\n        ------\n        MutuallyExclusiveViolationError\n            When more than one of mutually exclusive `source_path`, `source_code` and\n            `source_buffer` is provided to constructor.\n        \"\"\"\nif self.source_path:\nif self.source_code or self.source_buffer:\nmsg = \"'source_code' and 'source_buffer' provided at once.\"\nraise MutuallyExclusiveViolationError(msg)\nself.source_code = (\nPath(self.source_path or \"source.grb\")\n.expanduser()\n.resolve()\n.read_text(encoding=self.encoding)\n)\nreturn self\nif self.source_code:\nif self.source_path or self.source_buffer:\nmsg = \"'source_path' and 'source_buffer' provided at once.\"\nraise MutuallyExclusiveViolationError(msg)\nself.source_code = (\nself.source_code\nif isinstance(self.source_code, str)\nelse self.source_code.decode(self.encoding)\n)\nreturn self\nif self.source_buffer:\nif self.source_path or self.source_code:\nmsg = \"'source_path' and 'source_buffer' provided at once.\"\nraise MutuallyExclusiveViolationError(msg)\nsource_code = self.source_buffer.read()\nif isinstance(source_code, bytes):\nself.source_code = source_code.decode(encoding=\"utf-8\")\nelse:\nself.source_code = source_code\nreturn self\ndef get_source_code(self) -&gt; str:\n\"\"\"Return source code of layer.\"\"\"\nif not isinstance(self.source_code, str):\nmsg = f\"Expected {str} got {type(self.source_code)}.\"\nraise TypeError(msg)\nreturn self.source_code\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api._layers.LayerParams.source_path","title":"source_path  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>source_path: Optional[Union[Path, str]] = None\n</code></pre> <p>Path to source file containing Gerber code. It will be automatically loaded from local storage, when provided. Mutually exclusive with <code>source_code</code> and <code>source_buffer</code>.</p>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api._layers.LayerParams.source_code","title":"source_code  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>source_code: Optional[Union[str, bytes]] = None\n</code></pre> <p>Gerber source code. Mutually exclusive with <code>source_path</code> and <code>source_buffer</code>.</p>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api._layers.LayerParams.source_buffer","title":"source_buffer  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>source_buffer: Optional[Union[StringIO, BytesIO]] = None\n</code></pre> <p>Buffer containing Gerber source code. Buffer pointer should be at the beginning of the buffer. Mutually exclusive with <code>source_path</code> and <code>source_code</code>.</p>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api._layers.LayerParams.parser_error","title":"parser_error  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>parser_error: Union[\nCallable[[Exception, Parser, Token], None],\nParserOnErrorAction,\n] = ParserOnErrorAction.Raise\n</code></pre> <p>Callback function or rule describing how to treat errors during parsing.</p>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api._layers.LayerParams.encoding","title":"encoding  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>encoding: str = 'utf-8'\n</code></pre> <p>Encoding of code, used when loading from file, decoding <code>source_code</code> provided as bytes and reading <code>source_buffer</code> provided as BytesIO.</p>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api._layers.LayerParams.draw_region_outlines","title":"draw_region_outlines  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>draw_region_outlines: bool = False\n</code></pre> <p>When drawing regions, after filling region, draw also outline of region with apertures used for region outlines. This behavior is not expected by KiCAD by default but may be useful in some scenarios.</p>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api._layers.LayerParams.get_source_code","title":"get_source_code","text":"<pre><code>get_source_code() -&gt; str\n</code></pre> <p>Return source code of layer.</p> Source code in <code>src/pygerber/gerberx3/api/_layers.py</code> <pre><code>def get_source_code(self) -&gt; str:\n\"\"\"Return source code of layer.\"\"\"\nif not isinstance(self.source_code, str):\nmsg = f\"Expected {str} got {type(self.source_code)}.\"\nraise TypeError(msg)\nreturn self.source_code\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.OnUpdateDrawingStateError","title":"OnUpdateDrawingStateError","text":"<p>             Bases: <code>ParserError</code></p> <p>Raised when parser encounters fatal failure from non-parser specific exception during call to .update_drawing_state() call.</p> Source code in <code>src/pygerber/gerberx3/parser/errors.py</code> <pre><code>class OnUpdateDrawingStateError(ParserError):\n\"\"\"Raised when parser encounters fatal failure from non-parser specific\n    exception during call to .update_drawing_state() call.\n    \"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.UnitNotSetError","title":"UnitNotSetError","text":"<p>             Bases: <code>ParserError</code></p> <p>Raised when operation which requires units to be set is executed before units are set.</p> Source code in <code>src/pygerber/gerberx3/parser/errors.py</code> <pre><code>class UnitNotSetError(ParserError):\n\"\"\"Raised when operation which requires units to be set is executed before units\n    are set.\n    \"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.ApertureNotDefinedError","title":"ApertureNotDefinedError","text":"<p>             Bases: <code>ParserError</code></p> <p>Raised when undefined aperture is selected.</p> Source code in <code>src/pygerber/gerberx3/parser/errors.py</code> <pre><code>class ApertureNotDefinedError(ParserError):\n\"\"\"Raised when undefined aperture is selected.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.CoordinateFormatNotSetError","title":"CoordinateFormatNotSetError","text":"<p>             Bases: <code>ParserError</code></p> <p>Raised when coordinate parser is requested before coordinate format was set.</p> Source code in <code>src/pygerber/gerberx3/parser/errors.py</code> <pre><code>class CoordinateFormatNotSetError(ParserError):\n\"\"\"Raised when coordinate parser is requested before coordinate format was set.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.ApertureNotSelectedError","title":"ApertureNotSelectedError","text":"<p>             Bases: <code>ParserError</code></p> <p>Raised when attempting to use aperture without selecting it first.</p> Source code in <code>src/pygerber/gerberx3/parser/errors.py</code> <pre><code>class ApertureNotSelectedError(ParserError):\n\"\"\"Raised when attempting to use aperture without selecting it first.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.ExitParsingProcessInterrupt","title":"ExitParsingProcessInterrupt","text":"<p>             Bases: <code>Exception</code></p> <p>Raised to stop parsing.</p> Source code in <code>src/pygerber/gerberx3/parser/errors.py</code> <pre><code>class ExitParsingProcessInterrupt(Exception):  # noqa: N818\n\"\"\"Raised to stop parsing.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.ParserOnErrorAction","title":"ParserOnErrorAction","text":"<p>             Bases: <code>Enum</code></p> <p>Possible error actions.</p> Source code in <code>src/pygerber/gerberx3/parser/parser.py</code> <pre><code>class ParserOnErrorAction(Enum):\n\"\"\"Possible error actions.\"\"\"\nIgnore = \"ignore\"\n\"\"\"Ignore parser errors. Errors which occurred will not be signaled. May yield\n    unexpected results for broken files, with missing draw commands or even more\n    significant errors.\"\"\"\nWarn = \"warn\"\n\"\"\"Warn on parser error. Parser will log warning message about what went wrong.\n    Best for supporting wide range of files without silently ignoring errors in code.\"\"\"\nRaise = \"raise\"\n\"\"\"Raise exception whenever parser encounters error. Will completely break out of\n    parsing process, making it impossible to render slightly malformed files.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.parser.parser.ParserOnErrorAction.Ignore","title":"Ignore  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Ignore = 'ignore'\n</code></pre> <p>Ignore parser errors. Errors which occurred will not be signaled. May yield unexpected results for broken files, with missing draw commands or even more significant errors.</p>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.parser.parser.ParserOnErrorAction.Warn","title":"Warn  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Warn = 'warn'\n</code></pre> <p>Warn on parser error. Parser will log warning message about what went wrong. Best for supporting wide range of files without silently ignoring errors in code.</p>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.parser.parser.ParserOnErrorAction.Raise","title":"Raise  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Raise = 'raise'\n</code></pre> <p>Raise exception whenever parser encounters error. Will completely break out of parsing process, making it impossible to render slightly malformed files.</p>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.Layer","title":"Layer","text":"<p>Representation of Gerber X3 image layer.</p> <p>This is only abstract base class, please use one of its subclasses with rendering system guarantees.</p> Source code in <code>src/pygerber/gerberx3/api/_layers.py</code> <pre><code>class Layer:\n\"\"\"Representation of Gerber X3 image layer.\n    This is only abstract base class, please use one of its subclasses with rendering\n    system guarantees.\n    \"\"\"\ndef __init__(self, options: LayerParams) -&gt; None:\n\"\"\"Create PCB layer.\n        Parameters\n        ----------\n        options: LayerOptions\n            Configuration of layer.\n        \"\"\"\nself.options = options\nself.tokenizer = self._create_tokenizer()\nself.backend = self._create_backend()\nself.parser = self._create_parser()\nself._rendering_result: Optional[RenderingResult] = None\ndef _create_tokenizer(self) -&gt; Tokenizer:\nreturn Tokenizer()\n@abstractmethod\ndef _create_backend(self) -&gt; Backend:\npass\ndef _create_parser(self) -&gt; Parser:\nreturn Parser(\nParserOptions(\nbackend=self.backend,\non_update_drawing_state_error=self.options.parser_error,\n),\n)\ndef render(self) -&gt; RenderingResult:\n\"\"\"Render layer image.\"\"\"\nstack = self.tokenizer.tokenize(self.options.get_source_code())\ndraw_commands = self.parser.parse(stack)\nresult_handle = draw_commands.draw()\nproperties = LayerProperties(\ntarget_bounding_box=self.backend.drawing_target.bounding_box,\ntarget_coordinate_origin=self.backend.drawing_target.coordinate_origin,\ngerber_bounding_box=self.backend.bounding_box,\ngerber_coordinate_origin=self.backend.coordinate_origin,\n)\nself._rendering_result = self._get_rendering_result_cls()(\nresult_handle=result_handle,\nproperties=properties,\n)\nreturn self._rendering_result\ndef _get_rendering_result_cls(self) -&gt; type[RenderingResult]:\nreturn RenderingResult\ndef get_rendering_result(self) -&gt; RenderingResult:\n\"\"\"Return result of rendering Gerber file.\"\"\"\nif self._rendering_result is None:\nmsg = \"Use `render()` method to create result first.\"\nraise RenderingResultNotReadyError(msg)\nreturn self._rendering_result\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api._layers.Layer.__init__","title":"__init__","text":"<pre><code>__init__(options: LayerParams) -&gt; None\n</code></pre> <p>Create PCB layer.</p> <p>Parameters:</p> Name Type Description Default <code>options</code> <code>LayerParams</code> <p>Configuration of layer.</p> required Source code in <code>src/pygerber/gerberx3/api/_layers.py</code> <pre><code>def __init__(self, options: LayerParams) -&gt; None:\n\"\"\"Create PCB layer.\n    Parameters\n    ----------\n    options: LayerOptions\n        Configuration of layer.\n    \"\"\"\nself.options = options\nself.tokenizer = self._create_tokenizer()\nself.backend = self._create_backend()\nself.parser = self._create_parser()\nself._rendering_result: Optional[RenderingResult] = None\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api._layers.Layer.render","title":"render","text":"<pre><code>render() -&gt; RenderingResult\n</code></pre> <p>Render layer image.</p> Source code in <code>src/pygerber/gerberx3/api/_layers.py</code> <pre><code>def render(self) -&gt; RenderingResult:\n\"\"\"Render layer image.\"\"\"\nstack = self.tokenizer.tokenize(self.options.get_source_code())\ndraw_commands = self.parser.parse(stack)\nresult_handle = draw_commands.draw()\nproperties = LayerProperties(\ntarget_bounding_box=self.backend.drawing_target.bounding_box,\ntarget_coordinate_origin=self.backend.drawing_target.coordinate_origin,\ngerber_bounding_box=self.backend.bounding_box,\ngerber_coordinate_origin=self.backend.coordinate_origin,\n)\nself._rendering_result = self._get_rendering_result_cls()(\nresult_handle=result_handle,\nproperties=properties,\n)\nreturn self._rendering_result\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api._layers.Layer.get_rendering_result","title":"get_rendering_result","text":"<pre><code>get_rendering_result() -&gt; RenderingResult\n</code></pre> <p>Return result of rendering Gerber file.</p> Source code in <code>src/pygerber/gerberx3/api/_layers.py</code> <pre><code>def get_rendering_result(self) -&gt; RenderingResult:\n\"\"\"Return result of rendering Gerber file.\"\"\"\nif self._rendering_result is None:\nmsg = \"Use `render()` method to create result first.\"\nraise RenderingResultNotReadyError(msg)\nreturn self._rendering_result\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.LayerProperties","title":"LayerProperties","text":"<p>Properties of layer retrieved from Gerber source code.</p> Source code in <code>src/pygerber/gerberx3/api/_layers.py</code> <pre><code>class LayerProperties:\n\"\"\"Properties of layer retrieved from Gerber source code.\"\"\"\ntarget_bounding_box: BoundingBox\n\"\"\"Bounding box of rendering target. May differ from coordinates used in Gerber\n    file as it uses rendering target coordinate space.\"\"\"\ntarget_coordinate_origin: Vector2D\n\"\"\"Offset of origin of coordinate system used by rendering target. Bottom left\n    corner of coordinate space of rendering target.\"\"\"\ngerber_bounding_box: BoundingBox\n\"\"\"Bounding box of drawing area in Gerber file coordinate space.\"\"\"\ngerber_coordinate_origin: Vector2D\n\"\"\"Origin of coordinate space of Gerber file. Equivalent to bottom left corner of\n    `gerber_bounding_box`.\n    Can be useful to determine how to align multiple Gerber files by calculating\n    how their coordinate origins are positioned in relation to each other.\"\"\"\ndef __init__(\nself,\ntarget_bounding_box: BoundingBox,\ntarget_coordinate_origin: Vector2D,\ngerber_bounding_box: BoundingBox,\ngerber_coordinate_origin: Vector2D,\n) -&gt; None:\n\"\"\"Initialize layer properties.\"\"\"\nself.target_bounding_box = target_bounding_box\nself.target_coordinate_origin = target_coordinate_origin\nself.gerber_bounding_box = gerber_bounding_box\nself.gerber_coordinate_origin = gerber_coordinate_origin\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api._layers.LayerProperties.target_bounding_box","title":"target_bounding_box  <code>instance-attribute</code>","text":"<pre><code>target_bounding_box: BoundingBox = target_bounding_box\n</code></pre> <p>Bounding box of rendering target. May differ from coordinates used in Gerber file as it uses rendering target coordinate space.</p>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api._layers.LayerProperties.target_coordinate_origin","title":"target_coordinate_origin  <code>instance-attribute</code>","text":"<pre><code>target_coordinate_origin: Vector2D = (\ntarget_coordinate_origin\n)\n</code></pre> <p>Offset of origin of coordinate system used by rendering target. Bottom left corner of coordinate space of rendering target.</p>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api._layers.LayerProperties.gerber_bounding_box","title":"gerber_bounding_box  <code>instance-attribute</code>","text":"<pre><code>gerber_bounding_box: BoundingBox = gerber_bounding_box\n</code></pre> <p>Bounding box of drawing area in Gerber file coordinate space.</p>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api._layers.LayerProperties.gerber_coordinate_origin","title":"gerber_coordinate_origin  <code>instance-attribute</code>","text":"<pre><code>gerber_coordinate_origin: Vector2D = (\ngerber_coordinate_origin\n)\n</code></pre> <p>Origin of coordinate space of Gerber file. Equivalent to bottom left corner of <code>gerber_bounding_box</code>.</p> <p>Can be useful to determine how to align multiple Gerber files by calculating how their coordinate origins are positioned in relation to each other.</p>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api._layers.LayerProperties.__init__","title":"__init__","text":"<pre><code>__init__(\ntarget_bounding_box: BoundingBox,\ntarget_coordinate_origin: Vector2D,\ngerber_bounding_box: BoundingBox,\ngerber_coordinate_origin: Vector2D,\n) -&gt; None\n</code></pre> <p>Initialize layer properties.</p> Source code in <code>src/pygerber/gerberx3/api/_layers.py</code> <pre><code>def __init__(\nself,\ntarget_bounding_box: BoundingBox,\ntarget_coordinate_origin: Vector2D,\ngerber_bounding_box: BoundingBox,\ngerber_coordinate_origin: Vector2D,\n) -&gt; None:\n\"\"\"Initialize layer properties.\"\"\"\nself.target_bounding_box = target_bounding_box\nself.target_coordinate_origin = target_coordinate_origin\nself.gerber_bounding_box = gerber_bounding_box\nself.gerber_coordinate_origin = gerber_coordinate_origin\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.RenderingResult","title":"RenderingResult","text":"<p>Result of rendering of layer.</p> Source code in <code>src/pygerber/gerberx3/api/_layers.py</code> <pre><code>class RenderingResult:\n\"\"\"Result of rendering of layer.\"\"\"\ndef __init__(\nself,\nproperties: LayerProperties,\nresult_handle: ResultHandle,\n) -&gt; None:\n\"\"\"Initialize rendering result object.\"\"\"\nself._properties = properties\nself._result_handle = result_handle\ndef save(\nself,\ndest: Path | str | BytesIO,\n**options: Any,\n) -&gt; None:\n\"\"\"Save result to specified file or buffer.\n        Parameters\n        ----------\n        dest : Path | str | BytesIO\n            Write target.\n        **options: Any\n            Extra parameters which will be passed to saving implementation.\n            When dest is BytesIO or alike, `format` option must be specified.\n            For Rasterized2D rendering options see [Pillow documentation](https://pillow.readthedocs.io/en/stable/reference/Image.html#PIL.Image.Image.save).\n        \"\"\"\nself._result_handle.save(dest, **options)\ndef get_properties(self) -&gt; LayerProperties:\n\"\"\"Get properties of layer.\"\"\"\nreturn self._properties\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api._layers.RenderingResult.__init__","title":"__init__","text":"<pre><code>__init__(\nproperties: LayerProperties, result_handle: ResultHandle\n) -&gt; None\n</code></pre> <p>Initialize rendering result object.</p> Source code in <code>src/pygerber/gerberx3/api/_layers.py</code> <pre><code>def __init__(\nself,\nproperties: LayerProperties,\nresult_handle: ResultHandle,\n) -&gt; None:\n\"\"\"Initialize rendering result object.\"\"\"\nself._properties = properties\nself._result_handle = result_handle\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api._layers.RenderingResult.save","title":"save","text":"<pre><code>save(dest: Path | str | BytesIO, **options: Any) -&gt; None\n</code></pre> <p>Save result to specified file or buffer.</p> <p>Parameters:</p> Name Type Description Default <code>dest</code> <code>Path | str | BytesIO</code> <p>Write target.</p> required <code>**options</code> <code>Any</code> <p>Extra parameters which will be passed to saving implementation. When dest is BytesIO or alike, <code>format</code> option must be specified. For Rasterized2D rendering options see Pillow documentation.</p> <code>{}</code> Source code in <code>src/pygerber/gerberx3/api/_layers.py</code> <pre><code>def save(\nself,\ndest: Path | str | BytesIO,\n**options: Any,\n) -&gt; None:\n\"\"\"Save result to specified file or buffer.\n    Parameters\n    ----------\n    dest : Path | str | BytesIO\n        Write target.\n    **options: Any\n        Extra parameters which will be passed to saving implementation.\n        When dest is BytesIO or alike, `format` option must be specified.\n        For Rasterized2D rendering options see [Pillow documentation](https://pillow.readthedocs.io/en/stable/reference/Image.html#PIL.Image.Image.save).\n    \"\"\"\nself._result_handle.save(dest, **options)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api._layers.RenderingResult.get_properties","title":"get_properties","text":"<pre><code>get_properties() -&gt; LayerProperties\n</code></pre> <p>Get properties of layer.</p> Source code in <code>src/pygerber/gerberx3/api/_layers.py</code> <pre><code>def get_properties(self) -&gt; LayerProperties:\n\"\"\"Get properties of layer.\"\"\"\nreturn self._properties\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.Rasterized2DLayerParams","title":"Rasterized2DLayerParams","text":"<p>             Bases: <code>LayerParams</code></p> <p>Parameters for Layer with 2D rendering.</p> <p><code>source_path</code>, <code>source_code</code> and <code>source_buffer</code> are mutually exclusive. When more than one of them is provided to constructor, MutuallyExclusiveViolationError will be raised.</p> Source code in <code>src/pygerber/gerberx3/api/_layers.py</code> <pre><code>class Rasterized2DLayerParams(LayerParams):\n\"\"\"Parameters for Layer with 2D rendering.\n    `source_path`, `source_code` and `source_buffer` are mutually exclusive.\n    When more than one of them is provided to constructor,\n    MutuallyExclusiveViolationError will be raised.\n    \"\"\"\ncolors: ColorScheme\n\"\"\"Colors to use for rendering of image.\"\"\"\ndpi: int = 1000\n\"\"\"DPI of output image.\"\"\"\ndebug_dump_apertures: Optional[Path] = None\n\"\"\"Debug option - dump aperture images to files in given directory.\"\"\"\ndebug_include_extra_padding: bool = False\n\"\"\"Debug option - include large extra padding on all rendering targets to simplify\n    tracking of mispositioned draw commands.\"\"\"\ndebug_include_bounding_boxes: bool = False\n\"\"\"Debug option - include bounding boxes as square outlines on drawing targets\n    to simplify tracking of miscalculated bounding boxes.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api._layers.Rasterized2DLayerParams.colors","title":"colors  <code>instance-attribute</code>","text":"<pre><code>colors: ColorScheme\n</code></pre> <p>Colors to use for rendering of image.</p>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api._layers.Rasterized2DLayerParams.dpi","title":"dpi  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dpi: int = 1000\n</code></pre> <p>DPI of output image.</p>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api._layers.Rasterized2DLayerParams.debug_dump_apertures","title":"debug_dump_apertures  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>debug_dump_apertures: Optional[Path] = None\n</code></pre> <p>Debug option - dump aperture images to files in given directory.</p>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api._layers.Rasterized2DLayerParams.debug_include_extra_padding","title":"debug_include_extra_padding  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>debug_include_extra_padding: bool = False\n</code></pre> <p>Debug option - include large extra padding on all rendering targets to simplify tracking of mispositioned draw commands.</p>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api._layers.Rasterized2DLayerParams.debug_include_bounding_boxes","title":"debug_include_bounding_boxes  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>debug_include_bounding_boxes: bool = False\n</code></pre> <p>Debug option - include bounding boxes as square outlines on drawing targets to simplify tracking of miscalculated bounding boxes.</p>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.Rasterized2DLayer","title":"Rasterized2DLayer","text":"<p>             Bases: <code>Layer</code></p> <p>Representation of Gerber X3 rasterized 2D image layer.</p> <p>Rasterized images can be saved in any image format supported by Pillow library. For full list of supported formats please refer to Pillow documentation.</p> Source code in <code>src/pygerber/gerberx3/api/_layers.py</code> <pre><code>class Rasterized2DLayer(Layer):\n\"\"\"Representation of Gerber X3 rasterized 2D image layer.\n    Rasterized images can be saved in any image format supported by Pillow library.\n    For full list of supported formats please refer to\n    [Pillow documentation](https://pillow.readthedocs.io/en/stable/handbook/image-file-formats.html).\n    \"\"\"\noptions: Rasterized2DLayerParams\ndef __init__(self, options: Rasterized2DLayerParams) -&gt; None:\n\"\"\"Initialize Layer object.\"\"\"\nif not isinstance(options, Rasterized2DLayerParams):\nmsg = (  # type: ignore[unreachable]\nf\"Expected {Rasterized2DLayerParams} got {type(options)}.\"\n)\nraise TypeError(msg)\nsuper().__init__(options)\ndef _create_backend(self) -&gt; Backend:\nreturn Rasterized2DBackend(\nRasterized2DBackendOptions(\ndpi=self.options.dpi,\ncolor_scheme=self.options.colors,\ndump_apertures=self.options.debug_dump_apertures,\ninclude_debug_padding=self.options.debug_include_extra_padding,\ninclude_bounding_boxes=self.options.debug_include_bounding_boxes,\ndraw_region_outlines=self.options.draw_region_outlines,\n),\n)\ndef _get_rendering_result_cls(self) -&gt; type[RenderingResult]:\nreturn Rasterized2DRenderingResult\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api._layers.Rasterized2DLayer.__init__","title":"__init__","text":"<pre><code>__init__(options: Rasterized2DLayerParams) -&gt; None\n</code></pre> <p>Initialize Layer object.</p> Source code in <code>src/pygerber/gerberx3/api/_layers.py</code> <pre><code>def __init__(self, options: Rasterized2DLayerParams) -&gt; None:\n\"\"\"Initialize Layer object.\"\"\"\nif not isinstance(options, Rasterized2DLayerParams):\nmsg = (  # type: ignore[unreachable]\nf\"Expected {Rasterized2DLayerParams} got {type(options)}.\"\n)\nraise TypeError(msg)\nsuper().__init__(options)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/_errors.html","title":"_errors","text":""},{"location":"reference/pygerber/gerberx3/api/_errors.html#pygerber.gerberx3.api._errors","title":"_errors","text":"<p>Errors which may be called by API layer.</p>"},{"location":"reference/pygerber/gerberx3/api/_errors.html#pygerber.gerberx3.api._errors.GerberX3APIError","title":"GerberX3APIError","text":"<p>             Bases: <code>Exception</code></p> <p>Base class for API errors.</p> <p>Exceptions derived from this exception are exclusively raised in PyGerber's Gerber X3 high level API. This exception can be used in <code>try: ... except GerberX3APIError: ...</code> block to catch all exceptions raised by this API while allowing other exceptions to interrupt execution.</p> Source code in <code>src/pygerber/gerberx3/api/_errors.py</code> <pre><code>class GerberX3APIError(Exception):\n\"\"\"Base class for API errors.\n    Exceptions derived from this exception are exclusively raised in PyGerber's Gerber\n    X3 high level API. This exception can be used in\n    `#!python try: ... except GerberX3APIError: ...` block to catch all exceptions\n    raised by this API while allowing other exceptions to interrupt execution.\n    \"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/_errors.html#pygerber.gerberx3.api._errors.RenderingResultNotReadyError","title":"RenderingResultNotReadyError","text":"<p>             Bases: <code>GerberX3APIError</code></p> <p>Raised when RenderingResult is requested before it was rendered.</p> <p><code>Layer.get_rendering_result()</code> method can only be called after <code>Layer.render()</code>. Breaking this rule will cause this exception to be raised.</p> Source code in <code>src/pygerber/gerberx3/api/_errors.py</code> <pre><code>class RenderingResultNotReadyError(GerberX3APIError):\n\"\"\"Raised when RenderingResult is requested before it was rendered.\n    `Layer.get_rendering_result()` method can only be called after `Layer.render()`.\n    Breaking this rule will cause this exception to be raised.\n    \"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/_errors.html#pygerber.gerberx3.api._errors.MutuallyExclusiveViolationError","title":"MutuallyExclusiveViolationError","text":"<p>             Bases: <code>GerberX3APIError</code></p> <p>Raised when two or more of mutually exclusive parameters are provided.</p> <p><code>LayerParams</code> class accepts three mutually exclusive fields, <code>source_path</code>, <code>source_code</code> and <code>source_buffer</code> for providing source code to <code>Layer</code>. When more than one of those options is set, this exception will be raised.</p> Source code in <code>src/pygerber/gerberx3/api/_errors.py</code> <pre><code>class MutuallyExclusiveViolationError(GerberX3APIError):\n\"\"\"Raised when two or more of mutually exclusive parameters are provided.\n    `LayerParams` class accepts three mutually exclusive fields, `source_path`,\n    `source_code` and `source_buffer` for providing source code to `Layer`.\n    When more than one of those options is set, this exception will be raised.\n    \"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/_layers.html","title":"_layers","text":""},{"location":"reference/pygerber/gerberx3/api/_layers.html#pygerber.gerberx3.api._layers","title":"_layers","text":"<p>High level API for rendering multi layer gerber projects.</p>"},{"location":"reference/pygerber/gerberx3/api/_layers.html#pygerber.gerberx3.api._layers.LayerParams","title":"LayerParams","text":"<p>             Bases: <code>BaseModel</code></p> <p>Parameters for Layer object.</p> <p><code>source_path</code>, <code>source_code</code> and <code>source_buffer</code> are mutually exclusive. When more than one of them is provided to constructor, MutuallyExclusiveViolationError will be raised.</p> Source code in <code>src/pygerber/gerberx3/api/_layers.py</code> <pre><code>class LayerParams(BaseModel):\n\"\"\"Parameters for Layer object.\n    `source_path`, `source_code` and `source_buffer` are mutually exclusive.\n    When more than one of them is provided to constructor,\n    MutuallyExclusiveViolationError will be raised.\n    \"\"\"\nmodel_config = ConfigDict(arbitrary_types_allowed=True, extra=\"forbid\")\nsource_path: Optional[Union[Path, str]] = None\n\"\"\"Path to source file containing Gerber code. It will be automatically loaded\n    from local storage, when provided. Mutually exclusive with `source_code` and\n    `source_buffer`.\n    \"\"\"\nsource_code: Optional[Union[str, bytes]] = None\n\"\"\"Gerber source code. Mutually exclusive with `source_path` and `source_buffer`.\"\"\"\nsource_buffer: Optional[Union[StringIO, BytesIO]] = None\n\"\"\"Buffer containing Gerber source code. Buffer pointer should be at the\n    beginning of the buffer. Mutually exclusive with `source_path` and\n    `source_code`.\"\"\"\nparser_error: Union[\nCallable[[Exception, Parser, Token], None],\nParserOnErrorAction,\n] = ParserOnErrorAction.Raise\n\"\"\"Callback function or rule describing how to treat errors during parsing.\"\"\"\nencoding: str = \"utf-8\"\n\"\"\"Encoding of code, used when loading from file, decoding `source_code`\n    provided as bytes and reading `source_buffer` provided as BytesIO.\"\"\"\ndraw_region_outlines: bool = False\n\"\"\"When drawing regions, after filling region, draw also outline of region with\n    apertures used for region outlines. This behavior is not expected by KiCAD by\n    default but may be useful in some scenarios.\"\"\"\n@model_validator(mode=\"after\")\ndef _load_source_code(self) -&gt; Self:\n\"\"\"Load source code.\n        Raises\n        ------\n        MutuallyExclusiveViolationError\n            When more than one of mutually exclusive `source_path`, `source_code` and\n            `source_buffer` is provided to constructor.\n        \"\"\"\nif self.source_path:\nif self.source_code or self.source_buffer:\nmsg = \"'source_code' and 'source_buffer' provided at once.\"\nraise MutuallyExclusiveViolationError(msg)\nself.source_code = (\nPath(self.source_path or \"source.grb\")\n.expanduser()\n.resolve()\n.read_text(encoding=self.encoding)\n)\nreturn self\nif self.source_code:\nif self.source_path or self.source_buffer:\nmsg = \"'source_path' and 'source_buffer' provided at once.\"\nraise MutuallyExclusiveViolationError(msg)\nself.source_code = (\nself.source_code\nif isinstance(self.source_code, str)\nelse self.source_code.decode(self.encoding)\n)\nreturn self\nif self.source_buffer:\nif self.source_path or self.source_code:\nmsg = \"'source_path' and 'source_buffer' provided at once.\"\nraise MutuallyExclusiveViolationError(msg)\nsource_code = self.source_buffer.read()\nif isinstance(source_code, bytes):\nself.source_code = source_code.decode(encoding=\"utf-8\")\nelse:\nself.source_code = source_code\nreturn self\ndef get_source_code(self) -&gt; str:\n\"\"\"Return source code of layer.\"\"\"\nif not isinstance(self.source_code, str):\nmsg = f\"Expected {str} got {type(self.source_code)}.\"\nraise TypeError(msg)\nreturn self.source_code\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/_layers.html#pygerber.gerberx3.api._layers.LayerParams.source_path","title":"source_path  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>source_path: Optional[Union[Path, str]] = None\n</code></pre> <p>Path to source file containing Gerber code. It will be automatically loaded from local storage, when provided. Mutually exclusive with <code>source_code</code> and <code>source_buffer</code>.</p>"},{"location":"reference/pygerber/gerberx3/api/_layers.html#pygerber.gerberx3.api._layers.LayerParams.source_code","title":"source_code  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>source_code: Optional[Union[str, bytes]] = None\n</code></pre> <p>Gerber source code. Mutually exclusive with <code>source_path</code> and <code>source_buffer</code>.</p>"},{"location":"reference/pygerber/gerberx3/api/_layers.html#pygerber.gerberx3.api._layers.LayerParams.source_buffer","title":"source_buffer  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>source_buffer: Optional[Union[StringIO, BytesIO]] = None\n</code></pre> <p>Buffer containing Gerber source code. Buffer pointer should be at the beginning of the buffer. Mutually exclusive with <code>source_path</code> and <code>source_code</code>.</p>"},{"location":"reference/pygerber/gerberx3/api/_layers.html#pygerber.gerberx3.api._layers.LayerParams.parser_error","title":"parser_error  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>parser_error: Union[\nCallable[[Exception, Parser, Token], None],\nParserOnErrorAction,\n] = ParserOnErrorAction.Raise\n</code></pre> <p>Callback function or rule describing how to treat errors during parsing.</p>"},{"location":"reference/pygerber/gerberx3/api/_layers.html#pygerber.gerberx3.api._layers.LayerParams.encoding","title":"encoding  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>encoding: str = 'utf-8'\n</code></pre> <p>Encoding of code, used when loading from file, decoding <code>source_code</code> provided as bytes and reading <code>source_buffer</code> provided as BytesIO.</p>"},{"location":"reference/pygerber/gerberx3/api/_layers.html#pygerber.gerberx3.api._layers.LayerParams.draw_region_outlines","title":"draw_region_outlines  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>draw_region_outlines: bool = False\n</code></pre> <p>When drawing regions, after filling region, draw also outline of region with apertures used for region outlines. This behavior is not expected by KiCAD by default but may be useful in some scenarios.</p>"},{"location":"reference/pygerber/gerberx3/api/_layers.html#pygerber.gerberx3.api._layers.LayerParams.get_source_code","title":"get_source_code","text":"<pre><code>get_source_code() -&gt; str\n</code></pre> <p>Return source code of layer.</p> Source code in <code>src/pygerber/gerberx3/api/_layers.py</code> <pre><code>def get_source_code(self) -&gt; str:\n\"\"\"Return source code of layer.\"\"\"\nif not isinstance(self.source_code, str):\nmsg = f\"Expected {str} got {type(self.source_code)}.\"\nraise TypeError(msg)\nreturn self.source_code\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/_layers.html#pygerber.gerberx3.api._layers.Layer","title":"Layer","text":"<p>Representation of Gerber X3 image layer.</p> <p>This is only abstract base class, please use one of its subclasses with rendering system guarantees.</p> Source code in <code>src/pygerber/gerberx3/api/_layers.py</code> <pre><code>class Layer:\n\"\"\"Representation of Gerber X3 image layer.\n    This is only abstract base class, please use one of its subclasses with rendering\n    system guarantees.\n    \"\"\"\ndef __init__(self, options: LayerParams) -&gt; None:\n\"\"\"Create PCB layer.\n        Parameters\n        ----------\n        options: LayerOptions\n            Configuration of layer.\n        \"\"\"\nself.options = options\nself.tokenizer = self._create_tokenizer()\nself.backend = self._create_backend()\nself.parser = self._create_parser()\nself._rendering_result: Optional[RenderingResult] = None\ndef _create_tokenizer(self) -&gt; Tokenizer:\nreturn Tokenizer()\n@abstractmethod\ndef _create_backend(self) -&gt; Backend:\npass\ndef _create_parser(self) -&gt; Parser:\nreturn Parser(\nParserOptions(\nbackend=self.backend,\non_update_drawing_state_error=self.options.parser_error,\n),\n)\ndef render(self) -&gt; RenderingResult:\n\"\"\"Render layer image.\"\"\"\nstack = self.tokenizer.tokenize(self.options.get_source_code())\ndraw_commands = self.parser.parse(stack)\nresult_handle = draw_commands.draw()\nproperties = LayerProperties(\ntarget_bounding_box=self.backend.drawing_target.bounding_box,\ntarget_coordinate_origin=self.backend.drawing_target.coordinate_origin,\ngerber_bounding_box=self.backend.bounding_box,\ngerber_coordinate_origin=self.backend.coordinate_origin,\n)\nself._rendering_result = self._get_rendering_result_cls()(\nresult_handle=result_handle,\nproperties=properties,\n)\nreturn self._rendering_result\ndef _get_rendering_result_cls(self) -&gt; type[RenderingResult]:\nreturn RenderingResult\ndef get_rendering_result(self) -&gt; RenderingResult:\n\"\"\"Return result of rendering Gerber file.\"\"\"\nif self._rendering_result is None:\nmsg = \"Use `render()` method to create result first.\"\nraise RenderingResultNotReadyError(msg)\nreturn self._rendering_result\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/_layers.html#pygerber.gerberx3.api._layers.Layer.__init__","title":"__init__","text":"<pre><code>__init__(options: LayerParams) -&gt; None\n</code></pre> <p>Create PCB layer.</p> <p>Parameters:</p> Name Type Description Default <code>options</code> <code>LayerParams</code> <p>Configuration of layer.</p> required Source code in <code>src/pygerber/gerberx3/api/_layers.py</code> <pre><code>def __init__(self, options: LayerParams) -&gt; None:\n\"\"\"Create PCB layer.\n    Parameters\n    ----------\n    options: LayerOptions\n        Configuration of layer.\n    \"\"\"\nself.options = options\nself.tokenizer = self._create_tokenizer()\nself.backend = self._create_backend()\nself.parser = self._create_parser()\nself._rendering_result: Optional[RenderingResult] = None\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/_layers.html#pygerber.gerberx3.api._layers.Layer.render","title":"render","text":"<pre><code>render() -&gt; RenderingResult\n</code></pre> <p>Render layer image.</p> Source code in <code>src/pygerber/gerberx3/api/_layers.py</code> <pre><code>def render(self) -&gt; RenderingResult:\n\"\"\"Render layer image.\"\"\"\nstack = self.tokenizer.tokenize(self.options.get_source_code())\ndraw_commands = self.parser.parse(stack)\nresult_handle = draw_commands.draw()\nproperties = LayerProperties(\ntarget_bounding_box=self.backend.drawing_target.bounding_box,\ntarget_coordinate_origin=self.backend.drawing_target.coordinate_origin,\ngerber_bounding_box=self.backend.bounding_box,\ngerber_coordinate_origin=self.backend.coordinate_origin,\n)\nself._rendering_result = self._get_rendering_result_cls()(\nresult_handle=result_handle,\nproperties=properties,\n)\nreturn self._rendering_result\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/_layers.html#pygerber.gerberx3.api._layers.Layer.get_rendering_result","title":"get_rendering_result","text":"<pre><code>get_rendering_result() -&gt; RenderingResult\n</code></pre> <p>Return result of rendering Gerber file.</p> Source code in <code>src/pygerber/gerberx3/api/_layers.py</code> <pre><code>def get_rendering_result(self) -&gt; RenderingResult:\n\"\"\"Return result of rendering Gerber file.\"\"\"\nif self._rendering_result is None:\nmsg = \"Use `render()` method to create result first.\"\nraise RenderingResultNotReadyError(msg)\nreturn self._rendering_result\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/_layers.html#pygerber.gerberx3.api._layers.LayerProperties","title":"LayerProperties","text":"<p>Properties of layer retrieved from Gerber source code.</p> Source code in <code>src/pygerber/gerberx3/api/_layers.py</code> <pre><code>class LayerProperties:\n\"\"\"Properties of layer retrieved from Gerber source code.\"\"\"\ntarget_bounding_box: BoundingBox\n\"\"\"Bounding box of rendering target. May differ from coordinates used in Gerber\n    file as it uses rendering target coordinate space.\"\"\"\ntarget_coordinate_origin: Vector2D\n\"\"\"Offset of origin of coordinate system used by rendering target. Bottom left\n    corner of coordinate space of rendering target.\"\"\"\ngerber_bounding_box: BoundingBox\n\"\"\"Bounding box of drawing area in Gerber file coordinate space.\"\"\"\ngerber_coordinate_origin: Vector2D\n\"\"\"Origin of coordinate space of Gerber file. Equivalent to bottom left corner of\n    `gerber_bounding_box`.\n    Can be useful to determine how to align multiple Gerber files by calculating\n    how their coordinate origins are positioned in relation to each other.\"\"\"\ndef __init__(\nself,\ntarget_bounding_box: BoundingBox,\ntarget_coordinate_origin: Vector2D,\ngerber_bounding_box: BoundingBox,\ngerber_coordinate_origin: Vector2D,\n) -&gt; None:\n\"\"\"Initialize layer properties.\"\"\"\nself.target_bounding_box = target_bounding_box\nself.target_coordinate_origin = target_coordinate_origin\nself.gerber_bounding_box = gerber_bounding_box\nself.gerber_coordinate_origin = gerber_coordinate_origin\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/_layers.html#pygerber.gerberx3.api._layers.LayerProperties.target_bounding_box","title":"target_bounding_box  <code>instance-attribute</code>","text":"<pre><code>target_bounding_box: BoundingBox = target_bounding_box\n</code></pre> <p>Bounding box of rendering target. May differ from coordinates used in Gerber file as it uses rendering target coordinate space.</p>"},{"location":"reference/pygerber/gerberx3/api/_layers.html#pygerber.gerberx3.api._layers.LayerProperties.target_coordinate_origin","title":"target_coordinate_origin  <code>instance-attribute</code>","text":"<pre><code>target_coordinate_origin: Vector2D = (\ntarget_coordinate_origin\n)\n</code></pre> <p>Offset of origin of coordinate system used by rendering target. Bottom left corner of coordinate space of rendering target.</p>"},{"location":"reference/pygerber/gerberx3/api/_layers.html#pygerber.gerberx3.api._layers.LayerProperties.gerber_bounding_box","title":"gerber_bounding_box  <code>instance-attribute</code>","text":"<pre><code>gerber_bounding_box: BoundingBox = gerber_bounding_box\n</code></pre> <p>Bounding box of drawing area in Gerber file coordinate space.</p>"},{"location":"reference/pygerber/gerberx3/api/_layers.html#pygerber.gerberx3.api._layers.LayerProperties.gerber_coordinate_origin","title":"gerber_coordinate_origin  <code>instance-attribute</code>","text":"<pre><code>gerber_coordinate_origin: Vector2D = (\ngerber_coordinate_origin\n)\n</code></pre> <p>Origin of coordinate space of Gerber file. Equivalent to bottom left corner of <code>gerber_bounding_box</code>.</p> <p>Can be useful to determine how to align multiple Gerber files by calculating how their coordinate origins are positioned in relation to each other.</p>"},{"location":"reference/pygerber/gerberx3/api/_layers.html#pygerber.gerberx3.api._layers.LayerProperties.__init__","title":"__init__","text":"<pre><code>__init__(\ntarget_bounding_box: BoundingBox,\ntarget_coordinate_origin: Vector2D,\ngerber_bounding_box: BoundingBox,\ngerber_coordinate_origin: Vector2D,\n) -&gt; None\n</code></pre> <p>Initialize layer properties.</p> Source code in <code>src/pygerber/gerberx3/api/_layers.py</code> <pre><code>def __init__(\nself,\ntarget_bounding_box: BoundingBox,\ntarget_coordinate_origin: Vector2D,\ngerber_bounding_box: BoundingBox,\ngerber_coordinate_origin: Vector2D,\n) -&gt; None:\n\"\"\"Initialize layer properties.\"\"\"\nself.target_bounding_box = target_bounding_box\nself.target_coordinate_origin = target_coordinate_origin\nself.gerber_bounding_box = gerber_bounding_box\nself.gerber_coordinate_origin = gerber_coordinate_origin\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/_layers.html#pygerber.gerberx3.api._layers.RenderingResult","title":"RenderingResult","text":"<p>Result of rendering of layer.</p> Source code in <code>src/pygerber/gerberx3/api/_layers.py</code> <pre><code>class RenderingResult:\n\"\"\"Result of rendering of layer.\"\"\"\ndef __init__(\nself,\nproperties: LayerProperties,\nresult_handle: ResultHandle,\n) -&gt; None:\n\"\"\"Initialize rendering result object.\"\"\"\nself._properties = properties\nself._result_handle = result_handle\ndef save(\nself,\ndest: Path | str | BytesIO,\n**options: Any,\n) -&gt; None:\n\"\"\"Save result to specified file or buffer.\n        Parameters\n        ----------\n        dest : Path | str | BytesIO\n            Write target.\n        **options: Any\n            Extra parameters which will be passed to saving implementation.\n            When dest is BytesIO or alike, `format` option must be specified.\n            For Rasterized2D rendering options see [Pillow documentation](https://pillow.readthedocs.io/en/stable/reference/Image.html#PIL.Image.Image.save).\n        \"\"\"\nself._result_handle.save(dest, **options)\ndef get_properties(self) -&gt; LayerProperties:\n\"\"\"Get properties of layer.\"\"\"\nreturn self._properties\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/_layers.html#pygerber.gerberx3.api._layers.RenderingResult.__init__","title":"__init__","text":"<pre><code>__init__(\nproperties: LayerProperties, result_handle: ResultHandle\n) -&gt; None\n</code></pre> <p>Initialize rendering result object.</p> Source code in <code>src/pygerber/gerberx3/api/_layers.py</code> <pre><code>def __init__(\nself,\nproperties: LayerProperties,\nresult_handle: ResultHandle,\n) -&gt; None:\n\"\"\"Initialize rendering result object.\"\"\"\nself._properties = properties\nself._result_handle = result_handle\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/_layers.html#pygerber.gerberx3.api._layers.RenderingResult.save","title":"save","text":"<pre><code>save(dest: Path | str | BytesIO, **options: Any) -&gt; None\n</code></pre> <p>Save result to specified file or buffer.</p> <p>Parameters:</p> Name Type Description Default <code>dest</code> <code>Path | str | BytesIO</code> <p>Write target.</p> required <code>**options</code> <code>Any</code> <p>Extra parameters which will be passed to saving implementation. When dest is BytesIO or alike, <code>format</code> option must be specified. For Rasterized2D rendering options see Pillow documentation.</p> <code>{}</code> Source code in <code>src/pygerber/gerberx3/api/_layers.py</code> <pre><code>def save(\nself,\ndest: Path | str | BytesIO,\n**options: Any,\n) -&gt; None:\n\"\"\"Save result to specified file or buffer.\n    Parameters\n    ----------\n    dest : Path | str | BytesIO\n        Write target.\n    **options: Any\n        Extra parameters which will be passed to saving implementation.\n        When dest is BytesIO or alike, `format` option must be specified.\n        For Rasterized2D rendering options see [Pillow documentation](https://pillow.readthedocs.io/en/stable/reference/Image.html#PIL.Image.Image.save).\n    \"\"\"\nself._result_handle.save(dest, **options)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/_layers.html#pygerber.gerberx3.api._layers.RenderingResult.get_properties","title":"get_properties","text":"<pre><code>get_properties() -&gt; LayerProperties\n</code></pre> <p>Get properties of layer.</p> Source code in <code>src/pygerber/gerberx3/api/_layers.py</code> <pre><code>def get_properties(self) -&gt; LayerProperties:\n\"\"\"Get properties of layer.\"\"\"\nreturn self._properties\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/_layers.html#pygerber.gerberx3.api._layers.Rasterized2DLayerParams","title":"Rasterized2DLayerParams","text":"<p>             Bases: <code>LayerParams</code></p> <p>Parameters for Layer with 2D rendering.</p> <p><code>source_path</code>, <code>source_code</code> and <code>source_buffer</code> are mutually exclusive. When more than one of them is provided to constructor, MutuallyExclusiveViolationError will be raised.</p> Source code in <code>src/pygerber/gerberx3/api/_layers.py</code> <pre><code>class Rasterized2DLayerParams(LayerParams):\n\"\"\"Parameters for Layer with 2D rendering.\n    `source_path`, `source_code` and `source_buffer` are mutually exclusive.\n    When more than one of them is provided to constructor,\n    MutuallyExclusiveViolationError will be raised.\n    \"\"\"\ncolors: ColorScheme\n\"\"\"Colors to use for rendering of image.\"\"\"\ndpi: int = 1000\n\"\"\"DPI of output image.\"\"\"\ndebug_dump_apertures: Optional[Path] = None\n\"\"\"Debug option - dump aperture images to files in given directory.\"\"\"\ndebug_include_extra_padding: bool = False\n\"\"\"Debug option - include large extra padding on all rendering targets to simplify\n    tracking of mispositioned draw commands.\"\"\"\ndebug_include_bounding_boxes: bool = False\n\"\"\"Debug option - include bounding boxes as square outlines on drawing targets\n    to simplify tracking of miscalculated bounding boxes.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/_layers.html#pygerber.gerberx3.api._layers.Rasterized2DLayerParams.colors","title":"colors  <code>instance-attribute</code>","text":"<pre><code>colors: ColorScheme\n</code></pre> <p>Colors to use for rendering of image.</p>"},{"location":"reference/pygerber/gerberx3/api/_layers.html#pygerber.gerberx3.api._layers.Rasterized2DLayerParams.dpi","title":"dpi  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dpi: int = 1000\n</code></pre> <p>DPI of output image.</p>"},{"location":"reference/pygerber/gerberx3/api/_layers.html#pygerber.gerberx3.api._layers.Rasterized2DLayerParams.debug_dump_apertures","title":"debug_dump_apertures  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>debug_dump_apertures: Optional[Path] = None\n</code></pre> <p>Debug option - dump aperture images to files in given directory.</p>"},{"location":"reference/pygerber/gerberx3/api/_layers.html#pygerber.gerberx3.api._layers.Rasterized2DLayerParams.debug_include_extra_padding","title":"debug_include_extra_padding  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>debug_include_extra_padding: bool = False\n</code></pre> <p>Debug option - include large extra padding on all rendering targets to simplify tracking of mispositioned draw commands.</p>"},{"location":"reference/pygerber/gerberx3/api/_layers.html#pygerber.gerberx3.api._layers.Rasterized2DLayerParams.debug_include_bounding_boxes","title":"debug_include_bounding_boxes  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>debug_include_bounding_boxes: bool = False\n</code></pre> <p>Debug option - include bounding boxes as square outlines on drawing targets to simplify tracking of miscalculated bounding boxes.</p>"},{"location":"reference/pygerber/gerberx3/api/_layers.html#pygerber.gerberx3.api._layers.Rasterized2DLayer","title":"Rasterized2DLayer","text":"<p>             Bases: <code>Layer</code></p> <p>Representation of Gerber X3 rasterized 2D image layer.</p> <p>Rasterized images can be saved in any image format supported by Pillow library. For full list of supported formats please refer to Pillow documentation.</p> Source code in <code>src/pygerber/gerberx3/api/_layers.py</code> <pre><code>class Rasterized2DLayer(Layer):\n\"\"\"Representation of Gerber X3 rasterized 2D image layer.\n    Rasterized images can be saved in any image format supported by Pillow library.\n    For full list of supported formats please refer to\n    [Pillow documentation](https://pillow.readthedocs.io/en/stable/handbook/image-file-formats.html).\n    \"\"\"\noptions: Rasterized2DLayerParams\ndef __init__(self, options: Rasterized2DLayerParams) -&gt; None:\n\"\"\"Initialize Layer object.\"\"\"\nif not isinstance(options, Rasterized2DLayerParams):\nmsg = (  # type: ignore[unreachable]\nf\"Expected {Rasterized2DLayerParams} got {type(options)}.\"\n)\nraise TypeError(msg)\nsuper().__init__(options)\ndef _create_backend(self) -&gt; Backend:\nreturn Rasterized2DBackend(\nRasterized2DBackendOptions(\ndpi=self.options.dpi,\ncolor_scheme=self.options.colors,\ndump_apertures=self.options.debug_dump_apertures,\ninclude_debug_padding=self.options.debug_include_extra_padding,\ninclude_bounding_boxes=self.options.debug_include_bounding_boxes,\ndraw_region_outlines=self.options.draw_region_outlines,\n),\n)\ndef _get_rendering_result_cls(self) -&gt; type[RenderingResult]:\nreturn Rasterized2DRenderingResult\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/_layers.html#pygerber.gerberx3.api._layers.Rasterized2DLayer.__init__","title":"__init__","text":"<pre><code>__init__(options: Rasterized2DLayerParams) -&gt; None\n</code></pre> <p>Initialize Layer object.</p> Source code in <code>src/pygerber/gerberx3/api/_layers.py</code> <pre><code>def __init__(self, options: Rasterized2DLayerParams) -&gt; None:\n\"\"\"Initialize Layer object.\"\"\"\nif not isinstance(options, Rasterized2DLayerParams):\nmsg = (  # type: ignore[unreachable]\nf\"Expected {Rasterized2DLayerParams} got {type(options)}.\"\n)\nraise TypeError(msg)\nsuper().__init__(options)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/_layers.html#pygerber.gerberx3.api._layers.Rasterized2DRenderingResult","title":"Rasterized2DRenderingResult","text":"<p>             Bases: <code>RenderingResult</code></p> <p>Result of rendering of layer.</p> Source code in <code>src/pygerber/gerberx3/api/_layers.py</code> <pre><code>class Rasterized2DRenderingResult(RenderingResult):\n\"\"\"Result of rendering of layer.\"\"\"\n_result_handle: Rasterized2DResultHandle\ndef get_image(self) -&gt; Image.Image:\n\"\"\"Get rendered image object.\"\"\"\nreturn self._result_handle.get_image()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/_layers.html#pygerber.gerberx3.api._layers.Rasterized2DRenderingResult.get_image","title":"get_image","text":"<pre><code>get_image() -&gt; Image.Image\n</code></pre> <p>Get rendered image object.</p> Source code in <code>src/pygerber/gerberx3/api/_layers.py</code> <pre><code>def get_image(self) -&gt; Image.Image:\n\"\"\"Get rendered image object.\"\"\"\nreturn self._result_handle.get_image()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/math/__init__.html","title":"init","text":""},{"location":"reference/pygerber/gerberx3/math/__init__.html#pygerber.gerberx3.math","title":"math","text":"<p>Module containing math utilities.</p>"},{"location":"reference/pygerber/gerberx3/math/bounding_box.html","title":"bounding_box","text":""},{"location":"reference/pygerber/gerberx3/math/bounding_box.html#pygerber.gerberx3.math.bounding_box","title":"bounding_box","text":"<p>Utility class for calculating bounding boxes of drawing elements.</p>"},{"location":"reference/pygerber/gerberx3/math/bounding_box.html#pygerber.gerberx3.math.bounding_box.BoundingBox","title":"BoundingBox","text":"<p>             Bases: <code>FrozenGeneralModel</code></p> <p>Class for calculating bounding boxes.</p> Source code in <code>src/pygerber/gerberx3/math/bounding_box.py</code> <pre><code>class BoundingBox(FrozenGeneralModel):\n\"\"\"Class for calculating bounding boxes.\"\"\"\nNULL: ClassVar[BoundingBox]\nmax_x: Offset = Field(default=Offset.NULL)\nmax_y: Offset = Field(default=Offset.NULL)\nmin_x: Offset = Field(default=Offset.NULL)\nmin_y: Offset = Field(default=Offset.NULL)\n@classmethod\ndef from_diameter(cls, diameter: Offset) -&gt; BoundingBox:\n\"\"\"Create a bounding box from a given diameter.\"\"\"\nhalf_diameter = diameter / 2\nreturn cls(\nmax_x=half_diameter,\nmax_y=half_diameter,\nmin_x=-half_diameter,\nmin_y=-half_diameter,\n)\n@classmethod\ndef from_rectangle(cls, x_size: Offset, y_size: Offset) -&gt; BoundingBox:\n\"\"\"Create a bounding box from a given diameter.\"\"\"\nhalf_x = x_size / 2\nhalf_y = y_size / 2\nreturn cls(\nmax_x=half_x,\nmax_y=half_y,\nmin_x=-half_x,\nmin_y=-half_y,\n)\n@property\ndef width(self) -&gt; Offset:\n\"\"\"Return width of the bounding box.\"\"\"\nreturn self.max_x - self.min_x\n@property\ndef height(self) -&gt; Offset:\n\"\"\"Return height of the bounding box.\"\"\"\nreturn self.max_y - self.min_y\ndef get_size(self) -&gt; Vector2D:\n\"\"\"Get bounding box size.\"\"\"\nreturn Vector2D(x=self.width, y=self.height)\n@property\ndef center(self) -&gt; Vector2D:\n\"\"\"Return current center of the bounding box.\"\"\"\ncenter_x = (self.max_x + self.min_x) / Offset(value=Decimal(2))\ncenter_y = (self.max_y + self.min_y) / Offset(value=Decimal(2))\nreturn Vector2D(x=center_x, y=center_y)\ndef get_min_vector(self) -&gt; Vector2D:\n\"\"\"Return Vector2D of min_x and min_y.\"\"\"\nreturn Vector2D(x=self.min_x, y=self.min_y)\ndef as_pixel_box(  # noqa: PLR0913\nself,\ndpi: int,\n*,\ndx_max: int = 0,\ndy_max: int = 0,\ndx_min: int = 0,\ndy_min: int = 0,\n) -&gt; PixelBox:\n\"\"\"Return box as tuple of ints with order.\n        [x0, y0, x1, y1], where x1 &gt;= x0 and y1 &gt;= y0\n        \"\"\"\nreturn PixelBox(\n(\nself.min_x.as_pixels(dpi) + dx_min,\nself.min_y.as_pixels(dpi) + dy_min,\nself.max_x.as_pixels(dpi) + dx_max,\nself.max_y.as_pixels(dpi) + dy_max,\n),\n)\ndef scale(self, by: Decimal) -&gt; BoundingBox:\n\"\"\"Return scaled bounding box.\"\"\"\ndx_dy = (self.get_size() * by) / 2\nreturn BoundingBox(\nmax_x=self.max_x + dx_dy.x,\nmax_y=self.max_y + dx_dy.y,\nmin_x=self.min_x - dx_dy.x,\nmin_y=self.min_y - dx_dy.y,\n)\ndef _operator(\nself,\nother: object,\nop: Callable,\n) -&gt; BoundingBox:\nif isinstance(other, Vector2D):\nreturn BoundingBox(\nmax_x=op(self.max_x, other.x),\nmax_y=op(self.max_y, other.y),\nmin_x=op(self.min_x, other.x),\nmin_y=op(self.min_y, other.y),\n)\nif isinstance(other, (Offset, Decimal, int, float)):\nreturn BoundingBox(\nmax_x=op(self.max_x, other),\nmax_y=op(self.max_y, other),\nmin_x=op(self.min_x, -other),\nmin_y=op(self.min_y, -other),\n)\nreturn NotImplemented  # type: ignore[unreachable]\ndef __add__(self, other: object) -&gt; BoundingBox:\nif isinstance(other, BoundingBox):\nreturn BoundingBox(\nmax_x=max(self.max_x, other.max_x),\nmax_y=max(self.max_y, other.max_y),\nmin_x=min(self.min_x, other.min_x),\nmin_y=min(self.min_y, other.min_y),\n)\nreturn self._operator(other, operator.add)\ndef __sub__(self, other: object) -&gt; BoundingBox:\nreturn self._operator(other, operator.sub)\ndef __mul__(self, other: object) -&gt; BoundingBox:\nreturn self._operator(other, operator.mul)\ndef __truediv__(self, other: object) -&gt; BoundingBox:\nreturn self._operator(other, operator.truediv)\ndef __str__(self) -&gt; str:\nreturn (\nf\"{self.__class__.__qualname__}(max_x={self.max_x}, max_y={self.max_y}, \"\nf\"min_x={self.min_x}, min_y={self.min_y})\"\n)\ndef include_point(self, point: Vector2D) -&gt; BoundingBox:\n\"\"\"Include point in bounding box by extending bounding box overt the point.\"\"\"\n# Check for the x-coordinate\nnew_max_x = max(self.max_x, point.x)\nnew_min_x = min(self.min_x, point.x)\n# Check for the y-coordinate\nnew_max_y = max(self.max_y, point.y)\nnew_min_y = min(self.min_y, point.y)\nreturn BoundingBox(\nmax_x=new_max_x,\nmax_y=new_max_y,\nmin_x=new_min_x,\nmin_y=new_min_y,\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/math/bounding_box.html#pygerber.gerberx3.math.bounding_box.BoundingBox.width","title":"width  <code>property</code>","text":"<pre><code>width: Offset\n</code></pre> <p>Return width of the bounding box.</p>"},{"location":"reference/pygerber/gerberx3/math/bounding_box.html#pygerber.gerberx3.math.bounding_box.BoundingBox.height","title":"height  <code>property</code>","text":"<pre><code>height: Offset\n</code></pre> <p>Return height of the bounding box.</p>"},{"location":"reference/pygerber/gerberx3/math/bounding_box.html#pygerber.gerberx3.math.bounding_box.BoundingBox.center","title":"center  <code>property</code>","text":"<pre><code>center: Vector2D\n</code></pre> <p>Return current center of the bounding box.</p>"},{"location":"reference/pygerber/gerberx3/math/bounding_box.html#pygerber.gerberx3.math.bounding_box.BoundingBox.from_diameter","title":"from_diameter  <code>classmethod</code>","text":"<pre><code>from_diameter(diameter: Offset) -&gt; BoundingBox\n</code></pre> <p>Create a bounding box from a given diameter.</p> Source code in <code>src/pygerber/gerberx3/math/bounding_box.py</code> <pre><code>@classmethod\ndef from_diameter(cls, diameter: Offset) -&gt; BoundingBox:\n\"\"\"Create a bounding box from a given diameter.\"\"\"\nhalf_diameter = diameter / 2\nreturn cls(\nmax_x=half_diameter,\nmax_y=half_diameter,\nmin_x=-half_diameter,\nmin_y=-half_diameter,\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/math/bounding_box.html#pygerber.gerberx3.math.bounding_box.BoundingBox.from_rectangle","title":"from_rectangle  <code>classmethod</code>","text":"<pre><code>from_rectangle(\nx_size: Offset, y_size: Offset\n) -&gt; BoundingBox\n</code></pre> <p>Create a bounding box from a given diameter.</p> Source code in <code>src/pygerber/gerberx3/math/bounding_box.py</code> <pre><code>@classmethod\ndef from_rectangle(cls, x_size: Offset, y_size: Offset) -&gt; BoundingBox:\n\"\"\"Create a bounding box from a given diameter.\"\"\"\nhalf_x = x_size / 2\nhalf_y = y_size / 2\nreturn cls(\nmax_x=half_x,\nmax_y=half_y,\nmin_x=-half_x,\nmin_y=-half_y,\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/math/bounding_box.html#pygerber.gerberx3.math.bounding_box.BoundingBox.get_size","title":"get_size","text":"<pre><code>get_size() -&gt; Vector2D\n</code></pre> <p>Get bounding box size.</p> Source code in <code>src/pygerber/gerberx3/math/bounding_box.py</code> <pre><code>def get_size(self) -&gt; Vector2D:\n\"\"\"Get bounding box size.\"\"\"\nreturn Vector2D(x=self.width, y=self.height)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/math/bounding_box.html#pygerber.gerberx3.math.bounding_box.BoundingBox.get_min_vector","title":"get_min_vector","text":"<pre><code>get_min_vector() -&gt; Vector2D\n</code></pre> <p>Return Vector2D of min_x and min_y.</p> Source code in <code>src/pygerber/gerberx3/math/bounding_box.py</code> <pre><code>def get_min_vector(self) -&gt; Vector2D:\n\"\"\"Return Vector2D of min_x and min_y.\"\"\"\nreturn Vector2D(x=self.min_x, y=self.min_y)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/math/bounding_box.html#pygerber.gerberx3.math.bounding_box.BoundingBox.as_pixel_box","title":"as_pixel_box","text":"<pre><code>as_pixel_box(\ndpi: int,\n*,\ndx_max: int = 0,\ndy_max: int = 0,\ndx_min: int = 0,\ndy_min: int = 0\n) -&gt; PixelBox\n</code></pre> <p>Return box as tuple of ints with order.</p> <p>[x0, y0, x1, y1], where x1 &gt;= x0 and y1 &gt;= y0</p> Source code in <code>src/pygerber/gerberx3/math/bounding_box.py</code> <pre><code>def as_pixel_box(  # noqa: PLR0913\nself,\ndpi: int,\n*,\ndx_max: int = 0,\ndy_max: int = 0,\ndx_min: int = 0,\ndy_min: int = 0,\n) -&gt; PixelBox:\n\"\"\"Return box as tuple of ints with order.\n    [x0, y0, x1, y1], where x1 &gt;= x0 and y1 &gt;= y0\n    \"\"\"\nreturn PixelBox(\n(\nself.min_x.as_pixels(dpi) + dx_min,\nself.min_y.as_pixels(dpi) + dy_min,\nself.max_x.as_pixels(dpi) + dx_max,\nself.max_y.as_pixels(dpi) + dy_max,\n),\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/math/bounding_box.html#pygerber.gerberx3.math.bounding_box.BoundingBox.scale","title":"scale","text":"<pre><code>scale(by: Decimal) -&gt; BoundingBox\n</code></pre> <p>Return scaled bounding box.</p> Source code in <code>src/pygerber/gerberx3/math/bounding_box.py</code> <pre><code>def scale(self, by: Decimal) -&gt; BoundingBox:\n\"\"\"Return scaled bounding box.\"\"\"\ndx_dy = (self.get_size() * by) / 2\nreturn BoundingBox(\nmax_x=self.max_x + dx_dy.x,\nmax_y=self.max_y + dx_dy.y,\nmin_x=self.min_x - dx_dy.x,\nmin_y=self.min_y - dx_dy.y,\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/math/bounding_box.html#pygerber.gerberx3.math.bounding_box.BoundingBox.include_point","title":"include_point","text":"<pre><code>include_point(point: Vector2D) -&gt; BoundingBox\n</code></pre> <p>Include point in bounding box by extending bounding box overt the point.</p> Source code in <code>src/pygerber/gerberx3/math/bounding_box.py</code> <pre><code>def include_point(self, point: Vector2D) -&gt; BoundingBox:\n\"\"\"Include point in bounding box by extending bounding box overt the point.\"\"\"\n# Check for the x-coordinate\nnew_max_x = max(self.max_x, point.x)\nnew_min_x = min(self.min_x, point.x)\n# Check for the y-coordinate\nnew_max_y = max(self.max_y, point.y)\nnew_min_y = min(self.min_y, point.y)\nreturn BoundingBox(\nmax_x=new_max_x,\nmax_y=new_max_y,\nmin_x=new_min_x,\nmin_y=new_min_y,\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/math/bounding_box.html#pygerber.gerberx3.math.bounding_box.PixelBox","title":"PixelBox","text":"<p>             Bases: <code>Tuple[int, int, int, int]</code></p> <p>Custom class for representing pixel boxes.</p> Source code in <code>src/pygerber/gerberx3/math/bounding_box.py</code> <pre><code>class PixelBox(Tuple[int, int, int, int]):\n\"\"\"Custom class for representing pixel boxes.\"\"\"\n__slots__ = ()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/math/offset.html","title":"offset","text":""},{"location":"reference/pygerber/gerberx3/math/offset.html#pygerber.gerberx3.math.offset","title":"offset","text":"<p>Offset representation used by drawing backend.</p>"},{"location":"reference/pygerber/gerberx3/math/offset.html#pygerber.gerberx3.math.offset.INCH_TO_MM_MULTIPLIER","title":"INCH_TO_MM_MULTIPLIER  <code>module-attribute</code>","text":"<pre><code>INCH_TO_MM_MULTIPLIER = Decimal('25.4')\n</code></pre>"},{"location":"reference/pygerber/gerberx3/math/offset.html#pygerber.gerberx3.math.offset.MM_TO_INCH_MULTIPLIER","title":"MM_TO_INCH_MULTIPLIER  <code>module-attribute</code>","text":"<pre><code>MM_TO_INCH_MULTIPLIER = Decimal(\"1\") / INCH_TO_MM_MULTIPLIER\n</code></pre>"},{"location":"reference/pygerber/gerberx3/math/offset.html#pygerber.gerberx3.math.offset.Offset","title":"Offset","text":"<p>             Bases: <code>FrozenGeneralModel</code></p> <p>Class representing offset in 2D space.</p> Source code in <code>src/pygerber/gerberx3/math/offset.py</code> <pre><code>class Offset(FrozenGeneralModel):\n\"\"\"Class representing offset in 2D space.\"\"\"\nNULL: ClassVar[Offset]\nvalue: Decimal\n@classmethod\ndef new(\ncls,\nvalue: Decimal | float | str | tuple[int, Sequence[int], int],\nunit: Unit = Unit.Millimeters,\n) -&gt; Self:\n\"\"\"Initialize offset with value.\"\"\"\n# Gerber spec recommends using millimeters as unit, so they are used here too.\nif unit == Unit.Millimeters:\nvalue = Decimal(value)\nelse:\nvalue = Decimal(value) * INCH_TO_MM_MULTIPLIER\nreturn cls(value=value)\n@classmethod\ndef from_pixels(\ncls,\nvalue: Decimal | float | str | tuple[int, Sequence[int], int],\ndpi: int,\n) -&gt; Self:\n\"\"\"Initialize offset with value.\"\"\"\n# Gerber spec recommends using millimeters as unit, so they are used here too.\nvalue = (Decimal(value) / dpi) * INCH_TO_MM_MULTIPLIER\nreturn cls(value=value)\ndef as_millimeters(self) -&gt; Decimal:\n\"\"\"Offset in millimeters.\"\"\"\nreturn self.value\ndef as_inches(self) -&gt; Decimal:\n\"\"\"Offset in millimeters.\"\"\"\nreturn self.value * MM_TO_INCH_MULTIPLIER\ndef as_pixels(self, dpi: int | Decimal) -&gt; int:\n\"\"\"Offset in pixels with respect to drawing DPI.\"\"\"\nreturn int(self.as_inches() * dpi)\ndef _compare(\nself,\nother: object,\nop: Callable,\n) -&gt; bool:\nif isinstance(other, Offset):\nreturn op(self.value, other.value)  # type: ignore[no-any-return]\nif isinstance(other, (Decimal, int, float, str)):\nreturn op(self.value, Decimal(other))  # type: ignore[no-any-return]\nreturn NotImplemented  # type: ignore[unreachable]\ndef __eq__(self, other: object) -&gt; bool:\nreturn self._compare(other, operator.eq)\ndef __lt__(self, other: object) -&gt; bool:\nreturn self._compare(other, operator.lt)\ndef __le__(self, other: object) -&gt; bool:\nreturn self._compare(other, operator.le)\ndef __gt__(self, other: object) -&gt; bool:\nreturn self._compare(other, operator.gt)\ndef __ge__(self, other: object) -&gt; bool:\nreturn self._compare(other, operator.ge)\ndef _operator(\nself,\nother: object,\nop: Callable,\n) -&gt; Offset:\nif isinstance(other, Offset):\nreturn Offset(value=op(self.value, other.value))\nif isinstance(other, (Decimal, int, float, str)):\nreturn Offset(value=op(self.value, Decimal(other)))\nreturn NotImplemented  # type: ignore[unreachable]\ndef __add__(self, other: object) -&gt; Offset:\nreturn self._operator(other, operator.add)\ndef __sub__(self, other: object) -&gt; Offset:\nreturn self._operator(other, operator.sub)\ndef __mul__(self, other: object) -&gt; Offset:\nreturn self._operator(other, operator.mul)\ndef __truediv__(self, other: object) -&gt; Offset:\nreturn self._operator(other, operator.truediv)\ndef __neg__(self) -&gt; Offset:\nreturn Offset(value=-self.value)\ndef _i_operator(\nself,\nother: object,\nop: Callable,\n) -&gt; Offset:\nif isinstance(other, Offset):\nreturn self.model_copy(\nupdate={\n\"value\": op(self.value, other.value),\n},\n)\nif isinstance(other, (Decimal, int, float, str)):\nreturn self.model_copy(\nupdate={\n\"value\": op(self.value, Decimal(other)),\n},\n)\nreturn NotImplemented  # type: ignore[unreachable]\ndef __iadd__(self, other: object) -&gt; Offset:\nreturn self._i_operator(other, operator.add)\ndef __isub__(self, other: object) -&gt; Offset:\nreturn self._i_operator(other, operator.sub)\ndef __imul__(self, other: object) -&gt; Offset:\nreturn self._i_operator(other, operator.mul)\ndef __itruediv__(self, other: object) -&gt; Offset:\nreturn self._i_operator(other, operator.truediv)\ndef __str__(self) -&gt; str:\nreturn f\"Offset({float(self.value)})\"\n__repr__ = __str__\n</code></pre>"},{"location":"reference/pygerber/gerberx3/math/offset.html#pygerber.gerberx3.math.offset.Offset.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(\nvalue: Decimal\n| float\n| str\n| tuple[int, Sequence[int], int],\nunit: Unit = Unit.Millimeters,\n) -&gt; Self\n</code></pre> <p>Initialize offset with value.</p> Source code in <code>src/pygerber/gerberx3/math/offset.py</code> <pre><code>@classmethod\ndef new(\ncls,\nvalue: Decimal | float | str | tuple[int, Sequence[int], int],\nunit: Unit = Unit.Millimeters,\n) -&gt; Self:\n\"\"\"Initialize offset with value.\"\"\"\n# Gerber spec recommends using millimeters as unit, so they are used here too.\nif unit == Unit.Millimeters:\nvalue = Decimal(value)\nelse:\nvalue = Decimal(value) * INCH_TO_MM_MULTIPLIER\nreturn cls(value=value)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/math/offset.html#pygerber.gerberx3.math.offset.Offset.from_pixels","title":"from_pixels  <code>classmethod</code>","text":"<pre><code>from_pixels(\nvalue: Decimal\n| float\n| str\n| tuple[int, Sequence[int], int],\ndpi: int,\n) -&gt; Self\n</code></pre> <p>Initialize offset with value.</p> Source code in <code>src/pygerber/gerberx3/math/offset.py</code> <pre><code>@classmethod\ndef from_pixels(\ncls,\nvalue: Decimal | float | str | tuple[int, Sequence[int], int],\ndpi: int,\n) -&gt; Self:\n\"\"\"Initialize offset with value.\"\"\"\n# Gerber spec recommends using millimeters as unit, so they are used here too.\nvalue = (Decimal(value) / dpi) * INCH_TO_MM_MULTIPLIER\nreturn cls(value=value)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/math/offset.html#pygerber.gerberx3.math.offset.Offset.as_millimeters","title":"as_millimeters","text":"<pre><code>as_millimeters() -&gt; Decimal\n</code></pre> <p>Offset in millimeters.</p> Source code in <code>src/pygerber/gerberx3/math/offset.py</code> <pre><code>def as_millimeters(self) -&gt; Decimal:\n\"\"\"Offset in millimeters.\"\"\"\nreturn self.value\n</code></pre>"},{"location":"reference/pygerber/gerberx3/math/offset.html#pygerber.gerberx3.math.offset.Offset.as_inches","title":"as_inches","text":"<pre><code>as_inches() -&gt; Decimal\n</code></pre> <p>Offset in millimeters.</p> Source code in <code>src/pygerber/gerberx3/math/offset.py</code> <pre><code>def as_inches(self) -&gt; Decimal:\n\"\"\"Offset in millimeters.\"\"\"\nreturn self.value * MM_TO_INCH_MULTIPLIER\n</code></pre>"},{"location":"reference/pygerber/gerberx3/math/offset.html#pygerber.gerberx3.math.offset.Offset.as_pixels","title":"as_pixels","text":"<pre><code>as_pixels(dpi: int | Decimal) -&gt; int\n</code></pre> <p>Offset in pixels with respect to drawing DPI.</p> Source code in <code>src/pygerber/gerberx3/math/offset.py</code> <pre><code>def as_pixels(self, dpi: int | Decimal) -&gt; int:\n\"\"\"Offset in pixels with respect to drawing DPI.\"\"\"\nreturn int(self.as_inches() * dpi)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/math/rotate_point.html","title":"rotate_point","text":""},{"location":"reference/pygerber/gerberx3/math/rotate_point.html#pygerber.gerberx3.math.rotate_point","title":"rotate_point","text":"<p>Tool for rotating point around center.</p>"},{"location":"reference/pygerber/gerberx3/math/rotate_point.html#pygerber.gerberx3.math.rotate_point.rotate_point","title":"rotate_point","text":"<pre><code>rotate_point(\ncenter: Vector2D,\nangle: Decimal | float,\npoint: Vector2D,\n) -&gt; Vector2D\n</code></pre> <p>Rotate point around center by given angle.</p> Source code in <code>src/pygerber/gerberx3/math/rotate_point.py</code> <pre><code>def rotate_point(center: Vector2D, angle: Decimal | float, point: Vector2D) -&gt; Vector2D:\n\"\"\"Rotate point around center by given angle.\"\"\"\ns = sin(angle)\nc = cos(angle)\n# Translate point back to origin\nx, y = point.x, point.y\nx -= center.x\ny -= center.y\n# Rotate point\nx_new = x * c - y * s\ny_new = x * s + y * c\n# Translate point back\nx = x_new + center.x\ny = y_new + center.y\nreturn Vector2D(x=x, y=y)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/math/vector_2d.html","title":"vector_2d","text":""},{"location":"reference/pygerber/gerberx3/math/vector_2d.html#pygerber.gerberx3.math.vector_2d","title":"vector_2d","text":"<p>Simple of 2D vector container class.</p>"},{"location":"reference/pygerber/gerberx3/math/vector_2d.html#pygerber.gerberx3.math.vector_2d.Vector2D","title":"Vector2D","text":"<p>             Bases: <code>FrozenGeneralModel</code></p> <p>Tuple wrapper for representing size with custom accessors.</p> Source code in <code>src/pygerber/gerberx3/math/vector_2d.py</code> <pre><code>class Vector2D(FrozenGeneralModel):\n\"\"\"Tuple wrapper for representing size with custom accessors.\"\"\"\nNULL: ClassVar[Vector2D]\nUNIT_X: ClassVar[Vector2D]\nUNIT_Y: ClassVar[Vector2D]\nx: Offset\ny: Offset\ndef as_pixels(self, dpi: int) -&gt; tuple[int, int]:\n\"\"\"Return size as pixels using given DPI for conversion.\"\"\"\nreturn (self.x.as_pixels(dpi), self.y.as_pixels(dpi))\ndef __eq__(self, other: object) -&gt; bool:\nif isinstance(other, Vector2D):\nreturn self.x == other.x and self.y == other.y\nreturn NotImplemented\ndef _operator(\nself,\nother: object,\nop: Callable,\n) -&gt; Vector2D:\nif isinstance(other, Offset):\nreturn Vector2D(\nx=op(self.x, other),\ny=op(self.y, other),\n)\nif isinstance(other, Vector2D):\nreturn Vector2D(\nx=op(self.x, other.x),\ny=op(self.y, other.y),\n)\nif isinstance(other, (Decimal, int, float, str)):\nreturn Vector2D(\nx=op(self.x, Decimal(other)),\ny=op(self.y, Decimal(other)),\n)\nreturn NotImplemented  # type: ignore[unreachable]\ndef __add__(self, other: object) -&gt; Vector2D:\nreturn self._operator(other, operator.add)\ndef __sub__(self, other: object) -&gt; Vector2D:\nreturn self._operator(other, operator.sub)\ndef __mul__(self, other: object) -&gt; Vector2D:\nreturn self._operator(other, operator.mul)\ndef __truediv__(self, other: object) -&gt; Vector2D:\nreturn self._operator(other, operator.truediv)\ndef __neg__(self) -&gt; Vector2D:\nreturn Vector2D(x=-self.x, y=-self.y)\ndef _i_operator(\nself,\nother: object,\nop: Callable,\n) -&gt; Vector2D:\nif isinstance(other, Vector2D):\nreturn self.model_copy(\nupdate={\n\"x\": op(self.x, other.x),\n\"y\": op(self.y, other.y),\n},\n)\nif isinstance(other, Offset):\nreturn self.model_copy(\nupdate={\n\"x\": op(self.x, other),\n\"y\": op(self.y, other),\n},\n)\nif isinstance(other, (Decimal, int, float, str)):\nreturn self.model_copy(\nupdate={\n\"x\": op(self.x, Decimal(other)),\n\"y\": op(self.y, Decimal(other)),\n},\n)\nreturn NotImplemented  # type: ignore[unreachable]\ndef __iadd__(self, other: object) -&gt; Vector2D:\nreturn self._i_operator(other, operator.add)\ndef __isub__(self, other: object) -&gt; Vector2D:\nreturn self._i_operator(other, operator.sub)\ndef __imul__(self, other: object) -&gt; Vector2D:\nreturn self._i_operator(other, operator.mul)\ndef __itruediv__(self, other: object) -&gt; Vector2D:\nreturn self._i_operator(other, operator.truediv)\ndef __str__(self) -&gt; str:\nreturn f\"{self.__class__.__qualname__}(x={self.x}, y={self.y})\"\ndef length(self) -&gt; Offset:\n\"\"\"Return length of vector.\"\"\"\nreturn Offset(value=((self.x * self.x).value + (self.y * self.y).value).sqrt())\ndef angle_between_clockwise(self, other: Vector2D) -&gt; float:\n\"\"\"Calculate angle between two vectors in degrees clockwise.\"\"\"\nself_norm = self / self.length()\nother_norm = other / other.length()\ndot = other_norm.dot(self_norm)\ndeterminant = self_norm.determinant(other_norm)\ntheta = math.atan2(float(dot.value), float(determinant.value))\nreturn math.degrees(theta)\ndef dot(self, other: Vector2D) -&gt; Offset:\n\"\"\"Calculate dot product of two vectors.\"\"\"\nreturn self.x * other.x + self.y * other.y\ndef determinant(self, other: Vector2D) -&gt; Offset:\n\"\"\"Calculate determinant of matrix constructed from self and other.\"\"\"\nreturn self.x * other.y - self.y * other.x\n</code></pre>"},{"location":"reference/pygerber/gerberx3/math/vector_2d.html#pygerber.gerberx3.math.vector_2d.Vector2D.as_pixels","title":"as_pixels","text":"<pre><code>as_pixels(dpi: int) -&gt; tuple[int, int]\n</code></pre> <p>Return size as pixels using given DPI for conversion.</p> Source code in <code>src/pygerber/gerberx3/math/vector_2d.py</code> <pre><code>def as_pixels(self, dpi: int) -&gt; tuple[int, int]:\n\"\"\"Return size as pixels using given DPI for conversion.\"\"\"\nreturn (self.x.as_pixels(dpi), self.y.as_pixels(dpi))\n</code></pre>"},{"location":"reference/pygerber/gerberx3/math/vector_2d.html#pygerber.gerberx3.math.vector_2d.Vector2D.length","title":"length","text":"<pre><code>length() -&gt; Offset\n</code></pre> <p>Return length of vector.</p> Source code in <code>src/pygerber/gerberx3/math/vector_2d.py</code> <pre><code>def length(self) -&gt; Offset:\n\"\"\"Return length of vector.\"\"\"\nreturn Offset(value=((self.x * self.x).value + (self.y * self.y).value).sqrt())\n</code></pre>"},{"location":"reference/pygerber/gerberx3/math/vector_2d.html#pygerber.gerberx3.math.vector_2d.Vector2D.angle_between_clockwise","title":"angle_between_clockwise","text":"<pre><code>angle_between_clockwise(other: Vector2D) -&gt; float\n</code></pre> <p>Calculate angle between two vectors in degrees clockwise.</p> Source code in <code>src/pygerber/gerberx3/math/vector_2d.py</code> <pre><code>def angle_between_clockwise(self, other: Vector2D) -&gt; float:\n\"\"\"Calculate angle between two vectors in degrees clockwise.\"\"\"\nself_norm = self / self.length()\nother_norm = other / other.length()\ndot = other_norm.dot(self_norm)\ndeterminant = self_norm.determinant(other_norm)\ntheta = math.atan2(float(dot.value), float(determinant.value))\nreturn math.degrees(theta)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/math/vector_2d.html#pygerber.gerberx3.math.vector_2d.Vector2D.dot","title":"dot","text":"<pre><code>dot(other: Vector2D) -&gt; Offset\n</code></pre> <p>Calculate dot product of two vectors.</p> Source code in <code>src/pygerber/gerberx3/math/vector_2d.py</code> <pre><code>def dot(self, other: Vector2D) -&gt; Offset:\n\"\"\"Calculate dot product of two vectors.\"\"\"\nreturn self.x * other.x + self.y * other.y\n</code></pre>"},{"location":"reference/pygerber/gerberx3/math/vector_2d.html#pygerber.gerberx3.math.vector_2d.Vector2D.determinant","title":"determinant","text":"<pre><code>determinant(other: Vector2D) -&gt; Offset\n</code></pre> <p>Calculate determinant of matrix constructed from self and other.</p> Source code in <code>src/pygerber/gerberx3/math/vector_2d.py</code> <pre><code>def determinant(self, other: Vector2D) -&gt; Offset:\n\"\"\"Calculate determinant of matrix constructed from self and other.\"\"\"\nreturn self.x * other.y - self.y * other.x\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser/__init__.html","title":"init","text":""},{"location":"reference/pygerber/gerberx3/parser/__init__.html#pygerber.gerberx3.parser","title":"parser","text":"<p>Gerber X3 parer.</p>"},{"location":"reference/pygerber/gerberx3/parser/errors.html","title":"errors","text":""},{"location":"reference/pygerber/gerberx3/parser/errors.html#pygerber.gerberx3.parser.errors","title":"errors","text":"<p>Base error classes used in this module.</p>"},{"location":"reference/pygerber/gerberx3/parser/errors.html#pygerber.gerberx3.parser.errors.ParserError","title":"ParserError","text":"<p>             Bases: <code>ValueError</code></p> <p>Base class for parser errors.</p> <p>Exceptions derived from this exception are exclusively raised in PyGerber's Gerber X3 Parser. This exception can be used in <code>try: ... except ParserError: ...</code> block to catch all exceptions raised by Parser while allowing other exceptions to interrupt execution.</p> Source code in <code>src/pygerber/gerberx3/parser/errors.py</code> <pre><code>class ParserError(ValueError):\n\"\"\"Base class for parser errors.\n    Exceptions derived from this exception are exclusively raised in PyGerber's Gerber\n    X3 Parser. This exception can be used in\n    `#!python try: ... except ParserError: ...` block to catch all exceptions\n    raised by Parser while allowing other exceptions to interrupt execution.\n    \"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser/errors.html#pygerber.gerberx3.parser.errors.ZeroOmissionNotSupportedError","title":"ZeroOmissionNotSupportedError","text":"<p>             Bases: <code>ParserError</code></p> <p>Raised when incremental coordinates are selected. (Spec. 8.2.1.2).</p> Source code in <code>src/pygerber/gerberx3/parser/errors.py</code> <pre><code>class ZeroOmissionNotSupportedError(ParserError):\n\"\"\"Raised when incremental coordinates are selected. (Spec. 8.2.1.2).\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser/errors.html#pygerber.gerberx3.parser.errors.IncrementalCoordinatesNotSupportedError","title":"IncrementalCoordinatesNotSupportedError","text":"<p>             Bases: <code>ParserError</code></p> <p>Raised when incremental coordinates are selected. (Spec. 8.2.1.2).</p> Source code in <code>src/pygerber/gerberx3/parser/errors.py</code> <pre><code>class IncrementalCoordinatesNotSupportedError(ParserError):\n\"\"\"Raised when incremental coordinates are selected. (Spec. 8.2.1.2).\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser/errors.html#pygerber.gerberx3.parser.errors.UnsupportedCoordinateTypeError","title":"UnsupportedCoordinateTypeError","text":"<p>             Bases: <code>ParserError</code></p> <p>Raised for unsupported coordinate types.</p> Source code in <code>src/pygerber/gerberx3/parser/errors.py</code> <pre><code>class UnsupportedCoordinateTypeError(ParserError):\n\"\"\"Raised for unsupported coordinate types.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser/errors.html#pygerber.gerberx3.parser.errors.InvalidCoordinateLengthError","title":"InvalidCoordinateLengthError","text":"<p>             Bases: <code>ParserError</code></p> <p>Raised when coordinate string is too long.</p> Source code in <code>src/pygerber/gerberx3/parser/errors.py</code> <pre><code>class InvalidCoordinateLengthError(ParserError):\n\"\"\"Raised when coordinate string is too long.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser/errors.html#pygerber.gerberx3.parser.errors.ParserFatalError","title":"ParserFatalError","text":"<p>             Bases: <code>ParserError</code></p> <p>Raised when parser encounters fatal failure from non-parser specific exception.</p> Source code in <code>src/pygerber/gerberx3/parser/errors.py</code> <pre><code>class ParserFatalError(ParserError):\n\"\"\"Raised when parser encounters fatal failure from non-parser specific\n    exception.\n    \"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser/errors.html#pygerber.gerberx3.parser.errors.OnUpdateDrawingStateError","title":"OnUpdateDrawingStateError","text":"<p>             Bases: <code>ParserError</code></p> <p>Raised when parser encounters fatal failure from non-parser specific exception during call to .update_drawing_state() call.</p> Source code in <code>src/pygerber/gerberx3/parser/errors.py</code> <pre><code>class OnUpdateDrawingStateError(ParserError):\n\"\"\"Raised when parser encounters fatal failure from non-parser specific\n    exception during call to .update_drawing_state() call.\n    \"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser/errors.html#pygerber.gerberx3.parser.errors.UnitNotSetError","title":"UnitNotSetError","text":"<p>             Bases: <code>ParserError</code></p> <p>Raised when operation which requires units to be set is executed before units are set.</p> Source code in <code>src/pygerber/gerberx3/parser/errors.py</code> <pre><code>class UnitNotSetError(ParserError):\n\"\"\"Raised when operation which requires units to be set is executed before units\n    are set.\n    \"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser/errors.html#pygerber.gerberx3.parser.errors.ApertureNotDefinedError","title":"ApertureNotDefinedError","text":"<p>             Bases: <code>ParserError</code></p> <p>Raised when undefined aperture is selected.</p> Source code in <code>src/pygerber/gerberx3/parser/errors.py</code> <pre><code>class ApertureNotDefinedError(ParserError):\n\"\"\"Raised when undefined aperture is selected.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser/errors.html#pygerber.gerberx3.parser.errors.CoordinateFormatNotSetError","title":"CoordinateFormatNotSetError","text":"<p>             Bases: <code>ParserError</code></p> <p>Raised when coordinate parser is requested before coordinate format was set.</p> Source code in <code>src/pygerber/gerberx3/parser/errors.py</code> <pre><code>class CoordinateFormatNotSetError(ParserError):\n\"\"\"Raised when coordinate parser is requested before coordinate format was set.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser/errors.html#pygerber.gerberx3.parser.errors.ApertureNotSelectedError","title":"ApertureNotSelectedError","text":"<p>             Bases: <code>ParserError</code></p> <p>Raised when attempting to use aperture without selecting it first.</p> Source code in <code>src/pygerber/gerberx3/parser/errors.py</code> <pre><code>class ApertureNotSelectedError(ParserError):\n\"\"\"Raised when attempting to use aperture without selecting it first.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser/errors.html#pygerber.gerberx3.parser.errors.ExitParsingProcessInterrupt","title":"ExitParsingProcessInterrupt","text":"<p>             Bases: <code>Exception</code></p> <p>Raised to stop parsing.</p> Source code in <code>src/pygerber/gerberx3/parser/errors.py</code> <pre><code>class ExitParsingProcessInterrupt(Exception):  # noqa: N818\n\"\"\"Raised to stop parsing.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser/parser.html","title":"parser","text":""},{"location":"reference/pygerber/gerberx3/parser/parser.html#pygerber.gerberx3.parser.parser","title":"parser","text":"<p>GerberX3 format parser.</p>"},{"location":"reference/pygerber/gerberx3/parser/parser.html#pygerber.gerberx3.parser.parser.Parser","title":"Parser","text":"<p>Gerber X3 parser object.</p> Source code in <code>src/pygerber/gerberx3/parser/parser.py</code> <pre><code>class Parser:\n\"\"\"Gerber X3 parser object.\"\"\"\ndef __init__(\nself,\noptions: Optional[ParserOptions] = None,\n) -&gt; None:\n\"\"\"Initialize parser.\n        Parameters\n        ----------\n        options : ParserOptions | None\n            Additional options for modifying parser behavior.\n        \"\"\"\nself.options = ParserOptions() if options is None else options\n@property\ndef backend(self) -&gt; Backend:\n\"\"\"Get reference to backend object.\"\"\"\nreturn self.options.backend\ndef parse(self, tokens: TokenStack) -&gt; DrawCommandsHandle:\n\"\"\"Parse token stack.\"\"\"\nfor _ in self.parse_iter(tokens):\npass\nreturn self.get_draw_commands_handle()\ndef parse_iter(self, tokens: TokenStack) -&gt; Generator[Token, None, None]:\n\"\"\"Iterate over tokens in stack and parse them.\"\"\"\nself.state = (\nState()\nif self.options.initial_state is None\nelse self.options.initial_state\n)\nself.draw_actions: list[DrawCommand] = []\nfor token in tokens:\nself._update_drawing_state(token)\nyield token\ndef get_draw_commands_handle(self) -&gt; DrawCommandsHandle:\n\"\"\"Return handle to drawing commands.\"\"\"\nreturn self.backend.get_draw_commands_handle_cls()(\nself.draw_actions,\nself.backend,\n)\ndef _update_drawing_state(self, token: Token) -&gt; None:\ntry:\nself.state, actions = token.update_drawing_state(self.state, self.backend)\nif actions is not None:\nself.draw_actions.extend(actions)\nexcept ExitParsingProcessInterrupt:\nreturn\nexcept Exception as e:  # noqa: BLE001\nif self.options.on_update_drawing_state_error == ParserOnErrorAction.Ignore:\npass\nelif (\nself.options.on_update_drawing_state_error == ParserOnErrorAction.Raise\n):\nif not isinstance(e, ParserError):\nraise OnUpdateDrawingStateError(token) from e\nraise\nelif self.options.on_update_drawing_state_error == ParserOnErrorAction.Warn:\nlogging.warning(\n\"Encountered fatal error during call to update_drawing_state() \"\n\"of '%s' token. Parser will skip this token and continue.\",\ntoken,\n)\nelse:\nself.options.on_update_drawing_state_error(e, self, token)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser/parser.html#pygerber.gerberx3.parser.parser.Parser.backend","title":"backend  <code>property</code>","text":"<pre><code>backend: Backend\n</code></pre> <p>Get reference to backend object.</p>"},{"location":"reference/pygerber/gerberx3/parser/parser.html#pygerber.gerberx3.parser.parser.Parser.__init__","title":"__init__","text":"<pre><code>__init__(options: Optional[ParserOptions] = None) -&gt; None\n</code></pre> <p>Initialize parser.</p> <p>Parameters:</p> Name Type Description Default <code>options</code> <code>ParserOptions | None</code> <p>Additional options for modifying parser behavior.</p> <code>None</code> Source code in <code>src/pygerber/gerberx3/parser/parser.py</code> <pre><code>def __init__(\nself,\noptions: Optional[ParserOptions] = None,\n) -&gt; None:\n\"\"\"Initialize parser.\n    Parameters\n    ----------\n    options : ParserOptions | None\n        Additional options for modifying parser behavior.\n    \"\"\"\nself.options = ParserOptions() if options is None else options\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser/parser.html#pygerber.gerberx3.parser.parser.Parser.parse","title":"parse","text":"<pre><code>parse(tokens: TokenStack) -&gt; DrawCommandsHandle\n</code></pre> <p>Parse token stack.</p> Source code in <code>src/pygerber/gerberx3/parser/parser.py</code> <pre><code>def parse(self, tokens: TokenStack) -&gt; DrawCommandsHandle:\n\"\"\"Parse token stack.\"\"\"\nfor _ in self.parse_iter(tokens):\npass\nreturn self.get_draw_commands_handle()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser/parser.html#pygerber.gerberx3.parser.parser.Parser.parse_iter","title":"parse_iter","text":"<pre><code>parse_iter(\ntokens: TokenStack,\n) -&gt; Generator[Token, None, None]\n</code></pre> <p>Iterate over tokens in stack and parse them.</p> Source code in <code>src/pygerber/gerberx3/parser/parser.py</code> <pre><code>def parse_iter(self, tokens: TokenStack) -&gt; Generator[Token, None, None]:\n\"\"\"Iterate over tokens in stack and parse them.\"\"\"\nself.state = (\nState()\nif self.options.initial_state is None\nelse self.options.initial_state\n)\nself.draw_actions: list[DrawCommand] = []\nfor token in tokens:\nself._update_drawing_state(token)\nyield token\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser/parser.html#pygerber.gerberx3.parser.parser.Parser.get_draw_commands_handle","title":"get_draw_commands_handle","text":"<pre><code>get_draw_commands_handle() -&gt; DrawCommandsHandle\n</code></pre> <p>Return handle to drawing commands.</p> Source code in <code>src/pygerber/gerberx3/parser/parser.py</code> <pre><code>def get_draw_commands_handle(self) -&gt; DrawCommandsHandle:\n\"\"\"Return handle to drawing commands.\"\"\"\nreturn self.backend.get_draw_commands_handle_cls()(\nself.draw_actions,\nself.backend,\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser/parser.html#pygerber.gerberx3.parser.parser.ParserOnErrorAction","title":"ParserOnErrorAction","text":"<p>             Bases: <code>Enum</code></p> <p>Possible error actions.</p> Source code in <code>src/pygerber/gerberx3/parser/parser.py</code> <pre><code>class ParserOnErrorAction(Enum):\n\"\"\"Possible error actions.\"\"\"\nIgnore = \"ignore\"\n\"\"\"Ignore parser errors. Errors which occurred will not be signaled. May yield\n    unexpected results for broken files, with missing draw commands or even more\n    significant errors.\"\"\"\nWarn = \"warn\"\n\"\"\"Warn on parser error. Parser will log warning message about what went wrong.\n    Best for supporting wide range of files without silently ignoring errors in code.\"\"\"\nRaise = \"raise\"\n\"\"\"Raise exception whenever parser encounters error. Will completely break out of\n    parsing process, making it impossible to render slightly malformed files.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser/parser.html#pygerber.gerberx3.parser.parser.ParserOnErrorAction.Ignore","title":"Ignore  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Ignore = 'ignore'\n</code></pre> <p>Ignore parser errors. Errors which occurred will not be signaled. May yield unexpected results for broken files, with missing draw commands or even more significant errors.</p>"},{"location":"reference/pygerber/gerberx3/parser/parser.html#pygerber.gerberx3.parser.parser.ParserOnErrorAction.Warn","title":"Warn  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Warn = 'warn'\n</code></pre> <p>Warn on parser error. Parser will log warning message about what went wrong. Best for supporting wide range of files without silently ignoring errors in code.</p>"},{"location":"reference/pygerber/gerberx3/parser/parser.html#pygerber.gerberx3.parser.parser.ParserOnErrorAction.Raise","title":"Raise  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Raise = 'raise'\n</code></pre> <p>Raise exception whenever parser encounters error. Will completely break out of parsing process, making it impossible to render slightly malformed files.</p>"},{"location":"reference/pygerber/gerberx3/parser/parser.html#pygerber.gerberx3.parser.parser.ParserOptions","title":"ParserOptions","text":"<p>Container class for Gerber parser options.</p> Source code in <code>src/pygerber/gerberx3/parser/parser.py</code> <pre><code>class ParserOptions:\n\"\"\"Container class for Gerber parser options.\"\"\"\ndef __init__(\nself,\nbackend: Backend | None = None,\ninitial_state: State | None = None,\non_update_drawing_state_error: Callable[[Exception, Parser, Token], None]\n| ParserOnErrorAction = ParserOnErrorAction.Raise,\n) -&gt; None:\n\"\"\"Initialize options.\"\"\"\nself.backend = Rasterized2DBackend() if backend is None else backend\nself.initial_state = initial_state\nself.on_update_drawing_state_error = on_update_drawing_state_error\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser/parser.html#pygerber.gerberx3.parser.parser.ParserOptions.__init__","title":"__init__","text":"<pre><code>__init__(\nbackend: Backend | None = None,\ninitial_state: State | None = None,\non_update_drawing_state_error: Callable[\n[Exception, Parser, Token], None\n]\n| ParserOnErrorAction = ParserOnErrorAction.Raise,\n) -&gt; None\n</code></pre> <p>Initialize options.</p> Source code in <code>src/pygerber/gerberx3/parser/parser.py</code> <pre><code>def __init__(\nself,\nbackend: Backend | None = None,\ninitial_state: State | None = None,\non_update_drawing_state_error: Callable[[Exception, Parser, Token], None]\n| ParserOnErrorAction = ParserOnErrorAction.Raise,\n) -&gt; None:\n\"\"\"Initialize options.\"\"\"\nself.backend = Rasterized2DBackend() if backend is None else backend\nself.initial_state = initial_state\nself.on_update_drawing_state_error = on_update_drawing_state_error\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser/state.html","title":"state","text":""},{"location":"reference/pygerber/gerberx3/parser/state.html#pygerber.gerberx3.parser.state","title":"state","text":"<p>Global drawing state containing configuration which can be altered by tokens.</p>"},{"location":"reference/pygerber/gerberx3/parser/state.html#pygerber.gerberx3.parser.state.State","title":"State","text":"<p>             Bases: <code>FrozenGeneralModel</code></p> <p>GerberX3 interpreter state.</p> Source code in <code>src/pygerber/gerberx3/parser/state.py</code> <pre><code>class State(FrozenGeneralModel):\n\"\"\"GerberX3 interpreter state.\"\"\"\ncurrent_position: Vector2D = Vector2D(x=Offset.NULL, y=Offset.NULL)\n# MO | Mode | Sets the unit to mm or inch                           | 4.2.1\ndraw_units: Optional[Unit] = None\n# FS | Format specification | Sets the coordinate format,           | 4.2.2\n#    |                      | e.g. the number of decimals\ncoordinate_parser: Optional[CoordinateParser] = None\n# Dnn | (nn\u226510) | Sets the current aperture to D code nn.           | 4.6\ncurrent_aperture: Optional[PublicApertureHandle] = None\n# G01 | | Sets linear/circular mode to linear.                      | 4.7.1\n# G02 | | Sets linear/circular mode to clockwise circular           | 4.7.2\n# G03 | | Sets linear/circular mode to counterclockwise circular    | 4.7.3\ndraw_mode: DrawMode = DrawMode.Linear\n# LP  | | Load polarity | Loads the polarity object transformation  | 4.9.2\n#                       parameter.\npolarity: Polarity = Polarity.Dark\n# LM  | | Load mirroring | Loads the mirror object transformation   | 4.9.3\n#                         parameter.\nmirroring: Mirroring = Mirroring.NoMirroring\n# LR  | Load rotation |  Loads the rotation object transformation   | 4.9.4\n#                       parameter.\nrotation: Decimal = Decimal(\"0.0\")\nregion_boundary_points: List[Vector2D] = Field(default_factory=list)\n\"\"\"Points defining the shape of the region.\"\"\"\n# LS  | Load scaling |   Loads the scale object transformation      | 4.9.5\n#                       parameter\nscaling: Decimal = Decimal(\"1.0\")\n# G36 | |   Starts a region statement which creates a region by     | 4.10\n#     | |   defining its contours.\n# G37 | |   Ends the region statement.                              | 4.10\nis_region: bool = False\n# AB  | |   Aperture blockOpens a block aperture statement and      | 4.11\n#     | |   assigns its aperture number or closes a block aperture  |\n#     | |   statement.                                              |\nis_aperture_block: bool = False\n# SR  | |   Step and repeatOpen or closes a step and repeat         | 4.11\n#     | |   statement.                                              |\nis_step_and_repeat: bool = False\n# TF  | |   Attribute on fileSet a file attribute.                  | 5.3\n# TD  | |   Attribute deleteDelete one or all attributes in the     | 5.5\n#     | |   dictionary.                                             |\nfile_attributes: Dict[str, str] = Field(default_factory=dict)\n# G75 | |   Sets multi quadrant mode\n# G74 | |   Sets single quadrant mode\nis_multi_quadrant: bool = False\nis_output_image_negation_required: bool = False\n\"\"\"In Gerber specification deprecated IP command is mentioned.\n    It can set image polarity to either positive, the usual one, or to negative.\n    Under negative image polarity, image generation is different. Its purpose is to\n    create a negative image, clear areas in a dark background. The entire image plane\n    in the background is initially dark instead of clear. The effect of dark and clear\n    polarity is toggled. The entire image is simply reversed, dark becomes white and\n    vice versa.\n    This effect can be achieved by simply inverting colors of output image.\n    \"\"\"\napertures: Dict[ApertureID, PublicApertureHandle] = Field(default_factory=dict)\n\"\"\"Collection of all apertures defined until given point in code.\"\"\"\nmacros: Dict[str, MacroDefinition] = Field(default_factory=dict)\n\"\"\"Collection of all macros defined until given point in code.\"\"\"\ndef get_units(self) -&gt; Unit:\n\"\"\"Get drawing unit or raise UnitNotSetError.\"\"\"\nif self.draw_units is None:\nraise UnitNotSetError\nreturn self.draw_units\ndef get_coordinate_parser(self) -&gt; CoordinateParser:\n\"\"\"Get coordinate parser or raise CoordinateFormatNotSetError.\"\"\"\nif self.coordinate_parser is None:\nraise CoordinateFormatNotSetError\nreturn self.coordinate_parser\ndef get_current_aperture(self) -&gt; PublicApertureHandle:\n\"\"\"Get current aperture or raise ApertureNotSelectedError.\"\"\"\nif self.current_aperture is None:\nraise ApertureNotSelectedError\nreturn self.current_aperture\ndef parse_coordinate(self, coordinate: Coordinate) -&gt; Offset:\n\"\"\"Parse, include substitution with current and conversion to Offset.\"\"\"\nif coordinate.coordinate_type == CoordinateType.MISSING_X:\nreturn self.current_position.x\nif coordinate.coordinate_type == CoordinateType.MISSING_Y:\nreturn self.current_position.y\nif coordinate.coordinate_type == CoordinateType.MISSING_I:\nreturn Offset.NULL\nif coordinate.coordinate_type == CoordinateType.MISSING_J:\nreturn Offset.NULL\nreturn Offset.new(\nself.get_coordinate_parser().parse(coordinate),\nunit=self.get_units(),\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser/state.html#pygerber.gerberx3.parser.state.State.region_boundary_points","title":"region_boundary_points  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>region_boundary_points: List[Vector2D] = Field(\ndefault_factory=list\n)\n</code></pre> <p>Points defining the shape of the region.</p>"},{"location":"reference/pygerber/gerberx3/parser/state.html#pygerber.gerberx3.parser.state.State.is_output_image_negation_required","title":"is_output_image_negation_required  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>is_output_image_negation_required: bool = False\n</code></pre> <p>In Gerber specification deprecated IP command is mentioned. It can set image polarity to either positive, the usual one, or to negative. Under negative image polarity, image generation is different. Its purpose is to create a negative image, clear areas in a dark background. The entire image plane in the background is initially dark instead of clear. The effect of dark and clear polarity is toggled. The entire image is simply reversed, dark becomes white and vice versa. This effect can be achieved by simply inverting colors of output image.</p>"},{"location":"reference/pygerber/gerberx3/parser/state.html#pygerber.gerberx3.parser.state.State.apertures","title":"apertures  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>apertures: Dict[ApertureID, PublicApertureHandle] = Field(\ndefault_factory=dict\n)\n</code></pre> <p>Collection of all apertures defined until given point in code.</p>"},{"location":"reference/pygerber/gerberx3/parser/state.html#pygerber.gerberx3.parser.state.State.macros","title":"macros  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>macros: Dict[str, MacroDefinition] = Field(\ndefault_factory=dict\n)\n</code></pre> <p>Collection of all macros defined until given point in code.</p>"},{"location":"reference/pygerber/gerberx3/parser/state.html#pygerber.gerberx3.parser.state.State.get_units","title":"get_units","text":"<pre><code>get_units() -&gt; Unit\n</code></pre> <p>Get drawing unit or raise UnitNotSetError.</p> Source code in <code>src/pygerber/gerberx3/parser/state.py</code> <pre><code>def get_units(self) -&gt; Unit:\n\"\"\"Get drawing unit or raise UnitNotSetError.\"\"\"\nif self.draw_units is None:\nraise UnitNotSetError\nreturn self.draw_units\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser/state.html#pygerber.gerberx3.parser.state.State.get_coordinate_parser","title":"get_coordinate_parser","text":"<pre><code>get_coordinate_parser() -&gt; CoordinateParser\n</code></pre> <p>Get coordinate parser or raise CoordinateFormatNotSetError.</p> Source code in <code>src/pygerber/gerberx3/parser/state.py</code> <pre><code>def get_coordinate_parser(self) -&gt; CoordinateParser:\n\"\"\"Get coordinate parser or raise CoordinateFormatNotSetError.\"\"\"\nif self.coordinate_parser is None:\nraise CoordinateFormatNotSetError\nreturn self.coordinate_parser\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser/state.html#pygerber.gerberx3.parser.state.State.get_current_aperture","title":"get_current_aperture","text":"<pre><code>get_current_aperture() -&gt; PublicApertureHandle\n</code></pre> <p>Get current aperture or raise ApertureNotSelectedError.</p> Source code in <code>src/pygerber/gerberx3/parser/state.py</code> <pre><code>def get_current_aperture(self) -&gt; PublicApertureHandle:\n\"\"\"Get current aperture or raise ApertureNotSelectedError.\"\"\"\nif self.current_aperture is None:\nraise ApertureNotSelectedError\nreturn self.current_aperture\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser/state.html#pygerber.gerberx3.parser.state.State.parse_coordinate","title":"parse_coordinate","text":"<pre><code>parse_coordinate(coordinate: Coordinate) -&gt; Offset\n</code></pre> <p>Parse, include substitution with current and conversion to Offset.</p> Source code in <code>src/pygerber/gerberx3/parser/state.py</code> <pre><code>def parse_coordinate(self, coordinate: Coordinate) -&gt; Offset:\n\"\"\"Parse, include substitution with current and conversion to Offset.\"\"\"\nif coordinate.coordinate_type == CoordinateType.MISSING_X:\nreturn self.current_position.x\nif coordinate.coordinate_type == CoordinateType.MISSING_Y:\nreturn self.current_position.y\nif coordinate.coordinate_type == CoordinateType.MISSING_I:\nreturn Offset.NULL\nif coordinate.coordinate_type == CoordinateType.MISSING_J:\nreturn Offset.NULL\nreturn Offset.new(\nself.get_coordinate_parser().parse(coordinate),\nunit=self.get_units(),\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/__init__.html","title":"init","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/__init__.html#pygerber.gerberx3.tokenizer","title":"tokenizer","text":"<p>Gerber X3 tokenizer.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/errors.html","title":"errors","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/errors.html#pygerber.gerberx3.tokenizer.errors","title":"errors","text":"<p>Base error classes used in this module.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/errors.html#pygerber.gerberx3.tokenizer.errors.TokenizerError","title":"TokenizerError","text":"<p>             Bases: <code>ValueError</code></p> <p>Base class for tokenizer errors.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/errors.py</code> <pre><code>class TokenizerError(ValueError):\n\"\"\"Base class for tokenizer errors.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html","title":"grammar","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar","title":"grammar","text":"<p>GerberX3 grammar.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar.EOEX","title":"EOEX  <code>module-attribute</code>","text":"<pre><code>EOEX = Suppress(Literal('*').set_name('end of expression'))\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar.SOSTMT","title":"SOSTMT  <code>module-attribute</code>","text":"<pre><code>SOSTMT = Suppress(\nLiteral(\"%\").set_name(\"start of statement\")\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar.EOSTMT","title":"EOSTMT  <code>module-attribute</code>","text":"<pre><code>EOSTMT = Suppress(Literal(\"%\").set_name(\"end of statement\"))\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar.positive_integer","title":"positive_integer  <code>module-attribute</code>","text":"<pre><code>positive_integer = Word(\"123456789\", nums).set_name(\n\"positive integer\"\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar.integer","title":"integer  <code>module-attribute</code>","text":"<pre><code>integer = Combine(Opt(oneOf(\"+ -\")) + Word(nums)).set_name(\n\"integer\"\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar.decimal","title":"decimal  <code>module-attribute</code>","text":"<pre><code>decimal = Combine(\nOpt(oneOf(\"+ -\"))\n+ Opt(Word(nums))\n+ \".\"\n+ Opt(Word(nums))\n| Word(nums)\n).set_name(\"decimal\")\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar.aperture_identifier","title":"aperture_identifier  <code>module-attribute</code>","text":"<pre><code>aperture_identifier = (\nCombine(\"D\" + Regex(\"[1-9][0-9]+\"))\n.set_name(\"aperture identifier\")\n.set_results_name(\"aperture_identifier\")\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar.name","title":"name  <code>module-attribute</code>","text":"<pre><code>name = Regex('[._a-zA-Z$][._a-zA-Z0-9]*').set_name('name')\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar.user_name","title":"user_name  <code>module-attribute</code>","text":"<pre><code>user_name = Regex(\"/[_a-zA-Z$][._a-zA-Z0-9]*/\").set_name(\n\"user name\"\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar.string","title":"string  <code>module-attribute</code>","text":"<pre><code>string = CharsNotIn('%*').set_name('string')\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar.field","title":"field  <code>module-attribute</code>","text":"<pre><code>field = (\nCharsNotIn(\"%*,\")\n.set_name(\"field\")\n.set_results_name(\"field\", list_all_matches=True)\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar.file_attribute_name","title":"file_attribute_name  <code>module-attribute</code>","text":"<pre><code>file_attribute_name = oneOf(\n\".Part .FileFunction .FilePolarity .SameCoordinates .CreationDate        .GenerationSoftware .ProjectId .MD5\"\n) | user_name.set_name(\"file_attribute_name\")\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar.aperture_attribute_name","title":"aperture_attribute_name  <code>module-attribute</code>","text":"<pre><code>aperture_attribute_name = oneOf(\n\".AperFunction .DrillTolerance .FlashText\"\n) | user_name.set_name(\"aperture_attribute_name\")\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar.object_attribute_name","title":"object_attribute_name  <code>module-attribute</code>","text":"<pre><code>object_attribute_name = oneOf(\n\".N .P .C .CRot .CMfr .CMPN .CVal .CMnt .CFtp .CPgN .CPgD .CHgt .CLbN        .CLbD .CSup\"\n) | user_name.set_name(\"object_attribute_name\")\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar.TF","title":"TF  <code>module-attribute</code>","text":"<pre><code>TF = FileAttribute.wrap(\nwrap_statement(\nLiteral(\"TF\")\n+ file_attribute_name.set_results_name(\n\"file_attribute_name\"\n)\n+ ZeroOrMore(\",\" + field | \"\")\n)\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar.TA","title":"TA  <code>module-attribute</code>","text":"<pre><code>TA = ApertureAttribute.wrap(\nwrap_statement(\nLiteral(\"TA\")\n+ aperture_attribute_name.set_results_name(\n\"aperture_attribute_name\"\n)\n+ ZeroOrMore(\",\" + field | \"\")\n)\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar.TO","title":"TO  <code>module-attribute</code>","text":"<pre><code>TO = ObjectAttribute.wrap(\nwrap_statement(\nLiteral(\"TO\")\n+ object_attribute_name.set_results_name(\n\"object_attribute_name\"\n)\n+ ZeroOrMore(\",\" + field | \"\")\n)\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar.TD","title":"TD  <code>module-attribute</code>","text":"<pre><code>TD = DeleteAttribute.wrap(\nwrap_statement(\nLiteral(\"TD\")\n+ Opt(\nfile_attribute_name\n| aperture_attribute_name\n| object_attribute_name\n| user_name\n).set_results_name(\"attribute_name\")\n)\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar.G04","title":"G04  <code>module-attribute</code>","text":"<pre><code>G04 = Comment.wrap(\nSuppress(Literal(\"G04\"))\n+ string.set_results_name(\"string\")\n+ EOEX\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar.macro_variable","title":"macro_variable  <code>module-attribute</code>","text":"<pre><code>macro_variable = MacroVariableName.wrap(\nRegex(\"\\\\$[0-9]*[1-9][0-9]*\")(\"macro_variable_name\"),\nuse_group=False,\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar.numeric_constant","title":"numeric_constant  <code>module-attribute</code>","text":"<pre><code>numeric_constant = NumericConstant.wrap(\ndecimal(\"numeric_constant_value\"), use_group=False\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar.arithmetic_expression","title":"arithmetic_expression  <code>module-attribute</code>","text":"<pre><code>arithmetic_expression: ParserElement = infix_notation(\nmacro_variable | numeric_constant,\n[\n(\noneOf(\"+ -\"),\n1,\nOpAssoc.RIGHT,\nArithmeticExpression.new,\n),\n(\noneOf(\"x X /\"),\n2,\nOpAssoc.LEFT,\nArithmeticExpression.new,\n),\n(\noneOf(\"+ -\"),\n2,\nOpAssoc.LEFT,\nArithmeticExpression.new,\n),\n],\n).set_name(\"arithmetic expression\")\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar.expr","title":"expr  <code>module-attribute</code>","text":"<pre><code>expr = (\narithmetic_expression\n| macro_variable\n| numeric_constant.set_name(\"macro body expression.\")\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar.cs","title":"cs  <code>module-attribute</code>","text":"<pre><code>cs = Suppress(Literal(',').set_name('comma'))\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar.primitive","title":"primitive  <code>module-attribute</code>","text":"<pre><code>primitive = (\nMacroComment.wrap(\n\"0\" + string.set_results_name(\"string\")\n)\n| PrimitiveCircle.wrap(\n\"1\"\n+ cs\n+ expr.set_results_name(\"exposure\")\n+ cs\n+ expr.set_results_name(\"diameter\")\n+ cs\n+ expr.set_results_name(\"center_x\")\n+ cs\n+ expr.set_results_name(\"center_y\")\n+ Opt(cs + expr.set_results_name(\"rotation\"))\n)\n| PrimitiveVectorLine.wrap(\n\"20\"\n+ cs\n+ expr.set_results_name(\"exposure\")\n+ cs\n+ expr.set_results_name(\"width\")\n+ cs\n+ expr.set_results_name(\"start_x\")\n+ cs\n+ expr.set_results_name(\"start_y\")\n+ cs\n+ expr.set_results_name(\"end_x\")\n+ cs\n+ expr.set_results_name(\"end_y\")\n+ cs\n+ expr.set_results_name(\"rotation\")\n)\n| PrimitiveCenterLine.wrap(\n\"21\"\n+ cs\n+ expr.set_results_name(\"exposure\")\n+ cs\n+ expr.set_results_name(\"width\")\n+ cs\n+ expr.set_results_name(\"hight\")\n+ cs\n+ expr.set_results_name(\"center_x\")\n+ cs\n+ expr.set_results_name(\"center_y\")\n+ cs\n+ expr.set_results_name(\"rotation\")\n)\n| PrimitiveOutline.wrap(\n\"4\"\n+ cs\n+ expr.set_results_name(\"exposure\")\n+ cs\n+ expr.set_results_name(\"number_of_vertices\")\n+ cs\n+ expr.set_results_name(\"start_x\")\n+ cs\n+ expr.set_results_name(\"start_y\")\n+ OneOrMore(\nPoint.wrap(\ncs\n+ expr.set_results_name(\"x\")\n+ cs\n+ expr.set_results_name(\"y\"),\nuse_group=False,\n).set_results_name(\n\"point\", list_all_matches=True\n)\n)\n+ cs\n+ expr.set_results_name(\"rotation\")\n)\n| PrimitivePolygon.wrap(\n\"5\"\n+ cs\n+ expr.set_results_name(\"exposure\")\n+ cs\n+ expr.set_results_name(\"number_of_vertices\")\n+ cs\n+ expr.set_results_name(\"center_x\")\n+ cs\n+ expr.set_results_name(\"center_y\")\n+ cs\n+ expr.set_results_name(\"diameter\")\n+ cs\n+ expr.set_results_name(\"rotation\")\n)\n| PrimitiveThermal.wrap(\n\"7\"\n+ cs\n+ expr.set_results_name(\"center_x\")\n+ cs\n+ expr.set_results_name(\"center_y\")\n+ cs\n+ expr.set_results_name(\"outer_diameter\")\n+ cs\n+ expr.set_results_name(\"inner_diameter\")\n+ cs\n+ expr.set_results_name(\"gap\")\n+ cs\n+ expr.set_results_name(\"rotation\")\n)\n+ EOEX\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar.variable_definition","title":"variable_definition  <code>module-attribute</code>","text":"<pre><code>variable_definition = MacroVariableDefinition.wrap(\nmacro_variable\n+ \"=\"\n+ expr.set_results_name(\"value\")\n+ EOEX\n).set_name(\"variable definition\")\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar.macro_body","title":"macro_body  <code>module-attribute</code>","text":"<pre><code>macro_body = (\nprimitive\n| variable_definition\n| G04.set_results_name(\n\"macro_body\", list_all_matches=True\n).set_name(\"macro body expression\")[1, ...]\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar.AM","title":"AM  <code>module-attribute</code>","text":"<pre><code>AM = MacroDefinition.wrap(\nwrap_statement(\nLiteral(\"AM\")\n+ name.set_results_name(\"macro_name\").set_name(\n\"macro name\"\n)\n+ EOEX\n+ macro_body.set_name(\"macro body\"),\neoex=False,\n)\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar.am_param","title":"am_param  <code>module-attribute</code>","text":"<pre><code>am_param = decimal.set_results_name(\n\"am_param\", list_all_matches=True\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar.AD","title":"AD  <code>module-attribute</code>","text":"<pre><code>AD = DefineAperture.wrap(\nwrap_statement(\nLiteral(\"AD\")\n+ aperture_identifier\n+ Literal(\"C\").set_results_name(\"aperture_type\")\n+ \",\"\n+ decimal.set_results_name(\"diameter\")\n+ Opt(\n\"X\" + decimal.set_results_name(\"hole_diameter\")\n)\n| Literal(\"R\").set_results_name(\"aperture_type\")\n+ \",\"\n+ decimal.set_results_name(\"x_size\")\n+ \"X\"\n+ decimal.set_results_name(\"y_size\")\n+ Opt(\n\"X\" + decimal.set_results_name(\"hole_diameter\")\n)\n| Literal(\"O\").set_results_name(\"aperture_type\")\n+ \",\"\n+ decimal.set_results_name(\"x_size\")\n+ \"X\"\n+ decimal.set_results_name(\"y_size\")\n+ Opt(\n\"X\" + decimal.set_results_name(\"hole_diameter\")\n)\n| Literal(\"P\").set_results_name(\"aperture_type\")\n+ \",\"\n+ decimal.set_results_name(\"outer_diameter\")\n+ \"X\"\n+ decimal.set_results_name(\"number_of_vertices\")\n+ Opt(\n\"X\"\n+ decimal.set_results_name(\"rotation\")\n+ Opt(\n\"X\"\n+ decimal.set_results_name(\"hole_diameter\")\n)\n)\n| name.set_results_name(\"aperture_type\")\n+ Opt(\",\" + am_param + ZeroOrMore(\"X\" + am_param))\n)\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar.LN","title":"LN  <code>module-attribute</code>","text":"<pre><code>LN = LoadName.wrap(\nwrap_statement(\nLiteral(\"LN\") + string.set_results_name(\"string\")\n)\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar.LN--load-name-ln","title":"Load Name (LN)","text":"<p>Note: The LN command was deprecated in revision I4 from October 2013.</p> <p>The historic <code>LN</code> command doesn't influence the image in any manner and can safely be overlooked.</p> <p>Function of the <code>LN</code> command: - <code>LN</code> is designed to allocate a name to the following section of the file. - It was originally conceptualized to serve as a human-readable comment. - For creating human-readable comments, it's advisable to utilize the standard <code>G04</code>     command. - The <code>LN</code> command has the flexibility to be executed multiple times within a file.</p> <p>SPEC: <code>2023.03</code> SECTION: <code>8.1.6</code></p>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar.LS","title":"LS  <code>module-attribute</code>","text":"<pre><code>LS = LoadScaling.wrap(\nwrap_statement(\nLiteral(\"LS\") + decimal.set_results_name(\"scaling\")\n)\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar.LS--ls-command-scaling-graphics-state-parameter","title":"LS Command: Scaling Graphics State Parameter","text":"<p>The <code>LS</code> command is employed to establish the scaling graphics state parameter.</p> <p>Functionality: - The command dictates the scale factor utilized during object creation. - The aperture undergoes scaling, anchored at its origin. It's crucial to note that this     origin might not always align with its geometric center.</p> <p>Usage and Persistence: - The <code>LS</code> command can be invoked multiple times within a single file. - Once set, the object scaling retains its value unless a subsequent <code>LS</code> command     modifies it. - The scaling gets adjusted based on the specific value mentioned in the command and     doesn't accumulate with the preceding scale factor.</p> <p>The LS command was introduced in revision 2016.12.</p> <p>SPEC: <code>2023.03</code> SECTION: <code>4.9.5</code></p>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar.LR","title":"LR  <code>module-attribute</code>","text":"<pre><code>LR = LoadRotation.wrap(\nwrap_statement(\nLiteral(\"LR\") + decimal.set_results_name(\"rotation\")\n)\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar.LR--lr-command-rotation-graphics-state-parameter","title":"LR Command: Rotation Graphics State Parameter","text":"<p>The <code>LR</code> command is utilized to configure the rotation graphics state parameter.</p> <p>Functionality: - This command specifies the rotation angle to be applied when crafting objects. - The aperture is rotated centered on its origin, which might either coincide with or     differ from its geometric center.</p> <p>Usage and Persistence: - The <code>LR</code> command can be invoked numerous times throughout a file. - Once defined, the object rotation retains its configuration unless overridden by an     ensuing <code>LR</code> command. - Rotation is strictly determined by the exact value mentioned in the command and     doesn't integrate with any prior rotation values.</p> <p>The LR command was introduced in revision 2016.12.</p> <p>SPEC: <code>2023.03</code> SECTION: <code>4.9.4</code></p>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar.LM","title":"LM  <code>module-attribute</code>","text":"<pre><code>LM = LoadMirroring.wrap(\nwrap_statement(\nLiteral(\"LM\")\n+ oneOf(\"N XY Y X\").set_results_name(\"mirroring\")\n)\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar.LP","title":"LP  <code>module-attribute</code>","text":"<pre><code>LP = LoadPolarity.wrap(\nwrap_statement(\nLiteral(\"LP\")\n+ oneOf(\"C D\").set_results_name(\"polarity\")\n)\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar.IP","title":"IP  <code>module-attribute</code>","text":"<pre><code>IP = ImagePolarity.wrap(\nwrap_statement(\nLiteral(\"POS\")\n+ oneOf(\"POS NEG\").set_results_name(\n\"image_polarity\"\n)\n)\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar.M02","title":"M02  <code>module-attribute</code>","text":"<pre><code>M02 = M02EndOfFile.wrap(\nLiteral(\"M02\").set_name(\"End of file\") + EOEX\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar.M01","title":"M01  <code>module-attribute</code>","text":"<pre><code>M01 = M01OptionalStop.wrap(\nLiteral(\"M01\").set_name(\"Optional stop\") + EOEX\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar.M00","title":"M00  <code>module-attribute</code>","text":"<pre><code>M00 = M00ProgramStop.wrap(\nLiteral(\"M00\").set_name(\"Program stop\") + EOEX\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar.DNN","title":"DNN  <code>module-attribute</code>","text":"<pre><code>DNN = DNNSelectAperture.wrap(aperture_identifier + EOEX)\n</code></pre> <p>Sets the current aperture to D code nn.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar.G54DNN","title":"G54DNN  <code>module-attribute</code>","text":"<pre><code>G54DNN = DNNSelectAperture.wrap(\nLiteral(\"G54\") + aperture_identifier + EOEX\n)\n</code></pre> <p>Sets the current aperture to D code nn.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar.G01","title":"G01  <code>module-attribute</code>","text":"<pre><code>G01 = SetLinear.wrap(oneOf('G1 G01 G001 G0001') + EOEX)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar.G01--sets-linearcircular-mode-to-linear","title":"Sets linear/circular mode to linear.","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar.G02","title":"G02  <code>module-attribute</code>","text":"<pre><code>G02 = SetClockwiseCircular.wrap(\noneOf(\"G2 G02 G002 G0002\") + EOEX\n)\n</code></pre> <p>Sets linear/circular mode to clockwise circular.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar.G03","title":"G03  <code>module-attribute</code>","text":"<pre><code>G03 = SetCounterclockwiseCircular.wrap(\noneOf(\"G3 G03 G003 G0003\") + EOEX\n)\n</code></pre> <p>Sets linear/circular mode to counterclockwise circular.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar.G70","title":"G70  <code>module-attribute</code>","text":"<pre><code>G70 = SetUnitInch.wrap(Literal('G70') + EOEX)\n</code></pre> <p>DEPRECATED: Set the <code>Unit</code> to inch.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar.G71","title":"G71  <code>module-attribute</code>","text":"<pre><code>G71 = SetUnitMillimeters.wrap(Literal('G71') + EOEX)\n</code></pre> <p>DEPRECATED: Set the <code>Unit</code> to millimeter.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar.G74","title":"G74  <code>module-attribute</code>","text":"<pre><code>G74 = SetMultiQuadrantMode.wrap(Literal('G74') + EOEX)\n</code></pre> <p>DEPRECATED: Set's single quadrant mode.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar.G75","title":"G75  <code>module-attribute</code>","text":"<pre><code>G75 = SetMultiQuadrantMode.wrap(Literal('G75') + EOEX)\n</code></pre> <p>Set's multi quadrant mode.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar.G90","title":"G90  <code>module-attribute</code>","text":"<pre><code>G90 = SetAbsoluteNotation.wrap(Literal('G90') + EOEX)\n</code></pre> <p>Set the <code>Coordinate format</code> to <code>Absolute notation</code>.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar.G91","title":"G91  <code>module-attribute</code>","text":"<pre><code>G91 = SetIncrementalNotation.wrap(Literal('G91') + EOEX)\n</code></pre> <p>Set the <code>Coordinate format</code> to <code>Incremental notation</code>.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar.X_coordinate","title":"X_coordinate  <code>module-attribute</code>","text":"<pre><code>X_coordinate = Literal(\"X\") + integer.set_results_name(\n\"x\"\n).set_name(\"X coordinate\")\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar.Y_coordinate","title":"Y_coordinate  <code>module-attribute</code>","text":"<pre><code>Y_coordinate = Literal(\"Y\") + integer.set_results_name(\n\"y\"\n).set_name(\"Y coordinate\")\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar.I_coordinate","title":"I_coordinate  <code>module-attribute</code>","text":"<pre><code>I_coordinate = Literal(\"I\") + integer.set_results_name(\n\"i\"\n).set_name(\"I offset\")\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar.J_coordinate","title":"J_coordinate  <code>module-attribute</code>","text":"<pre><code>J_coordinate = Literal(\"J\") + integer.set_results_name(\n\"j\"\n).set_name(\"J offset\")\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar.XY","title":"XY  <code>module-attribute</code>","text":"<pre><code>XY = (\nX_coordinate + Opt(Y_coordinate)\n| Opt(X_coordinate) + Y_coordinate\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar.IJ","title":"IJ  <code>module-attribute</code>","text":"<pre><code>IJ = (\nI_coordinate + Opt(J_coordinate)\n| Opt(I_coordinate) + J_coordinate\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar.D03","title":"D03  <code>module-attribute</code>","text":"<pre><code>D03 = D03Flash.wrap(\nOpt(XY) + oneOf(\"D3 D03 D003 D0003\") + EOEX\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar.D02","title":"D02  <code>module-attribute</code>","text":"<pre><code>D02 = D02Move.wrap(\nOpt(XY) + oneOf(\"D2 D02 D002 D0002\") + EOEX\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar.D01","title":"D01  <code>module-attribute</code>","text":"<pre><code>D01 = D01Draw.wrap(\nOpt(XY) + Opt(IJ) + oneOf(\"D1 D01 D001 D0001\")\n| XY + Opt(IJ) + EOEX\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar.coord_digits","title":"coord_digits  <code>module-attribute</code>","text":"<pre><code>coord_digits = Regex('[1-6][1-6]')\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar.FS","title":"FS  <code>module-attribute</code>","text":"<pre><code>FS = CoordinateFormat.wrap(\nwrap_statement(\nLiteral(\"FS\")\n+ oneOf(\"L T\")\n.set_results_name(\"zeros_mode\")\n.set_name(\"zeros mode\")\n+ oneOf(\"A I\")\n.set_results_name(\"coordinate_mode\")\n.set_name(\"coordinate mode\")\n+ \"X\"\n+ coord_digits.set_results_name(\n\"x_format\"\n).set_name(\"X coordinate format\")\n+ \"Y\"\n+ coord_digits.set_results_name(\n\"y_format\"\n).set_name(\"Y coordinate format\")\n)\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar.MO","title":"MO  <code>module-attribute</code>","text":"<pre><code>MO = UnitMode.wrap(\nwrap_statement(\nLiteral(\"MO\")\n+ oneOf(\"MM IN\")\n.set_results_name(\"unit\")\n.set_name(\"unit\")\n)\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar.G36","title":"G36  <code>module-attribute</code>","text":"<pre><code>G36 = BeginRegion.wrap(Literal('G36') + EOEX)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar.G37","title":"G37  <code>module-attribute</code>","text":"<pre><code>G37 = EndRegion.wrap(Literal('G37') + EOEX)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar.AB_statement","title":"AB_statement  <code>module-attribute</code>","text":"<pre><code>AB_statement = Forward()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar.SR_statement","title":"SR_statement  <code>module-attribute</code>","text":"<pre><code>SR_statement = Forward()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar.block","title":"block  <code>module-attribute</code>","text":"<pre><code>block = Forward()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar.SR_open","title":"SR_open  <code>module-attribute</code>","text":"<pre><code>SR_open = StepRepeatBegin.wrap(\nwrap_statement(\nLiteral(\"SR\")\n+ \"X\"\n+ positive_integer.set_results_name(\"x_repeat\")\n+ \"Y\"\n+ positive_integer.set_results_name(\"y_repeat\")\n+ \"I\"\n+ decimal.set_results_name(\"x_step\")\n+ \"J\"\n+ decimal.set_results_name(\"y_step\")\n)\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar.SR_close","title":"SR_close  <code>module-attribute</code>","text":"<pre><code>SR_close = StepRepeatEnd.wrap(wrap_statement(Literal(\"SR\")))\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar.AB_open","title":"AB_open  <code>module-attribute</code>","text":"<pre><code>AB_open = BlockApertureBegin.wrap(\nwrap_statement(Literal(\"AB\") + aperture_identifier)\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar.AB_close","title":"AB_close  <code>module-attribute</code>","text":"<pre><code>AB_close = BlockApertureEnd.wrap(\nwrap_statement(Literal(\"AB\"))\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar.common","title":"common  <code>module-attribute</code>","text":"<pre><code>common = (\nG04\n| MO\n| FS\n| AD\n| AM\n| DNN\n| G54DNN\n| D01\n| D02\n| D03\n| G01\n| G02\n| G03\n| G70\n| G71\n| G74\n| G75\n| G90\n| G91\n| LP\n| LM\n| LR\n| LS\n| LN\n| G36\n| G37\n| AB_statement\n| SR_statement\n| TF\n| TA\n| TO\n| TD\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar._G01","title":"_G01  <code>module-attribute</code>","text":"<pre><code>_G01 = SetLinear.wrap(Literal('G01'))\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar._G02","title":"_G02  <code>module-attribute</code>","text":"<pre><code>_G02 = SetClockwiseCircular.wrap(Literal('G02'))\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar._G03","title":"_G03  <code>module-attribute</code>","text":"<pre><code>_G03 = SetCounterclockwiseCircular.wrap(Literal('G03'))\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar._G70","title":"_G70  <code>module-attribute</code>","text":"<pre><code>_G70 = SetUnitInch.wrap(Literal('G70'))\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar._G71","title":"_G71  <code>module-attribute</code>","text":"<pre><code>_G71 = SetUnitMillimeters.wrap(Literal('G71'))\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar.EXPRESSIONS","title":"EXPRESSIONS  <code>module-attribute</code>","text":"<pre><code>EXPRESSIONS = common | M02 | M01 | M00[0, ...]\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar.GRAMMAR","title":"GRAMMAR  <code>module-attribute</code>","text":"<pre><code>GRAMMAR = common[0, ...] + M02 | M01 | M00\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar.wrap_statement","title":"wrap_statement","text":"<pre><code>wrap_statement(\nexpr: ParserElement, *, eoex: bool = True\n) -&gt; ParserElement\n</code></pre> <p>Wrap statement in start of statement (%) and end of statement (*%) symbols.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/grammar.py</code> <pre><code>def wrap_statement(expr: ParserElement, *, eoex: bool = True) -&gt; ParserElement:\n\"\"\"Wrap statement in start of statement (%) and end of statement (*%) symbols.\"\"\"\nreturn SOSTMT + expr + ((EOEX + EOSTMT) if eoex else EOSTMT)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokenizer.html","title":"tokenizer","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokenizer.html#pygerber.gerberx3.tokenizer.tokenizer","title":"tokenizer","text":"<p>GerberX3 format tokenizer.</p> <p>Parser is based on GerberX3 format described in Ucamco's <code>The Gerber Layer Format Specification</code>.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokenizer.html#pygerber.gerberx3.tokenizer.tokenizer.Tokenizer","title":"Tokenizer","text":"<p>GerberX3 format tokenizer.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokenizer.py</code> <pre><code>class Tokenizer:\n\"\"\"GerberX3 format tokenizer.\"\"\"\ndef __init__(self) -&gt; None:\n\"\"\"GerberX3 format tokenizer.\"\"\"\nlogging.debug(\n\"Created %s GerberX3 tokenizer.\",\n)\ndef tokenize(self, source: str) -&gt; TokenStack:\n\"\"\"Convert source code into token stack.\n        Supports only full, valid GerberX3 files.\n        \"\"\"\nreturn self._tokenize_grammar(source, GRAMMAR, parse_all=False)\ndef tokenize_expressions(self, source: str) -&gt; TokenStack:\n\"\"\"Convert source code into token stack.\n        Supports arbitrary sequences of valid GerberX3 expressions.\n        \"\"\"\nreturn self._tokenize_grammar(source, EXPRESSIONS, parse_all=True)\ndef _tokenize_grammar(\nself,\nsource: str,\ngrammar: ParserElement,\n*,\nparse_all: bool,\n) -&gt; TokenStack:\ntokens: list[Token] = [\ntoken\nfor token in flatten(\ngrammar.parse_string(source, parse_all=parse_all).as_list(),\n)\nif isinstance(token, Token)\n]\nreturn TokenStack(tokens)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokenizer.html#pygerber.gerberx3.tokenizer.tokenizer.Tokenizer.__init__","title":"__init__","text":"<pre><code>__init__() -&gt; None\n</code></pre> <p>GerberX3 format tokenizer.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokenizer.py</code> <pre><code>def __init__(self) -&gt; None:\n\"\"\"GerberX3 format tokenizer.\"\"\"\nlogging.debug(\n\"Created %s GerberX3 tokenizer.\",\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokenizer.html#pygerber.gerberx3.tokenizer.tokenizer.Tokenizer.tokenize","title":"tokenize","text":"<pre><code>tokenize(source: str) -&gt; TokenStack\n</code></pre> <p>Convert source code into token stack.</p> <p>Supports only full, valid GerberX3 files.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokenizer.py</code> <pre><code>def tokenize(self, source: str) -&gt; TokenStack:\n\"\"\"Convert source code into token stack.\n    Supports only full, valid GerberX3 files.\n    \"\"\"\nreturn self._tokenize_grammar(source, GRAMMAR, parse_all=False)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokenizer.html#pygerber.gerberx3.tokenizer.tokenizer.Tokenizer.tokenize_expressions","title":"tokenize_expressions","text":"<pre><code>tokenize_expressions(source: str) -&gt; TokenStack\n</code></pre> <p>Convert source code into token stack.</p> <p>Supports arbitrary sequences of valid GerberX3 expressions.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokenizer.py</code> <pre><code>def tokenize_expressions(self, source: str) -&gt; TokenStack:\n\"\"\"Convert source code into token stack.\n    Supports arbitrary sequences of valid GerberX3 expressions.\n    \"\"\"\nreturn self._tokenize_grammar(source, EXPRESSIONS, parse_all=True)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokenizer.html#pygerber.gerberx3.tokenizer.tokenizer.TokenStack","title":"TokenStack","text":"<p>             Bases: <code>List[Token]</code></p> <p>Token stack wrapper.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokenizer.py</code> <pre><code>class TokenStack(List[Token]):\n\"\"\"Token stack wrapper.\"\"\"\ndef debug_display(self) -&gt; Self:\n\"\"\"Debug display.\"\"\"\nfor token in self:\nlogging.debug(token)\nif len(self) == 0:\nlogging.debug(\"&lt;Empty token stack&gt;\")\nreturn self\ndef format_gerberx3(self) -&gt; str:\n\"\"\"Return formatted GerberX3 code.\"\"\"\nreturn str.join(\"\\n\", (str(token) for token in self))\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokenizer.html#pygerber.gerberx3.tokenizer.tokenizer.TokenStack.debug_display","title":"debug_display","text":"<pre><code>debug_display() -&gt; Self\n</code></pre> <p>Debug display.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokenizer.py</code> <pre><code>def debug_display(self) -&gt; Self:\n\"\"\"Debug display.\"\"\"\nfor token in self:\nlogging.debug(token)\nif len(self) == 0:\nlogging.debug(\"&lt;Empty token stack&gt;\")\nreturn self\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokenizer.html#pygerber.gerberx3.tokenizer.tokenizer.TokenStack.format_gerberx3","title":"format_gerberx3","text":"<pre><code>format_gerberx3() -&gt; str\n</code></pre> <p>Return formatted GerberX3 code.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokenizer.py</code> <pre><code>def format_gerberx3(self) -&gt; str:\n\"\"\"Return formatted GerberX3 code.\"\"\"\nreturn str.join(\"\\n\", (str(token) for token in self))\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/__init__.html","title":"init","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/__init__.html#pygerber.gerberx3.tokenizer.tokens","title":"tokens","text":"<p>Gerber X3 token wrappers.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ab_block_aperture.html","title":"ab_block_aperture","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ab_block_aperture.html#pygerber.gerberx3.tokenizer.tokens.ab_block_aperture","title":"ab_block_aperture","text":"<p>Wrapper for aperture select token.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ab_block_aperture.html#pygerber.gerberx3.tokenizer.tokens.ab_block_aperture.BlockApertureBegin","title":"BlockApertureBegin","text":"<p>             Bases: <code>Token</code></p> <p>Wrapper for AB begin token.</p> <p>Opens a block aperture statement and assigns its aperture number.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/ab_block_aperture.py</code> <pre><code>class BlockApertureBegin(Token):\n\"\"\"Wrapper for AB begin token.\n    Opens a block aperture statement and assigns its aperture number.\n    \"\"\"\nidentifier: ApertureID\n@classmethod\ndef from_tokens(cls, **tokens: Any) -&gt; Self:\n\"\"\"Initialize token object.\"\"\"\nidentifier = ApertureID(tokens[\"aperture_identifier\"])\nreturn cls(identifier=identifier)\ndef update_drawing_state(\nself,\nstate: State,\nbackend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n\"\"\"Update drawing state.\"\"\"\nhandle = backend.create_aperture_handle(self.identifier)\nwith handle:\n# Must be included to initialize drawing target.\npass\nfrozen_handle = handle.get_public_handle()\nnew_aperture_dict = {**state.apertures}\nnew_aperture_dict[self.identifier] = frozen_handle\nreturn (\nstate.model_copy(\nupdate={\n\"apertures\": new_aperture_dict,\n},\n),\n(),\n)\ndef __str__(self) -&gt; str:\nreturn f\"AB{self.identifier}*\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ab_block_aperture.html#pygerber.gerberx3.tokenizer.tokens.ab_block_aperture.BlockApertureBegin.from_tokens","title":"from_tokens  <code>classmethod</code>","text":"<pre><code>from_tokens(**tokens: Any) -&gt; Self\n</code></pre> <p>Initialize token object.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/ab_block_aperture.py</code> <pre><code>@classmethod\ndef from_tokens(cls, **tokens: Any) -&gt; Self:\n\"\"\"Initialize token object.\"\"\"\nidentifier = ApertureID(tokens[\"aperture_identifier\"])\nreturn cls(identifier=identifier)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ab_block_aperture.html#pygerber.gerberx3.tokenizer.tokens.ab_block_aperture.BlockApertureBegin.update_drawing_state","title":"update_drawing_state","text":"<pre><code>update_drawing_state(\nstate: State, backend: Backend\n) -&gt; Tuple[State, Iterable[DrawCommand]]\n</code></pre> <p>Update drawing state.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/ab_block_aperture.py</code> <pre><code>def update_drawing_state(\nself,\nstate: State,\nbackend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n\"\"\"Update drawing state.\"\"\"\nhandle = backend.create_aperture_handle(self.identifier)\nwith handle:\n# Must be included to initialize drawing target.\npass\nfrozen_handle = handle.get_public_handle()\nnew_aperture_dict = {**state.apertures}\nnew_aperture_dict[self.identifier] = frozen_handle\nreturn (\nstate.model_copy(\nupdate={\n\"apertures\": new_aperture_dict,\n},\n),\n(),\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ab_block_aperture.html#pygerber.gerberx3.tokenizer.tokens.ab_block_aperture.BlockApertureEnd","title":"BlockApertureEnd","text":"<p>             Bases: <code>Token</code></p> <p>Wrapper for AB end token.</p> <p>Ends block aperture statement.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/ab_block_aperture.py</code> <pre><code>class BlockApertureEnd(Token):\n\"\"\"Wrapper for AB end token.\n    Ends block aperture statement.\n    \"\"\"\n@classmethod\ndef from_tokens(cls, **_tokens: Any) -&gt; Self:\n\"\"\"Initialize token object.\"\"\"\nreturn cls()\ndef __str__(self) -&gt; str:\nreturn \"AB*\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ab_block_aperture.html#pygerber.gerberx3.tokenizer.tokens.ab_block_aperture.BlockApertureEnd.from_tokens","title":"from_tokens  <code>classmethod</code>","text":"<pre><code>from_tokens(**_tokens: Any) -&gt; Self\n</code></pre> <p>Initialize token object.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/ab_block_aperture.py</code> <pre><code>@classmethod\ndef from_tokens(cls, **_tokens: Any) -&gt; Self:\n\"\"\"Initialize token object.\"\"\"\nreturn cls()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.html","title":"ad_define_aperture","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.html#pygerber.gerberx3.tokenizer.tokens.ad_define_aperture","title":"ad_define_aperture","text":"<p>Wrapper for aperture definition token.</p> <p>Generally, apertures with size zero are invalid, and so are objects created with them. There is one exception. The C (circular) standard aperture with zero diameter is allowed, and so are objects created with it. Attributes can be attached to them. For the avoidance of doubt, zero size is only allowed for the C aperture, not another aperture type whose shape is fortuitously circular.</p> <p>Zero-size objects do not affect the image. They can be used to provide meta-information to locations in the image plane.</p> <p>Allowed does not mean recommended, quite the contrary. If you are tempted to use a zero-size object, consider whether it is useful, and whether there is no proper way to convey the meta information. Certainly do not abuse a zero-size object to indicate the absence of an object, e.g. by flashing a zero-size aperture to indicate the absence of a pad. This is just confusing. If there is nothing, put nothing.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.html#pygerber.gerberx3.tokenizer.tokens.ad_define_aperture.DefineAperture","title":"DefineAperture","text":"<p>             Bases: <code>Token</code></p> <p>Wrapper for aperture definition token.</p> <p>Defines a template-based aperture, assigns a D code to it. This class is never used to create objects, only its subclasses are used.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.py</code> <pre><code>class DefineAperture(Token):\n\"\"\"Wrapper for aperture definition token.\n    Defines a template-based aperture, assigns a D code to it. This class is never used\n    to create objects, only its subclasses are used.\n    \"\"\"\n@classmethod\ndef new(\ncls,\n_string: str,\n_location: int,\ntokens: ParseResults,\n) -&gt; DefineAperture:\n\"\"\"Create instance of this class.\n        Created to be used as callback in `ParserElement.set_parse_action()`.\n        \"\"\"\naperture_type = tokens.pop(\"aperture_type\")\nif not isinstance(aperture_type, str):\nmsg = \"Expected aperture type to be string.\"\nraise TypeError(msg)\nif aperture_type == \"C\":\nreturn DefineCircle.from_tokens(**tokens.as_dict())\nif aperture_type == \"R\":\nreturn DefineRectangle.from_tokens(**tokens.as_dict())\nif aperture_type == \"O\":\nreturn DefineObround.from_tokens(**tokens.as_dict())\nif aperture_type == \"P\":\nreturn DefinePolygon.from_tokens(**tokens.as_dict())\nreturn DefineMacro.from_tokens(aperture_type=aperture_type, **tokens.as_dict())\ndef __str__(self) -&gt; str:\nreturn \"&lt;ADDefineAperture-INVALID&gt;\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.html#pygerber.gerberx3.tokenizer.tokens.ad_define_aperture.DefineAperture.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(\n_string: str, _location: int, tokens: ParseResults\n) -&gt; DefineAperture\n</code></pre> <p>Create instance of this class.</p> <p>Created to be used as callback in <code>ParserElement.set_parse_action()</code>.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.py</code> <pre><code>@classmethod\ndef new(\ncls,\n_string: str,\n_location: int,\ntokens: ParseResults,\n) -&gt; DefineAperture:\n\"\"\"Create instance of this class.\n    Created to be used as callback in `ParserElement.set_parse_action()`.\n    \"\"\"\naperture_type = tokens.pop(\"aperture_type\")\nif not isinstance(aperture_type, str):\nmsg = \"Expected aperture type to be string.\"\nraise TypeError(msg)\nif aperture_type == \"C\":\nreturn DefineCircle.from_tokens(**tokens.as_dict())\nif aperture_type == \"R\":\nreturn DefineRectangle.from_tokens(**tokens.as_dict())\nif aperture_type == \"O\":\nreturn DefineObround.from_tokens(**tokens.as_dict())\nif aperture_type == \"P\":\nreturn DefinePolygon.from_tokens(**tokens.as_dict())\nreturn DefineMacro.from_tokens(aperture_type=aperture_type, **tokens.as_dict())\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.html#pygerber.gerberx3.tokenizer.tokens.ad_define_aperture.DefineCircle","title":"DefineCircle","text":"<p>             Bases: <code>DefineAperture</code></p> <p>Wrapper for aperture definition token.</p> <p>Defines a circle.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.py</code> <pre><code>class DefineCircle(DefineAperture):\n\"\"\"Wrapper for aperture definition token.\n    Defines a circle.\n    \"\"\"\naperture_id: ApertureID\ndiameter: Decimal\nhole_diameter: Optional[Decimal]\n@classmethod\ndef from_tokens(cls, **tokens: Any) -&gt; Self:\n\"\"\"Initialize token object.\"\"\"\naperture_id = ApertureID(tokens[\"aperture_identifier\"])\ndiameter: Decimal = Decimal(tokens[\"diameter\"])\nhole_diameter: Optional[Decimal] = (\nDecimal(tokens[\"hole_diameter\"])\nif tokens.get(\"hole_diameter\") is not None\nelse None\n)\nreturn cls(\naperture_id=aperture_id,\ndiameter=diameter,\nhole_diameter=hole_diameter,\n)\ndef update_drawing_state(\nself,\nstate: State,\nbackend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n\"\"\"Update drawing state.\"\"\"\nhandle = backend.create_aperture_handle(self.aperture_id)\nwith handle:\nhandle.add_draw(\nbackend.get_draw_circle_cls()(\nbackend=backend,\ndiameter=Offset.new(self.diameter, state.get_units()),\npolarity=Polarity.Dark,\ncenter_position=Vector2D(x=Offset.NULL, y=Offset.NULL),\n),\n)\nif self.hole_diameter is not None:\nhandle.add_draw(\nbackend.get_draw_circle_cls()(\nbackend=backend,\ndiameter=Offset.new(self.hole_diameter, state.get_units()),\npolarity=Polarity.Clear,\ncenter_position=Vector2D(x=Offset.NULL, y=Offset.NULL),\n),\n)\nfrozen_handle = handle.get_public_handle()\nnew_aperture_dict = {**state.apertures}\nnew_aperture_dict[self.aperture_id] = frozen_handle\nreturn (\nstate.model_copy(\nupdate={\n\"apertures\": new_aperture_dict,\n},\n),\n(),\n)\ndef __str__(self) -&gt; str:\nsuffix = \"\"\nif self.hole_diameter is not None:\nsuffix += f\"X{self.hole_diameter}\"\nreturn f\"%AD{self.aperture_id}C,{self.diameter}{suffix}*%\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.html#pygerber.gerberx3.tokenizer.tokens.ad_define_aperture.DefineCircle.from_tokens","title":"from_tokens  <code>classmethod</code>","text":"<pre><code>from_tokens(**tokens: Any) -&gt; Self\n</code></pre> <p>Initialize token object.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.py</code> <pre><code>@classmethod\ndef from_tokens(cls, **tokens: Any) -&gt; Self:\n\"\"\"Initialize token object.\"\"\"\naperture_id = ApertureID(tokens[\"aperture_identifier\"])\ndiameter: Decimal = Decimal(tokens[\"diameter\"])\nhole_diameter: Optional[Decimal] = (\nDecimal(tokens[\"hole_diameter\"])\nif tokens.get(\"hole_diameter\") is not None\nelse None\n)\nreturn cls(\naperture_id=aperture_id,\ndiameter=diameter,\nhole_diameter=hole_diameter,\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.html#pygerber.gerberx3.tokenizer.tokens.ad_define_aperture.DefineCircle.update_drawing_state","title":"update_drawing_state","text":"<pre><code>update_drawing_state(\nstate: State, backend: Backend\n) -&gt; Tuple[State, Iterable[DrawCommand]]\n</code></pre> <p>Update drawing state.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.py</code> <pre><code>def update_drawing_state(\nself,\nstate: State,\nbackend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n\"\"\"Update drawing state.\"\"\"\nhandle = backend.create_aperture_handle(self.aperture_id)\nwith handle:\nhandle.add_draw(\nbackend.get_draw_circle_cls()(\nbackend=backend,\ndiameter=Offset.new(self.diameter, state.get_units()),\npolarity=Polarity.Dark,\ncenter_position=Vector2D(x=Offset.NULL, y=Offset.NULL),\n),\n)\nif self.hole_diameter is not None:\nhandle.add_draw(\nbackend.get_draw_circle_cls()(\nbackend=backend,\ndiameter=Offset.new(self.hole_diameter, state.get_units()),\npolarity=Polarity.Clear,\ncenter_position=Vector2D(x=Offset.NULL, y=Offset.NULL),\n),\n)\nfrozen_handle = handle.get_public_handle()\nnew_aperture_dict = {**state.apertures}\nnew_aperture_dict[self.aperture_id] = frozen_handle\nreturn (\nstate.model_copy(\nupdate={\n\"apertures\": new_aperture_dict,\n},\n),\n(),\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.html#pygerber.gerberx3.tokenizer.tokens.ad_define_aperture.DefineRectangle","title":"DefineRectangle","text":"<p>             Bases: <code>DefineAperture</code></p> <p>Wrapper for aperture definition token.</p> <p>Defines a rectangle</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.py</code> <pre><code>class DefineRectangle(DefineAperture):\n\"\"\"Wrapper for aperture definition token.\n    Defines a rectangle\n    \"\"\"\naperture_id: ApertureID\nx_size: Decimal\ny_size: Decimal\nhole_diameter: Optional[Decimal]\n@classmethod\ndef from_tokens(cls, **tokens: Any) -&gt; Self:\n\"\"\"Initialize token object.\"\"\"\naperture_id = ApertureID(tokens[\"aperture_identifier\"])\nx_size: Decimal = Decimal(tokens[\"x_size\"])\ny_size: Decimal = Decimal(tokens[\"y_size\"])\nhole_diameter: Optional[Decimal] = (\nDecimal(tokens[\"hole_diameter\"])\nif tokens.get(\"hole_diameter\") is not None\nelse None\n)\nreturn cls(\naperture_id=aperture_id,\nx_size=x_size,\ny_size=y_size,\nhole_diameter=hole_diameter,\n)\ndef update_drawing_state(\nself,\nstate: State,\nbackend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n\"\"\"Update drawing state.\"\"\"\nhandle = backend.create_aperture_handle(self.aperture_id)\nwith handle:\nhandle.add_draw(\nbackend.get_draw_rectangle_cls()(\nbackend=backend,\nx_size=Offset.new(self.x_size, state.get_units()),\ny_size=Offset.new(self.y_size, state.get_units()),\npolarity=Polarity.Dark,\ncenter_position=Vector2D(x=Offset.NULL, y=Offset.NULL),\n),\n)\nif self.hole_diameter is not None:\nhandle.add_draw(\nbackend.get_draw_circle_cls()(\nbackend=backend,\ndiameter=Offset.new(self.hole_diameter, state.get_units()),\npolarity=Polarity.Clear,\ncenter_position=Vector2D(x=Offset.NULL, y=Offset.NULL),\n),\n)\nfrozen_handle = handle.get_public_handle()\nnew_aperture_dict = {**state.apertures}\nnew_aperture_dict[self.aperture_id] = frozen_handle\nreturn (\nstate.model_copy(\nupdate={\n\"apertures\": new_aperture_dict,\n},\n),\n(),\n)\ndef __str__(self) -&gt; str:\nsuffix = \"\"\nif self.hole_diameter is not None:\nsuffix += f\"X{self.hole_diameter}\"\nreturn f\"%AD{self.aperture_id}R,{self.x_size}X{self.y_size}{suffix}*%\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.html#pygerber.gerberx3.tokenizer.tokens.ad_define_aperture.DefineRectangle.from_tokens","title":"from_tokens  <code>classmethod</code>","text":"<pre><code>from_tokens(**tokens: Any) -&gt; Self\n</code></pre> <p>Initialize token object.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.py</code> <pre><code>@classmethod\ndef from_tokens(cls, **tokens: Any) -&gt; Self:\n\"\"\"Initialize token object.\"\"\"\naperture_id = ApertureID(tokens[\"aperture_identifier\"])\nx_size: Decimal = Decimal(tokens[\"x_size\"])\ny_size: Decimal = Decimal(tokens[\"y_size\"])\nhole_diameter: Optional[Decimal] = (\nDecimal(tokens[\"hole_diameter\"])\nif tokens.get(\"hole_diameter\") is not None\nelse None\n)\nreturn cls(\naperture_id=aperture_id,\nx_size=x_size,\ny_size=y_size,\nhole_diameter=hole_diameter,\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.html#pygerber.gerberx3.tokenizer.tokens.ad_define_aperture.DefineRectangle.update_drawing_state","title":"update_drawing_state","text":"<pre><code>update_drawing_state(\nstate: State, backend: Backend\n) -&gt; Tuple[State, Iterable[DrawCommand]]\n</code></pre> <p>Update drawing state.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.py</code> <pre><code>def update_drawing_state(\nself,\nstate: State,\nbackend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n\"\"\"Update drawing state.\"\"\"\nhandle = backend.create_aperture_handle(self.aperture_id)\nwith handle:\nhandle.add_draw(\nbackend.get_draw_rectangle_cls()(\nbackend=backend,\nx_size=Offset.new(self.x_size, state.get_units()),\ny_size=Offset.new(self.y_size, state.get_units()),\npolarity=Polarity.Dark,\ncenter_position=Vector2D(x=Offset.NULL, y=Offset.NULL),\n),\n)\nif self.hole_diameter is not None:\nhandle.add_draw(\nbackend.get_draw_circle_cls()(\nbackend=backend,\ndiameter=Offset.new(self.hole_diameter, state.get_units()),\npolarity=Polarity.Clear,\ncenter_position=Vector2D(x=Offset.NULL, y=Offset.NULL),\n),\n)\nfrozen_handle = handle.get_public_handle()\nnew_aperture_dict = {**state.apertures}\nnew_aperture_dict[self.aperture_id] = frozen_handle\nreturn (\nstate.model_copy(\nupdate={\n\"apertures\": new_aperture_dict,\n},\n),\n(),\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.html#pygerber.gerberx3.tokenizer.tokens.ad_define_aperture.DefineObround","title":"DefineObround","text":"<p>             Bases: <code>DefineAperture</code></p> <p>Wrapper for aperture definition token.</p> <p>Defines a obround.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.py</code> <pre><code>class DefineObround(DefineAperture):\n\"\"\"Wrapper for aperture definition token.\n    Defines a obround.\n    \"\"\"\naperture_id: ApertureID\nx_size: Decimal\ny_size: Decimal\nhole_diameter: Optional[Decimal]\n@classmethod\ndef from_tokens(cls, **tokens: Any) -&gt; Self:\n\"\"\"Initialize token object.\"\"\"\naperture_id = ApertureID(tokens[\"aperture_identifier\"])\nx_size: Decimal = Decimal(tokens[\"x_size\"])\ny_size: Decimal = Decimal(tokens[\"y_size\"])\nhole_diameter: Optional[Decimal] = (\nDecimal(tokens[\"hole_diameter\"])\nif tokens.get(\"hole_diameter\") is not None\nelse None\n)\nreturn cls(\naperture_id=aperture_id,\nx_size=x_size,\ny_size=y_size,\nhole_diameter=hole_diameter,\n)\ndef update_drawing_state(\nself,\nstate: State,\nbackend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n\"\"\"Update drawing state.\"\"\"\nhandle = backend.create_aperture_handle(self.aperture_id)\nx_size = Offset.new(self.x_size, state.get_units())\ny_size = Offset.new(self.y_size, state.get_units())\nif self.x_size &lt; self.y_size:\n# Obround is thin and tall.\ncircle_diameter = x_size\nmiddle_rectangle_x = x_size\nmiddle_rectangle_y = y_size - x_size\ncircle_positive = Vector2D(x=Offset.NULL, y=middle_rectangle_y / 2)\ncircle_negative = Vector2D(x=Offset.NULL, y=-middle_rectangle_y / 2)\nelse:\n# Obround is wide and short.\ncircle_diameter = y_size\nmiddle_rectangle_x = x_size - y_size\nmiddle_rectangle_y = y_size\ncircle_positive = Vector2D(x=middle_rectangle_x / 2, y=Offset.NULL)\ncircle_negative = Vector2D(x=-middle_rectangle_x / 2, y=Offset.NULL)\nwith handle:\nhandle.add_draw(\nbackend.get_draw_rectangle_cls()(\nbackend=backend,\nx_size=middle_rectangle_x,\ny_size=middle_rectangle_y,\npolarity=Polarity.Dark,\ncenter_position=Vector2D(x=Offset.NULL, y=Offset.NULL),\n),\n)\nhandle.add_draw(\nbackend.get_draw_circle_cls()(\nbackend=backend,\ndiameter=circle_diameter,\npolarity=Polarity.Dark,\ncenter_position=circle_positive,\n),\n)\nhandle.add_draw(\nbackend.get_draw_circle_cls()(\nbackend=backend,\ndiameter=circle_diameter,\npolarity=Polarity.Dark,\ncenter_position=circle_negative,\n),\n)\nif self.hole_diameter is not None:\nhandle.add_draw(\nbackend.get_draw_circle_cls()(\nbackend=backend,\ndiameter=Offset.new(self.hole_diameter, state.get_units()),\npolarity=Polarity.Clear,\ncenter_position=Vector2D(x=Offset.NULL, y=Offset.NULL),\n),\n)\nfrozen_handle = handle.get_public_handle()\nnew_aperture_dict = {**state.apertures}\nnew_aperture_dict[self.aperture_id] = frozen_handle\nreturn (\nstate.model_copy(\nupdate={\n\"apertures\": new_aperture_dict,\n},\n),\n(),\n)\ndef __str__(self) -&gt; str:\nsuffix = \"\"\nif self.hole_diameter is not None:\nsuffix += f\"X{self.hole_diameter}\"\nreturn f\"%AD{self.aperture_id}O,{self.x_size}X{self.y_size}{suffix}*%\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.html#pygerber.gerberx3.tokenizer.tokens.ad_define_aperture.DefineObround.from_tokens","title":"from_tokens  <code>classmethod</code>","text":"<pre><code>from_tokens(**tokens: Any) -&gt; Self\n</code></pre> <p>Initialize token object.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.py</code> <pre><code>@classmethod\ndef from_tokens(cls, **tokens: Any) -&gt; Self:\n\"\"\"Initialize token object.\"\"\"\naperture_id = ApertureID(tokens[\"aperture_identifier\"])\nx_size: Decimal = Decimal(tokens[\"x_size\"])\ny_size: Decimal = Decimal(tokens[\"y_size\"])\nhole_diameter: Optional[Decimal] = (\nDecimal(tokens[\"hole_diameter\"])\nif tokens.get(\"hole_diameter\") is not None\nelse None\n)\nreturn cls(\naperture_id=aperture_id,\nx_size=x_size,\ny_size=y_size,\nhole_diameter=hole_diameter,\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.html#pygerber.gerberx3.tokenizer.tokens.ad_define_aperture.DefineObround.update_drawing_state","title":"update_drawing_state","text":"<pre><code>update_drawing_state(\nstate: State, backend: Backend\n) -&gt; Tuple[State, Iterable[DrawCommand]]\n</code></pre> <p>Update drawing state.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.py</code> <pre><code>def update_drawing_state(\nself,\nstate: State,\nbackend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n\"\"\"Update drawing state.\"\"\"\nhandle = backend.create_aperture_handle(self.aperture_id)\nx_size = Offset.new(self.x_size, state.get_units())\ny_size = Offset.new(self.y_size, state.get_units())\nif self.x_size &lt; self.y_size:\n# Obround is thin and tall.\ncircle_diameter = x_size\nmiddle_rectangle_x = x_size\nmiddle_rectangle_y = y_size - x_size\ncircle_positive = Vector2D(x=Offset.NULL, y=middle_rectangle_y / 2)\ncircle_negative = Vector2D(x=Offset.NULL, y=-middle_rectangle_y / 2)\nelse:\n# Obround is wide and short.\ncircle_diameter = y_size\nmiddle_rectangle_x = x_size - y_size\nmiddle_rectangle_y = y_size\ncircle_positive = Vector2D(x=middle_rectangle_x / 2, y=Offset.NULL)\ncircle_negative = Vector2D(x=-middle_rectangle_x / 2, y=Offset.NULL)\nwith handle:\nhandle.add_draw(\nbackend.get_draw_rectangle_cls()(\nbackend=backend,\nx_size=middle_rectangle_x,\ny_size=middle_rectangle_y,\npolarity=Polarity.Dark,\ncenter_position=Vector2D(x=Offset.NULL, y=Offset.NULL),\n),\n)\nhandle.add_draw(\nbackend.get_draw_circle_cls()(\nbackend=backend,\ndiameter=circle_diameter,\npolarity=Polarity.Dark,\ncenter_position=circle_positive,\n),\n)\nhandle.add_draw(\nbackend.get_draw_circle_cls()(\nbackend=backend,\ndiameter=circle_diameter,\npolarity=Polarity.Dark,\ncenter_position=circle_negative,\n),\n)\nif self.hole_diameter is not None:\nhandle.add_draw(\nbackend.get_draw_circle_cls()(\nbackend=backend,\ndiameter=Offset.new(self.hole_diameter, state.get_units()),\npolarity=Polarity.Clear,\ncenter_position=Vector2D(x=Offset.NULL, y=Offset.NULL),\n),\n)\nfrozen_handle = handle.get_public_handle()\nnew_aperture_dict = {**state.apertures}\nnew_aperture_dict[self.aperture_id] = frozen_handle\nreturn (\nstate.model_copy(\nupdate={\n\"apertures\": new_aperture_dict,\n},\n),\n(),\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.html#pygerber.gerberx3.tokenizer.tokens.ad_define_aperture.DefinePolygon","title":"DefinePolygon","text":"<p>             Bases: <code>DefineAperture</code></p> <p>Wrapper for aperture definition token.</p> <p>Defines a polygon.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.py</code> <pre><code>class DefinePolygon(DefineAperture):\n\"\"\"Wrapper for aperture definition token.\n    Defines a polygon.\n    \"\"\"\naperture_id: ApertureID\nouter_diameter: Decimal\nnumber_of_vertices: int\nrotation: Optional[Decimal]\nhole_diameter: Optional[Decimal]\n@classmethod\ndef from_tokens(cls, **tokens: Any) -&gt; Self:\n\"\"\"Initialize token object.\"\"\"\naperture_id = ApertureID(tokens[\"aperture_identifier\"])\nouter_diameter: Decimal = Decimal(tokens[\"outer_diameter\"])\nnumber_of_vertices: int = int(tokens[\"number_of_vertices\"])\nrotation: Optional[Decimal] = (\nDecimal(tokens[\"rotation\"]) if tokens.get(\"rotation\") is not None else None\n)\nhole_diameter: Optional[Decimal] = (\nDecimal(tokens[\"hole_diameter\"])\nif tokens.get(\"hole_diameter\") is not None\nelse None\n)\nreturn cls(\naperture_id=aperture_id,\nouter_diameter=outer_diameter,\nnumber_of_vertices=number_of_vertices,\nrotation=rotation,\nhole_diameter=hole_diameter,\n)\ndef update_drawing_state(\nself,\nstate: State,\nbackend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n\"\"\"Update drawing state.\"\"\"\nhandle = backend.create_aperture_handle(self.aperture_id)\nwith handle:\nhandle.add_draw(\nbackend.get_draw_polygon_cls()(\nbackend=backend,\nouter_diameter=Offset.new(self.outer_diameter, state.get_units()),\nnumber_of_vertices=self.number_of_vertices,\nrotation=Decimal(\"0.0\") if self.rotation is None else self.rotation,\npolarity=Polarity.Dark,\ncenter_position=Vector2D(x=Offset.NULL, y=Offset.NULL),\n),\n)\nif self.hole_diameter is not None:\nhandle.add_draw(\nbackend.get_draw_circle_cls()(\nbackend=backend,\ndiameter=Offset.new(self.hole_diameter, state.get_units()),\npolarity=Polarity.Clear,\ncenter_position=Vector2D(x=Offset.NULL, y=Offset.NULL),\n),\n)\nfrozen_handle = handle.get_public_handle()\nnew_aperture_dict = {**state.apertures}\nnew_aperture_dict[self.aperture_id] = frozen_handle\nreturn (\nstate.model_copy(\nupdate={\n\"apertures\": new_aperture_dict,\n},\n),\n(),\n)\ndef __str__(self) -&gt; str:\nsuffix = \"\"\nif self.hole_diameter is not None:\nsuffix += f\"X{self.hole_diameter}\"\nreturn (\nf\"%AD{self.aperture_id}P,{self.outer_diameter}\"\nf\"X{self.number_of_vertices}X{self.rotation}{suffix}*%\"\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.html#pygerber.gerberx3.tokenizer.tokens.ad_define_aperture.DefinePolygon.from_tokens","title":"from_tokens  <code>classmethod</code>","text":"<pre><code>from_tokens(**tokens: Any) -&gt; Self\n</code></pre> <p>Initialize token object.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.py</code> <pre><code>@classmethod\ndef from_tokens(cls, **tokens: Any) -&gt; Self:\n\"\"\"Initialize token object.\"\"\"\naperture_id = ApertureID(tokens[\"aperture_identifier\"])\nouter_diameter: Decimal = Decimal(tokens[\"outer_diameter\"])\nnumber_of_vertices: int = int(tokens[\"number_of_vertices\"])\nrotation: Optional[Decimal] = (\nDecimal(tokens[\"rotation\"]) if tokens.get(\"rotation\") is not None else None\n)\nhole_diameter: Optional[Decimal] = (\nDecimal(tokens[\"hole_diameter\"])\nif tokens.get(\"hole_diameter\") is not None\nelse None\n)\nreturn cls(\naperture_id=aperture_id,\nouter_diameter=outer_diameter,\nnumber_of_vertices=number_of_vertices,\nrotation=rotation,\nhole_diameter=hole_diameter,\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.html#pygerber.gerberx3.tokenizer.tokens.ad_define_aperture.DefinePolygon.update_drawing_state","title":"update_drawing_state","text":"<pre><code>update_drawing_state(\nstate: State, backend: Backend\n) -&gt; Tuple[State, Iterable[DrawCommand]]\n</code></pre> <p>Update drawing state.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.py</code> <pre><code>def update_drawing_state(\nself,\nstate: State,\nbackend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n\"\"\"Update drawing state.\"\"\"\nhandle = backend.create_aperture_handle(self.aperture_id)\nwith handle:\nhandle.add_draw(\nbackend.get_draw_polygon_cls()(\nbackend=backend,\nouter_diameter=Offset.new(self.outer_diameter, state.get_units()),\nnumber_of_vertices=self.number_of_vertices,\nrotation=Decimal(\"0.0\") if self.rotation is None else self.rotation,\npolarity=Polarity.Dark,\ncenter_position=Vector2D(x=Offset.NULL, y=Offset.NULL),\n),\n)\nif self.hole_diameter is not None:\nhandle.add_draw(\nbackend.get_draw_circle_cls()(\nbackend=backend,\ndiameter=Offset.new(self.hole_diameter, state.get_units()),\npolarity=Polarity.Clear,\ncenter_position=Vector2D(x=Offset.NULL, y=Offset.NULL),\n),\n)\nfrozen_handle = handle.get_public_handle()\nnew_aperture_dict = {**state.apertures}\nnew_aperture_dict[self.aperture_id] = frozen_handle\nreturn (\nstate.model_copy(\nupdate={\n\"apertures\": new_aperture_dict,\n},\n),\n(),\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.html#pygerber.gerberx3.tokenizer.tokens.ad_define_aperture.DefineMacro","title":"DefineMacro","text":"<p>             Bases: <code>DefineAperture</code></p> <p>Wrapper for aperture definition token.</p> <p>Defines a macro based aperture.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.py</code> <pre><code>class DefineMacro(DefineAperture):\n\"\"\"Wrapper for aperture definition token.\n    Defines a macro based aperture.\n    \"\"\"\naperture_type: str\naperture_id: ApertureID\nam_param: List[str]\n@classmethod\ndef from_tokens(cls, **tokens: Any) -&gt; Self:\n\"\"\"Initialize token object.\"\"\"\naperture_type: str = tokens[\"aperture_type\"]\naperture_id = ApertureID(tokens[\"aperture_identifier\"])\nam_param: list[str] = tokens.get(\"am_param\", [])\nreturn cls(\naperture_type=aperture_type,\naperture_id=aperture_id,\nam_param=am_param,\n)\ndef update_drawing_state(\nself,\nstate: State,\nbackend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n\"\"\"Update drawing state.\"\"\"\nhandle = backend.create_aperture_handle(self.aperture_id)\nwith handle:\nmacro = state.macros[self.aperture_type]\nparameters = {\nf\"${i + 1}\": Offset.new(value, state.get_units())\nfor i, value in enumerate(self.am_param)\n}\nmacro.evaluate(state, handle, parameters)\nfrozen_handle = handle.get_public_handle()\nnew_aperture_dict = {**state.apertures}\nnew_aperture_dict[self.aperture_id] = frozen_handle\nreturn (\nstate.model_copy(\nupdate={\n\"apertures\": new_aperture_dict,\n},\n),\n(),\n)\ndef __str__(self) -&gt; str:\nreturn f\"%AD{self.aperture_id}{self.aperture_type},{'X'.join(self.am_param)}*%\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.html#pygerber.gerberx3.tokenizer.tokens.ad_define_aperture.DefineMacro.from_tokens","title":"from_tokens  <code>classmethod</code>","text":"<pre><code>from_tokens(**tokens: Any) -&gt; Self\n</code></pre> <p>Initialize token object.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.py</code> <pre><code>@classmethod\ndef from_tokens(cls, **tokens: Any) -&gt; Self:\n\"\"\"Initialize token object.\"\"\"\naperture_type: str = tokens[\"aperture_type\"]\naperture_id = ApertureID(tokens[\"aperture_identifier\"])\nam_param: list[str] = tokens.get(\"am_param\", [])\nreturn cls(\naperture_type=aperture_type,\naperture_id=aperture_id,\nam_param=am_param,\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.html#pygerber.gerberx3.tokenizer.tokens.ad_define_aperture.DefineMacro.update_drawing_state","title":"update_drawing_state","text":"<pre><code>update_drawing_state(\nstate: State, backend: Backend\n) -&gt; Tuple[State, Iterable[DrawCommand]]\n</code></pre> <p>Update drawing state.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.py</code> <pre><code>def update_drawing_state(\nself,\nstate: State,\nbackend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n\"\"\"Update drawing state.\"\"\"\nhandle = backend.create_aperture_handle(self.aperture_id)\nwith handle:\nmacro = state.macros[self.aperture_type]\nparameters = {\nf\"${i + 1}\": Offset.new(value, state.get_units())\nfor i, value in enumerate(self.am_param)\n}\nmacro.evaluate(state, handle, parameters)\nfrozen_handle = handle.get_public_handle()\nnew_aperture_dict = {**state.apertures}\nnew_aperture_dict[self.aperture_id] = frozen_handle\nreturn (\nstate.model_copy(\nupdate={\n\"apertures\": new_aperture_dict,\n},\n),\n(),\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/coordinate.html","title":"coordinate","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/coordinate.html#pygerber.gerberx3.tokenizer.tokens.coordinate","title":"coordinate","text":"<p>Coordinate wrapper class.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/coordinate.html#pygerber.gerberx3.tokenizer.tokens.coordinate._coordinate_type_to_missing_map","title":"_coordinate_type_to_missing_map  <code>module-attribute</code>","text":"<pre><code>_coordinate_type_to_missing_map = {\nCoordinateType.X: CoordinateType.MISSING_X,\nCoordinateType.Y: CoordinateType.MISSING_Y,\nCoordinateType.I: CoordinateType.MISSING_I,\nCoordinateType.J: CoordinateType.MISSING_J,\n}\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/coordinate.html#pygerber.gerberx3.tokenizer.tokens.coordinate.Coordinate","title":"Coordinate","text":"<p>             Bases: <code>FrozenGeneralModel</code></p> <p>Coordinate wrapper class.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/coordinate.py</code> <pre><code>class Coordinate(FrozenGeneralModel):\n\"\"\"Coordinate wrapper class.\"\"\"\ncoordinate_type: CoordinateType\nsign: CoordinateSign\noffset: str\n@classmethod\ndef new(cls, coordinate_type: CoordinateType, offset: Optional[str]) -&gt; Self:\n\"\"\"Create new Coordinate object.\"\"\"\nif offset is None:\ncoordinate_type = coordinate_type.to_missing()\noffset = \"\"\nsign = CoordinateSign.Positive\nelif len(offset) &gt; 0 and offset[0] in \"+-\":\nsign = CoordinateSign(offset[0])\noffset = offset[1:].ljust(1, \"0\")\nelse:\nsign = CoordinateSign.Positive\nreturn cls(coordinate_type=coordinate_type, sign=sign, offset=offset)\ndef __str__(self) -&gt; str:\nif self.coordinate_type.is_missing():\nreturn \"\"\nreturn f\"{self.coordinate_type}{self.sign}{self.offset}\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/coordinate.html#pygerber.gerberx3.tokenizer.tokens.coordinate.Coordinate.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(\ncoordinate_type: CoordinateType, offset: Optional[str]\n) -&gt; Self\n</code></pre> <p>Create new Coordinate object.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/coordinate.py</code> <pre><code>@classmethod\ndef new(cls, coordinate_type: CoordinateType, offset: Optional[str]) -&gt; Self:\n\"\"\"Create new Coordinate object.\"\"\"\nif offset is None:\ncoordinate_type = coordinate_type.to_missing()\noffset = \"\"\nsign = CoordinateSign.Positive\nelif len(offset) &gt; 0 and offset[0] in \"+-\":\nsign = CoordinateSign(offset[0])\noffset = offset[1:].ljust(1, \"0\")\nelse:\nsign = CoordinateSign.Positive\nreturn cls(coordinate_type=coordinate_type, sign=sign, offset=offset)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/coordinate.html#pygerber.gerberx3.tokenizer.tokens.coordinate.CoordinateType","title":"CoordinateType","text":"<p>             Bases: <code>Enum</code></p> <p>Type of coordinate axis/meaning.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/coordinate.py</code> <pre><code>class CoordinateType(Enum):\n\"\"\"Type of coordinate axis/meaning.\"\"\"\nX = \"X\"\nY = \"Y\"\nI = \"I\"  # noqa: E741\nJ = \"J\"\nNULL = \"\"\nMISSING_X = \"MISSING_X\"\nMISSING_Y = \"MISSING_Y\"\nMISSING_I = \"MISSING_I\"\nMISSING_J = \"MISSING_J\"\ndef to_missing(self) -&gt; CoordinateType:\n\"\"\"Map &lt;coordinate&gt; to MISSING_&lt;coordinate&gt;.\"\"\"\nreturn _coordinate_type_to_missing_map[self]\ndef is_missing(self) -&gt; bool:\n\"\"\"Check if coordinate is one of variants of missing coordinates.\"\"\"\nreturn self in (\nCoordinateType.MISSING_X,\nCoordinateType.MISSING_Y,\nCoordinateType.MISSING_I,\nCoordinateType.MISSING_J,\n)\ndef __str__(self) -&gt; str:\nreturn self.value\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/coordinate.html#pygerber.gerberx3.tokenizer.tokens.coordinate.CoordinateType.to_missing","title":"to_missing","text":"<pre><code>to_missing() -&gt; CoordinateType\n</code></pre> <p>Map  to MISSING_. Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/coordinate.py</code> <pre><code>def to_missing(self) -&gt; CoordinateType:\n\"\"\"Map &lt;coordinate&gt; to MISSING_&lt;coordinate&gt;.\"\"\"\nreturn _coordinate_type_to_missing_map[self]\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/coordinate.html#pygerber.gerberx3.tokenizer.tokens.coordinate.CoordinateType.is_missing","title":"is_missing","text":"<pre><code>is_missing() -&gt; bool\n</code></pre> <p>Check if coordinate is one of variants of missing coordinates.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/coordinate.py</code> <pre><code>def is_missing(self) -&gt; bool:\n\"\"\"Check if coordinate is one of variants of missing coordinates.\"\"\"\nreturn self in (\nCoordinateType.MISSING_X,\nCoordinateType.MISSING_Y,\nCoordinateType.MISSING_I,\nCoordinateType.MISSING_J,\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/coordinate.html#pygerber.gerberx3.tokenizer.tokens.coordinate.CoordinateSign","title":"CoordinateSign","text":"<p>             Bases: <code>Enum</code></p> <p>Coordinate sign.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/coordinate.py</code> <pre><code>class CoordinateSign(Enum):\n\"\"\"Coordinate sign.\"\"\"\nPositive = \"+\"\nNegative = \"-\"\ndef __str__(self) -&gt; str:\nreturn \"-\" if self == CoordinateSign.Negative else \"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/d01_draw.html","title":"d01_draw","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/d01_draw.html#pygerber.gerberx3.tokenizer.tokens.d01_draw","title":"d01_draw","text":"<p>Wrapper for plot operation token.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/d01_draw.html#pygerber.gerberx3.tokenizer.tokens.d01_draw.D01Draw","title":"D01Draw","text":"<p>             Bases: <code>Token</code></p> <p>Wrapper for plot operation token.</p> <p>Outside a region statement D01 creates a draw or arc object with the current aperture. Inside it adds a draw/arc segment to the contour under construction. The current point is moved to draw/arc end point after the creation of the draw/arc.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/d01_draw.py</code> <pre><code>class D01Draw(Token):\n\"\"\"Wrapper for plot operation token.\n    Outside a region statement D01 creates a draw or arc object with the current\n    aperture. Inside it adds a draw/arc segment to the contour under construction. The\n    current point is moved to draw/arc end point after the creation of the draw/arc.\n    \"\"\"\nx: Coordinate\ny: Coordinate\ni: Coordinate\nj: Coordinate\n@classmethod\ndef from_tokens(cls, **tokens: Any) -&gt; Self:\n\"\"\"Initialize token object.\"\"\"\nx = tokens.get(\"x\")\nx = Coordinate.new(coordinate_type=CoordinateType.X, offset=x)\ny = tokens.get(\"y\")\ny = Coordinate.new(coordinate_type=CoordinateType.Y, offset=y)\ni = tokens.get(\"i\")\ni = Coordinate.new(coordinate_type=CoordinateType.I, offset=i)\nj = tokens.get(\"j\")\nj = Coordinate.new(coordinate_type=CoordinateType.J, offset=j)\nreturn cls(x=x, y=y, i=i, j=j)\ndef update_drawing_state(\nself,\nstate: State,\nbackend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n\"\"\"Set coordinate parser.\"\"\"\nx = state.parse_coordinate(self.x)\ny = state.parse_coordinate(self.y)\nend_position = Vector2D(x=x, y=y)\nstart_position = state.current_position\ndraw_commands: list[DrawCommand] = []\ncurrent_aperture = backend.get_private_aperture_handle(\nstate.get_current_aperture(),\n)\nif state.is_region:\npolarity = state.polarity.to_region_variant()\nelse:\npolarity = state.polarity\ndraw_commands.append(\nbackend.get_draw_paste_cls()(\nbackend=backend,\npolarity=polarity,\ncenter_position=start_position,\nother=current_aperture.drawing_target,\n),\n)\nif state.draw_mode == DrawMode.Linear:\nif state.is_region:\nstate.region_boundary_points.append(start_position)\nstate.region_boundary_points.append(end_position)\ndraw_commands.append(\nbackend.get_draw_vector_line_cls()(\nbackend=backend,\npolarity=polarity,\nstart_position=start_position,\nend_position=end_position,\nwidth=current_aperture.get_line_width(),\n),\n)\nelif state.draw_mode in (\nDrawMode.ClockwiseCircular,\nDrawMode.CounterclockwiseCircular,\n):\ni = state.parse_coordinate(self.i)\nj = state.parse_coordinate(self.j)\ncenter_offset = Vector2D(x=i, y=j)\nif state.is_region:\nstate.region_boundary_points.append(start_position)\n# TODO(argmaster.world@gmail.com): Add region boundary points for region\n# https://github.com/Argmaster/pygerber/issues/29\nstate.region_boundary_points.append(end_position)\ndraw_commands.append(\nbackend.get_draw_arc_cls()(\nbackend=backend,\npolarity=polarity,\nstart_position=start_position,\ndx_dy_center=center_offset,\nend_position=end_position,\nwidth=current_aperture.get_line_width(),\nis_clockwise=(state.draw_mode == DrawMode.ClockwiseCircular),\n# Will require tweaking if support for single quadrant mode\n# will be desired.\nis_multi_quadrant=True,\n),\n)\nelse:\nraise NotImplementedError(state.draw_mode)\ndraw_commands.append(\nbackend.get_draw_paste_cls()(\nbackend=backend,\npolarity=polarity,\ncenter_position=end_position,\nother=current_aperture.drawing_target,\n),\n)\nif not state.is_region or backend.options.draw_region_outlines:\nreturn (\nstate.model_copy(\nupdate={\n\"current_position\": end_position,\n},\n),\ndraw_commands,\n)\nreturn (\nstate.model_copy(\nupdate={\n\"current_position\": end_position,\n},\n),\n(),\n)\ndef __str__(self) -&gt; str:\nreturn f\"{self.x}{self.y}{self.i}{self.j}D01*\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/d01_draw.html#pygerber.gerberx3.tokenizer.tokens.d01_draw.D01Draw.from_tokens","title":"from_tokens  <code>classmethod</code>","text":"<pre><code>from_tokens(**tokens: Any) -&gt; Self\n</code></pre> <p>Initialize token object.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/d01_draw.py</code> <pre><code>@classmethod\ndef from_tokens(cls, **tokens: Any) -&gt; Self:\n\"\"\"Initialize token object.\"\"\"\nx = tokens.get(\"x\")\nx = Coordinate.new(coordinate_type=CoordinateType.X, offset=x)\ny = tokens.get(\"y\")\ny = Coordinate.new(coordinate_type=CoordinateType.Y, offset=y)\ni = tokens.get(\"i\")\ni = Coordinate.new(coordinate_type=CoordinateType.I, offset=i)\nj = tokens.get(\"j\")\nj = Coordinate.new(coordinate_type=CoordinateType.J, offset=j)\nreturn cls(x=x, y=y, i=i, j=j)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/d01_draw.html#pygerber.gerberx3.tokenizer.tokens.d01_draw.D01Draw.update_drawing_state","title":"update_drawing_state","text":"<pre><code>update_drawing_state(\nstate: State, backend: Backend\n) -&gt; Tuple[State, Iterable[DrawCommand]]\n</code></pre> <p>Set coordinate parser.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/d01_draw.py</code> <pre><code>def update_drawing_state(\nself,\nstate: State,\nbackend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n\"\"\"Set coordinate parser.\"\"\"\nx = state.parse_coordinate(self.x)\ny = state.parse_coordinate(self.y)\nend_position = Vector2D(x=x, y=y)\nstart_position = state.current_position\ndraw_commands: list[DrawCommand] = []\ncurrent_aperture = backend.get_private_aperture_handle(\nstate.get_current_aperture(),\n)\nif state.is_region:\npolarity = state.polarity.to_region_variant()\nelse:\npolarity = state.polarity\ndraw_commands.append(\nbackend.get_draw_paste_cls()(\nbackend=backend,\npolarity=polarity,\ncenter_position=start_position,\nother=current_aperture.drawing_target,\n),\n)\nif state.draw_mode == DrawMode.Linear:\nif state.is_region:\nstate.region_boundary_points.append(start_position)\nstate.region_boundary_points.append(end_position)\ndraw_commands.append(\nbackend.get_draw_vector_line_cls()(\nbackend=backend,\npolarity=polarity,\nstart_position=start_position,\nend_position=end_position,\nwidth=current_aperture.get_line_width(),\n),\n)\nelif state.draw_mode in (\nDrawMode.ClockwiseCircular,\nDrawMode.CounterclockwiseCircular,\n):\ni = state.parse_coordinate(self.i)\nj = state.parse_coordinate(self.j)\ncenter_offset = Vector2D(x=i, y=j)\nif state.is_region:\nstate.region_boundary_points.append(start_position)\n# TODO(argmaster.world@gmail.com): Add region boundary points for region\n# https://github.com/Argmaster/pygerber/issues/29\nstate.region_boundary_points.append(end_position)\ndraw_commands.append(\nbackend.get_draw_arc_cls()(\nbackend=backend,\npolarity=polarity,\nstart_position=start_position,\ndx_dy_center=center_offset,\nend_position=end_position,\nwidth=current_aperture.get_line_width(),\nis_clockwise=(state.draw_mode == DrawMode.ClockwiseCircular),\n# Will require tweaking if support for single quadrant mode\n# will be desired.\nis_multi_quadrant=True,\n),\n)\nelse:\nraise NotImplementedError(state.draw_mode)\ndraw_commands.append(\nbackend.get_draw_paste_cls()(\nbackend=backend,\npolarity=polarity,\ncenter_position=end_position,\nother=current_aperture.drawing_target,\n),\n)\nif not state.is_region or backend.options.draw_region_outlines:\nreturn (\nstate.model_copy(\nupdate={\n\"current_position\": end_position,\n},\n),\ndraw_commands,\n)\nreturn (\nstate.model_copy(\nupdate={\n\"current_position\": end_position,\n},\n),\n(),\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/d02_move.html","title":"d02_move","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/d02_move.html#pygerber.gerberx3.tokenizer.tokens.d02_move","title":"d02_move","text":"<p>Wrapper for move operation token.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/d02_move.html#pygerber.gerberx3.tokenizer.tokens.d02_move.D02Move","title":"D02Move","text":"<p>             Bases: <code>Token</code></p> <p>Wrapper for move operation token.</p> <p>D02 moves the current point to the coordinate in the command. No graphical object is generated.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/d02_move.py</code> <pre><code>class D02Move(Token):\n\"\"\"Wrapper for move operation token.\n    D02 moves the current point to the coordinate in the command. No graphical object is\n    generated.\n    \"\"\"\nx: Coordinate\ny: Coordinate\n@classmethod\ndef from_tokens(cls, **tokens: Any) -&gt; Self:\n\"\"\"Initialize token object.\"\"\"\nx = tokens.get(\"x\", \"0\")\nx = Coordinate.new(coordinate_type=CoordinateType.X, offset=x)\ny = tokens.get(\"y\", \"0\")\ny = Coordinate.new(coordinate_type=CoordinateType.Y, offset=y)\nreturn cls(x=x, y=y)\ndef update_drawing_state(\nself,\nstate: State,\n_backend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n\"\"\"Set coordinate parser.\"\"\"\nx = state.parse_coordinate(self.x)\ny = state.parse_coordinate(self.y)\nposition = Vector2D(x=x, y=y)\nreturn (\nstate.model_copy(\nupdate={\n\"current_position\": position,\n},\n),\n(),\n)\ndef __str__(self) -&gt; str:\nreturn f\"{self.x}{self.y}D02*\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/d02_move.html#pygerber.gerberx3.tokenizer.tokens.d02_move.D02Move.from_tokens","title":"from_tokens  <code>classmethod</code>","text":"<pre><code>from_tokens(**tokens: Any) -&gt; Self\n</code></pre> <p>Initialize token object.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/d02_move.py</code> <pre><code>@classmethod\ndef from_tokens(cls, **tokens: Any) -&gt; Self:\n\"\"\"Initialize token object.\"\"\"\nx = tokens.get(\"x\", \"0\")\nx = Coordinate.new(coordinate_type=CoordinateType.X, offset=x)\ny = tokens.get(\"y\", \"0\")\ny = Coordinate.new(coordinate_type=CoordinateType.Y, offset=y)\nreturn cls(x=x, y=y)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/d02_move.html#pygerber.gerberx3.tokenizer.tokens.d02_move.D02Move.update_drawing_state","title":"update_drawing_state","text":"<pre><code>update_drawing_state(\nstate: State, _backend: Backend\n) -&gt; Tuple[State, Iterable[DrawCommand]]\n</code></pre> <p>Set coordinate parser.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/d02_move.py</code> <pre><code>def update_drawing_state(\nself,\nstate: State,\n_backend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n\"\"\"Set coordinate parser.\"\"\"\nx = state.parse_coordinate(self.x)\ny = state.parse_coordinate(self.y)\nposition = Vector2D(x=x, y=y)\nreturn (\nstate.model_copy(\nupdate={\n\"current_position\": position,\n},\n),\n(),\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/d03_flash.html","title":"d03_flash","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/d03_flash.html#pygerber.gerberx3.tokenizer.tokens.d03_flash","title":"d03_flash","text":"<p>Wrapper for flash operation token.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/d03_flash.html#pygerber.gerberx3.tokenizer.tokens.d03_flash.D03Flash","title":"D03Flash","text":"<p>             Bases: <code>Token</code></p> <p>Wrapper for flash operation token.</p> <p>Creates a flash object with the current aperture. The current point is moved to the flash point.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/d03_flash.py</code> <pre><code>class D03Flash(Token):\n\"\"\"Wrapper for flash operation token.\n    Creates a flash object with the current aperture. The current point is moved to the\n    flash point.\n    \"\"\"\nx: Coordinate\ny: Coordinate\n@classmethod\ndef from_tokens(cls, **tokens: Any) -&gt; Self:\n\"\"\"Initialize token object.\"\"\"\nx = tokens.get(\"x\", \"0\")\nx = Coordinate.new(coordinate_type=CoordinateType.X, offset=x)\ny = tokens.get(\"y\", \"0\")\ny = Coordinate.new(coordinate_type=CoordinateType.Y, offset=y)\nreturn cls(x=x, y=y)\ndef update_drawing_state(\nself,\nstate: State,\nbackend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n\"\"\"Set coordinate parser.\"\"\"\nx = state.parse_coordinate(self.x)\ny = state.parse_coordinate(self.y)\nposition = Vector2D(x=x, y=y)\ndraw_commands: list[DrawCommand] = []\ncurrent_aperture = backend.get_private_aperture_handle(\nstate.get_current_aperture(),\n)\nif state.is_region:\npolarity = state.polarity.to_region_variant()\nelse:\npolarity = state.polarity\ndraw_commands.append(\nbackend.get_draw_paste_cls()(\nbackend=backend,\npolarity=polarity,\ncenter_position=position,\nother=current_aperture.drawing_target,\n),\n)\nreturn (\nstate.model_copy(\nupdate={\n\"current_position\": position,\n},\n),\ndraw_commands,\n)\ndef __str__(self) -&gt; str:\nreturn f\"{self.x}{self.y}D03*\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/d03_flash.html#pygerber.gerberx3.tokenizer.tokens.d03_flash.D03Flash.from_tokens","title":"from_tokens  <code>classmethod</code>","text":"<pre><code>from_tokens(**tokens: Any) -&gt; Self\n</code></pre> <p>Initialize token object.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/d03_flash.py</code> <pre><code>@classmethod\ndef from_tokens(cls, **tokens: Any) -&gt; Self:\n\"\"\"Initialize token object.\"\"\"\nx = tokens.get(\"x\", \"0\")\nx = Coordinate.new(coordinate_type=CoordinateType.X, offset=x)\ny = tokens.get(\"y\", \"0\")\ny = Coordinate.new(coordinate_type=CoordinateType.Y, offset=y)\nreturn cls(x=x, y=y)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/d03_flash.html#pygerber.gerberx3.tokenizer.tokens.d03_flash.D03Flash.update_drawing_state","title":"update_drawing_state","text":"<pre><code>update_drawing_state(\nstate: State, backend: Backend\n) -&gt; Tuple[State, Iterable[DrawCommand]]\n</code></pre> <p>Set coordinate parser.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/d03_flash.py</code> <pre><code>def update_drawing_state(\nself,\nstate: State,\nbackend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n\"\"\"Set coordinate parser.\"\"\"\nx = state.parse_coordinate(self.x)\ny = state.parse_coordinate(self.y)\nposition = Vector2D(x=x, y=y)\ndraw_commands: list[DrawCommand] = []\ncurrent_aperture = backend.get_private_aperture_handle(\nstate.get_current_aperture(),\n)\nif state.is_region:\npolarity = state.polarity.to_region_variant()\nelse:\npolarity = state.polarity\ndraw_commands.append(\nbackend.get_draw_paste_cls()(\nbackend=backend,\npolarity=polarity,\ncenter_position=position,\nother=current_aperture.drawing_target,\n),\n)\nreturn (\nstate.model_copy(\nupdate={\n\"current_position\": position,\n},\n),\ndraw_commands,\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/dnn_select_aperture.html","title":"dnn_select_aperture","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/dnn_select_aperture.html#pygerber.gerberx3.tokenizer.tokens.dnn_select_aperture","title":"dnn_select_aperture","text":"<p>Wrapper for aperture select token.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/dnn_select_aperture.html#pygerber.gerberx3.tokenizer.tokens.dnn_select_aperture.DNNSelectAperture","title":"DNNSelectAperture","text":"<p>             Bases: <code>Token</code></p> <p>Wrapper for aperture select token.</p> <p>Sets the current aperture to D code NN (NN \u2265 10).</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/dnn_select_aperture.py</code> <pre><code>class DNNSelectAperture(Token):\n\"\"\"Wrapper for aperture select token.\n    Sets the current aperture to D code NN (NN \u2265 10).\n    \"\"\"\naperture_id: ApertureID\n@classmethod\ndef from_tokens(cls, **tokens: Any) -&gt; Self:\n\"\"\"Initialize token object.\"\"\"\naperture_id: ApertureID = tokens[\"aperture_identifier\"]\nreturn cls(aperture_id=aperture_id)\ndef update_drawing_state(\nself,\nstate: State,\n_backend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n\"\"\"Set current aperture.\"\"\"\nif self.aperture_id not in state.apertures:\nraise ApertureNotDefinedError(self.aperture_id)\nreturn (\nstate.model_copy(\nupdate={\n\"current_aperture\": state.apertures[self.aperture_id],\n},\n),\n(),\n)\ndef __str__(self) -&gt; str:\nreturn f\"{self.aperture_id}*\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/dnn_select_aperture.html#pygerber.gerberx3.tokenizer.tokens.dnn_select_aperture.DNNSelectAperture.from_tokens","title":"from_tokens  <code>classmethod</code>","text":"<pre><code>from_tokens(**tokens: Any) -&gt; Self\n</code></pre> <p>Initialize token object.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/dnn_select_aperture.py</code> <pre><code>@classmethod\ndef from_tokens(cls, **tokens: Any) -&gt; Self:\n\"\"\"Initialize token object.\"\"\"\naperture_id: ApertureID = tokens[\"aperture_identifier\"]\nreturn cls(aperture_id=aperture_id)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/dnn_select_aperture.html#pygerber.gerberx3.tokenizer.tokens.dnn_select_aperture.DNNSelectAperture.update_drawing_state","title":"update_drawing_state","text":"<pre><code>update_drawing_state(\nstate: State, _backend: Backend\n) -&gt; Tuple[State, Iterable[DrawCommand]]\n</code></pre> <p>Set current aperture.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/dnn_select_aperture.py</code> <pre><code>def update_drawing_state(\nself,\nstate: State,\n_backend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n\"\"\"Set current aperture.\"\"\"\nif self.aperture_id not in state.apertures:\nraise ApertureNotDefinedError(self.aperture_id)\nreturn (\nstate.model_copy(\nupdate={\n\"current_aperture\": state.apertures[self.aperture_id],\n},\n),\n(),\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/dnn_select_aperture.html#pygerber.gerberx3.tokenizer.tokens.dnn_select_aperture.ApertureID","title":"ApertureID","text":"<p>             Bases: <code>str</code></p> <p>Aperture ID wrapper.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/dnn_select_aperture.py</code> <pre><code>class ApertureID(str):\n\"\"\"Aperture ID wrapper.\"\"\"\n__slots__ = ()\n@classmethod\ndef __get_pydantic_core_schema__(\ncls,\nsource_type: Any,\nhandler: GetCoreSchemaHandler,\n) -&gt; CoreSchema:\n\"\"\"Generate the pydantic-core schema.\"\"\"\nreturn core_schema.no_info_after_validator_function(cls, handler(str))\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/dnn_select_aperture.html#pygerber.gerberx3.tokenizer.tokens.dnn_select_aperture.ApertureID.__get_pydantic_core_schema__","title":"__get_pydantic_core_schema__  <code>classmethod</code>","text":"<pre><code>__get_pydantic_core_schema__(\nsource_type: Any, handler: GetCoreSchemaHandler\n) -&gt; CoreSchema\n</code></pre> <p>Generate the pydantic-core schema.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/dnn_select_aperture.py</code> <pre><code>@classmethod\ndef __get_pydantic_core_schema__(\ncls,\nsource_type: Any,\nhandler: GetCoreSchemaHandler,\n) -&gt; CoreSchema:\n\"\"\"Generate the pydantic-core schema.\"\"\"\nreturn core_schema.no_info_after_validator_function(cls, handler(str))\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/fs_coordinate_format.html","title":"fs_coordinate_format","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/fs_coordinate_format.html#pygerber.gerberx3.tokenizer.tokens.fs_coordinate_format","title":"fs_coordinate_format","text":"<p>Coordinate format token.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/fs_coordinate_format.html#pygerber.gerberx3.tokenizer.tokens.fs_coordinate_format.RECOMMENDED_MINIMAL_DECIMAL_PLACES","title":"RECOMMENDED_MINIMAL_DECIMAL_PLACES  <code>module-attribute</code>","text":"<pre><code>RECOMMENDED_MINIMAL_DECIMAL_PLACES = 5\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/fs_coordinate_format.html#pygerber.gerberx3.tokenizer.tokens.fs_coordinate_format.CoordinateFormat","title":"CoordinateFormat","text":"<p>             Bases: <code>Token</code></p> <p>Description of coordinate format token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/fs_coordinate_format.py</code> <pre><code>class CoordinateFormat(Token):\n\"\"\"Description of coordinate format token.\"\"\"\nzeros_mode: TrailingZerosMode\ncoordinate_mode: CoordinateMode\nx_format: AxisFormat\ny_format: AxisFormat\n@classmethod\ndef from_tokens(cls, **tokens: Any) -&gt; Self:\n\"\"\"Initialize token object.\"\"\"\nzeros_mode = TrailingZerosMode(tokens[\"zeros_mode\"])\ncoordinate_mode = CoordinateMode(tokens[\"coordinate_mode\"])\nx_format = AxisFormat(\ninteger=int(tokens[\"x_format\"][0]),\ndecimal=int(tokens[\"x_format\"][1]),\n)\ny_format = AxisFormat(\ninteger=int(tokens[\"y_format\"][0]),\ndecimal=int(tokens[\"y_format\"][1]),\n)\nreturn cls(\nzeros_mode=zeros_mode,\ncoordinate_mode=coordinate_mode,\nx_format=x_format,\ny_format=y_format,\n)\ndef update_drawing_state(\nself,\nstate: State,\n_backend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n\"\"\"Set coordinate parser.\"\"\"\nif state.coordinate_parser is not None:\nlogging.warning(\n\"Overriding coordinate format is illegal.\"\n\"(See 4.2.2 in Gerber Layer Format Specification)\",\n)\nreturn (\nstate.model_copy(\nupdate={\n\"coordinate_parser\": CoordinateParser.new(\nx_format=self.x_format,\ny_format=self.y_format,\n),\n},\n),\n(),\n)\ndef __str__(self) -&gt; str:\nreturn (\nf\"%FS{self.zeros_mode}{self.coordinate_mode}\"\nf\"X{self.x_format}Y{self.y_format}*%\"\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/fs_coordinate_format.html#pygerber.gerberx3.tokenizer.tokens.fs_coordinate_format.CoordinateFormat.from_tokens","title":"from_tokens  <code>classmethod</code>","text":"<pre><code>from_tokens(**tokens: Any) -&gt; Self\n</code></pre> <p>Initialize token object.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/fs_coordinate_format.py</code> <pre><code>@classmethod\ndef from_tokens(cls, **tokens: Any) -&gt; Self:\n\"\"\"Initialize token object.\"\"\"\nzeros_mode = TrailingZerosMode(tokens[\"zeros_mode\"])\ncoordinate_mode = CoordinateMode(tokens[\"coordinate_mode\"])\nx_format = AxisFormat(\ninteger=int(tokens[\"x_format\"][0]),\ndecimal=int(tokens[\"x_format\"][1]),\n)\ny_format = AxisFormat(\ninteger=int(tokens[\"y_format\"][0]),\ndecimal=int(tokens[\"y_format\"][1]),\n)\nreturn cls(\nzeros_mode=zeros_mode,\ncoordinate_mode=coordinate_mode,\nx_format=x_format,\ny_format=y_format,\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/fs_coordinate_format.html#pygerber.gerberx3.tokenizer.tokens.fs_coordinate_format.CoordinateFormat.update_drawing_state","title":"update_drawing_state","text":"<pre><code>update_drawing_state(\nstate: State, _backend: Backend\n) -&gt; Tuple[State, Iterable[DrawCommand]]\n</code></pre> <p>Set coordinate parser.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/fs_coordinate_format.py</code> <pre><code>def update_drawing_state(\nself,\nstate: State,\n_backend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n\"\"\"Set coordinate parser.\"\"\"\nif state.coordinate_parser is not None:\nlogging.warning(\n\"Overriding coordinate format is illegal.\"\n\"(See 4.2.2 in Gerber Layer Format Specification)\",\n)\nreturn (\nstate.model_copy(\nupdate={\n\"coordinate_parser\": CoordinateParser.new(\nx_format=self.x_format,\ny_format=self.y_format,\n),\n},\n),\n(),\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/fs_coordinate_format.html#pygerber.gerberx3.tokenizer.tokens.fs_coordinate_format.TrailingZerosMode","title":"TrailingZerosMode","text":"<p>             Bases: <code>Enum</code></p> <p>Coordinate format mode.</p> <p>GerberX3 supports only one, L, the other is required for backwards compatibility.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/fs_coordinate_format.py</code> <pre><code>class TrailingZerosMode(Enum):\n\"\"\"Coordinate format mode.\n    GerberX3 supports only one, L, the other is required for backwards compatibility.\n    \"\"\"\nOmitLeading = \"L\"\nOmitTrailing = \"T\"\ndef __str__(self) -&gt; str:\nreturn self.value\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/fs_coordinate_format.html#pygerber.gerberx3.tokenizer.tokens.fs_coordinate_format.CoordinateMode","title":"CoordinateMode","text":"<p>             Bases: <code>Enum</code></p> <p>Coordinate format mode.</p> <p>GerberX3 supports only one, A, the other required for backwards compatibility.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/fs_coordinate_format.py</code> <pre><code>class CoordinateMode(Enum):\n\"\"\"Coordinate format mode.\n    GerberX3 supports only one, A, the other required for backwards compatibility.\n    \"\"\"\nAbsolute = \"A\"\nIncremental = \"I\"\ndef __str__(self) -&gt; str:\nreturn self.value\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/fs_coordinate_format.html#pygerber.gerberx3.tokenizer.tokens.fs_coordinate_format.AxisFormat","title":"AxisFormat","text":"<p>             Bases: <code>FrozenGeneralModel</code></p> <p>Wrapper for single axis format.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/fs_coordinate_format.py</code> <pre><code>class AxisFormat(FrozenGeneralModel):\n\"\"\"Wrapper for single axis format.\"\"\"\ninteger: int\ndecimal: int\n@property\ndef total_length(self) -&gt; int:\n\"\"\"Total format length.\"\"\"\nreturn self.integer + self.decimal\ndef __str__(self) -&gt; str:\nreturn f\"{self.integer}{self.decimal}\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/fs_coordinate_format.html#pygerber.gerberx3.tokenizer.tokens.fs_coordinate_format.AxisFormat.total_length","title":"total_length  <code>property</code>","text":"<pre><code>total_length: int\n</code></pre> <p>Total format length.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/fs_coordinate_format.html#pygerber.gerberx3.tokenizer.tokens.fs_coordinate_format.CoordinateParser","title":"CoordinateParser","text":"<p>             Bases: <code>FrozenGeneralModel</code></p> <p>Coordinate Parser class.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/fs_coordinate_format.py</code> <pre><code>class CoordinateParser(FrozenGeneralModel):\n\"\"\"Coordinate Parser class.\"\"\"\nx_format: AxisFormat\ny_format: AxisFormat\n@classmethod\ndef new(\ncls,\nx_format: AxisFormat,\ny_format: AxisFormat,\ncoordinate_mode: CoordinateMode = CoordinateMode.Absolute,\nzeros_mode: TrailingZerosMode = TrailingZerosMode.OmitLeading,\n) -&gt; Self:\n\"\"\"Update coordinate parser format configuration.\"\"\"\nif coordinate_mode != CoordinateMode.Absolute:\nraise IncrementalCoordinatesNotSupportedError\nif zeros_mode != TrailingZerosMode.OmitLeading:\nraise ZeroOmissionNotSupportedError\nfor axis, axis_format in ((\"X\", x_format), (\"Y\", y_format)):\nif axis_format.decimal &lt; RECOMMENDED_MINIMAL_DECIMAL_PLACES:\nlogging.warning(\n\"It is recommended to use at least 5 decimal places for coordinate \"\n\"data when using metric units and 6 decimal places for imperial \"\n\"units. (Detected for %s)\"\n\"(See 4.2.2 in Gerber Layer Format Specification)\",\naxis,\n)\nreturn cls(x_format=x_format, y_format=y_format)\ndef parse(self, coordinate: Coordinate) -&gt; Decimal:\n\"\"\"Parse raw coordinate data.\"\"\"\nif coordinate.coordinate_type in (CoordinateType.X, CoordinateType.I):\nreturn self._parse(self.x_format, coordinate.offset, coordinate.sign)\nif coordinate.coordinate_type in (CoordinateType.Y, CoordinateType.J):\nreturn self._parse(self.y_format, coordinate.offset, coordinate.sign)\nraise UnsupportedCoordinateTypeError(coordinate.coordinate_type)\ndef _parse(\nself,\naxis_format: AxisFormat,\noffset: str,\nsign: CoordinateSign,\n) -&gt; Decimal:\ntotal_length = axis_format.total_length\nif len(offset) &gt; total_length:\nmsg = f\"Got {offset!r} with length {len(offset)} expected {total_length}.\"\nraise InvalidCoordinateLengthError(msg)\noffset = offset.rjust(axis_format.total_length, \"0\")\ninteger, decimal = offset[: axis_format.integer], offset[axis_format.integer :]\nreturn Decimal(f\"{sign.value}{integer}.{decimal}\")\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/fs_coordinate_format.html#pygerber.gerberx3.tokenizer.tokens.fs_coordinate_format.CoordinateParser.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(\nx_format: AxisFormat,\ny_format: AxisFormat,\ncoordinate_mode: CoordinateMode = CoordinateMode.Absolute,\nzeros_mode: TrailingZerosMode = TrailingZerosMode.OmitLeading,\n) -&gt; Self\n</code></pre> <p>Update coordinate parser format configuration.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/fs_coordinate_format.py</code> <pre><code>@classmethod\ndef new(\ncls,\nx_format: AxisFormat,\ny_format: AxisFormat,\ncoordinate_mode: CoordinateMode = CoordinateMode.Absolute,\nzeros_mode: TrailingZerosMode = TrailingZerosMode.OmitLeading,\n) -&gt; Self:\n\"\"\"Update coordinate parser format configuration.\"\"\"\nif coordinate_mode != CoordinateMode.Absolute:\nraise IncrementalCoordinatesNotSupportedError\nif zeros_mode != TrailingZerosMode.OmitLeading:\nraise ZeroOmissionNotSupportedError\nfor axis, axis_format in ((\"X\", x_format), (\"Y\", y_format)):\nif axis_format.decimal &lt; RECOMMENDED_MINIMAL_DECIMAL_PLACES:\nlogging.warning(\n\"It is recommended to use at least 5 decimal places for coordinate \"\n\"data when using metric units and 6 decimal places for imperial \"\n\"units. (Detected for %s)\"\n\"(See 4.2.2 in Gerber Layer Format Specification)\",\naxis,\n)\nreturn cls(x_format=x_format, y_format=y_format)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/fs_coordinate_format.html#pygerber.gerberx3.tokenizer.tokens.fs_coordinate_format.CoordinateParser.parse","title":"parse","text":"<pre><code>parse(coordinate: Coordinate) -&gt; Decimal\n</code></pre> <p>Parse raw coordinate data.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/fs_coordinate_format.py</code> <pre><code>def parse(self, coordinate: Coordinate) -&gt; Decimal:\n\"\"\"Parse raw coordinate data.\"\"\"\nif coordinate.coordinate_type in (CoordinateType.X, CoordinateType.I):\nreturn self._parse(self.x_format, coordinate.offset, coordinate.sign)\nif coordinate.coordinate_type in (CoordinateType.Y, CoordinateType.J):\nreturn self._parse(self.y_format, coordinate.offset, coordinate.sign)\nraise UnsupportedCoordinateTypeError(coordinate.coordinate_type)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g01_set_linear.html","title":"g01_set_linear","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g01_set_linear.html#pygerber.gerberx3.tokenizer.tokens.g01_set_linear","title":"g01_set_linear","text":"<p>Wrapper for G01 mode set token.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g01_set_linear.html#pygerber.gerberx3.tokenizer.tokens.g01_set_linear.SetLinear","title":"SetLinear","text":"<p>             Bases: <code>Token</code></p> <p>Wrapper for G01 mode set token.</p> <p>Sets linear/circular mode to linear.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/g01_set_linear.py</code> <pre><code>class SetLinear(Token):\n\"\"\"Wrapper for G01 mode set token.\n    Sets linear/circular mode to linear.\n    \"\"\"\ndef update_drawing_state(\nself,\nstate: State,\n_backend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n\"\"\"Set drawing mode.\"\"\"\nreturn (\nstate.model_copy(\nupdate={\n\"draw_mode\": DrawMode.Linear,\n},\n),\n(),\n)\ndef __str__(self) -&gt; str:\nreturn \"G01*\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g01_set_linear.html#pygerber.gerberx3.tokenizer.tokens.g01_set_linear.SetLinear.update_drawing_state","title":"update_drawing_state","text":"<pre><code>update_drawing_state(\nstate: State, _backend: Backend\n) -&gt; Tuple[State, Iterable[DrawCommand]]\n</code></pre> <p>Set drawing mode.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/g01_set_linear.py</code> <pre><code>def update_drawing_state(\nself,\nstate: State,\n_backend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n\"\"\"Set drawing mode.\"\"\"\nreturn (\nstate.model_copy(\nupdate={\n\"draw_mode\": DrawMode.Linear,\n},\n),\n(),\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g02_set_clockwise_circular.html","title":"g02_set_clockwise_circular","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g02_set_clockwise_circular.html#pygerber.gerberx3.tokenizer.tokens.g02_set_clockwise_circular","title":"g02_set_clockwise_circular","text":"<p>Wrapper for G01 mode set token.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g02_set_clockwise_circular.html#pygerber.gerberx3.tokenizer.tokens.g02_set_clockwise_circular.SetClockwiseCircular","title":"SetClockwiseCircular","text":"<p>             Bases: <code>Token</code></p> <p>Wrapper for G02 mode set token.</p> <p>Sets linear/circular mode to clockwise circular.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/g02_set_clockwise_circular.py</code> <pre><code>class SetClockwiseCircular(Token):\n\"\"\"Wrapper for G02 mode set token.\n    Sets linear/circular mode to clockwise circular.\n    \"\"\"\ndef update_drawing_state(\nself,\nstate: State,\n_backend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n\"\"\"Set drawing mode.\"\"\"\nreturn (\nstate.model_copy(\nupdate={\n\"draw_mode\": DrawMode.ClockwiseCircular,\n},\n),\n(),\n)\ndef __str__(self) -&gt; str:\nreturn \"G02*\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g02_set_clockwise_circular.html#pygerber.gerberx3.tokenizer.tokens.g02_set_clockwise_circular.SetClockwiseCircular.update_drawing_state","title":"update_drawing_state","text":"<pre><code>update_drawing_state(\nstate: State, _backend: Backend\n) -&gt; Tuple[State, Iterable[DrawCommand]]\n</code></pre> <p>Set drawing mode.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/g02_set_clockwise_circular.py</code> <pre><code>def update_drawing_state(\nself,\nstate: State,\n_backend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n\"\"\"Set drawing mode.\"\"\"\nreturn (\nstate.model_copy(\nupdate={\n\"draw_mode\": DrawMode.ClockwiseCircular,\n},\n),\n(),\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g03_set_counterclockwise_circular.html","title":"g03_set_counterclockwise_circular","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g03_set_counterclockwise_circular.html#pygerber.gerberx3.tokenizer.tokens.g03_set_counterclockwise_circular","title":"g03_set_counterclockwise_circular","text":"<p>Wrapper for G01 mode set token.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g03_set_counterclockwise_circular.html#pygerber.gerberx3.tokenizer.tokens.g03_set_counterclockwise_circular.SetCounterclockwiseCircular","title":"SetCounterclockwiseCircular","text":"<p>             Bases: <code>Token</code></p> <p>Wrapper for G03 mode set token.</p> <p>Sets linear/circular mode to counterclockwise circular.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/g03_set_counterclockwise_circular.py</code> <pre><code>class SetCounterclockwiseCircular(Token):\n\"\"\"Wrapper for G03 mode set token.\n    Sets linear/circular mode to counterclockwise circular.\n    \"\"\"\ndef update_drawing_state(\nself,\nstate: State,\n_backend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n\"\"\"Set drawing mode.\"\"\"\nreturn (\nstate.model_copy(\nupdate={\n\"draw_mode\": DrawMode.CounterclockwiseCircular,\n},\n),\n(),\n)\ndef __str__(self) -&gt; str:\nreturn \"G03*\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g03_set_counterclockwise_circular.html#pygerber.gerberx3.tokenizer.tokens.g03_set_counterclockwise_circular.SetCounterclockwiseCircular.update_drawing_state","title":"update_drawing_state","text":"<pre><code>update_drawing_state(\nstate: State, _backend: Backend\n) -&gt; Tuple[State, Iterable[DrawCommand]]\n</code></pre> <p>Set drawing mode.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/g03_set_counterclockwise_circular.py</code> <pre><code>def update_drawing_state(\nself,\nstate: State,\n_backend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n\"\"\"Set drawing mode.\"\"\"\nreturn (\nstate.model_copy(\nupdate={\n\"draw_mode\": DrawMode.CounterclockwiseCircular,\n},\n),\n(),\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g04_comment.html","title":"g04_comment","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g04_comment.html#pygerber.gerberx3.tokenizer.tokens.g04_comment","title":"g04_comment","text":"<p>Comment token.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g04_comment.html#pygerber.gerberx3.tokenizer.tokens.g04_comment.Comment","title":"Comment","text":"<p>             Bases: <code>Expression</code></p> <p>Comment token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/g04_comment.py</code> <pre><code>class Comment(Expression):\n\"\"\"Comment token.\"\"\"\ncontent: str\n@classmethod\ndef from_tokens(cls, **tokens: Any) -&gt; Self:\n\"\"\"Initialize token object.\"\"\"\ncontent: str = tokens[\"string\"]\nreturn cls(content=content)\ndef __str__(self) -&gt; str:\nreturn f\"G04 {self.content}*\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g04_comment.html#pygerber.gerberx3.tokenizer.tokens.g04_comment.Comment.from_tokens","title":"from_tokens  <code>classmethod</code>","text":"<pre><code>from_tokens(**tokens: Any) -&gt; Self\n</code></pre> <p>Initialize token object.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/g04_comment.py</code> <pre><code>@classmethod\ndef from_tokens(cls, **tokens: Any) -&gt; Self:\n\"\"\"Initialize token object.\"\"\"\ncontent: str = tokens[\"string\"]\nreturn cls(content=content)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g3n_region.html","title":"g3n_region","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g3n_region.html#pygerber.gerberx3.tokenizer.tokens.g3n_region","title":"g3n_region","text":"<p>Wrapper for aperture select token.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g3n_region.html#pygerber.gerberx3.tokenizer.tokens.g3n_region.BeginRegion","title":"BeginRegion","text":"<p>             Bases: <code>Token</code></p> <p>Wrapper for G36 token.</p> <p>Starts a region statement which creates a region by defining its contours.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/g3n_region.py</code> <pre><code>class BeginRegion(Token):\n\"\"\"Wrapper for G36 token.\n    Starts a region statement which creates a region by defining its contours.\n    \"\"\"\ndef update_drawing_state(\nself,\nstate: State,\n_backend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n\"\"\"Set drawing polarity.\"\"\"\nif state.is_region:\nlogging.warning(\"Starting region within a region is not allowed.\")\nreturn (\nstate.model_copy(\nupdate={\n\"is_region\": True,\n\"region_boundary_points\": [],\n},\n),\n(),\n)\ndef __str__(self) -&gt; str:\nreturn \"G36*\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g3n_region.html#pygerber.gerberx3.tokenizer.tokens.g3n_region.BeginRegion.update_drawing_state","title":"update_drawing_state","text":"<pre><code>update_drawing_state(\nstate: State, _backend: Backend\n) -&gt; Tuple[State, Iterable[DrawCommand]]\n</code></pre> <p>Set drawing polarity.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/g3n_region.py</code> <pre><code>def update_drawing_state(\nself,\nstate: State,\n_backend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n\"\"\"Set drawing polarity.\"\"\"\nif state.is_region:\nlogging.warning(\"Starting region within a region is not allowed.\")\nreturn (\nstate.model_copy(\nupdate={\n\"is_region\": True,\n\"region_boundary_points\": [],\n},\n),\n(),\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g3n_region.html#pygerber.gerberx3.tokenizer.tokens.g3n_region.EndRegion","title":"EndRegion","text":"<p>             Bases: <code>Token</code></p> <p>Wrapper for G37 token.</p> <p>Ends the region statement.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/g3n_region.py</code> <pre><code>class EndRegion(Token):\n\"\"\"Wrapper for G37 token.\n    Ends the region statement.\n    \"\"\"\ndef update_drawing_state(\nself,\nstate: State,\nbackend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n\"\"\"Set drawing polarity.\"\"\"\nif not state.is_region:\nlogging.warning(\"Ending region which was not started.\")\nif len(state.region_boundary_points) == 0:\nlogging.warning(\"Created region with no boundaries.\")\ndraw_command = backend.get_draw_region_cls()(\nbackend,\nstate.polarity.to_region_variant(),\nstate.region_boundary_points,\n)\nreturn (\nstate.model_copy(\nupdate={\n\"is_region\": False,\n\"region_boundary_points\": [],\n},\n),\n(draw_command,),\n)\ndef __str__(self) -&gt; str:\nreturn \"G37*\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g3n_region.html#pygerber.gerberx3.tokenizer.tokens.g3n_region.EndRegion.update_drawing_state","title":"update_drawing_state","text":"<pre><code>update_drawing_state(\nstate: State, backend: Backend\n) -&gt; Tuple[State, Iterable[DrawCommand]]\n</code></pre> <p>Set drawing polarity.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/g3n_region.py</code> <pre><code>def update_drawing_state(\nself,\nstate: State,\nbackend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n\"\"\"Set drawing polarity.\"\"\"\nif not state.is_region:\nlogging.warning(\"Ending region which was not started.\")\nif len(state.region_boundary_points) == 0:\nlogging.warning(\"Created region with no boundaries.\")\ndraw_command = backend.get_draw_region_cls()(\nbackend,\nstate.polarity.to_region_variant(),\nstate.region_boundary_points,\n)\nreturn (\nstate.model_copy(\nupdate={\n\"is_region\": False,\n\"region_boundary_points\": [],\n},\n),\n(draw_command,),\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g54_select_aperture.html","title":"g54_select_aperture","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g54_select_aperture.html#pygerber.gerberx3.tokenizer.tokens.g54_select_aperture","title":"g54_select_aperture","text":"<p>Wrapper for G70 token.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g54_select_aperture.html#pygerber.gerberx3.tokenizer.tokens.g54_select_aperture.G54SelectAperture","title":"G54SelectAperture","text":"<p>             Bases: <code>DNNSelectAperture</code></p> <p>Wrapper for G54DNN token.</p> <p>Select aperture.</p> <p>This historic code optionally precedes an aperture selection Dnn command. It has no effect. Sometimes used. Deprecated in 2012.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/g54_select_aperture.py</code> <pre><code>class G54SelectAperture(DNNSelectAperture):\n\"\"\"Wrapper for G54DNN token.\n    Select aperture.\n    This historic code optionally precedes an aperture selection Dnn command. It has no\n    effect. Sometimes used. Deprecated in 2012.\n    \"\"\"\ndef __str__(self) -&gt; str:\nreturn f\"G54{self.aperture_id}*\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g70_set_unit_inch.html","title":"g70_set_unit_inch","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g70_set_unit_inch.html#pygerber.gerberx3.tokenizer.tokens.g70_set_unit_inch","title":"g70_set_unit_inch","text":"<p>Wrapper for G70 token.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g70_set_unit_inch.html#pygerber.gerberx3.tokenizer.tokens.g70_set_unit_inch.SetUnitInch","title":"SetUnitInch","text":"<p>             Bases: <code>Token</code></p> <p>Wrapper for G70 token.</p> <p>Set the <code>Unit</code> to inch.</p> <p>This historic codes perform a function handled by the MO command. See 4.2.1. Sometimes used. Deprecated in 2012</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/g70_set_unit_inch.py</code> <pre><code>class SetUnitInch(Token):\n\"\"\"Wrapper for G70 token.\n    Set the `Unit` to inch.\n    This historic codes perform a function handled by the MO command. See 4.2.1.\n    Sometimes used. Deprecated in 2012\n    \"\"\"\n@classmethod\ndef from_tokens(cls, **_tokens: Any) -&gt; Self:\n\"\"\"Initialize token object.\"\"\"\nlogging.warning(\n\"Using metric units is recommended. Imperial units will be deprecated \"\n\"in future. (See 4.2.1 in Gerber Layer Format Specification)\",\n)\nreturn cls()\ndef update_drawing_state(\nself,\nstate: State,\n_backend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n\"\"\"Set drawing polarity.\"\"\"\nif state.draw_units is not None:\nlogging.warning(\n\"Overriding coordinate format is illegal. \"\n\"(See 4.2.1 in Gerber Layer Format Specification)\",\n)\nreturn (\nstate.model_copy(\nupdate={\n\"draw_units\": Unit.Inches,\n},\n),\n(),\n)\ndef __str__(self) -&gt; str:\nreturn \"G70*\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g70_set_unit_inch.html#pygerber.gerberx3.tokenizer.tokens.g70_set_unit_inch.SetUnitInch.from_tokens","title":"from_tokens  <code>classmethod</code>","text":"<pre><code>from_tokens(**_tokens: Any) -&gt; Self\n</code></pre> <p>Initialize token object.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/g70_set_unit_inch.py</code> <pre><code>@classmethod\ndef from_tokens(cls, **_tokens: Any) -&gt; Self:\n\"\"\"Initialize token object.\"\"\"\nlogging.warning(\n\"Using metric units is recommended. Imperial units will be deprecated \"\n\"in future. (See 4.2.1 in Gerber Layer Format Specification)\",\n)\nreturn cls()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g70_set_unit_inch.html#pygerber.gerberx3.tokenizer.tokens.g70_set_unit_inch.SetUnitInch.update_drawing_state","title":"update_drawing_state","text":"<pre><code>update_drawing_state(\nstate: State, _backend: Backend\n) -&gt; Tuple[State, Iterable[DrawCommand]]\n</code></pre> <p>Set drawing polarity.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/g70_set_unit_inch.py</code> <pre><code>def update_drawing_state(\nself,\nstate: State,\n_backend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n\"\"\"Set drawing polarity.\"\"\"\nif state.draw_units is not None:\nlogging.warning(\n\"Overriding coordinate format is illegal. \"\n\"(See 4.2.1 in Gerber Layer Format Specification)\",\n)\nreturn (\nstate.model_copy(\nupdate={\n\"draw_units\": Unit.Inches,\n},\n),\n(),\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g71_set_unit_mm.html","title":"g71_set_unit_mm","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g71_set_unit_mm.html#pygerber.gerberx3.tokenizer.tokens.g71_set_unit_mm","title":"g71_set_unit_mm","text":"<p>Wrapper for G71 token.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g71_set_unit_mm.html#pygerber.gerberx3.tokenizer.tokens.g71_set_unit_mm.SetUnitMillimeters","title":"SetUnitMillimeters","text":"<p>             Bases: <code>Token</code></p> <p>Wrapper for G71 token.</p> <p>Set the <code>Unit</code> to millimeter.</p> <p>This historic codes perform a function handled by the MO command. See 4.2.1. Sometimes used. Deprecated in 2012</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/g71_set_unit_mm.py</code> <pre><code>class SetUnitMillimeters(Token):\n\"\"\"Wrapper for G71 token.\n    Set the `Unit` to millimeter.\n    This historic codes perform a function handled by the MO command. See 4.2.1.\n    Sometimes used. Deprecated in 2012\n    \"\"\"\ndef update_drawing_state(\nself,\nstate: State,\n_backend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n\"\"\"Set drawing polarity.\"\"\"\nif state.draw_units is not None:\nlogging.warning(\n\"Overriding coordinate format is illegal. \"\n\"(See 4.2.1 in Gerber Layer Format Specification)\",\n)\nreturn (\nstate.model_copy(\nupdate={\n\"draw_units\": Unit.Millimeters,\n},\n),\n(),\n)\ndef __str__(self) -&gt; str:\nreturn \"G71*\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g71_set_unit_mm.html#pygerber.gerberx3.tokenizer.tokens.g71_set_unit_mm.SetUnitMillimeters.update_drawing_state","title":"update_drawing_state","text":"<pre><code>update_drawing_state(\nstate: State, _backend: Backend\n) -&gt; Tuple[State, Iterable[DrawCommand]]\n</code></pre> <p>Set drawing polarity.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/g71_set_unit_mm.py</code> <pre><code>def update_drawing_state(\nself,\nstate: State,\n_backend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n\"\"\"Set drawing polarity.\"\"\"\nif state.draw_units is not None:\nlogging.warning(\n\"Overriding coordinate format is illegal. \"\n\"(See 4.2.1 in Gerber Layer Format Specification)\",\n)\nreturn (\nstate.model_copy(\nupdate={\n\"draw_units\": Unit.Millimeters,\n},\n),\n(),\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g74_single_quadrant.html","title":"g74_single_quadrant","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g74_single_quadrant.html#pygerber.gerberx3.tokenizer.tokens.g74_single_quadrant","title":"g74_single_quadrant","text":"<p>Wrapper for G74 token.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g74_single_quadrant.html#pygerber.gerberx3.tokenizer.tokens.g74_single_quadrant.SetSingleQuadrantMode","title":"SetSingleQuadrantMode","text":"<p>             Bases: <code>Token</code></p> <p>Wrapper for G74 token.</p> <p>Sets single quadrant mode - Rarely used, and then typically without effect. Deprecated in 2020. (Spec. 8.1.10).</p> <p>In single quadrant mode the arc is not allowed to extend over more than 90\u00b0.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/g74_single_quadrant.py</code> <pre><code>class SetSingleQuadrantMode(Token):\n\"\"\"Wrapper for G74 token.\n    Sets single quadrant mode - Rarely used, and then typically without effect.\n    Deprecated in 2020. (Spec. 8.1.10).\n    In single quadrant mode the arc is not allowed to extend over more than 90\u00b0.\n    \"\"\"\ndef update_drawing_state(\nself,\nstate: State,\n_backend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n\"\"\"Set drawing polarity.\"\"\"\nreturn (\nstate.model_copy(\nupdate={\n\"is_multi_quadrant\": False,\n},\n),\n(),\n)\ndef __str__(self) -&gt; str:\nreturn \"G74*\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g74_single_quadrant.html#pygerber.gerberx3.tokenizer.tokens.g74_single_quadrant.SetSingleQuadrantMode.update_drawing_state","title":"update_drawing_state","text":"<pre><code>update_drawing_state(\nstate: State, _backend: Backend\n) -&gt; Tuple[State, Iterable[DrawCommand]]\n</code></pre> <p>Set drawing polarity.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/g74_single_quadrant.py</code> <pre><code>def update_drawing_state(\nself,\nstate: State,\n_backend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n\"\"\"Set drawing polarity.\"\"\"\nreturn (\nstate.model_copy(\nupdate={\n\"is_multi_quadrant\": False,\n},\n),\n(),\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g75_multi_quadrant.html","title":"g75_multi_quadrant","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g75_multi_quadrant.html#pygerber.gerberx3.tokenizer.tokens.g75_multi_quadrant","title":"g75_multi_quadrant","text":"<p>Wrapper for G74 token.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g75_multi_quadrant.html#pygerber.gerberx3.tokenizer.tokens.g75_multi_quadrant.SetMultiQuadrantMode","title":"SetMultiQuadrantMode","text":"<p>             Bases: <code>Token</code></p> <p>Wrapper for G74 token.</p> <p>In multi quadrant mode the arc is allowed to extend over more than 90\u00b0. To avoid ambiguity between 0\u00b0 and 360\u00b0 arcs the following relation must hold:</p> <p>0\u00b0 &lt; A \u2264360\u00b0, where A is the arc angle</p> <p>If the start point of the arc is equal to the end point, the arc is a full circle of 360\u00b0.</p> <p>0\u00b0 \u2264A \u226490\u00b0, where A is the arc angle</p> <p>angleIf the start point of the arc is equal to the end point, the arc has length zero, i.e. it covers 0\u00b0. A separate operation is required for each quadrant. A minimum of four operations is required for a full circle.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/g75_multi_quadrant.py</code> <pre><code>class SetMultiQuadrantMode(Token):\n\"\"\"Wrapper for G74 token.\n    In multi quadrant mode the arc is allowed to extend over more than 90\u00b0.\n    To avoid ambiguity between 0\u00b0 and 360\u00b0 arcs the following relation must hold:\n    0\u00b0 &lt; A \u2264360\u00b0, where A is the arc angle\n    If the start point of the arc is equal to the\n    end point, the arc is a full circle of 360\u00b0.\n    0\u00b0 \u2264A \u226490\u00b0, where A is the arc angle\n    angleIf the start point of the arc is equal to the end point, the arc has length\n    zero, i.e. it covers 0\u00b0. A separate operation is required for each quadrant. A\n    minimum of four operations is required for a full circle.\n    \"\"\"\ndef update_drawing_state(\nself,\nstate: State,\n_backend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n\"\"\"Set drawing polarity.\"\"\"\nreturn (\nstate.model_copy(\nupdate={\n\"is_multi_quadrant\": True,\n},\n),\n(),\n)\ndef __str__(self) -&gt; str:\nreturn \"G75*\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g75_multi_quadrant.html#pygerber.gerberx3.tokenizer.tokens.g75_multi_quadrant.SetMultiQuadrantMode.update_drawing_state","title":"update_drawing_state","text":"<pre><code>update_drawing_state(\nstate: State, _backend: Backend\n) -&gt; Tuple[State, Iterable[DrawCommand]]\n</code></pre> <p>Set drawing polarity.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/g75_multi_quadrant.py</code> <pre><code>def update_drawing_state(\nself,\nstate: State,\n_backend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n\"\"\"Set drawing polarity.\"\"\"\nreturn (\nstate.model_copy(\nupdate={\n\"is_multi_quadrant\": True,\n},\n),\n(),\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g90_set_coordinate_absolute.html","title":"g90_set_coordinate_absolute","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g90_set_coordinate_absolute.html#pygerber.gerberx3.tokenizer.tokens.g90_set_coordinate_absolute","title":"g90_set_coordinate_absolute","text":"<p>Wrapper for G90 token.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g90_set_coordinate_absolute.html#pygerber.gerberx3.tokenizer.tokens.g90_set_coordinate_absolute.SetAbsoluteNotation","title":"SetAbsoluteNotation","text":"<p>             Bases: <code>Token</code></p> <p>Wrapper for G90 token.</p> <p>Set the <code>Coordinate format</code> to <code>Absolute notation</code>.</p> <p>This historic code performs a function handled by the FS command. See 4.1. Very rarely used nowadays. Deprecated in 2012.</p> <p>SPEC: <code>2023.03</code> SECTION: <code>8.1</code></p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/g90_set_coordinate_absolute.py</code> <pre><code>class SetAbsoluteNotation(Token):\n\"\"\"Wrapper for G90 token.\n    Set the `Coordinate format` to `Absolute notation`.\n    This historic code performs a function handled by the FS command. See 4.1. Very\n    rarely used nowadays. Deprecated in 2012.\n    SPEC: `2023.03` SECTION: `8.1`\n    \"\"\"\ndef update_drawing_state(\nself,\nstate: State,\n_backend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n\"\"\"Set drawing polarity.\"\"\"\nif state.coordinate_parser is not None:\nlogging.warning(\n\"Overriding coordinate format is illegal.\"\n\"(See 4.2.2 in Gerber Layer Format Specification)\",\n)\nreturn (\nstate.model_copy(deep=True),\n(),\n)\ndef __str__(self) -&gt; str:\nreturn \"G90*\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g90_set_coordinate_absolute.html#pygerber.gerberx3.tokenizer.tokens.g90_set_coordinate_absolute.SetAbsoluteNotation.update_drawing_state","title":"update_drawing_state","text":"<pre><code>update_drawing_state(\nstate: State, _backend: Backend\n) -&gt; Tuple[State, Iterable[DrawCommand]]\n</code></pre> <p>Set drawing polarity.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/g90_set_coordinate_absolute.py</code> <pre><code>def update_drawing_state(\nself,\nstate: State,\n_backend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n\"\"\"Set drawing polarity.\"\"\"\nif state.coordinate_parser is not None:\nlogging.warning(\n\"Overriding coordinate format is illegal.\"\n\"(See 4.2.2 in Gerber Layer Format Specification)\",\n)\nreturn (\nstate.model_copy(deep=True),\n(),\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g91_set_coordinate_incremental.html","title":"g91_set_coordinate_incremental","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g91_set_coordinate_incremental.html#pygerber.gerberx3.tokenizer.tokens.g91_set_coordinate_incremental","title":"g91_set_coordinate_incremental","text":"<p>Wrapper for G91 token.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g91_set_coordinate_incremental.html#pygerber.gerberx3.tokenizer.tokens.g91_set_coordinate_incremental.SetIncrementalNotation","title":"SetIncrementalNotation","text":"<p>             Bases: <code>Token</code></p> <p>Wrapper for G91 token.</p> <p>Set the <code>Coordinate format</code> to <code>Incremental notation</code>.</p> <p>This historic code performs a function handled by the FS command. See 4.1. Very rarely used nowadays. Deprecated in 2012.</p> <p>SPEC: <code>2023.03</code> SECTION: <code>8.1</code></p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/g91_set_coordinate_incremental.py</code> <pre><code>class SetIncrementalNotation(Token):\n\"\"\"Wrapper for G91 token.\n    Set the `Coordinate format` to `Incremental notation`.\n    This historic code performs a function handled by the FS command. See 4.1. Very\n    rarely used nowadays. Deprecated in 2012.\n    SPEC: `2023.03` SECTION: `8.1`\n    \"\"\"\ndef update_drawing_state(\nself,\nstate: State,\n_backend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n\"\"\"Set drawing polarity.\"\"\"\nif state.coordinate_parser is not None:\nlogging.warning(\n\"Overriding coordinate format is illegal.\"\n\"(See 4.2.2 in Gerber Layer Format Specification)\",\n)\nmsg = \"Incremental notation not supported.\"\nraise NotImplementedError(msg)\ndef __str__(self) -&gt; str:\nreturn \"G91*\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g91_set_coordinate_incremental.html#pygerber.gerberx3.tokenizer.tokens.g91_set_coordinate_incremental.SetIncrementalNotation.update_drawing_state","title":"update_drawing_state","text":"<pre><code>update_drawing_state(\nstate: State, _backend: Backend\n) -&gt; Tuple[State, Iterable[DrawCommand]]\n</code></pre> <p>Set drawing polarity.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/g91_set_coordinate_incremental.py</code> <pre><code>def update_drawing_state(\nself,\nstate: State,\n_backend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n\"\"\"Set drawing polarity.\"\"\"\nif state.coordinate_parser is not None:\nlogging.warning(\n\"Overriding coordinate format is illegal.\"\n\"(See 4.2.2 in Gerber Layer Format Specification)\",\n)\nmsg = \"Incremental notation not supported.\"\nraise NotImplementedError(msg)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ip_image_polarity.html","title":"ip_image_polarity","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ip_image_polarity.html#pygerber.gerberx3.tokenizer.tokens.ip_image_polarity","title":"ip_image_polarity","text":"<p>Wrapper for image polarity token.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ip_image_polarity.html#pygerber.gerberx3.tokenizer.tokens.ip_image_polarity.ImagePolarity","title":"ImagePolarity","text":"<p>             Bases: <code>Token</code></p> <p>Wrapper for image polarity token.</p> <p>The IP command is deprecated.</p> <p>IP sets positive or negative polarity for the entire image. It can only be used once, at the beginning of the file.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/ip_image_polarity.py</code> <pre><code>class ImagePolarity(Token):\n\"\"\"Wrapper for image polarity token.\n    The IP command is deprecated.\n    IP sets positive or negative polarity for the entire image. It can only be used\n    once, at the beginning of the file.\n    \"\"\"\nimage_polarity: ImagePolarityEnum\n@classmethod\ndef from_tokens(cls, **tokens: Any) -&gt; Self:\n\"\"\"Initialize token object.\"\"\"\nimage_polarity = ImagePolarityEnum(tokens[\"image_polarity\"])\nreturn cls(image_polarity=image_polarity)\ndef update_drawing_state(\nself,\nstate: State,\n_backend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n\"\"\"Set drawing polarity.\"\"\"\nreturn (\nstate.model_copy(\nupdate={\n\"is_output_image_negation_required\": (\nself.image_polarity == ImagePolarityEnum.NEGATIVE\n),\n},\n),\n(),\n)\ndef __str__(self) -&gt; str:\nreturn f\"%IP{self.image_polarity}*%\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ip_image_polarity.html#pygerber.gerberx3.tokenizer.tokens.ip_image_polarity.ImagePolarity.from_tokens","title":"from_tokens  <code>classmethod</code>","text":"<pre><code>from_tokens(**tokens: Any) -&gt; Self\n</code></pre> <p>Initialize token object.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/ip_image_polarity.py</code> <pre><code>@classmethod\ndef from_tokens(cls, **tokens: Any) -&gt; Self:\n\"\"\"Initialize token object.\"\"\"\nimage_polarity = ImagePolarityEnum(tokens[\"image_polarity\"])\nreturn cls(image_polarity=image_polarity)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ip_image_polarity.html#pygerber.gerberx3.tokenizer.tokens.ip_image_polarity.ImagePolarity.update_drawing_state","title":"update_drawing_state","text":"<pre><code>update_drawing_state(\nstate: State, _backend: Backend\n) -&gt; Tuple[State, Iterable[DrawCommand]]\n</code></pre> <p>Set drawing polarity.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/ip_image_polarity.py</code> <pre><code>def update_drawing_state(\nself,\nstate: State,\n_backend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n\"\"\"Set drawing polarity.\"\"\"\nreturn (\nstate.model_copy(\nupdate={\n\"is_output_image_negation_required\": (\nself.image_polarity == ImagePolarityEnum.NEGATIVE\n),\n},\n),\n(),\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/lm_load_mirroring.html","title":"lm_load_mirroring","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/lm_load_mirroring.html#pygerber.gerberx3.tokenizer.tokens.lm_load_mirroring","title":"lm_load_mirroring","text":"<p>Wrapper for load mirroring token.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/lm_load_mirroring.html#pygerber.gerberx3.tokenizer.tokens.lm_load_mirroring.LoadMirroring","title":"LoadMirroring","text":"<p>             Bases: <code>Token</code></p> <p>Wrapper for load mirroring token.</p> <p>Loads the mirror object transformation parameter.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/lm_load_mirroring.py</code> <pre><code>class LoadMirroring(Token):\n\"\"\"Wrapper for load mirroring token.\n    Loads the mirror object transformation parameter.\n    \"\"\"\nmirroring: Mirroring\n@classmethod\ndef from_tokens(cls, **tokens: Any) -&gt; Self:\n\"\"\"Initialize token object.\"\"\"\nmirroring = Mirroring(tokens[\"mirroring\"])\nreturn cls(mirroring=mirroring)\ndef update_drawing_state(\nself,\nstate: State,\n_backend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n\"\"\"Set drawing polarity.\"\"\"\nreturn (\nstate.model_copy(\nupdate={\n\"mirroring\": self.mirroring,\n},\n),\n(),\n)\ndef __str__(self) -&gt; str:\nreturn f\"LM{self.mirroring.value}*\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/lm_load_mirroring.html#pygerber.gerberx3.tokenizer.tokens.lm_load_mirroring.LoadMirroring.from_tokens","title":"from_tokens  <code>classmethod</code>","text":"<pre><code>from_tokens(**tokens: Any) -&gt; Self\n</code></pre> <p>Initialize token object.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/lm_load_mirroring.py</code> <pre><code>@classmethod\ndef from_tokens(cls, **tokens: Any) -&gt; Self:\n\"\"\"Initialize token object.\"\"\"\nmirroring = Mirroring(tokens[\"mirroring\"])\nreturn cls(mirroring=mirroring)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/lm_load_mirroring.html#pygerber.gerberx3.tokenizer.tokens.lm_load_mirroring.LoadMirroring.update_drawing_state","title":"update_drawing_state","text":"<pre><code>update_drawing_state(\nstate: State, _backend: Backend\n) -&gt; Tuple[State, Iterable[DrawCommand]]\n</code></pre> <p>Set drawing polarity.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/lm_load_mirroring.py</code> <pre><code>def update_drawing_state(\nself,\nstate: State,\n_backend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n\"\"\"Set drawing polarity.\"\"\"\nreturn (\nstate.model_copy(\nupdate={\n\"mirroring\": self.mirroring,\n},\n),\n(),\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ln_load_name.html","title":"ln_load_name","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ln_load_name.html#pygerber.gerberx3.tokenizer.tokens.ln_load_name","title":"ln_load_name","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ln_load_name.html#pygerber.gerberx3.tokenizer.tokens.ln_load_name--load-name-ln","title":"Load Name (LN).","text":"<p>Note: The LN command was deprecated in revision I4 from October 2013.</p> <p>The historic <code>LN</code> command doesn't influence the image in any manner and can safely be overlooked.</p> <p>Function of the <code>LN</code> command: - <code>LN</code> is designed to allocate a name to the following section of the file. - It was originally conceptualized to serve as a human-readable comment. - For creating human-readable comments, it's advisable to utilize the standard <code>G04</code>     command. - The <code>LN</code> command has the flexibility to be executed multiple times within a file.</p> <p>SPEC: <code>2023.03</code> SECTION: <code>8.1.6</code></p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ln_load_name.html#pygerber.gerberx3.tokenizer.tokens.ln_load_name.LoadName","title":"LoadName","text":"<p>             Bases: <code>Token</code></p> <p>Comment token.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ln_load_name.html#pygerber.gerberx3.tokenizer.tokens.ln_load_name.LoadName--load-name-ln","title":"Load Name (LN)","text":"<p>Note: The LN command was deprecated in revision I4 from October 2013.</p> <p>The historic <code>LN</code> command doesn't influence the image in any manner and can safely be overlooked.</p> <p>Function of the <code>LN</code> command: - <code>LN</code> is designed to allocate a name to the following section of the file. - It was originally conceptualized to serve as a human-readable comment. - For creating human-readable comments, it's advisable to utilize the standard <code>G04</code>     command. - The <code>LN</code> command has the flexibility to be executed multiple times within a file.</p> <p>SPEC: <code>2023.03</code> SECTION: <code>8.1.6</code></p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/ln_load_name.py</code> <pre><code>class LoadName(Token):\n\"\"\"Comment token.\n    ### Load Name (LN)\n    Note: The LN command was deprecated in revision I4 from October 2013.\n    The historic `LN` command doesn't influence the image in any manner and can safely\n    be overlooked.\n    Function of the `LN` command:\n    - `LN` is designed to allocate a name to the following section of the file.\n    - It was originally conceptualized to serve as a human-readable comment.\n    - For creating human-readable comments, it's advisable to utilize the standard `G04`\n        command.\n    - The `LN` command has the flexibility to be executed multiple times within a file.\n    SPEC: `2023.03` SECTION: `8.1.6`\n    \"\"\"\ncontent: str\n@classmethod\ndef from_tokens(cls, **tokens: Any) -&gt; Self:\n\"\"\"Initialize token object.\"\"\"\ncontent: str = tokens[\"string\"]\nreturn cls(content=content)\ndef __str__(self) -&gt; str:\nreturn f\"%LN {self.content}*%\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ln_load_name.html#pygerber.gerberx3.tokenizer.tokens.ln_load_name.LoadName.from_tokens","title":"from_tokens  <code>classmethod</code>","text":"<pre><code>from_tokens(**tokens: Any) -&gt; Self\n</code></pre> <p>Initialize token object.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/ln_load_name.py</code> <pre><code>@classmethod\ndef from_tokens(cls, **tokens: Any) -&gt; Self:\n\"\"\"Initialize token object.\"\"\"\ncontent: str = tokens[\"string\"]\nreturn cls(content=content)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/lp_load_polarity.html","title":"lp_load_polarity","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/lp_load_polarity.html#pygerber.gerberx3.tokenizer.tokens.lp_load_polarity","title":"lp_load_polarity","text":"<p>Wrapper for load polarity token.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/lp_load_polarity.html#pygerber.gerberx3.tokenizer.tokens.lp_load_polarity.LoadPolarity","title":"LoadPolarity","text":"<p>             Bases: <code>Token</code></p> <p>Wrapper for load polarity token.</p> <p>Loads the scale object transformation parameter.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/lp_load_polarity.py</code> <pre><code>class LoadPolarity(Token):\n\"\"\"Wrapper for load polarity token.\n    Loads the scale object transformation parameter.\n    \"\"\"\npolarity: Polarity\n@classmethod\ndef from_tokens(cls, **tokens: Any) -&gt; Self:\n\"\"\"Initialize token object.\"\"\"\npolarity = Polarity(tokens[\"polarity\"])\nreturn cls(polarity=polarity)\ndef update_drawing_state(\nself,\nstate: State,\n_backend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n\"\"\"Set drawing polarity.\"\"\"\nreturn (\nstate.model_copy(\nupdate={\n\"polarity\": self.polarity,\n},\n),\n(),\n)\ndef __str__(self) -&gt; str:\nreturn f\"LP{self.polarity.value}*\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/lp_load_polarity.html#pygerber.gerberx3.tokenizer.tokens.lp_load_polarity.LoadPolarity.from_tokens","title":"from_tokens  <code>classmethod</code>","text":"<pre><code>from_tokens(**tokens: Any) -&gt; Self\n</code></pre> <p>Initialize token object.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/lp_load_polarity.py</code> <pre><code>@classmethod\ndef from_tokens(cls, **tokens: Any) -&gt; Self:\n\"\"\"Initialize token object.\"\"\"\npolarity = Polarity(tokens[\"polarity\"])\nreturn cls(polarity=polarity)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/lp_load_polarity.html#pygerber.gerberx3.tokenizer.tokens.lp_load_polarity.LoadPolarity.update_drawing_state","title":"update_drawing_state","text":"<pre><code>update_drawing_state(\nstate: State, _backend: Backend\n) -&gt; Tuple[State, Iterable[DrawCommand]]\n</code></pre> <p>Set drawing polarity.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/lp_load_polarity.py</code> <pre><code>def update_drawing_state(\nself,\nstate: State,\n_backend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n\"\"\"Set drawing polarity.\"\"\"\nreturn (\nstate.model_copy(\nupdate={\n\"polarity\": self.polarity,\n},\n),\n(),\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/lr_load_rotation.html","title":"lr_load_rotation","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/lr_load_rotation.html#pygerber.gerberx3.tokenizer.tokens.lr_load_rotation","title":"lr_load_rotation","text":"<p>Wrapper for load rotation token.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/lr_load_rotation.html#pygerber.gerberx3.tokenizer.tokens.lr_load_rotation.LoadRotation","title":"LoadRotation","text":"<p>             Bases: <code>Token</code></p> <p>Wrapper for load rotation token.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/lr_load_rotation.html#pygerber.gerberx3.tokenizer.tokens.lr_load_rotation.LoadRotation--lr-command-rotation-graphics-state-parameter","title":"LR Command: Rotation Graphics State Parameter","text":"<p>The <code>LR</code> command is utilized to configure the rotation graphics state parameter.</p> <p>Functionality: - This command specifies the rotation angle to be applied when crafting objects. - The aperture is rotated centered on its origin, which might either coincide with     or differ from its geometric center.</p> <p>Usage and Persistence: - The <code>LR</code> command can be invoked numerous times throughout a file. - Once defined, the object rotation retains its configuration unless overridden by     an ensuing <code>LR</code> command. - Rotation is strictly determined by the exact value mentioned in the command and     doesn't integrate with any prior rotation values.</p> <p>The LR command was introduced in revision 2016.12.</p> <p>SPEC: <code>2023.03</code> SECTION: <code>4.9.4</code></p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/lr_load_rotation.py</code> <pre><code>class LoadRotation(Token):\n\"\"\"Wrapper for load rotation token.\n    ### LR Command: Rotation Graphics State Parameter\n    The `LR` command is utilized to configure the rotation graphics state parameter.\n    Functionality:\n    - This command specifies the rotation angle to be applied when crafting objects.\n    - The aperture is rotated centered on its origin, which might either coincide with\n        or differ from its geometric center.\n    Usage and Persistence:\n    - The `LR` command can be invoked numerous times throughout a file.\n    - Once defined, the object rotation retains its configuration unless overridden by\n        an ensuing `LR` command.\n    - Rotation is strictly determined by the exact value mentioned in the command and\n        doesn't integrate with any prior rotation values.\n    The LR command was introduced in revision 2016.12.\n    SPEC: `2023.03` SECTION: `4.9.4`\n    \"\"\"\nrotation: Decimal\n@classmethod\ndef from_tokens(cls, **tokens: Any) -&gt; Self:\n\"\"\"Initialize token object.\"\"\"\nrotation = Decimal(tokens[\"rotation\"])\nreturn cls(rotation=rotation)\ndef update_drawing_state(\nself,\nstate: State,\n_backend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n\"\"\"Set drawing polarity.\"\"\"\nreturn (\nstate.model_copy(\nupdate={\n\"rotation\": self.rotation,\n},\n),\n(),\n)\ndef __str__(self) -&gt; str:\nreturn f\"LR{self.rotation}*\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/lr_load_rotation.html#pygerber.gerberx3.tokenizer.tokens.lr_load_rotation.LoadRotation.from_tokens","title":"from_tokens  <code>classmethod</code>","text":"<pre><code>from_tokens(**tokens: Any) -&gt; Self\n</code></pre> <p>Initialize token object.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/lr_load_rotation.py</code> <pre><code>@classmethod\ndef from_tokens(cls, **tokens: Any) -&gt; Self:\n\"\"\"Initialize token object.\"\"\"\nrotation = Decimal(tokens[\"rotation\"])\nreturn cls(rotation=rotation)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/lr_load_rotation.html#pygerber.gerberx3.tokenizer.tokens.lr_load_rotation.LoadRotation.update_drawing_state","title":"update_drawing_state","text":"<pre><code>update_drawing_state(\nstate: State, _backend: Backend\n) -&gt; Tuple[State, Iterable[DrawCommand]]\n</code></pre> <p>Set drawing polarity.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/lr_load_rotation.py</code> <pre><code>def update_drawing_state(\nself,\nstate: State,\n_backend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n\"\"\"Set drawing polarity.\"\"\"\nreturn (\nstate.model_copy(\nupdate={\n\"rotation\": self.rotation,\n},\n),\n(),\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ls_load_scaling.html","title":"ls_load_scaling","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ls_load_scaling.html#pygerber.gerberx3.tokenizer.tokens.ls_load_scaling","title":"ls_load_scaling","text":"<p>Wrapper for load scaling token.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ls_load_scaling.html#pygerber.gerberx3.tokenizer.tokens.ls_load_scaling.LoadScaling","title":"LoadScaling","text":"<p>             Bases: <code>Token</code></p> <p>Wrapper for load scaling token.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ls_load_scaling.html#pygerber.gerberx3.tokenizer.tokens.ls_load_scaling.LoadScaling--ls-command-scaling-graphics-state-parameter","title":"LS Command: Scaling Graphics State Parameter","text":"<p>The <code>LS</code> command is employed to establish the scaling graphics state parameter.</p> <p>Functionality: - The command dictates the scale factor utilized during object creation. - The aperture undergoes scaling, anchored at its origin. It's crucial to note that     this origin might not always align with its geometric center.</p> <p>Usage and Persistence: - The <code>LS</code> command can be invoked multiple times within a single file. - Once set, the object scaling retains its value unless a subsequent <code>LS</code> command     modifies it. - The scaling gets adjusted based on the specific value mentioned in the command and     doesn't accumulate with the preceding scale factor.</p> <p>The LS command was introduced in revision 2016.12.</p> <p>SPEC: <code>2023.03</code> SECTION: <code>4.9.5</code></p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/ls_load_scaling.py</code> <pre><code>class LoadScaling(Token):\n\"\"\"Wrapper for load scaling token.\n    ### LS Command: Scaling Graphics State Parameter\n    The `LS` command is employed to establish the scaling graphics state parameter.\n    Functionality:\n    - The command dictates the scale factor utilized during object creation.\n    - The aperture undergoes scaling, anchored at its origin. It's crucial to note that\n        this origin might not always align with its geometric center.\n    Usage and Persistence:\n    - The `LS` command can be invoked multiple times within a single file.\n    - Once set, the object scaling retains its value unless a subsequent `LS` command\n        modifies it.\n    - The scaling gets adjusted based on the specific value mentioned in the command and\n        doesn't accumulate with the preceding scale factor.\n    The LS command was introduced in revision 2016.12.\n    SPEC: `2023.03` SECTION: `4.9.5`\n    \"\"\"\nscaling: Decimal\n@classmethod\ndef from_tokens(cls, **tokens: Any) -&gt; Self:\n\"\"\"Initialize token object.\"\"\"\nscaling = Decimal(tokens[\"scaling\"])\nreturn cls(scaling=scaling)\ndef update_drawing_state(\nself,\nstate: State,\n_backend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n\"\"\"Set drawing polarity.\"\"\"\nreturn (\nstate.model_copy(\nupdate={\n\"scaling\": self.scaling,\n},\n),\n(),\n)\ndef __str__(self) -&gt; str:\nreturn f\"LS{self.scaling}*\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ls_load_scaling.html#pygerber.gerberx3.tokenizer.tokens.ls_load_scaling.LoadScaling.from_tokens","title":"from_tokens  <code>classmethod</code>","text":"<pre><code>from_tokens(**tokens: Any) -&gt; Self\n</code></pre> <p>Initialize token object.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/ls_load_scaling.py</code> <pre><code>@classmethod\ndef from_tokens(cls, **tokens: Any) -&gt; Self:\n\"\"\"Initialize token object.\"\"\"\nscaling = Decimal(tokens[\"scaling\"])\nreturn cls(scaling=scaling)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ls_load_scaling.html#pygerber.gerberx3.tokenizer.tokens.ls_load_scaling.LoadScaling.update_drawing_state","title":"update_drawing_state","text":"<pre><code>update_drawing_state(\nstate: State, _backend: Backend\n) -&gt; Tuple[State, Iterable[DrawCommand]]\n</code></pre> <p>Set drawing polarity.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/ls_load_scaling.py</code> <pre><code>def update_drawing_state(\nself,\nstate: State,\n_backend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n\"\"\"Set drawing polarity.\"\"\"\nreturn (\nstate.model_copy(\nupdate={\n\"scaling\": self.scaling,\n},\n),\n(),\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/m00_program_stop.html","title":"m00_program_stop","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/m00_program_stop.html#pygerber.gerberx3.tokenizer.tokens.m00_program_stop","title":"m00_program_stop","text":"<p>Wrapper for program stop token.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/m00_program_stop.html#pygerber.gerberx3.tokenizer.tokens.m00_program_stop.M00ProgramStop","title":"M00ProgramStop","text":"<p>             Bases: <code>Token</code></p> <p>Wrapper for program stop token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/m00_program_stop.py</code> <pre><code>class M00ProgramStop(Token):\n\"\"\"Wrapper for program stop token.\"\"\"\ndef update_drawing_state(\nself,\n_state: State,\n_backend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n\"\"\"Exit drawing process.\"\"\"\nraise ExitParsingProcessInterrupt\ndef __str__(self) -&gt; str:\nreturn \"M00*\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/m00_program_stop.html#pygerber.gerberx3.tokenizer.tokens.m00_program_stop.M00ProgramStop.update_drawing_state","title":"update_drawing_state","text":"<pre><code>update_drawing_state(\n_state: State, _backend: Backend\n) -&gt; Tuple[State, Iterable[DrawCommand]]\n</code></pre> <p>Exit drawing process.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/m00_program_stop.py</code> <pre><code>def update_drawing_state(\nself,\n_state: State,\n_backend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n\"\"\"Exit drawing process.\"\"\"\nraise ExitParsingProcessInterrupt\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/m01_optional_stop.html","title":"m01_optional_stop","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/m01_optional_stop.html#pygerber.gerberx3.tokenizer.tokens.m01_optional_stop","title":"m01_optional_stop","text":"<p>Wrapper for optional stop token.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/m01_optional_stop.html#pygerber.gerberx3.tokenizer.tokens.m01_optional_stop.M01OptionalStop","title":"M01OptionalStop","text":"<p>             Bases: <code>Token</code></p> <p>Wrapper for optional stop token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/m01_optional_stop.py</code> <pre><code>class M01OptionalStop(Token):\n\"\"\"Wrapper for optional stop token.\"\"\"\ndef update_drawing_state(\nself,\n_state: State,\n_backend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n\"\"\"Exit drawing process.\"\"\"\nraise ExitParsingProcessInterrupt\ndef __str__(self) -&gt; str:\nreturn \"M00*\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/m01_optional_stop.html#pygerber.gerberx3.tokenizer.tokens.m01_optional_stop.M01OptionalStop.update_drawing_state","title":"update_drawing_state","text":"<pre><code>update_drawing_state(\n_state: State, _backend: Backend\n) -&gt; Tuple[State, Iterable[DrawCommand]]\n</code></pre> <p>Exit drawing process.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/m01_optional_stop.py</code> <pre><code>def update_drawing_state(\nself,\n_state: State,\n_backend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n\"\"\"Exit drawing process.\"\"\"\nraise ExitParsingProcessInterrupt\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/m02_end_of_file.html","title":"m02_end_of_file","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/m02_end_of_file.html#pygerber.gerberx3.tokenizer.tokens.m02_end_of_file","title":"m02_end_of_file","text":"<p>Wrapper for end of file token.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/m02_end_of_file.html#pygerber.gerberx3.tokenizer.tokens.m02_end_of_file.M02EndOfFile","title":"M02EndOfFile","text":"<p>             Bases: <code>Token</code></p> <p>Wrapper for end of file token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/m02_end_of_file.py</code> <pre><code>class M02EndOfFile(Token):\n\"\"\"Wrapper for end of file token.\"\"\"\ndef update_drawing_state(\nself,\n_state: State,\n_backend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n\"\"\"Exit drawing process.\"\"\"\nraise ExitParsingProcessInterrupt\ndef __str__(self) -&gt; str:\nreturn \"M02*\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/m02_end_of_file.html#pygerber.gerberx3.tokenizer.tokens.m02_end_of_file.M02EndOfFile.update_drawing_state","title":"update_drawing_state","text":"<pre><code>update_drawing_state(\n_state: State, _backend: Backend\n) -&gt; Tuple[State, Iterable[DrawCommand]]\n</code></pre> <p>Exit drawing process.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/m02_end_of_file.py</code> <pre><code>def update_drawing_state(\nself,\n_state: State,\n_backend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n\"\"\"Exit drawing process.\"\"\"\nraise ExitParsingProcessInterrupt\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/mo_unit_mode.html","title":"mo_unit_mode","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/mo_unit_mode.html#pygerber.gerberx3.tokenizer.tokens.mo_unit_mode","title":"mo_unit_mode","text":"<p>Wrapper for set unit mode token.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/mo_unit_mode.html#pygerber.gerberx3.tokenizer.tokens.mo_unit_mode.UnitMode","title":"UnitMode","text":"<p>             Bases: <code>Token</code></p> <p>Wrapper for set unit mode token.</p> <p>Sets the unit to mm or inch.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/mo_unit_mode.py</code> <pre><code>class UnitMode(Token):\n\"\"\"Wrapper for set unit mode token.\n    Sets the unit to mm or inch.\n    \"\"\"\nunit: Unit\n@classmethod\ndef from_tokens(cls, **tokens: Any) -&gt; Self:\n\"\"\"Initialize token object.\"\"\"\nunit: Unit = Unit(tokens[\"unit\"])\nif unit == Unit.Inches:\nlogging.warning(\n\"Using metric units is recommended. Imperial units will be deprecated \"\n\"in future. (See 4.2.1 in Gerber Layer Format Specification)\",\n)\nreturn cls(unit=unit)\ndef update_drawing_state(\nself,\nstate: State,\n_backend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n\"\"\"Update drawing state.\"\"\"\nif state.draw_units is not None:\nlogging.warning(\n\"Overriding coordinate format is illegal. \"\n\"(See 4.2.1 in Gerber Layer Format Specification)\",\n)\nreturn (\nstate.model_copy(\nupdate={\n\"draw_units\": self.unit,\n},\n),\n(),\n)\ndef __str__(self) -&gt; str:\nreturn f\"%MO{self.unit.value}*%\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/mo_unit_mode.html#pygerber.gerberx3.tokenizer.tokens.mo_unit_mode.UnitMode.from_tokens","title":"from_tokens  <code>classmethod</code>","text":"<pre><code>from_tokens(**tokens: Any) -&gt; Self\n</code></pre> <p>Initialize token object.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/mo_unit_mode.py</code> <pre><code>@classmethod\ndef from_tokens(cls, **tokens: Any) -&gt; Self:\n\"\"\"Initialize token object.\"\"\"\nunit: Unit = Unit(tokens[\"unit\"])\nif unit == Unit.Inches:\nlogging.warning(\n\"Using metric units is recommended. Imperial units will be deprecated \"\n\"in future. (See 4.2.1 in Gerber Layer Format Specification)\",\n)\nreturn cls(unit=unit)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/mo_unit_mode.html#pygerber.gerberx3.tokenizer.tokens.mo_unit_mode.UnitMode.update_drawing_state","title":"update_drawing_state","text":"<pre><code>update_drawing_state(\nstate: State, _backend: Backend\n) -&gt; Tuple[State, Iterable[DrawCommand]]\n</code></pre> <p>Update drawing state.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/mo_unit_mode.py</code> <pre><code>def update_drawing_state(\nself,\nstate: State,\n_backend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n\"\"\"Update drawing state.\"\"\"\nif state.draw_units is not None:\nlogging.warning(\n\"Overriding coordinate format is illegal. \"\n\"(See 4.2.1 in Gerber Layer Format Specification)\",\n)\nreturn (\nstate.model_copy(\nupdate={\n\"draw_units\": self.unit,\n},\n),\n(),\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/sr_step_repeat.html","title":"sr_step_repeat","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/sr_step_repeat.html#pygerber.gerberx3.tokenizer.tokens.sr_step_repeat","title":"sr_step_repeat","text":"<p>Wrapper for aperture select token.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/sr_step_repeat.html#pygerber.gerberx3.tokenizer.tokens.sr_step_repeat.StepRepeatBegin","title":"StepRepeatBegin","text":"<p>             Bases: <code>Token</code></p> <p>Wrapper for SR begin token.</p> <p>Opens an SR statement and starts block accumulation.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/sr_step_repeat.py</code> <pre><code>class StepRepeatBegin(Token):\n\"\"\"Wrapper for SR begin token.\n    Opens an SR statement and starts block accumulation.\n    \"\"\"\nx_repeat: float\ny_repeat: float\nx_step: float\ny_step: float\n@classmethod\ndef from_tokens(cls, **tokens: Any) -&gt; Self:\n\"\"\"Initialize token object.\"\"\"\nx_repeat = float(tokens[\"x_repeat\"])\ny_repeat = float(tokens[\"y_repeat\"])\nx_step = float(tokens[\"x_step\"])\ny_step = float(tokens[\"y_step\"])\nreturn cls(\nx_repeat=x_repeat,\ny_repeat=y_repeat,\nx_step=x_step,\ny_step=y_step,\n)\ndef __str__(self) -&gt; str:\nreturn f\"SRX{self.x_repeat}Y{self.y_repeat}I{self.x_step}J{self.y_step}*\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/sr_step_repeat.html#pygerber.gerberx3.tokenizer.tokens.sr_step_repeat.StepRepeatBegin.from_tokens","title":"from_tokens  <code>classmethod</code>","text":"<pre><code>from_tokens(**tokens: Any) -&gt; Self\n</code></pre> <p>Initialize token object.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/sr_step_repeat.py</code> <pre><code>@classmethod\ndef from_tokens(cls, **tokens: Any) -&gt; Self:\n\"\"\"Initialize token object.\"\"\"\nx_repeat = float(tokens[\"x_repeat\"])\ny_repeat = float(tokens[\"y_repeat\"])\nx_step = float(tokens[\"x_step\"])\ny_step = float(tokens[\"y_step\"])\nreturn cls(\nx_repeat=x_repeat,\ny_repeat=y_repeat,\nx_step=x_step,\ny_step=y_step,\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/sr_step_repeat.html#pygerber.gerberx3.tokenizer.tokens.sr_step_repeat.StepRepeatEnd","title":"StepRepeatEnd","text":"<p>             Bases: <code>Token</code></p> <p>Wrapper for SR end token.</p> <p>Ends step and repeat statement.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/sr_step_repeat.py</code> <pre><code>class StepRepeatEnd(Token):\n\"\"\"Wrapper for SR end token.\n    Ends step and repeat statement.\n    \"\"\"\ndef __str__(self) -&gt; str:\nreturn \"SR*\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/token.html","title":"token","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/token.html#pygerber.gerberx3.tokenizer.tokens.token","title":"token","text":"<p>Base class for creating token classes.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/token.html#pygerber.gerberx3.tokenizer.tokens.token.Token","title":"Token","text":"<p>             Bases: <code>FrozenGeneralModel</code></p> <p>Base class for creating token classes.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/token.py</code> <pre><code>class Token(FrozenGeneralModel):\n\"\"\"Base class for creating token classes.\"\"\"\n@classmethod\ndef wrap(\ncls,\nexpr: ParserElement,\n*,\nuse_group: bool = True,\n) -&gt; ParserElement:\n\"\"\"Set parse result to be instance of this class.\"\"\"\nexpr = expr.set_parse_action(cls.new)\nif use_group:\nreturn Group(expr)\nreturn expr\n@classmethod\ndef new(cls, _string: str, _location: int, tokens: ParseResults) -&gt; Self:\n\"\"\"Create instance of this class.\n        Created to be used as callback in `ParserElement.set_parse_action()`.\n        \"\"\"\nreturn cls.from_tokens(**dict(tokens))\n@classmethod\ndef from_tokens(cls, **_tokens: Any) -&gt; Self:\n\"\"\"Initialize token object.\"\"\"\nreturn cls()\ndef __str__(self) -&gt; str:\nreturn f\"&lt;TOKEN {self.__class__.__qualname__}&gt;\"\ndef __repr__(self) -&gt; str:\n\"\"\"Return pretty representation of comment token.\"\"\"\nstring = str(self)\nrepr_string = f\"&lt;TOKEN {self.__class__.__qualname__}&gt;\"\nif repr_string == string:\nreturn repr_string\nreturn f\"&lt;{self.__class__.__qualname__} {string!r}&gt;\"\ndef get_debug_format(self) -&gt; str:\n\"\"\"Return debug formatted token object.\"\"\"\nreturn super().__repr__()\ndef __getitem__(self, _: int) -&gt; Self:\n\"\"\"Index return self.\"\"\"\nreturn self\ndef update_drawing_state(\nself,\nstate: State,\n_backend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n\"\"\"Update drawing state.\"\"\"\nreturn state, ()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/token.html#pygerber.gerberx3.tokenizer.tokens.token.Token.wrap","title":"wrap  <code>classmethod</code>","text":"<pre><code>wrap(\nexpr: ParserElement, *, use_group: bool = True\n) -&gt; ParserElement\n</code></pre> <p>Set parse result to be instance of this class.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/token.py</code> <pre><code>@classmethod\ndef wrap(\ncls,\nexpr: ParserElement,\n*,\nuse_group: bool = True,\n) -&gt; ParserElement:\n\"\"\"Set parse result to be instance of this class.\"\"\"\nexpr = expr.set_parse_action(cls.new)\nif use_group:\nreturn Group(expr)\nreturn expr\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/token.html#pygerber.gerberx3.tokenizer.tokens.token.Token.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(\n_string: str, _location: int, tokens: ParseResults\n) -&gt; Self\n</code></pre> <p>Create instance of this class.</p> <p>Created to be used as callback in <code>ParserElement.set_parse_action()</code>.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/token.py</code> <pre><code>@classmethod\ndef new(cls, _string: str, _location: int, tokens: ParseResults) -&gt; Self:\n\"\"\"Create instance of this class.\n    Created to be used as callback in `ParserElement.set_parse_action()`.\n    \"\"\"\nreturn cls.from_tokens(**dict(tokens))\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/token.html#pygerber.gerberx3.tokenizer.tokens.token.Token.from_tokens","title":"from_tokens  <code>classmethod</code>","text":"<pre><code>from_tokens(**_tokens: Any) -&gt; Self\n</code></pre> <p>Initialize token object.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/token.py</code> <pre><code>@classmethod\ndef from_tokens(cls, **_tokens: Any) -&gt; Self:\n\"\"\"Initialize token object.\"\"\"\nreturn cls()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/token.html#pygerber.gerberx3.tokenizer.tokens.token.Token.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return pretty representation of comment token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/token.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"Return pretty representation of comment token.\"\"\"\nstring = str(self)\nrepr_string = f\"&lt;TOKEN {self.__class__.__qualname__}&gt;\"\nif repr_string == string:\nreturn repr_string\nreturn f\"&lt;{self.__class__.__qualname__} {string!r}&gt;\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/token.html#pygerber.gerberx3.tokenizer.tokens.token.Token.get_debug_format","title":"get_debug_format","text":"<pre><code>get_debug_format() -&gt; str\n</code></pre> <p>Return debug formatted token object.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/token.py</code> <pre><code>def get_debug_format(self) -&gt; str:\n\"\"\"Return debug formatted token object.\"\"\"\nreturn super().__repr__()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/token.html#pygerber.gerberx3.tokenizer.tokens.token.Token.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(_: int) -&gt; Self\n</code></pre> <p>Index return self.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/token.py</code> <pre><code>def __getitem__(self, _: int) -&gt; Self:\n\"\"\"Index return self.\"\"\"\nreturn self\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/token.html#pygerber.gerberx3.tokenizer.tokens.token.Token.update_drawing_state","title":"update_drawing_state","text":"<pre><code>update_drawing_state(\nstate: State, _backend: Backend\n) -&gt; Tuple[State, Iterable[DrawCommand]]\n</code></pre> <p>Update drawing state.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/token.py</code> <pre><code>def update_drawing_state(\nself,\nstate: State,\n_backend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n\"\"\"Update drawing state.\"\"\"\nreturn state, ()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/token.html#pygerber.gerberx3.tokenizer.tokens.token.GerberX3Token","title":"GerberX3Token","text":"<p>             Bases: <code>Token</code></p> <p>Base class for tokens which are part of Gerber X3 standard.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/token.py</code> <pre><code>class GerberX3Token(Token):\n\"\"\"Base class for tokens which are part of Gerber X3 standard.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/token.html#pygerber.gerberx3.tokenizer.tokens.token.DeprecatedToken","title":"DeprecatedToken","text":"<p>             Bases: <code>Token</code></p> <p>Base class for tokens which are deprecated.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/token.py</code> <pre><code>class DeprecatedToken(Token):\n\"\"\"Base class for tokens which are deprecated.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/tx_attributes.html","title":"tx_attributes","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/tx_attributes.html#pygerber.gerberx3.tokenizer.tokens.tx_attributes","title":"tx_attributes","text":"<p>Comment token.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/tx_attributes.html#pygerber.gerberx3.tokenizer.tokens.tx_attributes.AttributeToken","title":"AttributeToken","text":"<p>             Bases: <code>Token</code></p> <p>Base class for all attribute manipulation tokens.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/tx_attributes.py</code> <pre><code>class AttributeToken(Token):\n\"\"\"Base class for all attribute manipulation tokens.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/tx_attributes.html#pygerber.gerberx3.tokenizer.tokens.tx_attributes.FileAttribute","title":"FileAttribute","text":"<p>             Bases: <code>AttributeToken</code></p> <p>File attribute token.</p> <p>The semantics of a file attribute specifies where it must be defined, typically in the header of the file. File attributes are immutable. They cannot be redefined or deleted.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/tx_attributes.py</code> <pre><code>class FileAttribute(AttributeToken):\n\"\"\"File attribute token.\n    The semantics of a file attribute specifies where it must be defined, typically in\n    the header of the file. File attributes are immutable. They cannot be redefined or\n    deleted.\n    \"\"\"\nname: str\nvalue: List[str]\n@classmethod\ndef from_tokens(cls, **tokens: Any) -&gt; Self:\n\"\"\"Initialize token object.\"\"\"\nname: str = tokens[\"file_attribute_name\"]\nvalue = tokens.get(\"field\", [])\nif isinstance(value, ParseResults):\nvalue = value.as_list()\nreturn cls(name=name, value=value)\ndef __str__(self) -&gt; str:\nreturn f\"TF{','.join((self.name, *self.value))}*\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/tx_attributes.html#pygerber.gerberx3.tokenizer.tokens.tx_attributes.FileAttribute.from_tokens","title":"from_tokens  <code>classmethod</code>","text":"<pre><code>from_tokens(**tokens: Any) -&gt; Self\n</code></pre> <p>Initialize token object.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/tx_attributes.py</code> <pre><code>@classmethod\ndef from_tokens(cls, **tokens: Any) -&gt; Self:\n\"\"\"Initialize token object.\"\"\"\nname: str = tokens[\"file_attribute_name\"]\nvalue = tokens.get(\"field\", [])\nif isinstance(value, ParseResults):\nvalue = value.as_list()\nreturn cls(name=name, value=value)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/tx_attributes.html#pygerber.gerberx3.tokenizer.tokens.tx_attributes.ApertureAttribute","title":"ApertureAttribute","text":"<p>             Bases: <code>AttributeToken</code></p> <p>Add an aperture attribute to the dictionary or modify it.</p> <p>An aperture attribute is attached to an aperture or a region. They are a method to assign attributes to graphical objects in bulk: all objects that are created with an aperture inherit its attributes; for example, a via attribute on an aperture means that all pads flashed with this aperture are via pads. Providing information about graphical objects via their apertures is elegant, compact and efficient. As region objects are created without intermediary aperture, aperture objects can be assigned to regions directly.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/tx_attributes.py</code> <pre><code>class ApertureAttribute(AttributeToken):\n\"\"\"Add an aperture attribute to the dictionary or modify it.\n    An aperture attribute is attached to an aperture or a region. They are a method to\n    assign attributes to graphical objects in bulk: all objects that are created with\n    an aperture inherit its attributes; for example, a via attribute on an aperture\n    means that all pads flashed with this aperture are via pads. Providing information\n    about graphical objects via their apertures is elegant, compact and efficient. As\n    region objects are created without intermediary aperture, aperture objects can be\n    assigned to regions directly.\n    \"\"\"\nname: str\nvalue: List[str]\n@classmethod\ndef from_tokens(cls, **tokens: Any) -&gt; Self:\n\"\"\"Initialize token object.\"\"\"\nname: str = tokens[\"aperture_attribute_name\"]\nvalue = tokens.get(\"field\", [])\nif isinstance(value, ParseResults):\nvalue = value.as_list()\nreturn cls(name=name, value=value)\ndef __str__(self) -&gt; str:\nreturn f\"TA{','.join((self.name, *self.value))}*\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/tx_attributes.html#pygerber.gerberx3.tokenizer.tokens.tx_attributes.ApertureAttribute.from_tokens","title":"from_tokens  <code>classmethod</code>","text":"<pre><code>from_tokens(**tokens: Any) -&gt; Self\n</code></pre> <p>Initialize token object.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/tx_attributes.py</code> <pre><code>@classmethod\ndef from_tokens(cls, **tokens: Any) -&gt; Self:\n\"\"\"Initialize token object.\"\"\"\nname: str = tokens[\"aperture_attribute_name\"]\nvalue = tokens.get(\"field\", [])\nif isinstance(value, ParseResults):\nvalue = value.as_list()\nreturn cls(name=name, value=value)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/tx_attributes.html#pygerber.gerberx3.tokenizer.tokens.tx_attributes.ObjectAttribute","title":"ObjectAttribute","text":"<p>             Bases: <code>AttributeToken</code></p> <p>Add an object attribute to the dictionary or modify it.</p> <p>An object attribute is attached to graphical objects. When a D01, D03 or region statement (G36/G37) creates an object all object attributes in the attribute dictionary are attached to it. As attribute commands are not allowed inside a region statement, all regions created by that statement have the same object attributes. Once attached to an object they cannot be chan</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/tx_attributes.py</code> <pre><code>class ObjectAttribute(AttributeToken):\n\"\"\"Add an object attribute to the dictionary or modify it.\n    An object attribute is attached to graphical objects. When a D01, D03 or region\n    statement (G36/G37) creates an object all object attributes in the attribute\n    dictionary are attached to it. As attribute commands are not allowed inside a region\n    statement, all regions created by that statement have the same object attributes.\n    Once attached to an object they cannot be chan\n    \"\"\"\nname: str\nvalue: List[str]\n@classmethod\ndef from_tokens(cls, **tokens: Any) -&gt; Self:\n\"\"\"Initialize token object.\"\"\"\nname: str = tokens[\"object_attribute_name\"]\nvalue = tokens.get(\"field\", [])\nif isinstance(value, ParseResults):\nvalue = value.as_list()\nreturn cls(name=name, value=value)\ndef __str__(self) -&gt; str:\nreturn f\"TO{','.join((self.name, *self.value))}*\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/tx_attributes.html#pygerber.gerberx3.tokenizer.tokens.tx_attributes.ObjectAttribute.from_tokens","title":"from_tokens  <code>classmethod</code>","text":"<pre><code>from_tokens(**tokens: Any) -&gt; Self\n</code></pre> <p>Initialize token object.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/tx_attributes.py</code> <pre><code>@classmethod\ndef from_tokens(cls, **tokens: Any) -&gt; Self:\n\"\"\"Initialize token object.\"\"\"\nname: str = tokens[\"object_attribute_name\"]\nvalue = tokens.get(\"field\", [])\nif isinstance(value, ParseResults):\nvalue = value.as_list()\nreturn cls(name=name, value=value)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/tx_attributes.html#pygerber.gerberx3.tokenizer.tokens.tx_attributes.DeleteAttribute","title":"DeleteAttribute","text":"<p>             Bases: <code>AttributeToken</code></p> <p>Delete one or all attributes in the dictionary.</p> <p>The TD command deletes an aperture attribute or object attribute from the attributes dictionary. (File attributes are immutable and are not deleted.)</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/tx_attributes.py</code> <pre><code>class DeleteAttribute(AttributeToken):\n\"\"\"Delete one or all attributes in the dictionary.\n    The TD command deletes an aperture attribute or object attribute from the attributes\n    dictionary. (File attributes are immutable and are not deleted.)\n    \"\"\"\nname: Optional[str]\n@classmethod\ndef from_tokens(cls, **tokens: Any) -&gt; Self:\n\"\"\"Initialize token object.\"\"\"\nname: Optional[str] = tokens.get(\"attribute_name\")\nreturn cls(name=name)\ndef __str__(self) -&gt; str:\nreturn f\"TD{self.name if self.name is not None else ''}*\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/tx_attributes.html#pygerber.gerberx3.tokenizer.tokens.tx_attributes.DeleteAttribute.from_tokens","title":"from_tokens  <code>classmethod</code>","text":"<pre><code>from_tokens(**tokens: Any) -&gt; Self\n</code></pre> <p>Initialize token object.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/tx_attributes.py</code> <pre><code>@classmethod\ndef from_tokens(cls, **tokens: Any) -&gt; Self:\n\"\"\"Initialize token object.\"\"\"\nname: Optional[str] = tokens.get(\"attribute_name\")\nreturn cls(name=name)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/__init__.html","title":"init","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/__init__.html#pygerber.gerberx3.tokenizer.tokens.macro","title":"macro","text":"<p>The AM command creates a macro aperture template and adds it to the aperture template dictionary (see 2.2). A template is a parametrized shape. The AD command instantiates a template into an aperture by suppling values to the template parameters.</p> <p>Templates of any shape or parametrization can be created. Multiple simple shapes called primitives can be combined in a single template. An aperture macro can contain variables whose actual values are defined by:</p> <ul> <li> <p>Values provided by the AD command</p> </li> <li> <p>Arithmetic expressions with other variables</p> </li> </ul> <p>The template is created by positioning primitives in a coordinate space. The origin of that coordinate space will be the origin of all apertures created with the state.</p> <p>A template must be defined before the first AD that refers to it. The AM command can be used multiple times in a file.</p> <p>Attributes are not attached to templates. They are attached to the aperture at the time of its creation with the AD command.</p> <p>An AM command contains the following words:</p> <ul> <li> <p>The AM declaration with the macro name</p> </li> <li> <p>Primitives with their comma-separated parameters</p> </li> <li> <p>Macro variables, defined by an arithmetic expression</p> </li> </ul>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/am_macro.html","title":"am_macro","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/am_macro.html#pygerber.gerberx3.tokenizer.tokens.macro.am_macro","title":"am_macro","text":"<p>Container token for macro definition.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/am_macro.html#pygerber.gerberx3.tokenizer.tokens.macro.am_macro.MacroDefinition","title":"MacroDefinition","text":"<p>             Bases: <code>Token</code></p> <p>Container token for macro definition.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/am_macro.py</code> <pre><code>class MacroDefinition(Token):\n\"\"\"Container token for macro definition.\"\"\"\nmacro_name: str\nmacro_body: List[Expression]\n@classmethod\ndef from_tokens(cls, **tokens: Any) -&gt; Self:\n\"\"\"Initialize token object.\"\"\"\nmacro_name: str = tokens[\"macro_name\"]\nmacro_body: List[Expression] = [\nunwrap(e) for e in flatten(tokens[\"macro_body\"])\n]\nreturn cls(macro_name=macro_name, macro_body=macro_body)\ndef update_drawing_state(\nself,\nstate: State,\n_backend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n\"\"\"Exit drawing process.\"\"\"\nnew_macros_dict = {**state.macros}\nnew_macros_dict[self.macro_name] = self\nreturn (\nstate.model_copy(\nupdate={\n\"macros\": new_macros_dict,\n},\n),\n(),\n)\ndef evaluate(\nself,\nstate: State,\nhandle: PrivateApertureHandle,\nparameters: dict[str, Offset],\n) -&gt; None:\n\"\"\"Evaluate macro into series of DrawCommands.\"\"\"\ncontext = MacroContext()\ncontext.variables.update(parameters)\nfor expression in self.macro_body:\nexpression.evaluate(context, state, handle)\ndef __str__(self) -&gt; str:\nstr_body = \"\\n\".join(str(e) for e in self.macro_body)\nindented_body = indent(str_body, prefix=\"  \")\nreturn f\"%AM{self.macro_name}*\\n{indented_body}\\n%\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/am_macro.html#pygerber.gerberx3.tokenizer.tokens.macro.am_macro.MacroDefinition.from_tokens","title":"from_tokens  <code>classmethod</code>","text":"<pre><code>from_tokens(**tokens: Any) -&gt; Self\n</code></pre> <p>Initialize token object.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/am_macro.py</code> <pre><code>@classmethod\ndef from_tokens(cls, **tokens: Any) -&gt; Self:\n\"\"\"Initialize token object.\"\"\"\nmacro_name: str = tokens[\"macro_name\"]\nmacro_body: List[Expression] = [\nunwrap(e) for e in flatten(tokens[\"macro_body\"])\n]\nreturn cls(macro_name=macro_name, macro_body=macro_body)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/am_macro.html#pygerber.gerberx3.tokenizer.tokens.macro.am_macro.MacroDefinition.update_drawing_state","title":"update_drawing_state","text":"<pre><code>update_drawing_state(\nstate: State, _backend: Backend\n) -&gt; Tuple[State, Iterable[DrawCommand]]\n</code></pre> <p>Exit drawing process.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/am_macro.py</code> <pre><code>def update_drawing_state(\nself,\nstate: State,\n_backend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n\"\"\"Exit drawing process.\"\"\"\nnew_macros_dict = {**state.macros}\nnew_macros_dict[self.macro_name] = self\nreturn (\nstate.model_copy(\nupdate={\n\"macros\": new_macros_dict,\n},\n),\n(),\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/am_macro.html#pygerber.gerberx3.tokenizer.tokens.macro.am_macro.MacroDefinition.evaluate","title":"evaluate","text":"<pre><code>evaluate(\nstate: State,\nhandle: PrivateApertureHandle,\nparameters: dict[str, Offset],\n) -&gt; None\n</code></pre> <p>Evaluate macro into series of DrawCommands.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/am_macro.py</code> <pre><code>def evaluate(\nself,\nstate: State,\nhandle: PrivateApertureHandle,\nparameters: dict[str, Offset],\n) -&gt; None:\n\"\"\"Evaluate macro into series of DrawCommands.\"\"\"\ncontext = MacroContext()\ncontext.variables.update(parameters)\nfor expression in self.macro_body:\nexpression.evaluate(context, state, handle)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/arithmetic_expression.html","title":"arithmetic_expression","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/arithmetic_expression.html#pygerber.gerberx3.tokenizer.tokens.macro.arithmetic_expression","title":"arithmetic_expression","text":"<p>Arithmetic expression token.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/arithmetic_expression.html#pygerber.gerberx3.tokenizer.tokens.macro.arithmetic_expression.ARITHMETIC_EXPRESSION_TOKEN_COUNT","title":"ARITHMETIC_EXPRESSION_TOKEN_COUNT  <code>module-attribute</code>","text":"<pre><code>ARITHMETIC_EXPRESSION_TOKEN_COUNT = 3\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/arithmetic_expression.html#pygerber.gerberx3.tokenizer.tokens.macro.arithmetic_expression.ARITHMETIC_EXPRESSION_SINGLE_OPERAND_TOKEN_COUNT","title":"ARITHMETIC_EXPRESSION_SINGLE_OPERAND_TOKEN_COUNT  <code>module-attribute</code>","text":"<pre><code>ARITHMETIC_EXPRESSION_SINGLE_OPERAND_TOKEN_COUNT = 2\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/arithmetic_expression.html#pygerber.gerberx3.tokenizer.tokens.macro.arithmetic_expression.ArithmeticExpression","title":"ArithmeticExpression","text":"<p>             Bases: <code>NumericExpression</code></p> <p>Wrapper for arithmetic expression.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/arithmetic_expression.py</code> <pre><code>class ArithmeticExpression(NumericExpression):\n\"\"\"Wrapper for arithmetic expression.\"\"\"\nleft: NumericExpression\noperator: ArithmeticOperator\nright: NumericExpression\n@classmethod\ndef from_tokens(cls, **tokens: Any) -&gt; Self:\n\"\"\"Initialize token object.\"\"\"\nleft = tokens[\"left\"]\noperator = str(tokens[\"operator\"]).lower()\nright = tokens[\"right\"]\nreturn cls(left=left, operator=ArithmeticOperator(operator), right=right)\n@classmethod\ndef new(cls, _string: str, _location: int, tokens: ParseResults) -&gt; Self:\n\"\"\"Create instance of this class.\n        Created to be used as callback in `ParserElement.set_parse_action()`.\n        \"\"\"\nreturn cls._build(tokens.as_list()[0])\n@classmethod\ndef _build(cls, tokens: list[ParseResults]) -&gt; Self:\nleft: Any\noperator: Any\n(left, operator, *rest) = tokens\nright: NumericExpression\nif len(rest) &gt;= ARITHMETIC_EXPRESSION_TOKEN_COUNT:\nright = cls._build(rest)\nelif len(rest) == ARITHMETIC_EXPRESSION_SINGLE_OPERAND_TOKEN_COUNT:\nraise InvalidArithmeticExpressionError\nelif len(rest) == 1:\n(right,) = cast(\"tuple[NumericExpression]\", rest)\nelif len(rest) == 0:\n(left, operator, right) = (\nNumericConstant(value=Decimal(\"0.0\")),\nleft,\noperator,\n)\nelse:\nraise AssertionError\nreturn cls.from_tokens(\nleft=left,\noperator=operator,\nright=right,\n)\ndef evaluate_numeric(self, macro_context: MacroContext, state: State) -&gt; Offset:\n\"\"\"Evaluate numeric value of this macro expression.\"\"\"\nleft = self.left.evaluate_numeric(macro_context, state)\nright = self.right.evaluate_numeric(macro_context, state)\noutput = self.operator.evaluate(left, right)\nif not isinstance(output, Offset):\nraise InvalidArithmeticExpressionError\nreturn output\ndef __str__(self) -&gt; str:\nreturn f\"{self.left}{self.operator.value}{self.right}\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/arithmetic_expression.html#pygerber.gerberx3.tokenizer.tokens.macro.arithmetic_expression.ArithmeticExpression.from_tokens","title":"from_tokens  <code>classmethod</code>","text":"<pre><code>from_tokens(**tokens: Any) -&gt; Self\n</code></pre> <p>Initialize token object.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/arithmetic_expression.py</code> <pre><code>@classmethod\ndef from_tokens(cls, **tokens: Any) -&gt; Self:\n\"\"\"Initialize token object.\"\"\"\nleft = tokens[\"left\"]\noperator = str(tokens[\"operator\"]).lower()\nright = tokens[\"right\"]\nreturn cls(left=left, operator=ArithmeticOperator(operator), right=right)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/arithmetic_expression.html#pygerber.gerberx3.tokenizer.tokens.macro.arithmetic_expression.ArithmeticExpression.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(\n_string: str, _location: int, tokens: ParseResults\n) -&gt; Self\n</code></pre> <p>Create instance of this class.</p> <p>Created to be used as callback in <code>ParserElement.set_parse_action()</code>.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/arithmetic_expression.py</code> <pre><code>@classmethod\ndef new(cls, _string: str, _location: int, tokens: ParseResults) -&gt; Self:\n\"\"\"Create instance of this class.\n    Created to be used as callback in `ParserElement.set_parse_action()`.\n    \"\"\"\nreturn cls._build(tokens.as_list()[0])\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/arithmetic_expression.html#pygerber.gerberx3.tokenizer.tokens.macro.arithmetic_expression.ArithmeticExpression.evaluate_numeric","title":"evaluate_numeric","text":"<pre><code>evaluate_numeric(\nmacro_context: MacroContext, state: State\n) -&gt; Offset\n</code></pre> <p>Evaluate numeric value of this macro expression.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/arithmetic_expression.py</code> <pre><code>def evaluate_numeric(self, macro_context: MacroContext, state: State) -&gt; Offset:\n\"\"\"Evaluate numeric value of this macro expression.\"\"\"\nleft = self.left.evaluate_numeric(macro_context, state)\nright = self.right.evaluate_numeric(macro_context, state)\noutput = self.operator.evaluate(left, right)\nif not isinstance(output, Offset):\nraise InvalidArithmeticExpressionError\nreturn output\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/arithmetic_expression.html#pygerber.gerberx3.tokenizer.tokens.macro.arithmetic_expression.InvalidArithmeticExpressionError","title":"InvalidArithmeticExpressionError","text":"<p>             Bases: <code>TokenizerError</code></p> <p>Raised when it's not possible to construct valid arithmetic expression.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/arithmetic_expression.py</code> <pre><code>class InvalidArithmeticExpressionError(TokenizerError):\n\"\"\"Raised when it's not possible to construct valid arithmetic expression.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/arithmetic_expression.html#pygerber.gerberx3.tokenizer.tokens.macro.arithmetic_expression.ArithmeticOperator","title":"ArithmeticOperator","text":"<p>             Bases: <code>Enum</code></p> <p>Enum of possible math operations.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/arithmetic_expression.py</code> <pre><code>class ArithmeticOperator(Enum):\n\"\"\"Enum of possible math operations.\"\"\"\nMULTIPLICATION = \"x\"\nDIVISION = \"/\"\nADDITION = \"+\"\nSUBTRACTION = \"-\"\ndef evaluate(self, left: Any, right: Any) -&gt; Any:\n\"\"\"Evaluate corresponding arithmetic operator on given operands.\"\"\"\nif self == ArithmeticOperator.MULTIPLICATION:\nreturn left * right\nif self == ArithmeticOperator.DIVISION:\nreturn left / right\nif self == ArithmeticOperator.ADDITION:\nreturn left + right\nif self == ArithmeticOperator.SUBTRACTION:\nreturn left - right\nraise AssertionError\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/arithmetic_expression.html#pygerber.gerberx3.tokenizer.tokens.macro.arithmetic_expression.ArithmeticOperator.evaluate","title":"evaluate","text":"<pre><code>evaluate(left: Any, right: Any) -&gt; Any\n</code></pre> <p>Evaluate corresponding arithmetic operator on given operands.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/arithmetic_expression.py</code> <pre><code>def evaluate(self, left: Any, right: Any) -&gt; Any:\n\"\"\"Evaluate corresponding arithmetic operator on given operands.\"\"\"\nif self == ArithmeticOperator.MULTIPLICATION:\nreturn left * right\nif self == ArithmeticOperator.DIVISION:\nreturn left / right\nif self == ArithmeticOperator.ADDITION:\nreturn left + right\nif self == ArithmeticOperator.SUBTRACTION:\nreturn left - right\nraise AssertionError\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/arithmetic_expression.html#pygerber.gerberx3.tokenizer.tokens.macro.arithmetic_expression.NumericConstant","title":"NumericConstant","text":"<p>             Bases: <code>NumericExpression</code></p> <p>Wrapper around numeric constant expression token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/arithmetic_expression.py</code> <pre><code>class NumericConstant(NumericExpression):\n\"\"\"Wrapper around numeric constant expression token.\"\"\"\nvalue: Decimal\n@classmethod\ndef from_tokens(cls, **tokens: Any) -&gt; Self:\n\"\"\"Initialize token object.\"\"\"\nvalue = Decimal(tokens[\"numeric_constant_value\"])\nreturn cls(value=value)\ndef evaluate_numeric(self, _macro_context: MacroContext, state: State) -&gt; Offset:\n\"\"\"Evaluate numeric value of this macro expression.\"\"\"\nreturn Offset.new(value=self.value, unit=state.get_units())\ndef __str__(self) -&gt; str:\nreturn str(self.value)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/arithmetic_expression.html#pygerber.gerberx3.tokenizer.tokens.macro.arithmetic_expression.NumericConstant.from_tokens","title":"from_tokens  <code>classmethod</code>","text":"<pre><code>from_tokens(**tokens: Any) -&gt; Self\n</code></pre> <p>Initialize token object.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/arithmetic_expression.py</code> <pre><code>@classmethod\ndef from_tokens(cls, **tokens: Any) -&gt; Self:\n\"\"\"Initialize token object.\"\"\"\nvalue = Decimal(tokens[\"numeric_constant_value\"])\nreturn cls(value=value)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/arithmetic_expression.html#pygerber.gerberx3.tokenizer.tokens.macro.arithmetic_expression.NumericConstant.evaluate_numeric","title":"evaluate_numeric","text":"<pre><code>evaluate_numeric(\n_macro_context: MacroContext, state: State\n) -&gt; Offset\n</code></pre> <p>Evaluate numeric value of this macro expression.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/arithmetic_expression.py</code> <pre><code>def evaluate_numeric(self, _macro_context: MacroContext, state: State) -&gt; Offset:\n\"\"\"Evaluate numeric value of this macro expression.\"\"\"\nreturn Offset.new(value=self.value, unit=state.get_units())\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/comment.html","title":"comment","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/comment.html#pygerber.gerberx3.tokenizer.tokens.macro.comment","title":"comment","text":"<p>Comment token.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/comment.html#pygerber.gerberx3.tokenizer.tokens.macro.comment.MacroComment","title":"MacroComment","text":"<p>             Bases: <code>Comment</code></p> <p>Macro comment token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/comment.py</code> <pre><code>class MacroComment(Comment):\n\"\"\"Macro comment token.\"\"\"\ndef __str__(self) -&gt; str:\nreturn f\"0 {self.content}*\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/expression.html","title":"expression","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/expression.html#pygerber.gerberx3.tokenizer.tokens.macro.expression","title":"expression","text":"<p>In-macro expression token.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/expression.html#pygerber.gerberx3.tokenizer.tokens.macro.expression.Expression","title":"Expression","text":"<p>             Bases: <code>Token</code></p> <p>Wrapper for in-macro expression.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/expression.py</code> <pre><code>class Expression(Token):\n\"\"\"Wrapper for in-macro expression.\"\"\"\ndef evaluate(\nself,\nmacro_context: MacroContext,\nstate: State,\nhandle: PrivateApertureHandle,\n/,\n) -&gt; None:\n\"\"\"Evaluate macro expression.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/expression.html#pygerber.gerberx3.tokenizer.tokens.macro.expression.Expression.evaluate","title":"evaluate","text":"<pre><code>evaluate(\nmacro_context: MacroContext,\nstate: State,\nhandle: PrivateApertureHandle,\n) -&gt; None\n</code></pre> <p>Evaluate macro expression.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/expression.py</code> <pre><code>def evaluate(\nself,\nmacro_context: MacroContext,\nstate: State,\nhandle: PrivateApertureHandle,\n/,\n) -&gt; None:\n\"\"\"Evaluate macro expression.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/macro_context.html","title":"macro_context","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/macro_context.html#pygerber.gerberx3.tokenizer.tokens.macro.macro_context","title":"macro_context","text":"<p>Module contains MacroContext class definition.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/macro_context.html#pygerber.gerberx3.tokenizer.tokens.macro.macro_context.MacroContext","title":"MacroContext","text":"<p>             Bases: <code>BaseModel</code></p> <p>Macro context object used during macro evaluation.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/macro_context.py</code> <pre><code>class MacroContext(BaseModel):\n\"\"\"Macro context object used during macro evaluation.\"\"\"\nvariables: Dict[str, Offset] = Field(default_factory=dict)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/numeric_expression.html","title":"numeric_expression","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/numeric_expression.html#pygerber.gerberx3.tokenizer.tokens.macro.numeric_expression","title":"numeric_expression","text":"<p>In-macro numeric expression token.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/numeric_expression.html#pygerber.gerberx3.tokenizer.tokens.macro.numeric_expression.NumericExpression","title":"NumericExpression","text":"<p>             Bases: <code>Token</code></p> <p>Wrapper for in-macro numeric expression.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/numeric_expression.py</code> <pre><code>class NumericExpression(Token):\n\"\"\"Wrapper for in-macro numeric expression.\"\"\"\ndef evaluate_numeric(\nself,\n_macro_context: MacroContext,\nstate: State,\n/,\n) -&gt; Offset:\n\"\"\"Evaluate numeric value of this macro expression.\"\"\"\nreturn Offset.new(value=\"0.0\", unit=state.get_units())\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/numeric_expression.html#pygerber.gerberx3.tokenizer.tokens.macro.numeric_expression.NumericExpression.evaluate_numeric","title":"evaluate_numeric","text":"<pre><code>evaluate_numeric(\n_macro_context: MacroContext, state: State\n) -&gt; Offset\n</code></pre> <p>Evaluate numeric value of this macro expression.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/numeric_expression.py</code> <pre><code>def evaluate_numeric(\nself,\n_macro_context: MacroContext,\nstate: State,\n/,\n) -&gt; Offset:\n\"\"\"Evaluate numeric value of this macro expression.\"\"\"\nreturn Offset.new(value=\"0.0\", unit=state.get_units())\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/point.html","title":"point","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/point.html#pygerber.gerberx3.tokenizer.tokens.macro.point","title":"point","text":"<p>Point wrapper token.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/point.html#pygerber.gerberx3.tokenizer.tokens.macro.point.Point","title":"Point","text":"<p>             Bases: <code>Expression</code></p> <p>Point wrapper token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/point.py</code> <pre><code>class Point(Expression):\n\"\"\"Point wrapper token.\"\"\"\nx: NumericExpression\ny: NumericExpression\n@classmethod\ndef from_tokens(cls, **tokens: Any) -&gt; Self:\n\"\"\"Initialize token object.\"\"\"\nx: NumericExpression = unwrap(tokens[\"x\"])\ny: NumericExpression = unwrap(tokens[\"y\"])\nreturn cls(x=x, y=y)\ndef __str__(self) -&gt; str:\nreturn f\"{self.x},{self.y}\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/point.html#pygerber.gerberx3.tokenizer.tokens.macro.point.Point.from_tokens","title":"from_tokens  <code>classmethod</code>","text":"<pre><code>from_tokens(**tokens: Any) -&gt; Self\n</code></pre> <p>Initialize token object.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/point.py</code> <pre><code>@classmethod\ndef from_tokens(cls, **tokens: Any) -&gt; Self:\n\"\"\"Initialize token object.\"\"\"\nx: NumericExpression = unwrap(tokens[\"x\"])\ny: NumericExpression = unwrap(tokens[\"y\"])\nreturn cls(x=x, y=y)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/primitives.html","title":"primitives","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/primitives.html#pygerber.gerberx3.tokenizer.tokens.macro.primitives","title":"primitives","text":"<p>Macro primitives tokens.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/primitives.html#pygerber.gerberx3.tokenizer.tokens.macro.primitives.Primitive","title":"Primitive","text":"<p>             Bases: <code>Expression</code></p> <p>Wrapper for macro primitive token, common base class for specialized tokens.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/primitives.py</code> <pre><code>class Primitive(Expression):\n\"\"\"Wrapper for macro primitive token, common base class for specialized tokens.\"\"\"\nsymbol: ClassVar[str] = \"X\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/primitives.html#pygerber.gerberx3.tokenizer.tokens.macro.primitives.PrimitiveCircle","title":"PrimitiveCircle","text":"<p>             Bases: <code>Primitive</code></p> <p>Wrapper for macro circle primitive token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/primitives.py</code> <pre><code>class PrimitiveCircle(Primitive):\n\"\"\"Wrapper for macro circle primitive token.\"\"\"\nsymbol: ClassVar[str] = \"1\"\nexposure: NumericExpression\ndiameter: NumericExpression\ncenter_x: NumericExpression\ncenter_y: NumericExpression\nrotation: NumericExpression\n@classmethod\ndef from_tokens(cls, **tokens: Any) -&gt; Self:\n\"\"\"Initialize token object.\"\"\"\nexposure: NumericExpression = unwrap(tokens[\"exposure\"])\ndiameter: NumericExpression = unwrap(tokens[\"diameter\"])\ncenter_x: NumericExpression = unwrap(tokens[\"center_x\"])\ncenter_y: NumericExpression = unwrap(tokens[\"center_y\"])\nrotation: Optional[NumericExpression] = (\nunwrap(tokens[\"rotation\"]) if tokens.get(\"rotation\") is not None else None\n)\nif rotation is None:\nrotation = NumericConstant(value=Decimal(\"0.0\"))\nreturn cls(\nexposure=exposure,\ndiameter=diameter,\ncenter_x=center_x,\ncenter_y=center_y,\nrotation=rotation,\n)\ndef evaluate(\nself,\nmacro_context: MacroContext,\nstate: State,\nhandle: PrivateApertureHandle,\n) -&gt; None:\n\"\"\"Evaluate macro expression.\"\"\"\nself.exposure.evaluate_numeric(macro_context, state)\nself.diameter.evaluate_numeric(macro_context, state)\nself.center_x.evaluate_numeric(macro_context, state)\nself.center_y.evaluate_numeric(macro_context, state)\nself.rotation.evaluate_numeric(macro_context, state)\nreturn super().evaluate(macro_context, state, handle)\ndef __str__(self) -&gt; str:\nstring = self.symbol\nstring += f\",{self.exposure}\"\nstring += f\",{self.diameter}\"\nstring += f\",{self.center_x}\"\nstring += f\",{self.center_y}\"\nif self.rotation is not None:\nstring += f\",{self.rotation}\"\nreturn string + \"*\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/primitives.html#pygerber.gerberx3.tokenizer.tokens.macro.primitives.PrimitiveCircle.from_tokens","title":"from_tokens  <code>classmethod</code>","text":"<pre><code>from_tokens(**tokens: Any) -&gt; Self\n</code></pre> <p>Initialize token object.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/primitives.py</code> <pre><code>@classmethod\ndef from_tokens(cls, **tokens: Any) -&gt; Self:\n\"\"\"Initialize token object.\"\"\"\nexposure: NumericExpression = unwrap(tokens[\"exposure\"])\ndiameter: NumericExpression = unwrap(tokens[\"diameter\"])\ncenter_x: NumericExpression = unwrap(tokens[\"center_x\"])\ncenter_y: NumericExpression = unwrap(tokens[\"center_y\"])\nrotation: Optional[NumericExpression] = (\nunwrap(tokens[\"rotation\"]) if tokens.get(\"rotation\") is not None else None\n)\nif rotation is None:\nrotation = NumericConstant(value=Decimal(\"0.0\"))\nreturn cls(\nexposure=exposure,\ndiameter=diameter,\ncenter_x=center_x,\ncenter_y=center_y,\nrotation=rotation,\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/primitives.html#pygerber.gerberx3.tokenizer.tokens.macro.primitives.PrimitiveCircle.evaluate","title":"evaluate","text":"<pre><code>evaluate(\nmacro_context: MacroContext,\nstate: State,\nhandle: PrivateApertureHandle,\n) -&gt; None\n</code></pre> <p>Evaluate macro expression.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/primitives.py</code> <pre><code>def evaluate(\nself,\nmacro_context: MacroContext,\nstate: State,\nhandle: PrivateApertureHandle,\n) -&gt; None:\n\"\"\"Evaluate macro expression.\"\"\"\nself.exposure.evaluate_numeric(macro_context, state)\nself.diameter.evaluate_numeric(macro_context, state)\nself.center_x.evaluate_numeric(macro_context, state)\nself.center_y.evaluate_numeric(macro_context, state)\nself.rotation.evaluate_numeric(macro_context, state)\nreturn super().evaluate(macro_context, state, handle)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/primitives.html#pygerber.gerberx3.tokenizer.tokens.macro.primitives.PrimitiveVectorLine","title":"PrimitiveVectorLine","text":"<p>             Bases: <code>Primitive</code></p> <p>Wrapper for macro vector line primitive token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/primitives.py</code> <pre><code>class PrimitiveVectorLine(Primitive):\n\"\"\"Wrapper for macro vector line primitive token.\"\"\"\nsymbol: ClassVar[str] = \"20\"\nexposure: NumericExpression\nwidth: NumericExpression\nstart_x: NumericExpression\nstart_y: NumericExpression\nend_x: NumericExpression\nend_y: NumericExpression\nrotation: NumericExpression\n@classmethod\ndef from_tokens(cls, **tokens: Any) -&gt; Self:\n\"\"\"Initialize token object.\"\"\"\nexposure: NumericExpression = unwrap(tokens[\"exposure\"])\nwidth: NumericExpression = unwrap(tokens[\"width\"])\nstart_x: NumericExpression = unwrap(tokens[\"start_x\"])\nstart_y: NumericExpression = unwrap(tokens[\"start_y\"])\nend_x: NumericExpression = unwrap(tokens[\"end_x\"])\nend_y: NumericExpression = unwrap(tokens[\"end_y\"])\nrotation: NumericExpression = unwrap(tokens[\"rotation\"])\nreturn cls(\nexposure=exposure,\nwidth=width,\nstart_x=start_x,\nstart_y=start_y,\nend_x=end_x,\nend_y=end_y,\nrotation=rotation,\n)\ndef __str__(self) -&gt; str:\nstring = self.symbol\nstring += f\",{self.exposure}\"\nstring += f\",{self.width}\"\nstring += f\",{self.start_x}\"\nstring += f\",{self.start_y}\"\nstring += f\",{self.end_x}\"\nstring += f\",{self.end_y}\"\nstring += f\",{self.rotation}\"\nreturn string + \"*\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/primitives.html#pygerber.gerberx3.tokenizer.tokens.macro.primitives.PrimitiveVectorLine.from_tokens","title":"from_tokens  <code>classmethod</code>","text":"<pre><code>from_tokens(**tokens: Any) -&gt; Self\n</code></pre> <p>Initialize token object.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/primitives.py</code> <pre><code>@classmethod\ndef from_tokens(cls, **tokens: Any) -&gt; Self:\n\"\"\"Initialize token object.\"\"\"\nexposure: NumericExpression = unwrap(tokens[\"exposure\"])\nwidth: NumericExpression = unwrap(tokens[\"width\"])\nstart_x: NumericExpression = unwrap(tokens[\"start_x\"])\nstart_y: NumericExpression = unwrap(tokens[\"start_y\"])\nend_x: NumericExpression = unwrap(tokens[\"end_x\"])\nend_y: NumericExpression = unwrap(tokens[\"end_y\"])\nrotation: NumericExpression = unwrap(tokens[\"rotation\"])\nreturn cls(\nexposure=exposure,\nwidth=width,\nstart_x=start_x,\nstart_y=start_y,\nend_x=end_x,\nend_y=end_y,\nrotation=rotation,\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/primitives.html#pygerber.gerberx3.tokenizer.tokens.macro.primitives.PrimitiveCenterLine","title":"PrimitiveCenterLine","text":"<p>             Bases: <code>Primitive</code></p> <p>Wrapper for macro center line primitive token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/primitives.py</code> <pre><code>class PrimitiveCenterLine(Primitive):\n\"\"\"Wrapper for macro center line primitive token.\"\"\"\nsymbol: ClassVar[str] = \"21\"\nexposure: NumericExpression\nwidth: NumericExpression\nhight: NumericExpression\ncenter_x: NumericExpression\ncenter_y: NumericExpression\nrotation: NumericExpression\n@classmethod\ndef from_tokens(cls, **tokens: Any) -&gt; Self:\n\"\"\"Initialize token object.\"\"\"\nexposure: NumericExpression = unwrap(tokens[\"exposure\"])\nwidth: NumericExpression = unwrap(tokens[\"width\"])\nhight: NumericExpression = unwrap(tokens[\"hight\"])\ncenter_x: NumericExpression = unwrap(tokens[\"center_x\"])\ncenter_y: NumericExpression = unwrap(tokens[\"center_y\"])\nrotation: NumericExpression = unwrap(tokens[\"rotation\"])\nreturn cls(\nexposure=exposure,\nwidth=width,\nhight=hight,\ncenter_x=center_x,\ncenter_y=center_y,\nrotation=rotation,\n)\ndef __str__(self) -&gt; str:\nstring = self.symbol\nstring += f\",{self.exposure}\"\nstring += f\",{self.width}\"\nstring += f\",{self.hight}\"\nstring += f\",{self.center_x}\"\nstring += f\",{self.center_y}\"\nstring += f\",{self.rotation}\"\nreturn string + \"*\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/primitives.html#pygerber.gerberx3.tokenizer.tokens.macro.primitives.PrimitiveCenterLine.from_tokens","title":"from_tokens  <code>classmethod</code>","text":"<pre><code>from_tokens(**tokens: Any) -&gt; Self\n</code></pre> <p>Initialize token object.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/primitives.py</code> <pre><code>@classmethod\ndef from_tokens(cls, **tokens: Any) -&gt; Self:\n\"\"\"Initialize token object.\"\"\"\nexposure: NumericExpression = unwrap(tokens[\"exposure\"])\nwidth: NumericExpression = unwrap(tokens[\"width\"])\nhight: NumericExpression = unwrap(tokens[\"hight\"])\ncenter_x: NumericExpression = unwrap(tokens[\"center_x\"])\ncenter_y: NumericExpression = unwrap(tokens[\"center_y\"])\nrotation: NumericExpression = unwrap(tokens[\"rotation\"])\nreturn cls(\nexposure=exposure,\nwidth=width,\nhight=hight,\ncenter_x=center_x,\ncenter_y=center_y,\nrotation=rotation,\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/primitives.html#pygerber.gerberx3.tokenizer.tokens.macro.primitives.PrimitiveOutline","title":"PrimitiveOutline","text":"<p>             Bases: <code>Primitive</code></p> <p>Wrapper for macro outline primitive token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/primitives.py</code> <pre><code>class PrimitiveOutline(Primitive):\n\"\"\"Wrapper for macro outline primitive token.\"\"\"\nsymbol: ClassVar[str] = \"4\"\nexposure: NumericExpression\nnumber_of_vertices: NumericExpression\nstart_x: NumericExpression\nstart_y: NumericExpression\nrotation: NumericExpression\npoint: List[Point]\n@classmethod\ndef from_tokens(cls, **tokens: Any) -&gt; Self:\n\"\"\"Initialize token object.\"\"\"\nexposure: NumericExpression = unwrap(tokens[\"exposure\"])\nnumber_of_vertices: NumericExpression = unwrap(tokens[\"number_of_vertices\"])\nstart_x: NumericExpression = unwrap(tokens[\"start_x\"])\nstart_y: NumericExpression = unwrap(tokens[\"start_y\"])\nrotation: NumericExpression = unwrap(tokens[\"rotation\"])\npoint: list[Point] = list(tokens.get(\"point\", []))\nreturn cls(\nexposure=exposure,\nnumber_of_vertices=number_of_vertices,\nstart_x=start_x,\nstart_y=start_y,\nrotation=rotation,\npoint=point,\n)\ndef __str__(self) -&gt; str:\nstring = self.symbol\nstring += f\",{self.exposure}\"\nstring += f\",{self.number_of_vertices}\"\nstring += f\",{self.start_x}\"\nstring += f\",{self.start_y}\"\nstring += f\",{self.rotation}\"\nfor point in self.point:\nstring += f\",{point}\"\nreturn string + \"*\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/primitives.html#pygerber.gerberx3.tokenizer.tokens.macro.primitives.PrimitiveOutline.from_tokens","title":"from_tokens  <code>classmethod</code>","text":"<pre><code>from_tokens(**tokens: Any) -&gt; Self\n</code></pre> <p>Initialize token object.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/primitives.py</code> <pre><code>@classmethod\ndef from_tokens(cls, **tokens: Any) -&gt; Self:\n\"\"\"Initialize token object.\"\"\"\nexposure: NumericExpression = unwrap(tokens[\"exposure\"])\nnumber_of_vertices: NumericExpression = unwrap(tokens[\"number_of_vertices\"])\nstart_x: NumericExpression = unwrap(tokens[\"start_x\"])\nstart_y: NumericExpression = unwrap(tokens[\"start_y\"])\nrotation: NumericExpression = unwrap(tokens[\"rotation\"])\npoint: list[Point] = list(tokens.get(\"point\", []))\nreturn cls(\nexposure=exposure,\nnumber_of_vertices=number_of_vertices,\nstart_x=start_x,\nstart_y=start_y,\nrotation=rotation,\npoint=point,\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/primitives.html#pygerber.gerberx3.tokenizer.tokens.macro.primitives.PrimitivePolygon","title":"PrimitivePolygon","text":"<p>             Bases: <code>Primitive</code></p> <p>Wrapper for macro outline primitive token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/primitives.py</code> <pre><code>class PrimitivePolygon(Primitive):\n\"\"\"Wrapper for macro outline primitive token.\"\"\"\nsymbol: ClassVar[str] = \"5\"\nexposure: NumericExpression\nnumber_of_vertices: NumericExpression\ncenter_x: NumericExpression\ncenter_y: NumericExpression\ndiameter: NumericExpression\nrotation: NumericExpression\n@classmethod\ndef from_tokens(cls, **tokens: Any) -&gt; Self:\n\"\"\"Initialize token object.\"\"\"\nexposure: NumericExpression = unwrap(tokens[\"exposure\"])\nnumber_of_vertices: NumericExpression = unwrap(tokens[\"number_of_vertices\"])\ncenter_x: NumericExpression = unwrap(tokens[\"center_x\"])\ncenter_y: NumericExpression = unwrap(tokens[\"center_y\"])\ndiameter: NumericExpression = unwrap(tokens[\"diameter\"])\nrotation: NumericExpression = unwrap(tokens[\"rotation\"])\nreturn cls(\nexposure=exposure,\nnumber_of_vertices=number_of_vertices,\ncenter_x=center_x,\ncenter_y=center_y,\ndiameter=diameter,\nrotation=rotation,\n)\ndef __str__(self) -&gt; str:\nstring = self.symbol\nstring += f\",{self.exposure}\"\nstring += f\",{self.number_of_vertices}\"\nstring += f\",{self.center_x}\"\nstring += f\",{self.center_y}\"\nstring += f\",{self.diameter}\"\nstring += f\",{self.rotation}\"\nreturn string + \"*\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/primitives.html#pygerber.gerberx3.tokenizer.tokens.macro.primitives.PrimitivePolygon.from_tokens","title":"from_tokens  <code>classmethod</code>","text":"<pre><code>from_tokens(**tokens: Any) -&gt; Self\n</code></pre> <p>Initialize token object.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/primitives.py</code> <pre><code>@classmethod\ndef from_tokens(cls, **tokens: Any) -&gt; Self:\n\"\"\"Initialize token object.\"\"\"\nexposure: NumericExpression = unwrap(tokens[\"exposure\"])\nnumber_of_vertices: NumericExpression = unwrap(tokens[\"number_of_vertices\"])\ncenter_x: NumericExpression = unwrap(tokens[\"center_x\"])\ncenter_y: NumericExpression = unwrap(tokens[\"center_y\"])\ndiameter: NumericExpression = unwrap(tokens[\"diameter\"])\nrotation: NumericExpression = unwrap(tokens[\"rotation\"])\nreturn cls(\nexposure=exposure,\nnumber_of_vertices=number_of_vertices,\ncenter_x=center_x,\ncenter_y=center_y,\ndiameter=diameter,\nrotation=rotation,\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/primitives.html#pygerber.gerberx3.tokenizer.tokens.macro.primitives.PrimitiveThermal","title":"PrimitiveThermal","text":"<p>             Bases: <code>Primitive</code></p> <p>Wrapper for macro outline primitive token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/primitives.py</code> <pre><code>class PrimitiveThermal(Primitive):\n\"\"\"Wrapper for macro outline primitive token.\"\"\"\nsymbol: ClassVar[str] = \"7\"\ncenter_x: NumericExpression\ncenter_y: NumericExpression\nouter_diameter: NumericExpression\ninner_diameter: NumericExpression\ngap: NumericExpression\nrotation: NumericExpression\n@classmethod\ndef from_tokens(cls, **tokens: Any) -&gt; Self:\n\"\"\"Initialize token object.\"\"\"\ncenter_x: NumericExpression = unwrap(tokens[\"center_x\"])\ncenter_y: NumericExpression = unwrap(tokens[\"center_y\"])\nouter_diameter: NumericExpression = unwrap(tokens[\"outer_diameter\"])\ninner_diameter: NumericExpression = unwrap(tokens[\"inner_diameter\"])\ngap: NumericExpression = unwrap(tokens[\"gap\"])\nrotation: NumericExpression = unwrap(tokens[\"rotation\"])\nreturn cls(\ncenter_x=center_x,\ncenter_y=center_y,\nouter_diameter=outer_diameter,\ninner_diameter=inner_diameter,\ngap=gap,\nrotation=rotation,\n)\ndef __str__(self) -&gt; str:\nstring = self.symbol\nstring += f\",{self.center_x}\"\nstring += f\",{self.center_y}\"\nstring += f\",{self.outer_diameter}\"\nstring += f\",{self.inner_diameter}\"\nstring += f\",{self.gap}\"\nstring += f\",{self.rotation}\"\nreturn string + \"*\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/primitives.html#pygerber.gerberx3.tokenizer.tokens.macro.primitives.PrimitiveThermal.from_tokens","title":"from_tokens  <code>classmethod</code>","text":"<pre><code>from_tokens(**tokens: Any) -&gt; Self\n</code></pre> <p>Initialize token object.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/primitives.py</code> <pre><code>@classmethod\ndef from_tokens(cls, **tokens: Any) -&gt; Self:\n\"\"\"Initialize token object.\"\"\"\ncenter_x: NumericExpression = unwrap(tokens[\"center_x\"])\ncenter_y: NumericExpression = unwrap(tokens[\"center_y\"])\nouter_diameter: NumericExpression = unwrap(tokens[\"outer_diameter\"])\ninner_diameter: NumericExpression = unwrap(tokens[\"inner_diameter\"])\ngap: NumericExpression = unwrap(tokens[\"gap\"])\nrotation: NumericExpression = unwrap(tokens[\"rotation\"])\nreturn cls(\ncenter_x=center_x,\ncenter_y=center_y,\nouter_diameter=outer_diameter,\ninner_diameter=inner_diameter,\ngap=gap,\nrotation=rotation,\n)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/variable_definition.html","title":"variable_definition","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/variable_definition.html#pygerber.gerberx3.tokenizer.tokens.macro.variable_definition","title":"variable_definition","text":"<p>Macro variable definition token.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/variable_definition.html#pygerber.gerberx3.tokenizer.tokens.macro.variable_definition.MacroVariableDefinition","title":"MacroVariableDefinition","text":"<p>             Bases: <code>Expression</code></p> <p>Wrapper for macro variable definition.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/variable_definition.py</code> <pre><code>class MacroVariableDefinition(Expression):\n\"\"\"Wrapper for macro variable definition.\"\"\"\nvariable: MacroVariableName\nvalue: NumericExpression\n@classmethod\ndef from_tokens(cls, **tokens: Any) -&gt; Self:\n\"\"\"Initialize token object.\"\"\"\nvariable = unwrap(tokens[\"macro_variable_name\"])\nvalue = unwrap(tokens[\"value\"])\nreturn cls(variable=variable, value=value)\ndef evaluate(\nself,\nmacro_context: MacroContext,\nstate: State,\nhandle: PrivateApertureHandle,\n) -&gt; None:\n\"\"\"Evaluate macro expression.\"\"\"\nname = self.variable.name\nvalue = self.value.evaluate_numeric(macro_context, state)\nmacro_context.variables[name] = value\nreturn super().evaluate(macro_context, state, handle)\ndef __str__(self) -&gt; str:\nreturn f\"{self.variable}={self.value}*\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/variable_definition.html#pygerber.gerberx3.tokenizer.tokens.macro.variable_definition.MacroVariableDefinition.from_tokens","title":"from_tokens  <code>classmethod</code>","text":"<pre><code>from_tokens(**tokens: Any) -&gt; Self\n</code></pre> <p>Initialize token object.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/variable_definition.py</code> <pre><code>@classmethod\ndef from_tokens(cls, **tokens: Any) -&gt; Self:\n\"\"\"Initialize token object.\"\"\"\nvariable = unwrap(tokens[\"macro_variable_name\"])\nvalue = unwrap(tokens[\"value\"])\nreturn cls(variable=variable, value=value)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/variable_definition.html#pygerber.gerberx3.tokenizer.tokens.macro.variable_definition.MacroVariableDefinition.evaluate","title":"evaluate","text":"<pre><code>evaluate(\nmacro_context: MacroContext,\nstate: State,\nhandle: PrivateApertureHandle,\n) -&gt; None\n</code></pre> <p>Evaluate macro expression.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/variable_definition.py</code> <pre><code>def evaluate(\nself,\nmacro_context: MacroContext,\nstate: State,\nhandle: PrivateApertureHandle,\n) -&gt; None:\n\"\"\"Evaluate macro expression.\"\"\"\nname = self.variable.name\nvalue = self.value.evaluate_numeric(macro_context, state)\nmacro_context.variables[name] = value\nreturn super().evaluate(macro_context, state, handle)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/variable_name.html","title":"variable_name","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/variable_name.html#pygerber.gerberx3.tokenizer.tokens.macro.variable_name","title":"variable_name","text":"<p>Macro variable use token.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/variable_name.html#pygerber.gerberx3.tokenizer.tokens.macro.variable_name.MacroVariableName","title":"MacroVariableName","text":"<p>             Bases: <code>NumericExpression</code></p> <p>Wrapper for macro variable use.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/variable_name.py</code> <pre><code>class MacroVariableName(NumericExpression):\n\"\"\"Wrapper for macro variable use.\"\"\"\nname: str\n@classmethod\ndef from_tokens(cls, **tokens: Any) -&gt; Self:\n\"\"\"Initialize token object.\"\"\"\nname = unwrap(tokens[\"macro_variable_name\"])\nreturn cls(name=name)\ndef evaluate_numeric(self, macro_context: MacroContext, _state: State) -&gt; Offset:\n\"\"\"Evaluate numeric value of this macro expression.\"\"\"\nreturn macro_context.variables[self.name]\ndef __str__(self) -&gt; str:\nreturn self.name\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/variable_name.html#pygerber.gerberx3.tokenizer.tokens.macro.variable_name.MacroVariableName.from_tokens","title":"from_tokens  <code>classmethod</code>","text":"<pre><code>from_tokens(**tokens: Any) -&gt; Self\n</code></pre> <p>Initialize token object.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/variable_name.py</code> <pre><code>@classmethod\ndef from_tokens(cls, **tokens: Any) -&gt; Self:\n\"\"\"Initialize token object.\"\"\"\nname = unwrap(tokens[\"macro_variable_name\"])\nreturn cls(name=name)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/variable_name.html#pygerber.gerberx3.tokenizer.tokens.macro.variable_name.MacroVariableName.evaluate_numeric","title":"evaluate_numeric","text":"<pre><code>evaluate_numeric(\nmacro_context: MacroContext, _state: State\n) -&gt; Offset\n</code></pre> <p>Evaluate numeric value of this macro expression.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/variable_name.py</code> <pre><code>def evaluate_numeric(self, macro_context: MacroContext, _state: State) -&gt; Offset:\n\"\"\"Evaluate numeric value of this macro expression.\"\"\"\nreturn macro_context.variables[self.name]\n</code></pre>"}]}