var __index = {"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Home","text":"PyGerber  <p>PyGerber is a Python implementation of Gerber X3/X2 format. It is based on Ucamco's <code>The Gerber Layer Format Specification. Revision 2023.03</code> (Available on Ucamco's webpage and in this repository). The goal of this project is to provide support for wide variety of Gerber-like syntaxes, with support for most of deprecated features along with support for modern ones.</p> <p> \ud83d\udcda See online documentation \ud83d\udcda </p>"},{"location":"index.html#target-set-of-tools","title":"Target set of tools:","text":"<ul> <li> Tokenizer</li> <li> Parser</li> <li> Optimizer</li> <li> Introspection API</li> <li> Rasterized 2D rendering engine (With       Pillow)</li> <li> Vector 2D rendering engine (With drawsvg)</li> <li> Model 3D rendering engine (With Blender)</li> <li> Formatter</li> <li> Linter (eg. deprecated syntax detection)</li> <li> Gerber X3/X2 Language Server (with <code>language-server</code> extras)</li> </ul> <p>You can view progress of development in Gerber features support section down below. All Gerber source files which can be redistributed under MIT license and included in this repository for testing purposes will be greatly appreciated.</p>"},{"location":"index.html#installation","title":"Installation","text":"<p>PyGerber can be installed with <code>pip</code> from PyPI:</p> <pre><code>pip install pygerber\n</code></pre> <p>Alternatively, it is also possible to install it directly from repository:</p> <pre><code>pip install git+https://github.com/Argmaster/pygerber\n</code></pre>"},{"location":"index.html#language-server","title":"Language Server","text":"<p>Since release 2.1.0 PyGerber now provides Gerber X3/X2 Language Server with LSP support. It can be enabled by installing PyGerber extras set <code>language-server</code> with following command:</p> <pre><code>pip install pygerber[language-server]\n</code></pre> <p>Afterwards you can use <code>pygerber is-language-server-available</code> to check if language server was correctly enabled. Please report all issues in PyGerber Issues section.</p>"},{"location":"index.html#command-line-usage","title":"Command line usage","text":"<p>After installing <code>pygerber</code>, depending on your environment, it should become available in your command line:</p> <pre><code>pygerber --version\n</code></pre> <p>Output should be similar to one below \u21e9, where <code>x.y.z</code> should match version of PyGerber installed.</p> <pre><code>$ pygerber --version\npygerber, version x.y.z\n</code></pre> <p>Use <code>--help</code> to display help messages with lists of subcommands and subcommand options:</p> <pre><code>pygerber raster-2d --help\n</code></pre> <p>To render 2D PNG image of some gerber file you can simply use:</p> <pre><code>pygerber raster-2d gerber-source.grb\n</code></pre> <p>Image will be saved to <code>output.png</code> in current working directory.</p> <p></p>"},{"location":"index.html#api-usage","title":"API usage","text":"<p>PyGerber offers a high-level API that simplifies the process of rendering Gerber files. Whether you're looking to save the rendered output to a file or directly into a buffer, PyGerber has got you covered.</p> <ul> <li>The <code>Layer</code> Class: At its core, the <code>Layer</code> class stands for a single Gerber   source file, complete with its associated PyGerber configuration.</li> </ul> <p>Important <code>Layer</code> class represents any Gerber file, not layer of PCB. For   example, silkscreen Gerber file will require one instance of <code>Layer</code>, paste mask will   require another one, copper top yet another, etc.</p> <ul> <li> <p>Configuration Flexibility: The configuration possibilities you get with a <code>Layer</code>   are driven by the backend you choose to render your source file.</p> </li> <li> <p>Selecting a Backend: PyGerber provides specialized subclasses of the <code>Layer</code> class   each tied to one rendering backend. For instance, if you're aiming for 2D rasterized   images, <code>Rasterized2DLayer</code> is your go-to choice.</p> </li> <li> <p>Output Types: Keep in mind, the type of your output file is closely tied to the   backend you select.For 2D rasterized rendering   all formats supported by Pillow   are accepted.</p> </li> </ul>"},{"location":"index.html#rasterized-render-from-file","title":"Rasterized render from file","text":"render_file.py<pre><code>from pygerber.gerberx3.api import (\n      ColorScheme,\n      Rasterized2DLayer,\n      Rasterized2DLayerParams,\n)\n\n# Path to Gerber source file.\nsource_path = \"main_cu.grb\"\n\nRasterized2DLayer(\n      options=Rasterized2DLayerParams(\n            source_path=source_path,\n            colors=ColorScheme.COPPER_ALPHA,\n      ),\n).render().save(\"output.png\")\n</code></pre> <p>Example code above creates <code>Rasterized2DLayer</code> object, renders it with rasterized 2D backend and saves it as <code>PNG</code> image. Use of <code>Rasterized2DLayer</code> and <code>Rasterized2DLayerOptions</code> classes implicitly use 2D rasterized backend. To use different rendering backend with high level API, user must pick different <code>Layer</code> and <code>LayerOptions</code> subclasses. For other backends see Target set of tools section, note that only checked ones are available.</p> <p><code>source_path</code> option accepts <code>str</code> or <code>Path</code> pointing to local Gerber file. No special file extension is required, content is blindly loaded from specified file, so it's user responsibility to provide correct path. There are also <code>source_code</code> and <code>source_buffer</code> parameters which allow for use of raw <code>str</code> or <code>bytes</code> objects (first one) and <code>StringIO</code> and <code>BytesIO</code> or file descriptors (second one). <code>source_code</code>, <code>source_buffer</code> and <code>source_path</code> are mutually exclusive.</p> <p><code>ColorScheme</code> is a class which describes what colors should be used for rendering different parts of image. Additionally it has a few static members which contain predefined colors schemes for frequently used layer types. It is not required to use predefined schemes, creating and passing custom <code>ColorScheme</code> object should work perfectly fine.</p> <p>Pattern of using <code>&lt;Class&gt;</code> and <code>&lt;Class&gt;Options</code>, like above, is used in many places in PyGerber. When initializing object like <code>Rasterized2DLayer</code> it is only valid to pass <code>Rasterized2DLayerOptions</code> to constructor. Passing <code>LayerOptions</code> or <code>Vectorized2DLayer</code> will cause undefined behavior, most likely yielding no result or raising exception.</p>"},{"location":"index.html#rasterized-render-from-string","title":"Rasterized render from string","text":"render_string.py<pre><code>from pygerber.gerberx3.api import (\n      ColorScheme,\n      Rasterized2DLayer,\n      Rasterized2DLayerParams,\n)\n\nsource_code = \"\"\"\n%FSLAX26Y26*%\n%MOMM*%\n%ADD100R,1.5X1.0X0.5*%\n%ADD200C,1.5X1.0*%\n%ADD300O,1.5X1.0X0.6*%\n%ADD400P,1.5X3X5.0*%\nD100*\nX0Y0D03*\nD200*\nX0Y2000000D03*\nD300*\nX2000000Y0D03*\nD400*\nX2000000Y2000000D03*\nM02*\n\"\"\"\n\nRasterized2DLayer(\n      options=Rasterized2DLayerParams(\n            source_code=source_code,\n            colors=ColorScheme.SILK,\n            dpi=3000,\n      ),\n).render().save(\"output.png\")\n</code></pre> <p>Code above renders following image:</p> <p> </p>"},{"location":"index.html#documentation","title":"Documentation","text":"<p>Official documentations is hosted on Github Pages and can be found here.</p>"},{"location":"index.html#gerber-features-support","title":"Gerber features support","text":"<p>Please refer to documentation for Tokenizer, Parser, Rasterized2DBackend and Parser2 for detailed list of features which are supported/not supported.</p>"},{"location":"index.html#syntax-feature-requests","title":"Syntax feature requests","text":"<p>All deprecated features (Mainly those from X2 format) are considered optional and priority to implement them will be assigned based on number of requests form community.</p> <p>If You needs support for syntax features which are not mentioned in <code>The Gerber Layer Format Specification. Revision 2023.08</code> (Available on Ucamco's webpage and in this repository) and this feature is not already listed in Support paragraph, please open a new Feature request issue.</p> <p>Feature request Issue should contain:</p> <ul> <li>detailed description how requested feature works,</li> <li>code samples for testing the feature,</li> <li>reference images (only applies to features changing image look).</li> </ul> <p>Requests which don't comply with those guidelines will be considered low priority.</p>"},{"location":"index.html#development","title":"Development","text":"<p>To quickly set up development environment, first you have to install <code>poetry</code> globally:</p> <pre><code>pip install poetry\n</code></pre> <p>Afterwards you will be able to create development virtual environment:</p> <pre><code>poetry shell\n</code></pre> <p>Then You have to install dependencies into this environment:</p> <pre><code>poetry install\n</code></pre> <p>And pre-commit hooks:</p> <pre><code>poe install-hooks\n</code></pre> <p>Now you are good to go. Whenever you commit changes, pre-commit hooks will be invoked. If they fail or change files, you will have to re-add changes and commit again.</p>"},{"location":"index.html#build-from-source","title":"Build from source","text":"<p>To build PyGerber from source You have to set up Development environment first. Make sure you have <code>poetry</code> environment activated with:</p> <pre><code>poetry shell\n</code></pre> <p>With environment active it should be possible to build wheel and source distribution with:</p> <pre><code>poetry build\n</code></pre> <p>Check <code>dist</code> directory within current working directory, <code>pygerber-x.y.z.tar.gz</code> and <code>pygerber-x.y.z-py3-none-any.whl</code> should be there.</p>"},{"location":"index.html#gerber-reference-archive","title":"Gerber reference archive","text":"<p>This repository contains also archival reference files. Although new specs contain dedicated changelog section it may still be helpful in some rare cases to look through old Gerber specs. Archival files can be found here.</p>"},{"location":"Changelog.html","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Calendar Versioning.</p>"},{"location":"Changelog.html#release-220","title":"Release 2.2.0","text":"<ul> <li>Added alternative parser implementation, <code>pygerber.gerberx3.parser2.parser2.Parser2</code>   class.</li> <li>Added introspection interface based on new Parser2 class.</li> <li>Added macro support to Parser2 class which was not previously available in Parser   class.</li> <li>Added API for customizing Token classes used by Tokenizer. <code>Tokenizer</code> class now   accepts optional <code>options</code> parameter of class <code>TokenizerOptions</code>.</li> <li>Added documentation for introspection.</li> <li>Added experimental SVG backend for Gerber code with Parser2 generated command buffers.</li> <li>Changed documentation layout to improve readability.</li> <li>Fixed switching to single quadrant mode being ignored.</li> <li>Refactored feature support documentation.</li> </ul>"},{"location":"Changelog.html#release-211","title":"Release 2.1.1","text":"<ul> <li>Fixed incorrect bounding box prediction for displaced drawings (#105).</li> <li>Added 3.12 as supported in package tags.</li> <li>Fixed documentation links in <code>README.md</code> and <code>pyproject.toml</code>.</li> </ul>"},{"location":"Changelog.html#release-210","title":"Release 2.1.0","text":"<ul> <li>Fixed #37</li> <li>Added latest Gerber spec file revision 2023.08 to documentation.</li> <li>Added command line interface for PyGerber 2D rendering.</li> <li>Added Gerber X3/X2 language server which can be acquired with   <code>pip install pygerber[language-server]</code>. Currently server capabilities include hover   messages with Gerber reference cited and minimal amount of suggestions. We are   planning to further extend this server in future releases.</li> <li>Added <code>is-language-server-available</code> CLI command for checking if   <code>pygerber[language-sever]</code> is available.</li> <li>Added support for arc region boundaries (#61).</li> <li>Added warning messages whenever zero surface flash is created.</li> <li>Improved documentation for many of supported Gerber commands. This documentation is   used by language server to provide specification reference.</li> <li>Refactored tokenizer implementation, as a result #67 was fixed and #64 is no longer an   issue in some cases.</li> </ul>"},{"location":"Changelog.html#release-202","title":"Release 2.0.2","text":"<ul> <li>Fixed incorrect bounding box prediction for displaced drawings (#105).</li> <li>Added 3.12 as supported in package tags.</li> <li>Fixed documentation links in <code>README.md</code> and <code>pyproject.toml</code>.</li> </ul>"},{"location":"Changelog.html#release-201","title":"Release 2.0.1","text":"<ul> <li>Fixed names of Gerber specification files (<code>.pdf.pdf</code> extension replaced with <code>.pdf</code>)</li> <li>Added <code>draw_region_outlines</code> option (disabled by default) which controls whether lines   which make up a region boundary should be drawn after region is filled. KiCAD seem to   assume that those boundaries are not drawn and region outline is 1px instead of   thickness of aperture.</li> <li>Changed <code>Decimal</code> precision to 60 decimal places.</li> <li>Changed precision of <code>INCH_TO_MM_MULTIPLIER</code> (now its 25.4) and   <code>MM_TO_INCH_MULTIPLIER</code> (dynamically calculated with <code>Decimal</code>).</li> <li>Changed circle aperture to make result better match expectations and <code>KiCAD</code>   reference.</li> <li>Fixed warning message logged every time a valid region was created to show up only   when region is not valid.</li> <li>Added warnings for zero surface aperture draws.</li> </ul>"},{"location":"Changelog.html#release-200","title":"Release 2.0.0","text":"<ul> <li> <p>Added Gerber X3 format tokenizer with support for selective feature support:</p> </li> <li> <p>Supported Gerber X3 features: <code>G04</code>, <code>MO</code>, <code>FS</code>, <code>AD</code>, <code>AM</code>, <code>Dnn</code> (nn\u226510), <code>D01</code>,     <code>D02</code>, <code>D03</code>, <code>G01</code>, <code>G02</code>, <code>G03</code>, <code>G75</code>, <code>LP</code>, <code>LM</code>, <code>LR</code>, <code>LS</code>, <code>G36</code>, <code>G37</code>,     <code>AB</code>, <code>SR</code>, <code>TF</code>, <code>TA</code>, <code>TO</code>,<code>TD</code>, <code>M02</code>.</p> </li> <li> <p>Supported DEPRECATED Gerber features: <code>G54</code>, <code>G70</code>, <code>G71</code>, <code>G90</code>, <code>G91</code>, <code>G74</code>,     <code>M00</code>, <code>M01</code>, <code>IP</code>, <code>LN</code>,     <code>Combining G01/G02/G03 and D01/D02/D03 in a single command</code>,     <code>Coordinate Data without Operation Code</code>, <code>Style Variations in Command Codes</code>, <code>FS</code>,     <code>Draws and Arcs with Rectangular Apertures</code>.</p> </li> </ul> <p>For more detailed descriptions of supported features please refer to documentation or   README.md.</p> <ul> <li> <p>Added Gerber X3 format parser with support for selective feature support:</p> </li> <li> <p>Supported Gerber X3 features: <code>G04</code>, <code>MO</code>, <code>FS</code>, <code>AD</code>, <code>AM</code>, <code>Dnn</code> (nn\u226510), <code>D01</code>,     <code>D02</code>, <code>D03</code>, <code>G01</code>, <code>G02</code>, <code>G03</code>, <code>G75</code>, <code>LP</code>, <code>LM</code>, <code>LR</code>, <code>LS</code>, <code>G36</code>, <code>G37</code>,     <code>M02</code>.</p> </li> <li> <p>Supported DEPRECATED Gerber features: <code>G54</code>, <code>G70</code>, <code>G71</code>, <code>G90</code>, <code>G91</code>, <code>G74</code>,     <code>M00</code>, <code>M01</code>, <code>IP</code>, <code>LN</code>, <code>Combining G01/G02/G03 and D01 in a single command</code>,     <code>Coordinate Data without Operation Code</code>, <code>Style Variations in Command Codes</code>,     <code>Draws and Arcs with Rectangular Apertures</code>.</p> </li> </ul> <p>For more detailed descriptions of supported features please refer to documentation or   README.md.</p> <ul> <li>Added rendering backend capable of producing 2D rasterized images based on parser   instructions. Supported drawing elements:</li> <li>Aperture definition with circle</li> <li>Aperture definition with rectangle</li> <li>Aperture definition with obround</li> <li>Aperture definition with polygon</li> <li>Draw flash with circle aperture</li> <li>Draw flash with rectangle aperture</li> <li>Draw flash with obround aperture</li> <li>Draw flash with polygon aperture</li> <li>Draw line</li> <li>Draw clockwise arc</li> <li>Draw counterclockwise arc</li> </ul>"},{"location":"LICENSE.html","title":"License","text":"<p>Copyright 2023 Krzysztof Wi\u015bniewski</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \u201cSoftware\u201d), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \u201cAS IS\u201d, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"gerber/0_usage.html","title":"Public API Usage","text":"<p>PyGerber offers simple high-level API for rendering Gerber files. All necessary tools can be imported from <code>pygerber.gerberx3.api</code> module. See module reference for full object list.</p> <p>Important</p> <p>API of <code>pygerber.gerberx3.api</code> module is guaranteed to remain unchanged between patches and minor releases of PyGerber, whereas other modules, even those contained deeper in <code>pygerber.gerberx3.api</code> like <code>gerber.gerberx3.api._layers</code>, may change at any time.</p> <p>Bug</p> <p>Please report any objects which have to be imported from other places than <code>pygerber.gerberx3.api</code> for high level API, it's typechecking or error handling to work. Such situations are considered a bug.</p>"},{"location":"gerber/0_usage.html#overview","title":"Overview","text":"<ul> <li> <p><code>Layer</code> class and it's subclasses in PyGerber API represent a Gerber file. It's   completely different meaning than in PCB design, much closer to what a image layer is   in image manipulation software, like Gimp. <code>Layer</code> class   itself it not a functional, only it's subclasses can be used to instruct PyGerber how   to render Gerber file. Based on what <code>Layer</code> subclass is used, different output image   types can be obtained. For example <code>Rasterized2DLayer</code> will allow for generating   rasterized images and saving them as JPEG, PNG, TIFF and other image formats.</p> </li> <li> <p><code>LayerParams</code> class and its subclasses are intended to be used to configure the   corresponding <code>Layer</code> classes. For example, when using <code>Rasterized2DLayer</code> for   rendering, it is only valid to pass <code>Rasterized2DLayerParams</code> to constructor. Passing   incorrect <code>LayerParams</code> subclass will result in <code>TypeError</code>.</p> </li> <li> <p><code>RenderingResult</code> class is returned from <code>render()</code> method of <code>Layer</code> instance. It   provides simple interface for saving rendering output. Different output formats will   be available depending on the layer type used. For <code>Rasterized2DLayer</code> list of   supported output formats is equivalent to list of formats supported by Pillow library.   It can be found in   Pillow documentation.</p> </li> </ul>"},{"location":"gerber/0_usage.html#usage","title":"Usage","text":"<p>Below we provided an example of simple API use.</p> <p>We have following Gerber file:</p> render_copper_from_path.grb<pre><code>%FSLAX26Y26*%\n%MOMM*%\n%ADD10C,10X5*%\n%ADD11C,1*%\nG01*\n%LPD*%\nD11*\nX-25000000Y-1000000D02*\nX25000000Y1000000D01*\nD10*\nX0Y0D03*\nM02*\n</code></pre> <p>Which should result in simple image:</p> <p></p> <p>To achieve such result with PyGerber, first we have to import all necessary classes from <code>pygerber.gerberx3.api</code> module:</p> <pre><code>from pygerber.gerberx3.api import (\n    ColorScheme,\n    Rasterized2DLayer,\n    Rasterized2DLayerParams,\n)\n</code></pre> <p>We will be using <code>Rasterized2DLayer</code>, as we want to create a PNG image. <code>Rasterized2DLayerParams</code> will be necessary to specify path to source file and image color scheme, declared with <code>ColorScheme</code>:</p> <pre><code>options = Rasterized2DLayerParams(\n    source_path=\"render_copper_from_path.grb\",\n    colors=ColorScheme.COPPER_ALPHA,\n)\n</code></pre> <p><code>ColorScheme</code> creation.</p> <p><code>ColorScheme.COPPER_ALPHA</code> is a predefined color scheme, equivalent can be created manually:</p> <pre><code>ColorScheme.COPPER_ALPHA = ColorScheme(\n    background_color=RGBA.from_rgba(0, 0, 0, 0),\n    clear_color=RGBA.from_rgba(60, 181, 60, 255),\n    solid_color=RGBA.from_rgba(40, 143, 40, 255),\n    clear_region_color=RGBA.from_rgba(60, 181, 60, 255),\n    solid_region_color=RGBA.from_rgba(40, 143, 40, 255),\n)\n</code></pre> <p>See reference for all possible ways of creating <code>RGBA</code> color objects and <code>ColorSchema</code> color schema objects.</p> <p>Afterwards we can create a <code>Rasterized2DLayer</code> object. Remember to provide previously constructed <code>Rasterized2DLayerParams</code> instance to constructor:</p> <pre><code>layer = Rasterized2DLayer(options=options)\n</code></pre> <p>Now we can use <code>render()</code> method of <code>Rasterized2DLayer</code> instance to create <code>RenderingResult</code>:</p> <pre><code>result = layer.render()\n</code></pre> <p>Then we can call <code>save()</code> method on <code>RenderingResult</code> to save rendered image to drive:</p> <pre><code>result = layer.save(\"output.png\")\n</code></pre> <p>Alternatively you can save image to BytesIO:</p> <pre><code>from io import BytesIO\nbuffer = BytesIO()\nresult = layer.save(buffer, format=\"PNG)\n</code></pre>"},{"location":"gerber/0_usage.html#more-examples","title":"More examples","text":"<p>Below are few more examples showing how to provide Gerber code to <code>Layer</code> by different ways, however they are all equivalent.</p>"},{"location":"gerber/0_usage.html#load-from-file-path","title":"Load from file path","text":"test/examples/render_copper_from_path.py<pre><code>from __future__ import annotations\n\nfrom pathlib import Path\n\nfrom pygerber.gerberx3.api import (\n    ColorScheme,\n    Rasterized2DLayer,\n    Rasterized2DLayerParams,\n)\n\n\ndef render() -&gt; None:\n    source_path = Path(__file__).parent / \"render_copper_from_path.grb\"\n\n    Rasterized2DLayer(\n        options=Rasterized2DLayerParams(\n            source_path=source_path,\n            colors=ColorScheme.COPPER_ALPHA,\n        ),\n    ).render().save(\"output.png\")\n\n\nif __name__ == \"__main__\":\n    render()\n</code></pre>"},{"location":"gerber/0_usage.html#read-from-buffer","title":"Read from buffer","text":"test/examples/render_copper_from_buffer.py<pre><code>from __future__ import annotations\n\nfrom io import BytesIO\n\nfrom pygerber.gerberx3.api import (\n    ColorScheme,\n    Rasterized2DLayer,\n    Rasterized2DLayerParams,\n)\n\n\ndef render() -&gt; None:\n    source_buffer = BytesIO(\n        b\"\"\"\n    %FSLAX26Y26*%\n    %MOMM*%\n    %ADD100R,1.5X1.0X0.5*%\n    %ADD200C,1.5X1.0*%\n    %ADD300O,1.5X1.0X0.6*%\n    %ADD400P,1.5X3X5.0*%\n    D100*\n    X0Y0D03*\n    D200*\n    X0Y2000000D03*\n    D300*\n    X2000000Y0D03*\n    D400*\n    X2000000Y2000000D03*\n    M02*\n    \"\"\",\n    )\n\n    Rasterized2DLayer(\n        options=Rasterized2DLayerParams(\n            source_buffer=source_buffer,\n            colors=ColorScheme.COPPER_ALPHA,\n        ),\n    ).render().save(\"output.png\")\n\n\nif __name__ == \"__main__\":\n    render()\n</code></pre>"},{"location":"gerber/0_usage.html#read-from-string","title":"Read from string","text":"test/examples/render_copper_from_string.py<pre><code>from __future__ import annotations\n\nfrom pygerber.gerberx3.api import (\n    ColorScheme,\n    Rasterized2DLayer,\n    Rasterized2DLayerParams,\n)\n\n\ndef render() -&gt; None:\n    source_code = \"\"\"\n    %FSLAX26Y26*%\n    %MOMM*%\n    %ADD100C,1.5*%\n    D100*\n    X0Y0D03*\n    M02*\n    \"\"\"\n\n    Rasterized2DLayer(\n        options=Rasterized2DLayerParams(\n            source_code=source_code,\n            colors=ColorScheme.COPPER_ALPHA,\n        ),\n    ).render().save(\"output.png\")\n\n\nif __name__ == \"__main__\":\n    render()\n</code></pre>"},{"location":"gerber/0_usage.html#obtaining-layer-properties","title":"Obtaining layer properties","text":"<p>I some cases it may be useful to obtain information about layer which was rendered. For example origin of coordinate system of image can be useful for aligning multiple layers on top of each other, or for other similar transformations.</p> <p>Those information can be extracted from <code>RenderingResult</code> object, returned from <code>Layer.render()</code> method. <code>RenderingResult</code> object has <code>get_properties()</code> method which returns <code>LayerProperties</code> object which contains all the necessary data to determine coordinate origins and bounding boxes of layer.</p>"},{"location":"gerber/0_usage.html#further-reading","title":"Further reading","text":"<p>To further extend your knowledge about how to use PyGerber you could read <code>pygerber.gerberx3.api</code> module reference or see Gerber Advanced API</p>"},{"location":"gerber/1_reference.html","title":"Public API Reference","text":""},{"location":"gerber/1_reference.html#pygerber.gerberx3.api","title":"api","text":"<p><code>pygerber.gerberx3.api</code> module provides simple, high-level API for rendering Gerber X3/X2 files.</p>"},{"location":"gerber/1_reference.html#pygerber.gerberx3.api.ColorScheme","title":"ColorScheme","text":"<p>             Bases: <code>FrozenGeneralModel</code></p> <p>Set of colors which should be used for rendering.</p> <p>ColorScheme class contains set of colors which should be used for different parts of rendered image. At the same time it also works as a container for predefined color schemes commonly used for parts of PCB.</p> <p>Predefined colors</p> <p>All predefined colors have two variants - normal one and one with \"*_ALPHA\" suffix. Those without suffix have solid background and are not intended for constructing multi-layer images out of them ie. they are not suitable for rendering a project consisting of separate copper, silk, pase mask and composing them into single image. For cases when rendered images are intended for stacking \"*_ALPHA\" schemes should be used, as background and transparent parts of image will be truly transparent.</p> Source code in <code>src/pygerber/backend/rasterized_2d/color_scheme.py</code> <pre><code>class ColorScheme(FrozenGeneralModel):\n    r\"\"\"Set of colors which should be used for rendering.\n\n    ColorScheme class contains set of colors which should be used for different parts\n    of rendered image. At the same time it also works as a container for predefined\n    color schemes commonly used for parts of PCB.\n\n    !!! info \"Predefined colors\"\n\n        All predefined colors have two variants - normal one and one with \"\\*_ALPHA\"\n        suffix. Those without suffix have solid background and are not intended for\n        constructing multi-layer images out of them ie. they are not suitable for\n        rendering a project consisting of separate copper, silk, pase mask and composing\n        them into single image. For cases when rendered images are intended for stacking\n        \"\\*_ALPHA\" schemes should be used, as background and transparent parts of image\n        will be truly transparent.\n\n    \"\"\"\n\n    SILK: ClassVar[ColorScheme]\n    \"\"\"Default color of silk layer.\n\n    This schema provided non-transparent background, which results in images which\n    can not be used for stacking on top of other layers, as they would completely\n    obscure them.\"\"\"\n\n    SILK_ALPHA: ClassVar[ColorScheme]\n    \"\"\"Default color of silk layer with alpha channel.\n\n    This schema provides transparent background. Images using this schema can be\n    stacked on top of each other without obscuring layers below.\"\"\"\n\n    COPPER: ClassVar[ColorScheme]\n    \"\"\"Default color of copper layer.\n\n    This schema provided non-transparent background, which results in images which\n    can not be used for stacking on top of other layers, as they would completely\n    obscure them.\"\"\"\n\n    COPPER_ALPHA: ClassVar[ColorScheme]\n    \"\"\"Default color of copper layer with alpha channel.\n\n    This schema provides transparent background. Images using this schema can be\n    stacked on top of each other without obscuring layers below.\"\"\"\n\n    PASTE_MASK: ClassVar[ColorScheme]\n    \"\"\"Default color of paste mask layer.\n\n    This schema provided non-transparent background, which results in images which\n    can not be used for stacking on top of other layers, as they would completely\n    obscure them.\"\"\"\n\n    PASTE_MASK_ALPHA: ClassVar[ColorScheme]\n    \"\"\"Default color of paste mask layer with alpha channel.\n\n    This schema provides transparent background. Images using this schema can be\n    stacked on top of each other without obscuring layers below.\"\"\"\n\n    SOLDER_MASK: ClassVar[ColorScheme]\n    \"\"\"Default color of solder mask layer.\n\n    This schema provided non-transparent background, which results in images which\n    can not be used for stacking on top of other layers, as they would completely\n    obscure them.\"\"\"\n\n    SOLDER_MASK_ALPHA: ClassVar[ColorScheme]\n    \"\"\"Default color of solder mask layer with alpha channel.\n\n    This schema provides transparent background. Images using this schema can be\n    stacked on top of each other without obscuring layers below.\"\"\"\n\n    DEFAULT_GRAYSCALE: ClassVar[ColorScheme]\n    \"\"\"Default color scheme for files which were not assigned other color scheme.\"\"\"\n\n    DEBUG_1: ClassVar[ColorScheme]\n    \"\"\"Debug color scheme.\"\"\"\n\n    DEBUG_1_ALPHA: ClassVar[ColorScheme]\n    \"\"\"Debug color scheme with alpha channel.\"\"\"\n\n    background_color: RGBA\n    \"\"\"Color used as empty image background.\"\"\"\n\n    clear_color: RGBA\n    \"\"\"Color used for clear draws.\"\"\"\n\n    solid_color: RGBA\n    \"\"\"Color used for solid draws.\"\"\"\n\n    clear_region_color: RGBA\n    \"\"\"Color used for clear region draws.\"\"\"\n\n    solid_region_color: RGBA\n    \"\"\"Color used for solid region draws.\"\"\"\n\n    debug_1_color: RGBA = RGBA.from_hex(\"#ababab\")\n    \"\"\"Color used for debug elements.\"\"\"\n\n    debug_2_color: RGBA = RGBA.from_hex(\"#7d7d7d\")\n    \"\"\"Color used for debug elements.\"\"\"\n\n    def get_grayscale_to_rgba_color_map(self) -&gt; dict[int, tuple[int, int, int, int]]:\n        \"\"\"Return grayscale to RGBA color map.\"\"\"\n        return {\n            Polarity.Dark.get_2d_rasterized_color(): self.solid_color.as_rgba_int(),\n            Polarity.Clear.get_2d_rasterized_color(): self.clear_color.as_rgba_int(),\n            Polarity.DarkRegion.get_2d_rasterized_color(): self.solid_region_color.as_rgba_int(),  # noqa: E501\n            Polarity.ClearRegion.get_2d_rasterized_color(): self.clear_region_color.as_rgba_int(),  # noqa: E501\n            Polarity.Background.get_2d_rasterized_color(): self.background_color.as_rgba_int(),  # noqa: E501\n            Polarity.DEBUG.get_2d_rasterized_color(): self.debug_1_color.as_rgba_int(),\n            Polarity.DEBUG2.get_2d_rasterized_color(): self.debug_2_color.as_rgba_int(),\n        }\n</code></pre>"},{"location":"gerber/1_reference.html#pygerber.gerberx3.api.ColorScheme.SILK","title":"SILK  <code>class-attribute</code>","text":"<pre><code>SILK: ColorScheme\n</code></pre> <p>Default color of silk layer.</p> <p>This schema provided non-transparent background, which results in images which can not be used for stacking on top of other layers, as they would completely obscure them.</p>"},{"location":"gerber/1_reference.html#pygerber.gerberx3.api.ColorScheme.SILK_ALPHA","title":"SILK_ALPHA  <code>class-attribute</code>","text":"<pre><code>SILK_ALPHA: ColorScheme\n</code></pre> <p>Default color of silk layer with alpha channel.</p> <p>This schema provides transparent background. Images using this schema can be stacked on top of each other without obscuring layers below.</p>"},{"location":"gerber/1_reference.html#pygerber.gerberx3.api.ColorScheme.COPPER","title":"COPPER  <code>class-attribute</code>","text":"<pre><code>COPPER: ColorScheme\n</code></pre> <p>Default color of copper layer.</p> <p>This schema provided non-transparent background, which results in images which can not be used for stacking on top of other layers, as they would completely obscure them.</p>"},{"location":"gerber/1_reference.html#pygerber.gerberx3.api.ColorScheme.COPPER_ALPHA","title":"COPPER_ALPHA  <code>class-attribute</code>","text":"<pre><code>COPPER_ALPHA: ColorScheme\n</code></pre> <p>Default color of copper layer with alpha channel.</p> <p>This schema provides transparent background. Images using this schema can be stacked on top of each other without obscuring layers below.</p>"},{"location":"gerber/1_reference.html#pygerber.gerberx3.api.ColorScheme.PASTE_MASK","title":"PASTE_MASK  <code>class-attribute</code>","text":"<pre><code>PASTE_MASK: ColorScheme\n</code></pre> <p>Default color of paste mask layer.</p> <p>This schema provided non-transparent background, which results in images which can not be used for stacking on top of other layers, as they would completely obscure them.</p>"},{"location":"gerber/1_reference.html#pygerber.gerberx3.api.ColorScheme.PASTE_MASK_ALPHA","title":"PASTE_MASK_ALPHA  <code>class-attribute</code>","text":"<pre><code>PASTE_MASK_ALPHA: ColorScheme\n</code></pre> <p>Default color of paste mask layer with alpha channel.</p> <p>This schema provides transparent background. Images using this schema can be stacked on top of each other without obscuring layers below.</p>"},{"location":"gerber/1_reference.html#pygerber.gerberx3.api.ColorScheme.SOLDER_MASK","title":"SOLDER_MASK  <code>class-attribute</code>","text":"<pre><code>SOLDER_MASK: ColorScheme\n</code></pre> <p>Default color of solder mask layer.</p> <p>This schema provided non-transparent background, which results in images which can not be used for stacking on top of other layers, as they would completely obscure them.</p>"},{"location":"gerber/1_reference.html#pygerber.gerberx3.api.ColorScheme.SOLDER_MASK_ALPHA","title":"SOLDER_MASK_ALPHA  <code>class-attribute</code>","text":"<pre><code>SOLDER_MASK_ALPHA: ColorScheme\n</code></pre> <p>Default color of solder mask layer with alpha channel.</p> <p>This schema provides transparent background. Images using this schema can be stacked on top of each other without obscuring layers below.</p>"},{"location":"gerber/1_reference.html#pygerber.gerberx3.api.ColorScheme.DEFAULT_GRAYSCALE","title":"DEFAULT_GRAYSCALE  <code>class-attribute</code>","text":"<pre><code>DEFAULT_GRAYSCALE: ColorScheme\n</code></pre> <p>Default color scheme for files which were not assigned other color scheme.</p>"},{"location":"gerber/1_reference.html#pygerber.gerberx3.api.ColorScheme.DEBUG_1","title":"DEBUG_1  <code>class-attribute</code>","text":"<pre><code>DEBUG_1: ColorScheme\n</code></pre> <p>Debug color scheme.</p>"},{"location":"gerber/1_reference.html#pygerber.gerberx3.api.ColorScheme.DEBUG_1_ALPHA","title":"DEBUG_1_ALPHA  <code>class-attribute</code>","text":"<pre><code>DEBUG_1_ALPHA: ColorScheme\n</code></pre> <p>Debug color scheme with alpha channel.</p>"},{"location":"gerber/1_reference.html#pygerber.gerberx3.api.ColorScheme.background_color","title":"background_color  <code>instance-attribute</code>","text":"<pre><code>background_color: RGBA\n</code></pre> <p>Color used as empty image background.</p>"},{"location":"gerber/1_reference.html#pygerber.gerberx3.api.ColorScheme.clear_color","title":"clear_color  <code>instance-attribute</code>","text":"<pre><code>clear_color: RGBA\n</code></pre> <p>Color used for clear draws.</p>"},{"location":"gerber/1_reference.html#pygerber.gerberx3.api.ColorScheme.solid_color","title":"solid_color  <code>instance-attribute</code>","text":"<pre><code>solid_color: RGBA\n</code></pre> <p>Color used for solid draws.</p>"},{"location":"gerber/1_reference.html#pygerber.gerberx3.api.ColorScheme.clear_region_color","title":"clear_region_color  <code>instance-attribute</code>","text":"<pre><code>clear_region_color: RGBA\n</code></pre> <p>Color used for clear region draws.</p>"},{"location":"gerber/1_reference.html#pygerber.gerberx3.api.ColorScheme.solid_region_color","title":"solid_region_color  <code>instance-attribute</code>","text":"<pre><code>solid_region_color: RGBA\n</code></pre> <p>Color used for solid region draws.</p>"},{"location":"gerber/1_reference.html#pygerber.gerberx3.api.ColorScheme.debug_1_color","title":"debug_1_color  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>debug_1_color: RGBA = from_hex('#ababab')\n</code></pre> <p>Color used for debug elements.</p>"},{"location":"gerber/1_reference.html#pygerber.gerberx3.api.ColorScheme.debug_2_color","title":"debug_2_color  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>debug_2_color: RGBA = from_hex('#7d7d7d')\n</code></pre> <p>Color used for debug elements.</p>"},{"location":"gerber/1_reference.html#pygerber.gerberx3.api.ColorScheme.get_grayscale_to_rgba_color_map","title":"get_grayscale_to_rgba_color_map","text":"<pre><code>get_grayscale_to_rgba_color_map() -&gt; (\n    dict[int, tuple[int, int, int, int]]\n)\n</code></pre> <p>Return grayscale to RGBA color map.</p> Source code in <code>src/pygerber/backend/rasterized_2d/color_scheme.py</code> <pre><code>def get_grayscale_to_rgba_color_map(self) -&gt; dict[int, tuple[int, int, int, int]]:\n    \"\"\"Return grayscale to RGBA color map.\"\"\"\n    return {\n        Polarity.Dark.get_2d_rasterized_color(): self.solid_color.as_rgba_int(),\n        Polarity.Clear.get_2d_rasterized_color(): self.clear_color.as_rgba_int(),\n        Polarity.DarkRegion.get_2d_rasterized_color(): self.solid_region_color.as_rgba_int(),  # noqa: E501\n        Polarity.ClearRegion.get_2d_rasterized_color(): self.clear_region_color.as_rgba_int(),  # noqa: E501\n        Polarity.Background.get_2d_rasterized_color(): self.background_color.as_rgba_int(),  # noqa: E501\n        Polarity.DEBUG.get_2d_rasterized_color(): self.debug_1_color.as_rgba_int(),\n        Polarity.DEBUG2.get_2d_rasterized_color(): self.debug_2_color.as_rgba_int(),\n    }\n</code></pre>"},{"location":"gerber/1_reference.html#pygerber.gerberx3.api.RGBA","title":"RGBA","text":"<p>             Bases: <code>FrozenGeneralModel</code></p> <p>Representation of RGBA color.</p> Source code in <code>src/pygerber/common/rgba.py</code> <pre><code>class RGBA(FrozenGeneralModel):\n    \"\"\"Representation of RGBA color.\"\"\"\n\n    r: Color = ColorField\n    g: Color = ColorField\n    b: Color = ColorField\n    a: Color = ColorField\n\n    @classmethod\n    def from_hex(cls, string: str) -&gt; Self:\n        \"\"\"Build RGBA color object from hexadecimal string.\n\n        Parameters\n        ----------\n        string : str\n            String containing color value. Accepted formats are `RRGGBBAA` and `RRGGBB`.\n            For latter, alpha value is assumed to be 0xFF. Formats are case insensitive.\n            `#` symbol prefix for hex string is accepted.\n\n        Returns\n        -------\n        RGBA\n            Color built from hexadecimal values.\n        \"\"\"\n        if string[0] == \"#\":\n            string = string[1:]\n\n        r, g, b, a = string[:2], string[2:4], string[4:6], string[6:]\n        if len(a) == 0:\n            a = \"FF\"\n\n        return cls(\n            r=int(r, base=16),\n            g=int(g, base=16),\n            b=int(b, base=16),\n            a=int(a, base=16),\n        )\n\n    @classmethod\n    def from_rgba(cls, r: int, g: int, b: int, a: int = 0xFF) -&gt; Self:\n        \"\"\"Build RGBA color object from reg, green, blue and alpha integer values.\n\n        Parameters\n        ----------\n        r : int\n            Red chanel value as integer from 0 to 255, inclusive.\n        g : int\n            Green chanel value as integer from 0 to 255, inclusive.\n        b : int\n            Blue chanel value as integer from 0 to 255, inclusive.\n        a : int, optional\n            Alpha chanel value as integer from 0 to 255, inclusive., by default 0xFF\n\n        Returns\n        -------\n        Self\n            Color built from r, g, b, a values.\n        \"\"\"\n        return cls(r=r, g=g, b=b, a=a)\n\n    @classmethod\n    def from_hsv(\n        cls,\n        h: int,\n        s: float,\n        v: float,\n        a: int = 255,\n    ) -&gt; Self:\n        \"\"\"Build RGBA color object from hue, saturation, value and alpha.\n\n        For extended information refer to Wikipedia: https://en.wikipedia.org/wiki/HSL_and_HSV\n\n        Parameters\n        ----------\n        h : int\n            Hue of color, integer in range 0 to 360 inclusive.\n        s : float\n            Saturation of color, float in range 0.0 to 100.0 inclusive.\n        v : float\n            Value of color, float in range 0.0 to 100.0 inclusive.\n        a : int\n            Alpha of color, int in range 0 to 255 inclusive.\n\n        Returns\n        -------\n        Self\n            Color built from h, s, v, a values.\n        \"\"\"\n        h %= 360\n        s /= 100\n        v /= 100\n\n        c = v * s\n        x = c * (1 - abs(((h / 60) % 2) - 1))\n        m = v - c\n\n        if 0 &lt;= h &lt; HSV_Q0_MAX_ANGLE_DEGREES:\n            r_, g_, b_ = c, x, 0.0\n        elif HSV_Q0_MAX_ANGLE_DEGREES &lt;= h &lt; HSV_Q1_MAX_ANGLE_DEGREES:\n            r_, g_, b_ = x, c, 0.0\n        elif HSV_Q1_MAX_ANGLE_DEGREES &lt;= h &lt; HSV_Q2_MAX_ANGLE_DEGREES:\n            r_, g_, b_ = 0.0, c, x\n        elif HSV_Q2_MAX_ANGLE_DEGREES &lt;= h &lt; HSV_Q3_MAX_ANGLE_DEGREES:\n            r_, g_, b_ = 0.0, x, c\n        elif HSV_Q3_MAX_ANGLE_DEGREES &lt;= h &lt; HSV_Q4_MAX_ANGLE_DEGREES:\n            r_, g_, b_ = x, 0.0, c\n        elif HSV_Q4_MAX_ANGLE_DEGREES &lt;= h &lt;= HSV_Q5_MAX_ANGLE_DEGREES:\n            r_, g_, b_ = c, 0.0, x\n        else:\n            raise ValueError(h)\n\n        return cls(\n            r=round((r_ + m) * 255),\n            g=round((g_ + m) * 255),\n            b=round((b_ + m) * 255),\n            a=a,\n        )\n\n    def as_rgba_int(self) -&gt; tuple[int, int, int, int]:\n        \"\"\"Return RGBA color as tuple of integers in range 0 to 255 inclusive.\"\"\"\n        return self.r, self.g, self.b, self.a\n\n    def as_rgba_float(self) -&gt; tuple[float, float, float, float]:\n        \"\"\"Return RGBA color as tuple of floats in range 0.0 to 1.0 inclusive.\"\"\"\n        return (\n            float(Decimal(self.r) / Decimal(255)),\n            float(Decimal(self.g) / Decimal(255)),\n            float(Decimal(self.b) / Decimal(255)),\n            float(Decimal(self.a) / Decimal(255)),\n        )\n\n    def to_hex(self) -&gt; str:\n        \"\"\"Return color as hexadecimal string.\"\"\"\n        r = f\"{self.r:0{2}x}\"\n        g = f\"{self.g:0{2}x}\"\n        b = f\"{self.b:0{2}x}\"\n        a = f\"{self.a:0{2}x}\"\n        return f\"#{r}{g}{b}{a}\"\n</code></pre>"},{"location":"gerber/1_reference.html#pygerber.gerberx3.api.RGBA.from_hex","title":"from_hex  <code>classmethod</code>","text":"<pre><code>from_hex(string: str) -&gt; Self\n</code></pre> <p>Build RGBA color object from hexadecimal string.</p> <p>Parameters:</p> Name Type Description Default <code>string</code> <code>str</code> <p>String containing color value. Accepted formats are <code>RRGGBBAA</code> and <code>RRGGBB</code>. For latter, alpha value is assumed to be 0xFF. Formats are case insensitive. <code>#</code> symbol prefix for hex string is accepted.</p> required <p>Returns:</p> Type Description <code>RGBA</code> <p>Color built from hexadecimal values.</p> Source code in <code>src/pygerber/common/rgba.py</code> <pre><code>@classmethod\ndef from_hex(cls, string: str) -&gt; Self:\n    \"\"\"Build RGBA color object from hexadecimal string.\n\n    Parameters\n    ----------\n    string : str\n        String containing color value. Accepted formats are `RRGGBBAA` and `RRGGBB`.\n        For latter, alpha value is assumed to be 0xFF. Formats are case insensitive.\n        `#` symbol prefix for hex string is accepted.\n\n    Returns\n    -------\n    RGBA\n        Color built from hexadecimal values.\n    \"\"\"\n    if string[0] == \"#\":\n        string = string[1:]\n\n    r, g, b, a = string[:2], string[2:4], string[4:6], string[6:]\n    if len(a) == 0:\n        a = \"FF\"\n\n    return cls(\n        r=int(r, base=16),\n        g=int(g, base=16),\n        b=int(b, base=16),\n        a=int(a, base=16),\n    )\n</code></pre>"},{"location":"gerber/1_reference.html#pygerber.gerberx3.api.RGBA.from_rgba","title":"from_rgba  <code>classmethod</code>","text":"<pre><code>from_rgba(r: int, g: int, b: int, a: int = 255) -&gt; Self\n</code></pre> <p>Build RGBA color object from reg, green, blue and alpha integer values.</p> <p>Parameters:</p> Name Type Description Default <code>r</code> <code>int</code> <p>Red chanel value as integer from 0 to 255, inclusive.</p> required <code>g</code> <code>int</code> <p>Green chanel value as integer from 0 to 255, inclusive.</p> required <code>b</code> <code>int</code> <p>Blue chanel value as integer from 0 to 255, inclusive.</p> required <code>a</code> <code>int</code> <p>Alpha chanel value as integer from 0 to 255, inclusive., by default 0xFF</p> <code>255</code> <p>Returns:</p> Type Description <code>Self</code> <p>Color built from r, g, b, a values.</p> Source code in <code>src/pygerber/common/rgba.py</code> <pre><code>@classmethod\ndef from_rgba(cls, r: int, g: int, b: int, a: int = 0xFF) -&gt; Self:\n    \"\"\"Build RGBA color object from reg, green, blue and alpha integer values.\n\n    Parameters\n    ----------\n    r : int\n        Red chanel value as integer from 0 to 255, inclusive.\n    g : int\n        Green chanel value as integer from 0 to 255, inclusive.\n    b : int\n        Blue chanel value as integer from 0 to 255, inclusive.\n    a : int, optional\n        Alpha chanel value as integer from 0 to 255, inclusive., by default 0xFF\n\n    Returns\n    -------\n    Self\n        Color built from r, g, b, a values.\n    \"\"\"\n    return cls(r=r, g=g, b=b, a=a)\n</code></pre>"},{"location":"gerber/1_reference.html#pygerber.gerberx3.api.RGBA.from_hsv","title":"from_hsv  <code>classmethod</code>","text":"<pre><code>from_hsv(h: int, s: float, v: float, a: int = 255) -&gt; Self\n</code></pre> <p>Build RGBA color object from hue, saturation, value and alpha.</p> <p>For extended information refer to Wikipedia: https://en.wikipedia.org/wiki/HSL_and_HSV</p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>int</code> <p>Hue of color, integer in range 0 to 360 inclusive.</p> required <code>s</code> <code>float</code> <p>Saturation of color, float in range 0.0 to 100.0 inclusive.</p> required <code>v</code> <code>float</code> <p>Value of color, float in range 0.0 to 100.0 inclusive.</p> required <code>a</code> <code>int</code> <p>Alpha of color, int in range 0 to 255 inclusive.</p> <code>255</code> <p>Returns:</p> Type Description <code>Self</code> <p>Color built from h, s, v, a values.</p> Source code in <code>src/pygerber/common/rgba.py</code> <pre><code>@classmethod\ndef from_hsv(\n    cls,\n    h: int,\n    s: float,\n    v: float,\n    a: int = 255,\n) -&gt; Self:\n    \"\"\"Build RGBA color object from hue, saturation, value and alpha.\n\n    For extended information refer to Wikipedia: https://en.wikipedia.org/wiki/HSL_and_HSV\n\n    Parameters\n    ----------\n    h : int\n        Hue of color, integer in range 0 to 360 inclusive.\n    s : float\n        Saturation of color, float in range 0.0 to 100.0 inclusive.\n    v : float\n        Value of color, float in range 0.0 to 100.0 inclusive.\n    a : int\n        Alpha of color, int in range 0 to 255 inclusive.\n\n    Returns\n    -------\n    Self\n        Color built from h, s, v, a values.\n    \"\"\"\n    h %= 360\n    s /= 100\n    v /= 100\n\n    c = v * s\n    x = c * (1 - abs(((h / 60) % 2) - 1))\n    m = v - c\n\n    if 0 &lt;= h &lt; HSV_Q0_MAX_ANGLE_DEGREES:\n        r_, g_, b_ = c, x, 0.0\n    elif HSV_Q0_MAX_ANGLE_DEGREES &lt;= h &lt; HSV_Q1_MAX_ANGLE_DEGREES:\n        r_, g_, b_ = x, c, 0.0\n    elif HSV_Q1_MAX_ANGLE_DEGREES &lt;= h &lt; HSV_Q2_MAX_ANGLE_DEGREES:\n        r_, g_, b_ = 0.0, c, x\n    elif HSV_Q2_MAX_ANGLE_DEGREES &lt;= h &lt; HSV_Q3_MAX_ANGLE_DEGREES:\n        r_, g_, b_ = 0.0, x, c\n    elif HSV_Q3_MAX_ANGLE_DEGREES &lt;= h &lt; HSV_Q4_MAX_ANGLE_DEGREES:\n        r_, g_, b_ = x, 0.0, c\n    elif HSV_Q4_MAX_ANGLE_DEGREES &lt;= h &lt;= HSV_Q5_MAX_ANGLE_DEGREES:\n        r_, g_, b_ = c, 0.0, x\n    else:\n        raise ValueError(h)\n\n    return cls(\n        r=round((r_ + m) * 255),\n        g=round((g_ + m) * 255),\n        b=round((b_ + m) * 255),\n        a=a,\n    )\n</code></pre>"},{"location":"gerber/1_reference.html#pygerber.gerberx3.api.RGBA.as_rgba_int","title":"as_rgba_int","text":"<pre><code>as_rgba_int() -&gt; tuple[int, int, int, int]\n</code></pre> <p>Return RGBA color as tuple of integers in range 0 to 255 inclusive.</p> Source code in <code>src/pygerber/common/rgba.py</code> <pre><code>def as_rgba_int(self) -&gt; tuple[int, int, int, int]:\n    \"\"\"Return RGBA color as tuple of integers in range 0 to 255 inclusive.\"\"\"\n    return self.r, self.g, self.b, self.a\n</code></pre>"},{"location":"gerber/1_reference.html#pygerber.gerberx3.api.RGBA.as_rgba_float","title":"as_rgba_float","text":"<pre><code>as_rgba_float() -&gt; tuple[float, float, float, float]\n</code></pre> <p>Return RGBA color as tuple of floats in range 0.0 to 1.0 inclusive.</p> Source code in <code>src/pygerber/common/rgba.py</code> <pre><code>def as_rgba_float(self) -&gt; tuple[float, float, float, float]:\n    \"\"\"Return RGBA color as tuple of floats in range 0.0 to 1.0 inclusive.\"\"\"\n    return (\n        float(Decimal(self.r) / Decimal(255)),\n        float(Decimal(self.g) / Decimal(255)),\n        float(Decimal(self.b) / Decimal(255)),\n        float(Decimal(self.a) / Decimal(255)),\n    )\n</code></pre>"},{"location":"gerber/1_reference.html#pygerber.gerberx3.api.RGBA.to_hex","title":"to_hex","text":"<pre><code>to_hex() -&gt; str\n</code></pre> <p>Return color as hexadecimal string.</p> Source code in <code>src/pygerber/common/rgba.py</code> <pre><code>def to_hex(self) -&gt; str:\n    \"\"\"Return color as hexadecimal string.\"\"\"\n    r = f\"{self.r:0{2}x}\"\n    g = f\"{self.g:0{2}x}\"\n    b = f\"{self.b:0{2}x}\"\n    a = f\"{self.a:0{2}x}\"\n    return f\"#{r}{g}{b}{a}\"\n</code></pre>"},{"location":"gerber/1_reference.html#pygerber.gerberx3.api.GerberX3APIError","title":"GerberX3APIError","text":"<p>             Bases: <code>Exception</code></p> <p>Base class for API errors.</p> <p>Exceptions derived from this exception are exclusively raised in PyGerber's Gerber X3 high level API. This exception can be used in <code>try: ... except GerberX3APIError: ...</code> block to catch all exceptions raised by this API while allowing other exceptions to interrupt execution.</p> Source code in <code>src/pygerber/gerberx3/api/_errors.py</code> <pre><code>class GerberX3APIError(Exception):\n    \"\"\"Base class for API errors.\n\n    Exceptions derived from this exception are exclusively raised in PyGerber's Gerber\n    X3 high level API. This exception can be used in\n    `#!python try: ... except GerberX3APIError: ...` block to catch all exceptions\n    raised by this API while allowing other exceptions to interrupt execution.\n    \"\"\"\n</code></pre>"},{"location":"gerber/1_reference.html#pygerber.gerberx3.api.MutuallyExclusiveViolationError","title":"MutuallyExclusiveViolationError","text":"<p>             Bases: <code>GerberX3APIError</code></p> <p>Raised when two or more of mutually exclusive parameters are provided.</p> <p><code>LayerParams</code> class accepts three mutually exclusive fields, <code>source_path</code>, <code>source_code</code> and <code>source_buffer</code> for providing source code to <code>Layer</code>. When more than one of those options is set, this exception will be raised.</p> Source code in <code>src/pygerber/gerberx3/api/_errors.py</code> <pre><code>class MutuallyExclusiveViolationError(GerberX3APIError):\n    \"\"\"Raised when two or more of mutually exclusive parameters are provided.\n\n    `LayerParams` class accepts three mutually exclusive fields, `source_path`,\n    `source_code` and `source_buffer` for providing source code to `Layer`.\n    When more than one of those options is set, this exception will be raised.\n    \"\"\"\n</code></pre>"},{"location":"gerber/1_reference.html#pygerber.gerberx3.api.RenderingResultNotReadyError","title":"RenderingResultNotReadyError","text":"<p>             Bases: <code>GerberX3APIError</code></p> <p>Raised when RenderingResult is requested before it was rendered.</p> <p><code>Layer.get_rendering_result()</code> method can only be called after <code>Layer.render()</code>. Breaking this rule will cause this exception to be raised.</p> Source code in <code>src/pygerber/gerberx3/api/_errors.py</code> <pre><code>class RenderingResultNotReadyError(GerberX3APIError):\n    \"\"\"Raised when RenderingResult is requested before it was rendered.\n\n    `Layer.get_rendering_result()` method can only be called after `Layer.render()`.\n    Breaking this rule will cause this exception to be raised.\n    \"\"\"\n</code></pre>"},{"location":"gerber/1_reference.html#pygerber.gerberx3.api.Layer","title":"Layer","text":"<p>Representation of Gerber X3 image layer.</p> <p>This is only abstract base class, please use one of its subclasses with rendering system guarantees.</p> Source code in <code>src/pygerber/gerberx3/api/_layers.py</code> <pre><code>class Layer:\n    \"\"\"Representation of Gerber X3 image layer.\n\n    This is only abstract base class, please use one of its subclasses with rendering\n    system guarantees.\n    \"\"\"\n\n    def __init__(self, options: LayerParams) -&gt; None:\n        \"\"\"Create PCB layer.\n\n        Parameters\n        ----------\n        options: LayerOptions\n            Configuration of layer.\n        \"\"\"\n        self.options = options\n\n        self.tokenizer = self._create_tokenizer()\n        self.backend = self._create_backend()\n        self.parser = self._create_parser()\n\n        self._rendering_result: Optional[RenderingResult] = None\n\n    def _create_tokenizer(self) -&gt; Tokenizer:\n        return Tokenizer()\n\n    @abstractmethod\n    def _create_backend(self) -&gt; Backend:\n        pass\n\n    def _create_parser(self) -&gt; Parser:\n        return Parser(\n            ParserOptions(\n                backend=self.backend,\n                on_update_drawing_state_error=self.options.parser_error,\n            ),\n        )\n\n    def render(self) -&gt; RenderingResult:\n        \"\"\"Render layer image.\"\"\"\n        stack = self.tokenizer.tokenize(self.options.get_source_code())\n        draw_commands = self.parser.parse(stack)\n\n        result_handle = draw_commands.draw()\n        properties = LayerProperties(\n            target_bounding_box=self.backend.drawing_target.bounding_box,\n            target_coordinate_origin=self.backend.drawing_target.coordinate_origin,\n            gerber_bounding_box=self.backend.bounding_box,\n            gerber_coordinate_origin=self.backend.coordinate_origin,\n        )\n\n        self._rendering_result = self._get_rendering_result_cls()(\n            result_handle=result_handle,\n            properties=properties,\n        )\n        return self._rendering_result\n\n    def _get_rendering_result_cls(self) -&gt; type[RenderingResult]:\n        return RenderingResult\n\n    def get_rendering_result(self) -&gt; RenderingResult:\n        \"\"\"Return result of rendering Gerber file.\"\"\"\n        if self._rendering_result is None:\n            msg = \"Use `render()` method to create result first.\"\n            raise RenderingResultNotReadyError(msg)\n\n        return self._rendering_result\n</code></pre>"},{"location":"gerber/1_reference.html#pygerber.gerberx3.api.Layer.__init__","title":"__init__","text":"<pre><code>__init__(options: LayerParams) -&gt; None\n</code></pre> <p>Create PCB layer.</p> <p>Parameters:</p> Name Type Description Default <code>options</code> <code>LayerParams</code> <p>Configuration of layer.</p> required Source code in <code>src/pygerber/gerberx3/api/_layers.py</code> <pre><code>def __init__(self, options: LayerParams) -&gt; None:\n    \"\"\"Create PCB layer.\n\n    Parameters\n    ----------\n    options: LayerOptions\n        Configuration of layer.\n    \"\"\"\n    self.options = options\n\n    self.tokenizer = self._create_tokenizer()\n    self.backend = self._create_backend()\n    self.parser = self._create_parser()\n\n    self._rendering_result: Optional[RenderingResult] = None\n</code></pre>"},{"location":"gerber/1_reference.html#pygerber.gerberx3.api.Layer.render","title":"render","text":"<pre><code>render() -&gt; RenderingResult\n</code></pre> <p>Render layer image.</p> Source code in <code>src/pygerber/gerberx3/api/_layers.py</code> <pre><code>def render(self) -&gt; RenderingResult:\n    \"\"\"Render layer image.\"\"\"\n    stack = self.tokenizer.tokenize(self.options.get_source_code())\n    draw_commands = self.parser.parse(stack)\n\n    result_handle = draw_commands.draw()\n    properties = LayerProperties(\n        target_bounding_box=self.backend.drawing_target.bounding_box,\n        target_coordinate_origin=self.backend.drawing_target.coordinate_origin,\n        gerber_bounding_box=self.backend.bounding_box,\n        gerber_coordinate_origin=self.backend.coordinate_origin,\n    )\n\n    self._rendering_result = self._get_rendering_result_cls()(\n        result_handle=result_handle,\n        properties=properties,\n    )\n    return self._rendering_result\n</code></pre>"},{"location":"gerber/1_reference.html#pygerber.gerberx3.api.Layer.get_rendering_result","title":"get_rendering_result","text":"<pre><code>get_rendering_result() -&gt; RenderingResult\n</code></pre> <p>Return result of rendering Gerber file.</p> Source code in <code>src/pygerber/gerberx3/api/_layers.py</code> <pre><code>def get_rendering_result(self) -&gt; RenderingResult:\n    \"\"\"Return result of rendering Gerber file.\"\"\"\n    if self._rendering_result is None:\n        msg = \"Use `render()` method to create result first.\"\n        raise RenderingResultNotReadyError(msg)\n\n    return self._rendering_result\n</code></pre>"},{"location":"gerber/1_reference.html#pygerber.gerberx3.api.LayerParams","title":"LayerParams","text":"<p>             Bases: <code>BaseModel</code></p> <p>Parameters for Layer object.</p> <p><code>source_path</code>, <code>source_code</code> and <code>source_buffer</code> are mutually exclusive. When more than one of them is provided to constructor, MutuallyExclusiveViolationError will be raised.</p> Source code in <code>src/pygerber/gerberx3/api/_layers.py</code> <pre><code>class LayerParams(BaseModel):\n    \"\"\"Parameters for Layer object.\n\n    `source_path`, `source_code` and `source_buffer` are mutually exclusive.\n    When more than one of them is provided to constructor,\n    MutuallyExclusiveViolationError will be raised.\n    \"\"\"\n\n    model_config = ConfigDict(arbitrary_types_allowed=True, extra=\"forbid\")\n\n    source_path: Optional[Union[Path, str]] = None\n    \"\"\"Path to source file containing Gerber code. It will be automatically loaded\n    from local storage, when provided. Mutually exclusive with `source_code` and\n    `source_buffer`.\n    \"\"\"\n\n    source_code: Optional[Union[str, bytes]] = None\n    \"\"\"Gerber source code. Mutually exclusive with `source_path` and `source_buffer`.\"\"\"\n\n    source_buffer: Optional[Union[StringIO, BytesIO]] = None\n    \"\"\"Buffer containing Gerber source code. Buffer pointer should be at the\n    beginning of the buffer. Mutually exclusive with `source_path` and\n    `source_code`.\"\"\"\n\n    parser_error: Union[\n        Callable[[Exception, Parser, Token], None],\n        ParserOnErrorAction,\n    ] = ParserOnErrorAction.Raise\n    \"\"\"Callback function or rule describing how to treat errors during parsing.\"\"\"\n\n    encoding: str = \"utf-8\"\n    \"\"\"Encoding of code, used when loading from file, decoding `source_code`\n    provided as bytes and reading `source_buffer` provided as BytesIO.\"\"\"\n\n    draw_region_outlines: bool = False\n    \"\"\"When drawing regions, after filling region, draw also outline of region with\n    apertures used for region outlines. This behavior is not expected by KiCAD by\n    default but may be useful in some scenarios.\"\"\"\n\n    @model_validator(mode=\"after\")\n    def _load_source_code(self) -&gt; Self:\n        \"\"\"Load source code.\n\n        Raises\n        ------\n        MutuallyExclusiveViolationError\n            When more than one of mutually exclusive `source_path`, `source_code` and\n            `source_buffer` is provided to constructor.\n        \"\"\"\n        if self.source_path:\n            if self.source_code or self.source_buffer:\n                msg = \"'source_code' and 'source_buffer' provided at once.\"\n                raise MutuallyExclusiveViolationError(msg)\n\n            self.source_code = (\n                Path(self.source_path or \"source.grb\")\n                .expanduser()\n                .resolve()\n                .read_text(encoding=self.encoding)\n            )\n            return self\n\n        if self.source_code:\n            if self.source_path or self.source_buffer:\n                msg = \"'source_path' and 'source_buffer' provided at once.\"\n                raise MutuallyExclusiveViolationError(msg)\n\n            self.source_code = (\n                self.source_code\n                if isinstance(self.source_code, str)\n                else self.source_code.decode(self.encoding)\n            )\n            return self\n\n        if self.source_buffer:\n            if self.source_path or self.source_code:\n                msg = \"'source_path' and 'source_buffer' provided at once.\"\n                raise MutuallyExclusiveViolationError(msg)\n\n            source_code = self.source_buffer.read()\n            if isinstance(source_code, bytes):\n                self.source_code = source_code.decode(encoding=\"utf-8\")\n            else:\n                self.source_code = source_code\n\n        return self\n\n    def get_source_code(self) -&gt; str:\n        \"\"\"Return source code of layer.\"\"\"\n        if not isinstance(self.source_code, str):\n            msg = f\"Expected {str} got {type(self.source_code)}.\"\n            raise TypeError(msg)\n\n        return self.source_code\n</code></pre>"},{"location":"gerber/1_reference.html#pygerber.gerberx3.api.LayerParams.source_path","title":"source_path  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>source_path: Optional[Union[Path, str]] = None\n</code></pre> <p>Path to source file containing Gerber code. It will be automatically loaded from local storage, when provided. Mutually exclusive with <code>source_code</code> and <code>source_buffer</code>.</p>"},{"location":"gerber/1_reference.html#pygerber.gerberx3.api.LayerParams.source_code","title":"source_code  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>source_code: Optional[Union[str, bytes]] = None\n</code></pre> <p>Gerber source code. Mutually exclusive with <code>source_path</code> and <code>source_buffer</code>.</p>"},{"location":"gerber/1_reference.html#pygerber.gerberx3.api.LayerParams.source_buffer","title":"source_buffer  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>source_buffer: Optional[Union[StringIO, BytesIO]] = None\n</code></pre> <p>Buffer containing Gerber source code. Buffer pointer should be at the beginning of the buffer. Mutually exclusive with <code>source_path</code> and <code>source_code</code>.</p>"},{"location":"gerber/1_reference.html#pygerber.gerberx3.api.LayerParams.parser_error","title":"parser_error  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>parser_error: Union[\n    Callable[[Exception, Parser, Token], None],\n    ParserOnErrorAction,\n] = Raise\n</code></pre> <p>Callback function or rule describing how to treat errors during parsing.</p>"},{"location":"gerber/1_reference.html#pygerber.gerberx3.api.LayerParams.encoding","title":"encoding  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>encoding: str = 'utf-8'\n</code></pre> <p>Encoding of code, used when loading from file, decoding <code>source_code</code> provided as bytes and reading <code>source_buffer</code> provided as BytesIO.</p>"},{"location":"gerber/1_reference.html#pygerber.gerberx3.api.LayerParams.draw_region_outlines","title":"draw_region_outlines  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>draw_region_outlines: bool = False\n</code></pre> <p>When drawing regions, after filling region, draw also outline of region with apertures used for region outlines. This behavior is not expected by KiCAD by default but may be useful in some scenarios.</p>"},{"location":"gerber/1_reference.html#pygerber.gerberx3.api.LayerParams.get_source_code","title":"get_source_code","text":"<pre><code>get_source_code() -&gt; str\n</code></pre> <p>Return source code of layer.</p> Source code in <code>src/pygerber/gerberx3/api/_layers.py</code> <pre><code>def get_source_code(self) -&gt; str:\n    \"\"\"Return source code of layer.\"\"\"\n    if not isinstance(self.source_code, str):\n        msg = f\"Expected {str} got {type(self.source_code)}.\"\n        raise TypeError(msg)\n\n    return self.source_code\n</code></pre>"},{"location":"gerber/1_reference.html#pygerber.gerberx3.api.LayerProperties","title":"LayerProperties","text":"<p>Properties of layer retrieved from Gerber source code.</p> Source code in <code>src/pygerber/gerberx3/api/_layers.py</code> <pre><code>class LayerProperties:\n    \"\"\"Properties of layer retrieved from Gerber source code.\"\"\"\n\n    target_bounding_box: BoundingBox\n    \"\"\"Bounding box of rendering target. May differ from coordinates used in Gerber\n    file as it uses rendering target coordinate space.\"\"\"\n\n    target_coordinate_origin: Vector2D\n    \"\"\"Offset of origin of coordinate system used by rendering target. Bottom left\n    corner of coordinate space of rendering target.\"\"\"\n\n    gerber_bounding_box: BoundingBox\n    \"\"\"Bounding box of drawing area in Gerber file coordinate space.\"\"\"\n\n    gerber_coordinate_origin: Vector2D\n    \"\"\"Origin of coordinate space of Gerber file. Equivalent to bottom left corner of\n    `gerber_bounding_box`.\n\n    Can be useful to determine how to align multiple Gerber files by calculating\n    how their coordinate origins are positioned in relation to each other.\"\"\"\n\n    def __init__(\n        self,\n        target_bounding_box: BoundingBox,\n        target_coordinate_origin: Vector2D,\n        gerber_bounding_box: BoundingBox,\n        gerber_coordinate_origin: Vector2D,\n    ) -&gt; None:\n        \"\"\"Initialize layer properties.\"\"\"\n        self.target_bounding_box = target_bounding_box\n        self.target_coordinate_origin = target_coordinate_origin\n\n        self.gerber_bounding_box = gerber_bounding_box\n        self.gerber_coordinate_origin = gerber_coordinate_origin\n</code></pre>"},{"location":"gerber/1_reference.html#pygerber.gerberx3.api.LayerProperties.target_bounding_box","title":"target_bounding_box  <code>instance-attribute</code>","text":"<pre><code>target_bounding_box: BoundingBox = target_bounding_box\n</code></pre> <p>Bounding box of rendering target. May differ from coordinates used in Gerber file as it uses rendering target coordinate space.</p>"},{"location":"gerber/1_reference.html#pygerber.gerberx3.api.LayerProperties.target_coordinate_origin","title":"target_coordinate_origin  <code>instance-attribute</code>","text":"<pre><code>target_coordinate_origin: Vector2D = (\n    target_coordinate_origin\n)\n</code></pre> <p>Offset of origin of coordinate system used by rendering target. Bottom left corner of coordinate space of rendering target.</p>"},{"location":"gerber/1_reference.html#pygerber.gerberx3.api.LayerProperties.gerber_bounding_box","title":"gerber_bounding_box  <code>instance-attribute</code>","text":"<pre><code>gerber_bounding_box: BoundingBox = gerber_bounding_box\n</code></pre> <p>Bounding box of drawing area in Gerber file coordinate space.</p>"},{"location":"gerber/1_reference.html#pygerber.gerberx3.api.LayerProperties.gerber_coordinate_origin","title":"gerber_coordinate_origin  <code>instance-attribute</code>","text":"<pre><code>gerber_coordinate_origin: Vector2D = (\n    gerber_coordinate_origin\n)\n</code></pre> <p>Origin of coordinate space of Gerber file. Equivalent to bottom left corner of <code>gerber_bounding_box</code>.</p> <p>Can be useful to determine how to align multiple Gerber files by calculating how their coordinate origins are positioned in relation to each other.</p>"},{"location":"gerber/1_reference.html#pygerber.gerberx3.api.LayerProperties.__init__","title":"__init__","text":"<pre><code>__init__(\n    target_bounding_box: BoundingBox,\n    target_coordinate_origin: Vector2D,\n    gerber_bounding_box: BoundingBox,\n    gerber_coordinate_origin: Vector2D,\n) -&gt; None\n</code></pre> <p>Initialize layer properties.</p> Source code in <code>src/pygerber/gerberx3/api/_layers.py</code> <pre><code>def __init__(\n    self,\n    target_bounding_box: BoundingBox,\n    target_coordinate_origin: Vector2D,\n    gerber_bounding_box: BoundingBox,\n    gerber_coordinate_origin: Vector2D,\n) -&gt; None:\n    \"\"\"Initialize layer properties.\"\"\"\n    self.target_bounding_box = target_bounding_box\n    self.target_coordinate_origin = target_coordinate_origin\n\n    self.gerber_bounding_box = gerber_bounding_box\n    self.gerber_coordinate_origin = gerber_coordinate_origin\n</code></pre>"},{"location":"gerber/1_reference.html#pygerber.gerberx3.api.Rasterized2DLayer","title":"Rasterized2DLayer","text":"<p>             Bases: <code>Layer</code></p> <p>Representation of Gerber X3 rasterized 2D image layer.</p> <p>Rasterized images can be saved in any image format supported by Pillow library. For full list of supported formats please refer to Pillow documentation.</p> Source code in <code>src/pygerber/gerberx3/api/_layers.py</code> <pre><code>class Rasterized2DLayer(Layer):\n    \"\"\"Representation of Gerber X3 rasterized 2D image layer.\n\n    Rasterized images can be saved in any image format supported by Pillow library.\n    For full list of supported formats please refer to\n    [Pillow documentation](https://pillow.readthedocs.io/en/stable/handbook/image-file-formats.html).\n    \"\"\"\n\n    options: Rasterized2DLayerParams\n\n    def __init__(self, options: Rasterized2DLayerParams) -&gt; None:\n        \"\"\"Initialize Layer object.\"\"\"\n        if not isinstance(options, Rasterized2DLayerParams):\n            msg = f\"Expected {Rasterized2DLayerParams} got {type(options)}.\"  # type: ignore[unreachable]\n            raise TypeError(msg)\n        super().__init__(options)\n\n    def _create_backend(self) -&gt; Backend:\n        return Rasterized2DBackend(\n            Rasterized2DBackendOptions(\n                dpi=self.options.dpi,\n                color_scheme=self.options.colors,\n                dump_apertures=self.options.debug_dump_apertures,\n                include_debug_padding=self.options.debug_include_extra_padding,\n                include_bounding_boxes=self.options.debug_include_bounding_boxes,\n                draw_region_outlines=self.options.draw_region_outlines,\n            ),\n        )\n\n    def _get_rendering_result_cls(self) -&gt; type[RenderingResult]:\n        return Rasterized2DRenderingResult\n</code></pre>"},{"location":"gerber/1_reference.html#pygerber.gerberx3.api.Rasterized2DLayer.__init__","title":"__init__","text":"<pre><code>__init__(options: Rasterized2DLayerParams) -&gt; None\n</code></pre> <p>Initialize Layer object.</p> Source code in <code>src/pygerber/gerberx3/api/_layers.py</code> <pre><code>def __init__(self, options: Rasterized2DLayerParams) -&gt; None:\n    \"\"\"Initialize Layer object.\"\"\"\n    if not isinstance(options, Rasterized2DLayerParams):\n        msg = f\"Expected {Rasterized2DLayerParams} got {type(options)}.\"  # type: ignore[unreachable]\n        raise TypeError(msg)\n    super().__init__(options)\n</code></pre>"},{"location":"gerber/1_reference.html#pygerber.gerberx3.api.Rasterized2DLayerParams","title":"Rasterized2DLayerParams","text":"<p>             Bases: <code>LayerParams</code></p> <p>Parameters for Layer with 2D rendering.</p> <p><code>source_path</code>, <code>source_code</code> and <code>source_buffer</code> are mutually exclusive. When more than one of them is provided to constructor, MutuallyExclusiveViolationError will be raised.</p> Source code in <code>src/pygerber/gerberx3/api/_layers.py</code> <pre><code>class Rasterized2DLayerParams(LayerParams):\n    \"\"\"Parameters for Layer with 2D rendering.\n\n    `source_path`, `source_code` and `source_buffer` are mutually exclusive.\n    When more than one of them is provided to constructor,\n    MutuallyExclusiveViolationError will be raised.\n    \"\"\"\n\n    colors: ColorScheme\n    \"\"\"Colors to use for rendering of image.\"\"\"\n\n    dpi: int = 1000\n    \"\"\"DPI of output image.\"\"\"\n\n    debug_dump_apertures: Optional[Path] = None\n    \"\"\"Debug option - dump aperture images to files in given directory.\"\"\"\n\n    debug_include_extra_padding: bool = False\n    \"\"\"Debug option - include large extra padding on all rendering targets to simplify\n    tracking of mispositioned draw commands.\"\"\"\n\n    debug_include_bounding_boxes: bool = False\n    \"\"\"Debug option - include bounding boxes as square outlines on drawing targets\n    to simplify tracking of miscalculated bounding boxes.\"\"\"\n</code></pre>"},{"location":"gerber/1_reference.html#pygerber.gerberx3.api.Rasterized2DLayerParams.colors","title":"colors  <code>instance-attribute</code>","text":"<pre><code>colors: ColorScheme\n</code></pre> <p>Colors to use for rendering of image.</p>"},{"location":"gerber/1_reference.html#pygerber.gerberx3.api.Rasterized2DLayerParams.dpi","title":"dpi  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dpi: int = 1000\n</code></pre> <p>DPI of output image.</p>"},{"location":"gerber/1_reference.html#pygerber.gerberx3.api.Rasterized2DLayerParams.debug_dump_apertures","title":"debug_dump_apertures  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>debug_dump_apertures: Optional[Path] = None\n</code></pre> <p>Debug option - dump aperture images to files in given directory.</p>"},{"location":"gerber/1_reference.html#pygerber.gerberx3.api.Rasterized2DLayerParams.debug_include_extra_padding","title":"debug_include_extra_padding  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>debug_include_extra_padding: bool = False\n</code></pre> <p>Debug option - include large extra padding on all rendering targets to simplify tracking of mispositioned draw commands.</p>"},{"location":"gerber/1_reference.html#pygerber.gerberx3.api.Rasterized2DLayerParams.debug_include_bounding_boxes","title":"debug_include_bounding_boxes  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>debug_include_bounding_boxes: bool = False\n</code></pre> <p>Debug option - include bounding boxes as square outlines on drawing targets to simplify tracking of miscalculated bounding boxes.</p>"},{"location":"gerber/1_reference.html#pygerber.gerberx3.api.RenderingResult","title":"RenderingResult","text":"<p>Result of rendering of layer.</p> Source code in <code>src/pygerber/gerberx3/api/_layers.py</code> <pre><code>class RenderingResult:\n    \"\"\"Result of rendering of layer.\"\"\"\n\n    def __init__(\n        self,\n        properties: LayerProperties,\n        result_handle: ResultHandle,\n    ) -&gt; None:\n        \"\"\"Initialize rendering result object.\"\"\"\n        self._properties = properties\n        self._result_handle = result_handle\n\n    def save(\n        self,\n        dest: Path | str | BytesIO,\n        **options: Any,\n    ) -&gt; None:\n        \"\"\"Save result to specified file or buffer.\n\n        Parameters\n        ----------\n        dest : Path | str | BytesIO\n            Write target.\n        **options: Any\n            Extra parameters which will be passed to saving implementation.\n            When dest is BytesIO or alike, `format` option must be specified.\n            For Rasterized2D rendering options see [Pillow documentation](https://pillow.readthedocs.io/en/stable/reference/Image.html#PIL.Image.Image.save).\n        \"\"\"\n        self._result_handle.save(dest, **options)\n\n    def get_properties(self) -&gt; LayerProperties:\n        \"\"\"Get properties of layer.\"\"\"\n        return self._properties\n</code></pre>"},{"location":"gerber/1_reference.html#pygerber.gerberx3.api.RenderingResult.__init__","title":"__init__","text":"<pre><code>__init__(\n    properties: LayerProperties, result_handle: ResultHandle\n) -&gt; None\n</code></pre> <p>Initialize rendering result object.</p> Source code in <code>src/pygerber/gerberx3/api/_layers.py</code> <pre><code>def __init__(\n    self,\n    properties: LayerProperties,\n    result_handle: ResultHandle,\n) -&gt; None:\n    \"\"\"Initialize rendering result object.\"\"\"\n    self._properties = properties\n    self._result_handle = result_handle\n</code></pre>"},{"location":"gerber/1_reference.html#pygerber.gerberx3.api.RenderingResult.save","title":"save","text":"<pre><code>save(dest: Path | str | BytesIO, **options: Any) -&gt; None\n</code></pre> <p>Save result to specified file or buffer.</p> <p>Parameters:</p> Name Type Description Default <code>dest</code> <code>Path | str | BytesIO</code> <p>Write target.</p> required <code>**options</code> <code>Any</code> <p>Extra parameters which will be passed to saving implementation. When dest is BytesIO or alike, <code>format</code> option must be specified. For Rasterized2D rendering options see Pillow documentation.</p> <code>{}</code> Source code in <code>src/pygerber/gerberx3/api/_layers.py</code> <pre><code>def save(\n    self,\n    dest: Path | str | BytesIO,\n    **options: Any,\n) -&gt; None:\n    \"\"\"Save result to specified file or buffer.\n\n    Parameters\n    ----------\n    dest : Path | str | BytesIO\n        Write target.\n    **options: Any\n        Extra parameters which will be passed to saving implementation.\n        When dest is BytesIO or alike, `format` option must be specified.\n        For Rasterized2D rendering options see [Pillow documentation](https://pillow.readthedocs.io/en/stable/reference/Image.html#PIL.Image.Image.save).\n    \"\"\"\n    self._result_handle.save(dest, **options)\n</code></pre>"},{"location":"gerber/1_reference.html#pygerber.gerberx3.api.RenderingResult.get_properties","title":"get_properties","text":"<pre><code>get_properties() -&gt; LayerProperties\n</code></pre> <p>Get properties of layer.</p> Source code in <code>src/pygerber/gerberx3/api/_layers.py</code> <pre><code>def get_properties(self) -&gt; LayerProperties:\n    \"\"\"Get properties of layer.\"\"\"\n    return self._properties\n</code></pre>"},{"location":"gerber/1_reference.html#pygerber.gerberx3.api.ApertureNotDefinedError","title":"ApertureNotDefinedError","text":"<p>             Bases: <code>ParserError</code></p> <p>Raised when undefined aperture is selected.</p> Source code in <code>src/pygerber/gerberx3/parser/errors.py</code> <pre><code>class ApertureNotDefinedError(ParserError):\n    \"\"\"Raised when undefined aperture is selected.\"\"\"\n</code></pre>"},{"location":"gerber/1_reference.html#pygerber.gerberx3.api.ApertureNotSelectedError","title":"ApertureNotSelectedError","text":"<p>             Bases: <code>ParserError</code></p> <p>Raised when attempting to use aperture without selecting it first.</p> Source code in <code>src/pygerber/gerberx3/parser/errors.py</code> <pre><code>class ApertureNotSelectedError(ParserError):\n    \"\"\"Raised when attempting to use aperture without selecting it first.\"\"\"\n</code></pre>"},{"location":"gerber/1_reference.html#pygerber.gerberx3.api.CoordinateFormatNotSetError","title":"CoordinateFormatNotSetError","text":"<p>             Bases: <code>ParserError</code></p> <p>Raised when coordinate parser is requested before coordinate format was set.</p> Source code in <code>src/pygerber/gerberx3/parser/errors.py</code> <pre><code>class CoordinateFormatNotSetError(ParserError):\n    \"\"\"Raised when coordinate parser is requested before coordinate format was set.\"\"\"\n</code></pre>"},{"location":"gerber/1_reference.html#pygerber.gerberx3.api.ExitParsingProcessInterrupt","title":"ExitParsingProcessInterrupt","text":"<p>             Bases: <code>Exception</code></p> <p>Raised to stop parsing.</p> Source code in <code>src/pygerber/gerberx3/parser/errors.py</code> <pre><code>class ExitParsingProcessInterrupt(Exception):  # noqa: N818\n    \"\"\"Raised to stop parsing.\"\"\"\n</code></pre>"},{"location":"gerber/1_reference.html#pygerber.gerberx3.api.IncrementalCoordinatesNotSupportedError","title":"IncrementalCoordinatesNotSupportedError","text":"<p>             Bases: <code>ParserError</code></p> <p>Raised when incremental coordinates are selected. (Spec. 8.2.1.2).</p> Source code in <code>src/pygerber/gerberx3/parser/errors.py</code> <pre><code>class IncrementalCoordinatesNotSupportedError(ParserError):\n    \"\"\"Raised when incremental coordinates are selected. (Spec. 8.2.1.2).\"\"\"\n</code></pre>"},{"location":"gerber/1_reference.html#pygerber.gerberx3.api.InvalidCoordinateLengthError","title":"InvalidCoordinateLengthError","text":"<p>             Bases: <code>ParserError</code></p> <p>Raised when coordinate string is too long.</p> Source code in <code>src/pygerber/gerberx3/parser/errors.py</code> <pre><code>class InvalidCoordinateLengthError(ParserError):\n    \"\"\"Raised when coordinate string is too long.\"\"\"\n</code></pre>"},{"location":"gerber/1_reference.html#pygerber.gerberx3.api.OnUpdateDrawingStateError","title":"OnUpdateDrawingStateError","text":"<p>             Bases: <code>ParserError</code></p> <p>Raised when parser encounters fatal failure from non-parser specific exception during call to .update_drawing_state() call.</p> Source code in <code>src/pygerber/gerberx3/parser/errors.py</code> <pre><code>class OnUpdateDrawingStateError(ParserError):\n    \"\"\"Raised when parser encounters fatal failure from non-parser specific\n    exception during call to .update_drawing_state() call.\n    \"\"\"\n\n    def __init__(self, token: Token, *args: object) -&gt; None:\n        super().__init__(*args)\n        self.token = token\n\n    def __str__(self) -&gt; str:\n        return f\"{self.token} {self.token.get_token_position()}\"\n</code></pre>"},{"location":"gerber/1_reference.html#pygerber.gerberx3.api.ParserError","title":"ParserError","text":"<p>             Bases: <code>ValueError</code></p> <p>Base class for parser errors.</p> <p>Exceptions derived from this exception are exclusively raised in PyGerber's Gerber X3 Parser. This exception can be used in <code>try: ... except ParserError: ...</code> block to catch all exceptions raised by Parser while allowing other exceptions to interrupt execution.</p> Source code in <code>src/pygerber/gerberx3/parser/errors.py</code> <pre><code>class ParserError(ValueError):\n    \"\"\"Base class for parser errors.\n\n    Exceptions derived from this exception are exclusively raised in PyGerber's Gerber\n    X3 Parser. This exception can be used in\n    `#!python try: ... except ParserError: ...` block to catch all exceptions\n    raised by Parser while allowing other exceptions to interrupt execution.\n    \"\"\"\n\n    def get_message(self) -&gt; str:\n        \"\"\"Get parser error help message.\"\"\"\n        return f\"{self.__class__.__qualname__}: {self.__doc__}\"\n</code></pre>"},{"location":"gerber/1_reference.html#pygerber.gerberx3.api.ParserError.get_message","title":"get_message","text":"<pre><code>get_message() -&gt; str\n</code></pre> <p>Get parser error help message.</p> Source code in <code>src/pygerber/gerberx3/parser/errors.py</code> <pre><code>def get_message(self) -&gt; str:\n    \"\"\"Get parser error help message.\"\"\"\n    return f\"{self.__class__.__qualname__}: {self.__doc__}\"\n</code></pre>"},{"location":"gerber/1_reference.html#pygerber.gerberx3.api.ParserFatalError","title":"ParserFatalError","text":"<p>             Bases: <code>ParserError</code></p> <p>Raised when parser encounters fatal failure from non-parser specific exception.</p> Source code in <code>src/pygerber/gerberx3/parser/errors.py</code> <pre><code>class ParserFatalError(ParserError):\n    \"\"\"Raised when parser encounters fatal failure from non-parser specific\n    exception.\n    \"\"\"\n</code></pre>"},{"location":"gerber/1_reference.html#pygerber.gerberx3.api.UnitNotSetError","title":"UnitNotSetError","text":"<p>             Bases: <code>ParserError</code></p> <p>Raised when operation which requires units to be set is executed before units are set.</p> Source code in <code>src/pygerber/gerberx3/parser/errors.py</code> <pre><code>class UnitNotSetError(ParserError):\n    \"\"\"Raised when operation which requires units to be set is executed before units\n    are set.\n    \"\"\"\n</code></pre>"},{"location":"gerber/1_reference.html#pygerber.gerberx3.api.UnsupportedCoordinateTypeError","title":"UnsupportedCoordinateTypeError","text":"<p>             Bases: <code>ParserError</code></p> <p>Raised for unsupported coordinate types.</p> Source code in <code>src/pygerber/gerberx3/parser/errors.py</code> <pre><code>class UnsupportedCoordinateTypeError(ParserError):\n    \"\"\"Raised for unsupported coordinate types.\"\"\"\n</code></pre>"},{"location":"gerber/1_reference.html#pygerber.gerberx3.api.ZeroOmissionNotSupportedError","title":"ZeroOmissionNotSupportedError","text":"<p>             Bases: <code>ParserError</code></p> <p>Raised when incremental coordinates are selected. (Spec. 8.2.1.2).</p> Source code in <code>src/pygerber/gerberx3/parser/errors.py</code> <pre><code>class ZeroOmissionNotSupportedError(ParserError):\n    \"\"\"Raised when incremental coordinates are selected. (Spec. 8.2.1.2).\"\"\"\n</code></pre>"},{"location":"gerber/1_reference.html#pygerber.gerberx3.api.ParserOnErrorAction","title":"ParserOnErrorAction","text":"<p>             Bases: <code>Enum</code></p> <p>Possible error actions.</p> Source code in <code>src/pygerber/gerberx3/parser/parser.py</code> <pre><code>class ParserOnErrorAction(Enum):\n    \"\"\"Possible error actions.\"\"\"\n\n    Ignore = \"ignore\"\n    \"\"\"Ignore parser errors. Errors which occurred will not be signaled. May yield\n    unexpected results for broken files, with missing draw commands or even more\n    significant errors.\"\"\"\n\n    Warn = \"warn\"\n    \"\"\"Warn on parser error. Parser will log warning message about what went wrong.\n    Best for supporting wide range of files without silently ignoring errors in code.\"\"\"\n\n    Raise = \"raise\"\n    \"\"\"Raise exception whenever parser encounters error. Will completely break out of\n    parsing process, making it impossible to render slightly malformed files.\"\"\"\n</code></pre>"},{"location":"gerber/1_reference.html#pygerber.gerberx3.api.ParserOnErrorAction.Ignore","title":"Ignore  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Ignore = 'ignore'\n</code></pre> <p>Ignore parser errors. Errors which occurred will not be signaled. May yield unexpected results for broken files, with missing draw commands or even more significant errors.</p>"},{"location":"gerber/1_reference.html#pygerber.gerberx3.api.ParserOnErrorAction.Warn","title":"Warn  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Warn = 'warn'\n</code></pre> <p>Warn on parser error. Parser will log warning message about what went wrong. Best for supporting wide range of files without silently ignoring errors in code.</p>"},{"location":"gerber/1_reference.html#pygerber.gerberx3.api.ParserOnErrorAction.Raise","title":"Raise  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Raise = 'raise'\n</code></pre> <p>Raise exception whenever parser encounters error. Will completely break out of parsing process, making it impossible to render slightly malformed files.</p>"},{"location":"gerber/3_internal_api_v1.html","title":"PyGerber internal API V1","text":""},{"location":"gerber/3_internal_api_v1.html#stability","title":"Stability","text":"<p>PyGerber's Gerber internal API is not as stable as high level API. This is because the implementation of subsequent functionalities may force changes in the structure of the code. However, our goal is to guarantee internal API stability between patch releases.</p> <p>Security</p> <p>In case of security vulnerability, patch update may introduce API break to guarantee safety of users. Such case will be mentioned in Changelog. If it was not mentioned in Changelog, please report it.</p> <p>When comes to minor releases, it will depend on features implemented. We will explicitly note weather subsequent minor release is considered compatible with previous one, but it would be unsafe to assume that all releases will be compatible. Therefore we recommend to our users to configure their automatic updates to only automatically suggest patches while leaving minor releases for manual review.</p> <p>Incompatible patches</p> <p>Please report API breaks introduced in patches, unless they were mentioned in Changelog with justification.</p>"},{"location":"gerber/3_internal_api_v1.html#internal-execution-model","title":"Internal execution model","text":"<p>PyGerber divides the processing of a Gerber file into three stages. In this chapter we will discuss what are those stages and how each of them work. As a starting point, to make it easier to get a general idea on PyGerber's internal structure we have provided simplified flowchart of it:</p> <pre><code>flowchart TD\n    source_code([Gerber source code])\n\n    tokenizer([Tokenizer])\n\n    token_stream(\"\n    TokenStream\n    [\n    CoordinateFormat(...)\n    Comment(...)\n    Comment(...)\n    UnitMode(...)\n    LoadPolarity(...)\n    Comment(...)\n    ApertureAttribute(...)\n    ...\n    ]\n    \")\n\n    parser([Parser])\n\n    draw_commands(\"\n    DrawCommands\n    [\n    Rasterized2DDrawPaste(...)\n    Rasterized2DDrawVectorLine(...)\n    Rasterized2DDrawPaste(...)\n    Rasterized2DDrawPaste(...)\n    Rasterized2DDrawVectorLine(...)\n    Rasterized2DDrawPaste(...)\n    Rasterized2DDrawPaste(...)\n    Rasterized2DDrawVectorLine(...)\n    Rasterized2DDrawPaste(...)\n    Rasterized2DDrawPaste(...)\n    Rasterized2DDrawVectorLine(...)\n    ...\n    ]\n    \")\n\n    backend([\"Backend, eg. Rasterized2DBackend\"])\n\n    output([Output image/model])\n\n    handle([ResultHandle])\n\n    source_code --&gt; tokenizer\n\n    subgraph \"Tokenization\"\n    tokenizer:::tokenizer_cls -- \"tokenizer.tokenize()\" --&gt; token_stream\n    end\n\n    token_stream --&gt; parser\n\n    subgraph \"Parsing\"\n    parser -- \"parser.parse()\" --&gt; draw_commands\n    end\n\n    draw_commands --&gt; backend\n\n    subgraph \"Rendering\"\n    backend -- \"draw_commands.draw()\" --&gt; handle\n    end\n\n    handle -- \"handle.save()\" --&gt; output\n\n    click tokenizer \"/reference/pygerber/gerberx3/tokenizer/tokenizer.html\" \"Tokenization\"\n    click parser \"/reference/pygerber/gerberx3/parser/parser.html\" \"Parser\"\n    click backend \"/reference/pygerber/backend/abstract/backend_cls.html\" \"Backend\"</code></pre>"},{"location":"gerber/3_internal_api_v1.html#stages","title":"Stages","text":""},{"location":"gerber/3_internal_api_v1.html#tokenization","title":"Tokenization","text":"<p>Tokenization is a fundamental process in the field of formal language processing. It involves breaking down a sequence of characters (like a source code) into smaller chunks, known as tokens. Each token represents a coherent sequence of characters that symbolize a fundamental entity in the language, like keywords, operators, or identifiers.</p>"},{"location":"gerber/3_internal_api_v1.html#pygerbers-tokenization-framework","title":"PyGerber's Tokenization Framework","text":"<p>In the PyGerber library, the tokenization process is tailored to parse the Gerber X3/X2 format, which is a widely used standard for PCB (Printed Circuit Board) data files. The library uses a combination of predefined grammar rules and token classes to achieve this.</p> <p>Core Components:</p> <ol> <li> <p>Tokenizer Class: The main driver behind the tokenization process. It offers    methods like <code>tokenize</code> and <code>tokenize_expressions</code> to convert source code into a    stack of tokens.</p> </li> <li> <p>Grammar Definitions: Housed in <code>grammar.py</code>, these provide the rules to recognize    various constructs in the Gerber X3/X2 format. The library employs the <code>pyparsing</code>    module to facilitate this.</p> </li> <li> <p>Token Class: An abstract base class in <code>token.py</code>, which serves as the foundation    for all token types in the library. It provides methods for wrapping parsing    expressions, initializing tokens from parsed results, and offers basic string    representations for debugging.</p> </li> <li> <p>Concrete Token Classes: These are implementations of the abstract <code>Token</code> class.    Each of these corresponds to a specific construct in the Gerber X3/X2 format. For    instance, <code>DNNSelectAperture</code> in <code>dnn_select_aperture.py</code> is a token representing the    aperture select command in the format.</p> </li> </ol>"},{"location":"gerber/3_internal_api_v1.html#tokenization-flow","title":"Tokenization Flow:","text":"<p>Tokenization in PyGerber follows a sequence of steps visualized in the mermaid graph present in this document. Here's a high-level overview:</p> <ol> <li>The source code of a Gerber file is fed into the <code>Tokenizer</code>.</li> <li>Using the grammar rules, the <code>Tokenizer</code> breaks down the source into meaningful    chunks.</li> <li>Each chunk is matched against a specific token class based on the grammar.</li> <li>The matched tokens are then collected into a <code>TokenStack</code>.</li> <li>Post-tokenization, this stack of tokens can be used for various purposes, like    rendering, linting, or further parsing.</li> </ol>"},{"location":"gerber/3_internal_api_v1.html#parsing","title":"Parsing","text":"<p>Once the Gerber X3/X2 source code has been tokenized, the next crucial step is parsing. The <code>Parser</code> class plays a pivotal role in this phase, ensuring the sequence of tokens is processed to generate meaningful and actionable structures.</p>"},{"location":"gerber/3_internal_api_v1.html#the-process","title":"The Process:","text":"<ol> <li> <p>Parsing the Token Stack: The <code>Parser</code> class processes the token stack produced by    the tokenizer. It ensures that the token sequence conforms to the grammar rules of    the Gerber X3/X2 format. As it progresses through the stack, it translates the tokens    into a set of drawing commands that encapsulate the instructions embedded within the    source code.</p> </li> <li> <p>State Management: An integral aspect of the parsing process is the management of    the drawing state. The <code>State</code> class, found in <code>state.py</code>, maintains the current    state of the drawing. Each token parsed potentially updates this state by    implementing <code>update_drawing_state()</code> method. This method returns two things:</p> </li> <li> <p>New instance of state if state modification was necessary or old one if it was not.</p> </li> <li> <p>Iterable of drawing commands which apply visual changes to rendering target.</p> </li> <li> <p>Error Handling: Robust error handling mechanisms are embedded within the parser.    It's equipped to detect discrepancies or violations in the token sequence. If the    sequence doesn't adhere to the expected grammar or if certain tokens are missing, the    parser raises specific exceptions to flag these issues.</p> </li> <li> <p>Generating Drawing Commands: Post-parsing, a sequence of drawing commands is    produced. These commands serve as a bridge between the Gerber X3/X2 format and the    rendering engines or other components of the PyGerber library. They are primed for    further processing or visualization.</p> </li> </ol>"},{"location":"gerber/3_internal_api_v1.html#rendering","title":"Rendering","text":"<p>After the GerberX3 source code has been tokenized into individual units and subsequently parsed into meaningful structures, the next pivotal step is rendering. This step visualizes the abstract representation of the Gerber file.</p>"},{"location":"gerber/3_internal_api_v1.html#backend-infrastructure","title":"Backend Infrastructure:","text":"<p>The essence of the rendering process in PyGerber is encapsulated within its backend infrastructure. This subsystem bridges the gap between the abstract parsed structures and their visual representations.</p> <ol> <li> <p>BackendOptions:</p> </li> <li> <p>Description: A utility class furnishing additional configurations that can      influence the rendering process, such as paths for dumping aperture data or other      specific render settings.</p> </li> <li> <p>Backend:</p> </li> <li> <p>Description: This abstract base class stands as the linchpin of the rendering      process. It amalgamates the essential attributes and methods imperative for      visualization.</p> </li> <li> <p>Key Features:</p> <ul> <li>Aperture Management: It safeguards a list of aperture handles and proffers    methods to both generate and access these handles.</li> <li>Drawing Execution: This core feature takes a suite of drawing commands and    metamorphoses them into their respective visual forms.</li> <li>Bounding Area: By preserving a bounding box, the backend delineates the    spatial constraints of the drawing.</li> <li>Coordinate Management: Orchestrating the coordinate system's origin, it    ensures the precise alignment and placement of visual elements.</li> </ul> </li> <li> <p>Extensions &amp; Implementations:</p> </li> <li>The generic interface provided by <code>Backend</code> lays the foundation. Concrete      implementations, tailored to particular rendering techniques\u2014whether rasterized 2D      visuals via Pillow, vector illustrations using drawsvg, or 3D models with      Blender\u2014build upon this foundation. They take the drawing commands and adapt them      to their unique visualization mediums.</li> </ol>"},{"location":"gerber/4_internal_api_v2.html","title":"PyGerber internal API V2","text":""},{"location":"gerber/4_internal_api_v2.html#introduction","title":"Introduction","text":"<p>Since PyGerber 2.2.0, there is alternative improved internal API to PyGerber. It was created to aid problems with design of API V2 build around <code>Tokenizer</code>, <code>Parser</code> and <code>AbstractBackend</code> classes and way they interact. They were designed to closely interact and made extension of PyGerber complicated due to multiple design flaws. Therefore, implementation of new features was becoming much harder than anticipated. To avoid breaking backward compatibility and forcing major refactoring, we have decided to introduce alternative API alongside existing one. To make it easier to distinguish parts of API V2 modules which contain parts of it contain a suffix or infix <code>2</code>, for example <code>parser2</code>, <code>renderer2</code>, <code>commands2</code>.</p> <p>API V2 contains new parser implementation, in form of <code>Parser2</code> class and new rendering implementation(s) based on <code>Renderer2</code>, eg. <code>SvgRenderer2</code> (experimental). We still rely on original <code>Tokenizer</code> and <code>Token</code> classes, although their interfaces were extended to provide integration with <code>Parser2</code> separate from how <code>Parser</code> (API V1) worked.</p> <p>New parser from the very begging was equipped with Visitor pattern based design and allows for easy substitution of implementation of various tokens. Most of Gerber file state is stored in immutable state which allows for quick jumping back in time. Additionally state is divided into multiple sub-objects each representing related set of state properties (compliant to Gerber standard). This separation simplifies process of sharing information about states with interested parties, eg. draw commands.</p>"},{"location":"gerber/4_internal_api_v2.html#rendering","title":"Rendering","text":"<p><code>Parser2</code> does not rely in any way on <code>Renderer2</code>, differently than how <code>Parser</code> interacted with <code>AbstractBackend</code>. API V2 parser generates command buffer containing draw commands which describe what should appear in the image. Those commands are later interpreted by <code>Renderer2</code>, but latter one knows nothing about the source of commands, making it possible to generate in arbitrary ways. Each command makes use of some aperture in a way described by The Gerber Format Specification. Set of commands is defined and quite small, same goes for apertures, so implementation of rendering of them can be very compact.</p> <p>In API V2 some parts of Gerber images are resolved at parser level into individual draws. This happens for SR blocks and AB apertures. These concepts doesn't exist at <code>Renderer2</code> level, they are resolved by <code>Parser2</code> into correctly transformed series of draw commands. Macros however remain as apertures and are used to create flashes consisting of multiple simple commands.</p>"},{"location":"gerber/4_internal_api_v2.html#usage","title":"Usage","text":"<p>Here's some sample code showing how to manually create objects from API V2 to parse and render Gerber file.</p> <pre><code>from pygerber.gerberx3.parser2.parser2 import Parser2\nfrom pygerber.gerberx3.renderer2.svg import SvgRenderer2\nfrom pygerber.gerberx3.tokenizer.tokenizer import Tokenizer\n\nsource = r\"\"\"\n%FSLAX26Y26*%\n%MOMM*%\n%ADD100R,1.5X1.0X0.5*%\n%ADD200C,1.5X1.0*%\n%ADD300O,1.5X1.0X0.6*%\n%ADD400P,1.5X3X5.0*%\nD100*\nX0Y0D03*\nD200*\nX0Y2000000D03*\nD300*\nX2000000Y0D03*\nD400*\nX2000000Y2000000D03*\nM02*\n\"\"\"\n\nast = Tokenizer().tokenize(source)\ncmd_buf = Parser2().parse(ast)\nimg_ref = SvgRenderer2().render(cmd_buf)\nimg_ref.save_to(\"output.png\")\n</code></pre>"},{"location":"gerber/feature_support/parser.html","title":"Parser2 feature support","text":""},{"location":"gerber/feature_support/parser.html#introduction","title":"Introduction","text":"<p>Parser is a implementation of Gerber format AST parser written in Python. It first appeared in PyGerber 2.0.0 and until release of 2.2.0 was only parser in PyGerber. However, since 2.2.0, Parser2 class is available as an alternative. It has a better design, better API and most importantly it has wider Gerber format support. Unfortunately it doesn't provide rendering support yet (however it is planned). Therefore Parser2 is recommended over Parser class for users interested in Gerber code introspection and building other code-centric tools. Until rendering support is added, other users are encouraged to stick with old Parser class.</p> <p>Contributing</p> <p>Community contributions are always welcome, they can speed up process of migrating from Parser to Parser2.</p> Symbol Meaning \u2705 Feature implemented and usable. \ud83d\udea7 Work in progress. Related APIs can change. \ud83d\udeab Not planned, unless contributed or needed. \u274c Not implemented, but planned. \ud83d\udc7d Partially implemented. \ud83d\udc7e Bugged. Symbol Count \u2705 92 \ud83d\udea7 0 \ud83d\udeab 4 \u274c 47 \ud83d\udc7d 34 \ud83d\udc7e 0 total 162"},{"location":"gerber/feature_support/parser.html#supported-gerber-x3-features","title":"Supported Gerber X3 features","text":""},{"location":"gerber/feature_support/parser.html#general","title":"General","text":"<ul> <li>\u2705 MO - Mode - Sets the unit to mm or inch.</li> <li>\u2705 FS - Format specification:<ul> <li>\u2705 absolute coordinates.</li> <li>\ud83d\udeab incremental coordinates</li> <li>\ud83d\udeab trailing zeros omission.</li> <li>\u2705 leading zeros omission.</li> </ul> </li> <li>\ud83d\udc7d AD - Aperture define - Defines a template-based aperture, assigns a D code to it.<ul> <li>\u2705 circle.</li> <li>\u2705 rectangle.</li> <li>\u2705 obround.</li> <li>\u2705 polygon.</li> <li>\u274c Define macro.</li> </ul> </li> <li>\u274c AM - Aperture macro - Defines a macro aperture template.</li> <li>\u2705 Dnn (nn\u226510) - Sets the current aperture to D code nn.</li> <li>\u2705 G01 - Sets draw mode to linear.<ul> <li>\u2705 Variable zero padding variants allowed.</li> </ul> </li> <li>\u2705 G02 - Sets draw mode to clockwise circular.<ul> <li>\u2705 Variable zero padding variants allowed.</li> </ul> </li> <li>\u2705 G03 - Sets draw mode to counterclockwise circular.<ul> <li>\u2705 Variable zero padding variants allowed.</li> </ul> </li> <li>\ud83d\udc7d LP - Load polarity (changes flag, not fully implemented).</li> <li>\ud83d\udc7d LM - Load mirroring (changes flag, not fully implemented).</li> <li>\ud83d\udc7d LR - Load rotation (changes flag, not fully implemented).</li> <li>\ud83d\udc7d LS - Load scaling (changes flag, not fully implemented).</li> <li>\u2705 TF - Attribute on file.</li> <li>\u2705 TA - Attribute on aperture.</li> <li>\u2705 TO - Attribute on object.</li> <li>\u2705 TD - Attribute delete.</li> <li>\u2705 M02 - End of file.</li> </ul>"},{"location":"gerber/feature_support/parser.html#d01-d02-d03","title":"D01, D02, D03","text":"<ul> <li>\ud83d\udc7d D01 - Plot operation, mode<ul> <li>\ud83d\udc7d Line, with:<ul> <li>\u2705 circle,</li> <li>\ud83d\udc7d rectangle,</li> <li>\ud83d\udc7d obround,</li> <li>\ud83d\udc7d polygon,</li> <li>\u274c macro.</li> </ul> </li> <li>\ud83d\udc7d Arc, with:<ul> <li>\u2705 circle,</li> <li>\ud83d\udc7d rectangle,</li> <li>\ud83d\udc7d obround,</li> <li>\ud83d\udc7d polygon,</li> <li>\u274c macro.</li> </ul> </li> <li>\ud83d\udc7d Counter clockwise arc, with:<ul> <li>\u2705 circle,</li> <li>\ud83d\udc7d rectangle,</li> <li>\ud83d\udc7d obround,</li> <li>\ud83d\udc7d polygon,</li> <li>\u274c macro.</li> </ul> </li> <li>\u2705 Variable zero padding variants allowed.</li> </ul> </li> <li>\u2705 D02 - Move operation<ul> <li>\u2705 Variable zero padding variants allowed.</li> </ul> </li> <li>\ud83d\udc7d D03 - Flash operation, with<ul> <li>\u2705 circle,</li> <li>\u2705 rectangle,</li> <li>\u2705 obround,</li> <li>\u2705 polygon,</li> <li>\u274c macro.</li> <li>\u2705 Variable zero padding variants allowed.</li> </ul> </li> </ul>"},{"location":"gerber/feature_support/parser.html#regions","title":"Regions","text":"<ul> <li>\u2705 G36 - Starts a region statement.</li> <li>\u2705 G37 - Ends the region statement.</li> <li>\ud83d\udc7d Regions, with:<ul> <li>\ud83d\udc7d Line, aperture:<ul> <li>\u2705 circle,</li> <li>\u2705 rectangle,</li> <li>\u2705 obround,</li> <li>\u2705 polygon,</li> <li>\u274c macro.</li> </ul> </li> <li>\ud83d\udc7d Arc, aperture:<ul> <li>\u2705 circle,</li> <li>\u2705 rectangle,</li> <li>\u2705 obround,</li> <li>\u2705 polygon,</li> <li>\u274c macro.</li> </ul> </li> <li>\ud83d\udc7d Counter clockwise arc, aperture:<ul> <li>\u2705 circle,</li> <li>\u2705 rectangle,</li> <li>\u2705 obround,</li> <li>\u2705 polygon,</li> <li>\u274c macro.</li> </ul> </li> </ul> </li> </ul>"},{"location":"gerber/feature_support/parser.html#macros","title":"Macros","text":"<ul> <li>\u274c Parameters.</li> <li>\u274c Primitives:<ul> <li>\u274c Code 0, Comment</li> <li>\u274c Code 1, Circle</li> <li>\u274c Code 20, Vector line</li> <li>\u274c Code 21, Center Line</li> <li>\u274c Code 4, Outline</li> <li>\u274c Code 5, Polygon</li> <li>\u274c Code 7, Thermal</li> </ul> </li> <li>\u274c Rotation around macro origin:<ul> <li>\u274c Code 0, Comment</li> <li>\u274c Code 1, Circle</li> <li>\u274c Code 20, Vector line</li> <li>\u274c Code 21, Center Line</li> <li>\u274c Code 4, Outline</li> <li>\u274c Code 5, Polygon</li> <li>\u274c Code 7, Thermal</li> </ul> </li> <li>\u274c Constants.</li> <li>\u274c Variables.</li> <li>\u274c Variable definitions.</li> </ul>"},{"location":"gerber/feature_support/parser.html#aperture-blocks","title":"Aperture blocks","text":"<ul> <li>\u274c Nested Line, aperture:<ul> <li>\u274c circle,</li> <li>\u274c rectangle,</li> <li>\u274c obround,</li> <li>\u274c polygon,</li> <li>\u274c macro.</li> </ul> </li> <li>\u274c Nested Arc, aperture:<ul> <li>\u274c circle,</li> <li>\u274c rectangle,</li> <li>\u274c obround,</li> <li>\u274c polygon,</li> <li>\u274c macro.</li> </ul> </li> <li>\u274c Nested Counter clockwise arc, aperture:<ul> <li>\u274c circle,</li> <li>\u274c rectangle,</li> <li>\u274c obround,</li> <li>\u274c polygon,</li> <li>\u274c macro.</li> </ul> </li> <li>\u274c Nested Flash:<ul> <li>\u274c circle,</li> <li>\u274c rectangle,</li> <li>\u274c obround,</li> <li>\u274c polygon,</li> <li>\u274c macro.</li> </ul> </li> <li>\u274c Nested regions (missing macro support).</li> </ul>"},{"location":"gerber/feature_support/parser.html#step-and-repeat","title":"Step and repeat","text":"<ul> <li>\u274c Nested Line, aperture:<ul> <li>\u274c circle,</li> <li>\u274c rectangle,</li> <li>\u274c obround,</li> <li>\u274c polygon,</li> <li>\u274c macro.</li> </ul> </li> <li>\u274c Nested Arc, aperture:<ul> <li>\u274c circle,</li> <li>\u274c rectangle,</li> <li>\u274c obround,</li> <li>\u274c polygon,</li> <li>\u274c macro.</li> </ul> </li> <li>\u274c Nested Counter clockwise arc, aperture:<ul> <li>\u274c circle,</li> <li>\u274c rectangle,</li> <li>\u274c obround,</li> <li>\u274c polygon,</li> <li>\u274c macro.</li> </ul> </li> <li>\u274c Nested Flash:<ul> <li>\u274c circle,</li> <li>\u274c rectangle,</li> <li>\u274c obround,</li> <li>\u274c polygon,</li> <li>\u274c macro.</li> </ul> </li> <li>\u274c Nested regions (missing macro support).</li> <li>\u274c Nested blocks (missing macro support).</li> </ul>"},{"location":"gerber/feature_support/parser.html#supported-deprecated-gerber-features","title":"Supported DEPRECATED Gerber features","text":"<ul> <li>\ud83d\udc7d G54 - Select aperture. (Spec. 8.1.1)</li> <li>\u274c G55 - Prepare for flash. (Spec. 8.1.1)</li> <li>\u2705 G70 - Set the 'Unit' to inch. (Spec. 8.1.1)</li> <li>\u2705 G71 - Set the 'Unit' to mm. (Spec. 8.1.1)</li> <li>\u2705 G90 - Set the 'Coordinate format' to 'Absolute notation'. (Spec. 8.1.1)</li> <li> <p>\u2705 G91 - Set the 'Coordinate format' to 'Incremental notation'. (Spec. 8.1.1)</p> <ul> <li>Important: Incremental notation itself is not supported and is not planned     due to lack of test assets and expected complications during implementation.</li> </ul> </li> <li> <p>\u2705 M00 - Program stop. (Spec. 8.1.1)</p> </li> <li>\u2705 M01 - Optional stop. (Spec. 8.1.1)</li> <li>\ud83d\udc7d AS - Sets the 'Axes correspondence'. (Spec. 8.1.2)</li> <li>\u2705 IN - Sets the name of the file image. (Spec. 8.1.3)</li> <li>\u2705 IP - Sets the 'Image polarity'. (Spec. 8.1.4)</li> <li>\u274c IR - Sets 'Image rotation' graphics state parameter. (Spec. 8.1.5)</li> <li>\u2705 LN - Loads a name. (Spec. 8.1.6)</li> <li>\u274c MI - Sets 'Image mirroring' graphics state parameter (Spec. 8.1.7)</li> <li>\ud83d\udc7d OF - Sets 'Image offset' graphics state parameter (Spec. 8.1.8)</li> <li>\u274c SF - Sets 'Scale factor' graphics state parameter (Spec. 8.1.9)</li> <li>\u2705 G74 - Sets single quadrant mode. (Spec. 8.1.10)</li> <li>\ud83d\udeab Format Specification (FS) Options. (Spec. 8.2.1)</li> <li>\ud83d\udeab Rectangular aperture hole in standard apertures. (Spec. 8.2.2)</li> <li>\u274c Draws and arcs wit rectangular apertures. (Spec. 8.2.3)</li> <li>\u274c Macro Primitive Code 2, Vector Line. (Spec 8.2.4)</li> <li>\u274c Macro Primitive Code 22, Lower Left Line. (Spec 8.2.5)</li> <li>\u274c Macro Primitive Code 6, Moir\u00e9. (Spec 8.2.6)</li> <li>\u2705 Combining G01/G02/G03/G70/G71 and D01 in a single command. (Spec 8.3.1)</li> <li>\u2705 Combining G01/G02/G03/G70/G71 and D02 in a single command. (Spec 8.3.1)</li> <li>\u2705 Combining G01/G02/G03/G70/G71 and D03 in a single command. (Spec 8.3.1)</li> <li>\u2705 Coordinate Data without Operation Code. (Spec 8.3.2)</li> <li>\u2705 Style Variations in Command Codes. (Spec 8.3.3)</li> <li>\u274c Deprecated usage of SR. (Spec 8.3.4)</li> <li> <p>\u274c Deprecated Attribute Values. (Spec 8.4)</p> <ul> <li>Important: Incremental notation itself is not supported and is not planned     due to lack of test assets and expected complications during implementation.</li> </ul> </li> </ul> <p>PS. I had great time adding emoji to this table.</p>"},{"location":"gerber/feature_support/parser2.html","title":"Parser feature support","text":""},{"location":"gerber/feature_support/parser2.html#introduction","title":"Introduction","text":"<p>Parser2 is an alternative implementation of Gerber AST parser redesigned to make process of implementation of Gerber features easier and quicker in addition to much better extension interface. Moreover it provides a easy way to introspect Gerber code with use of hook based interface.</p> <p>Contributing</p> <p>Community contributions are always welcome, they can speed up process of migrating from Parser to Parser2.</p> Symbol Meaning \u2705 Feature implemented and usable. \ud83d\udea7 Work in progress. Related APIs can change. \ud83d\udeab Not planned, unless contributed or needed. \u274c Not implemented, but planned. \ud83d\udc7d Partially implemented. \ud83d\udc7e Bugged. Symbol Count \u2705 116 \ud83d\udea7 0 \ud83d\udeab 4 \u274c 45 \ud83d\udc7d 39 \ud83d\udc7e 0 total 204"},{"location":"gerber/feature_support/parser2.html#supported-gerber-x3-features","title":"Supported Gerber X3 features","text":""},{"location":"gerber/feature_support/parser2.html#general","title":"General","text":"<ul> <li>\u2705 MO - Mode - Sets the unit to mm or inch.</li> <li>\u2705 FS - Format specification:<ul> <li>\u2705 absolute coordinates.</li> <li>\ud83d\udeab incremental coordinates</li> <li>\ud83d\udeab trailing zeros omission.</li> <li>\u2705 leading zeros omission.</li> </ul> </li> <li>\ud83d\udc7d AD - Aperture define - Defines a template-based aperture, assigns a D code to it.<ul> <li>\u2705 circle.</li> <li>\u2705 rectangle.</li> <li>\u2705 obround.</li> <li>\u2705 polygon.</li> <li>\u274c Define macro.</li> </ul> </li> <li>\u274c AM - Aperture macro - Defines a macro aperture template.</li> <li>\u2705 Dnn (nn\u226510) - Sets the current aperture to D code nn.</li> <li>\u2705 G01 - Sets draw mode to linear.<ul> <li>\u2705 Variable zero padding variants allowed.</li> </ul> </li> <li>\u2705 G02 - Sets draw mode to clockwise circular.<ul> <li>\u2705 Variable zero padding variants allowed.</li> </ul> </li> <li>\u2705 G03 - Sets draw mode to counterclockwise circular.<ul> <li>\u2705 Variable zero padding variants allowed.</li> </ul> </li> <li>\ud83d\udc7d LP - Load polarity (changes flag, not fully implemented).</li> <li>\ud83d\udc7d LM - Load mirroring (changes flag, not fully implemented).</li> <li>\ud83d\udc7d LR - Load rotation (changes flag, not fully implemented).</li> <li>\ud83d\udc7d LS - Load scaling (changes flag, not fully implemented).</li> <li>\u2705 TF - Attribute on file.</li> <li>\u2705 TA - Attribute on aperture.</li> <li>\u2705 TO - Attribute on object.</li> <li>\u2705 TD - Attribute delete.</li> <li>\u2705 M02 - End of file.</li> </ul>"},{"location":"gerber/feature_support/parser2.html#d01-d02-d03","title":"D01, D02, D03","text":"<ul> <li>\ud83d\udc7d D01 - Plot operation, mode<ul> <li>\ud83d\udc7d Line, with:<ul> <li>\u2705 circle,</li> <li>\ud83d\udc7d rectangle,</li> <li>\ud83d\udc7d obround,</li> <li>\ud83d\udc7d polygon,</li> <li>\u274c macro.</li> </ul> </li> <li>\ud83d\udc7d Arc, with:<ul> <li>\u2705 circle,</li> <li>\ud83d\udc7d rectangle,</li> <li>\ud83d\udc7d obround,</li> <li>\ud83d\udc7d polygon,</li> <li>\u274c macro.</li> </ul> </li> <li>\ud83d\udc7d Counter clockwise arc, with:<ul> <li>\u2705 circle,</li> <li>\ud83d\udc7d rectangle,</li> <li>\ud83d\udc7d obround,</li> <li>\ud83d\udc7d polygon,</li> <li>\u274c macro.</li> </ul> </li> <li>\u2705 Variable zero padding variants allowed.</li> </ul> </li> <li>\u2705 D02 - Move operation<ul> <li>\u2705 Variable zero padding variants allowed.</li> </ul> </li> <li>\ud83d\udc7d D03 - Flash operation, with<ul> <li>\u2705 circle,</li> <li>\u2705 rectangle,</li> <li>\u2705 obround,</li> <li>\u2705 polygon,</li> <li>\u274c macro.</li> <li>\u2705 Variable zero padding variants allowed.</li> </ul> </li> </ul>"},{"location":"gerber/feature_support/parser2.html#regions","title":"Regions","text":"<ul> <li>\u2705 G36 - Starts a region statement.</li> <li>\u2705 G37 - Ends the region statement.</li> <li>\ud83d\udc7d Regions, with:<ul> <li>\ud83d\udc7d Line, aperture:<ul> <li>\u2705 circle,</li> <li>\u2705 rectangle,</li> <li>\u2705 obround,</li> <li>\u2705 polygon,</li> <li>\u274c macro.</li> </ul> </li> <li>\ud83d\udc7d Arc, aperture:<ul> <li>\u2705 circle,</li> <li>\u2705 rectangle,</li> <li>\u2705 obround,</li> <li>\u2705 polygon,</li> <li>\u274c macro.</li> </ul> </li> <li>\ud83d\udc7d Counter clockwise arc, aperture:<ul> <li>\u2705 circle,</li> <li>\u2705 rectangle,</li> <li>\u2705 obround,</li> <li>\u2705 polygon,</li> <li>\u274c macro.</li> </ul> </li> </ul> </li> </ul>"},{"location":"gerber/feature_support/parser2.html#macros","title":"Macros","text":"<ul> <li>\u2705 Parameters.</li> <li>\ud83d\udc7d Primitives in definition:<ul> <li>\u2705 Code 1, Circle</li> <li>\u274c Code 2, Vector line</li> <li>\u2705 Code 4, Outline</li> <li>\u2705 Code 5, Polygon</li> <li>\u274c Code 6, Moire</li> <li>\u2705 Code 7, Thermal</li> <li>\u2705 Code 20, Vector line</li> <li>\u2705 Code 21, Center Line</li> <li>\u274c Code 22, Lower Left Line</li> </ul> </li> <li>\ud83d\udc7d Primitives in aperture instance:<ul> <li>\u2705 Code 1, Circle</li> <li>\u274c Code 2, Vector line</li> <li>\u2705 Code 4, Outline</li> <li>\u2705 Code 5, Polygon</li> <li>\u274c Code 6, Moire</li> <li>\u274c Code 7, Thermal</li> <li>\u2705 Code 20, Vector line</li> <li>\u2705 Code 21, Center Line</li> <li>\u274c Code 22, Lower Left Line</li> </ul> </li> <li>\u274c Rotation around macro origin:<ul> <li>\u274c Code 1, Circle</li> <li>\u274c Code 2, Vector line</li> <li>\u274c Code 4, Outline</li> <li>\u274c Code 5, Polygon</li> <li>\u274c Code 6, Moire</li> <li>\u274c Code 7, Thermal</li> <li>\u274c Code 20, Vector line</li> <li>\u274c Code 21, Center Line</li> <li>\u274c Code 22, Lower Left Line</li> </ul> </li> <li>\u2705 Expressions.<ul> <li>\u2705 Constants.</li> <li>\u2705 Variables.</li> <li>\u2705 Addition.</li> <li>\u2705 Subtraction.</li> <li>\u2705 Multiplication.</li> <li>\u2705 Division.</li> <li>\u2705 Unary + operator.</li> <li>\u2705 Negation.</li> </ul> </li> <li>\u2705 Variable definitions.</li> </ul>"},{"location":"gerber/feature_support/parser2.html#aperture-blocks","title":"Aperture blocks","text":"<ul> <li>\ud83d\udc7d Nested Line, aperture:<ul> <li>\u2705 circle,</li> <li>\u2705 rectangle,</li> <li>\u2705 obround,</li> <li>\u2705 polygon,</li> <li>\u274c macro.</li> </ul> </li> <li>\ud83d\udc7d Nested Arc, aperture:<ul> <li>\u2705 circle,</li> <li>\u2705 rectangle,</li> <li>\u2705 obround,</li> <li>\u2705 polygon,</li> <li>\u274c macro.</li> </ul> </li> <li>\ud83d\udc7d Nested Counter clockwise arc, aperture:<ul> <li>\u2705 circle,</li> <li>\u2705 rectangle,</li> <li>\u2705 obround,</li> <li>\u2705 polygon,</li> <li>\u274c macro.</li> </ul> </li> <li>\ud83d\udc7d Nested Flash:<ul> <li>\u2705 circle,</li> <li>\u2705 rectangle,</li> <li>\u2705 obround,</li> <li>\u2705 polygon,</li> <li>\u274c macro.</li> </ul> </li> <li>\ud83d\udc7d Nested regions (missing macro support).</li> </ul>"},{"location":"gerber/feature_support/parser2.html#step-and-repeat","title":"Step and repeat","text":"<ul> <li>\ud83d\udc7d Nested Line, aperture:<ul> <li>\u2705 circle,</li> <li>\u2705 rectangle,</li> <li>\u2705 obround,</li> <li>\u2705 polygon,</li> <li>\u274c macro.</li> </ul> </li> <li>\ud83d\udc7d Nested Arc, aperture:<ul> <li>\u2705 circle,</li> <li>\u2705 rectangle,</li> <li>\u2705 obround,</li> <li>\u2705 polygon,</li> <li>\u274c macro.</li> </ul> </li> <li>\ud83d\udc7d Nested Counter clockwise arc, aperture:<ul> <li>\u2705 circle,</li> <li>\u2705 rectangle,</li> <li>\u2705 obround,</li> <li>\u2705 polygon,</li> <li>\u274c macro.</li> </ul> </li> <li>\ud83d\udc7d Nested Flash:<ul> <li>\u2705 circle,</li> <li>\u2705 rectangle,</li> <li>\u2705 obround,</li> <li>\u2705 polygon,</li> <li>\u274c macro.</li> </ul> </li> <li>\ud83d\udc7d Nested regions (missing macro support).</li> <li>\ud83d\udc7d Nested blocks (missing macro support).</li> </ul>"},{"location":"gerber/feature_support/parser2.html#supported-deprecated-gerber-features","title":"Supported DEPRECATED Gerber features","text":"<ul> <li>\ud83d\udc7d G54 - Select aperture. (Spec. 8.1.1)</li> <li>\u274c G55 - Prepare for flash. (Spec. 8.1.1)</li> <li>\u2705 G70 - Set the 'Unit' to inch. (Spec. 8.1.1)</li> <li>\u2705 G71 - Set the 'Unit' to mm. (Spec. 8.1.1)</li> <li>\u2705 G90 - Set the 'Coordinate format' to 'Absolute notation'. (Spec. 8.1.1)</li> <li> <p>\u2705 G91 - Set the 'Coordinate format' to 'Incremental notation'. (Spec. 8.1.1)</p> <ul> <li>Important: Incremental notation itself is not supported and is not planned     due to lack of test assets and expected complications during implementation.</li> </ul> </li> <li> <p>\u2705 M00 - Program stop. (Spec. 8.1.1)</p> </li> <li>\u2705 M01 - Optional stop. (Spec. 8.1.1)</li> <li>\ud83d\udc7d AS - Sets the 'Axes correspondence'. (Spec. 8.1.2)</li> <li>\u2705 IN - Sets the name of the file image. (Spec. 8.1.3)</li> <li>\u2705 IP - Sets the 'Image polarity'. (Spec. 8.1.4)</li> <li>\u274c IR - Sets 'Image rotation' graphics state parameter. (Spec. 8.1.5)</li> <li>\u2705 LN - Loads a name. (Spec. 8.1.6)</li> <li>\u274c MI - Sets 'Image mirroring' graphics state parameter (Spec. 8.1.7)</li> <li>\ud83d\udc7d OF - Sets 'Image offset' graphics state parameter (Spec. 8.1.8)</li> <li>\u274c SF - Sets 'Scale factor' graphics state parameter (Spec. 8.1.9)</li> <li>\u2705 G74 - Sets single quadrant mode. (Spec. 8.1.10)</li> <li>\ud83d\udeab Format Specification (FS) Options. (Spec. 8.2.1)</li> <li>\ud83d\udeab Rectangular aperture hole in standard apertures. (Spec. 8.2.2)</li> <li>\u274c Draws and arcs wit rectangular apertures. (Spec. 8.2.3)</li> <li>\u274c Macro Primitive Code 2, Vector Line. (Spec 8.2.4)</li> <li>\u274c Macro Primitive Code 22, Lower Left Line. (Spec 8.2.5)</li> <li>\u274c Macro Primitive Code 6, Moir\u00e9. (Spec 8.2.6)</li> <li>\u2705 Combining G01/G02/G03/G70/G71 and D01 in a single command. (Spec 8.3.1)</li> <li>\u2705 Combining G01/G02/G03/G70/G71 and D02 in a single command. (Spec 8.3.1)</li> <li>\u2705 Combining G01/G02/G03/G70/G71 and D03 in a single command. (Spec 8.3.1)</li> <li>\u2705 Coordinate Data without Operation Code. (Spec 8.3.2)</li> <li>\u2705 Style Variations in Command Codes. (Spec 8.3.3)</li> <li>\u274c Deprecated usage of SR. (Spec 8.3.4)</li> <li> <p>\u274c Deprecated Attribute Values. (Spec 8.4)</p> <ul> <li>Important: Incremental notation itself is not supported and is not planned     due to lack of test assets and expected complications during implementation.</li> </ul> </li> </ul> <p>PS. I had great time adding emoji to this table.</p>"},{"location":"gerber/feature_support/rasterized_2d.html","title":"Rasterized2DBackend feature support","text":""},{"location":"gerber/feature_support/rasterized_2d.html#introduction","title":"Introduction","text":"<p>Rasterized2DBackend is a rendering engine for rendering 2D rasterized images from Gerber files. It is compatible only with Parser class (incompatible with Parser2 class).</p> <p>Contributing</p> <p>Community contributions are always welcome, they can speed up process of implementing rendering backend for Parser2, as well as vector rendering and 3D model generation backends.</p> Symbol Meaning \u2705 Feature implemented and usable. \ud83d\udea7 Work in progress. Related APIs can change. \ud83d\udeab Not planned, unless contributed or needed. \u274c Not implemented, but planned. \ud83d\udc7d Partially implemented. \ud83d\udc7e Bugged. \u26d4 Feature doesn't apply. Symbol Count \u2705 169 \ud83d\udea7 0 \ud83d\udeab 2 \u274c 7 \ud83d\udc7d 2 \ud83d\udc7e 0 total 185"},{"location":"gerber/feature_support/rasterized_2d.html#supported-gerber-x3-features","title":"Supported Gerber X3 features","text":""},{"location":"gerber/feature_support/rasterized_2d.html#general","title":"General","text":"<ul> <li>\u26d4 MO - Mode - Sets the unit to mm or inch.</li> <li>\u26d4 FS - Format specification:<ul> <li>\u26d4 absolute coordinates.</li> <li>\u26d4 incremental coordinates</li> <li>\u26d4 trailing zeros omission.</li> <li>\u26d4 leading zeros omission.</li> </ul> </li> <li>\u26d4 AD - Aperture define - Defines a template-based aperture, assigns a D code to it.<ul> <li>\u26d4 circle.</li> <li>\u26d4 rectangle.</li> <li>\u26d4 obround.</li> <li>\u26d4 polygon.</li> <li>\u26d4 Define macro.</li> </ul> </li> <li>\u26d4 AM - Aperture macro - Defines a macro aperture template.</li> <li>\u26d4 Dnn (nn\u226510) - Sets the current aperture to D code nn.</li> <li>\u26d4 G01 - Sets draw mode to linear.<ul> <li>\u26d4 Variable zero padding variants allowed.</li> </ul> </li> <li>\u26d4 G02 - Sets draw mode to clockwise circular.<ul> <li>\u26d4 Variable zero padding variants allowed.</li> </ul> </li> <li>\u26d4 G03 - Sets draw mode to counterclockwise circular.<ul> <li>\u26d4 Variable zero padding variants allowed.</li> </ul> </li> <li>\u274c LP - Load polarity (changes flag, not fully implemented).</li> <li>\u274c LM - Load mirroring (changes flag, not fully implemented).</li> <li>\u274c LR - Load rotation (changes flag, not fully implemented).</li> <li>\u274c LS - Load scaling (changes flag, not fully implemented).</li> <li>\u26d4 TF - Attribute on file.</li> <li>\u26d4 TA - Attribute on aperture.</li> <li>\u26d4 TO - Attribute on object.</li> <li>\u26d4 TD - Attribute delete.</li> <li>\u26d4 M02 - End of file.</li> </ul>"},{"location":"gerber/feature_support/rasterized_2d.html#d01-d02-d03","title":"D01, D02, D03","text":"<ul> <li>\ud83d\udc7d D01 - Plot operation, mode<ul> <li>\ud83d\udc7d Line, with:<ul> <li>\u2705 circle,</li> <li>\ud83d\udc7d rectangle,</li> <li>\ud83d\udc7d obround,</li> <li>\ud83d\udc7d polygon,</li> <li>\u274c macro.</li> </ul> </li> <li>\ud83d\udc7e Arc, with:<ul> <li>\ud83d\udc7e circle,</li> <li>\ud83d\udc7d rectangle,</li> <li>\ud83d\udc7d obround,</li> <li>\ud83d\udc7d polygon,</li> <li>\u274c macro.</li> </ul> </li> <li>\ud83d\udc7e Counter clockwise arc, with:<ul> <li>\ud83d\udc7e circle,</li> <li>\ud83d\udc7d rectangle,</li> <li>\ud83d\udc7d obround,</li> <li>\ud83d\udc7d polygon,</li> <li>\u274c macro.</li> </ul> </li> <li>\u26d4 Variable zero padding variants allowed.</li> </ul> </li> <li>\u26d4 D02 - Move operation<ul> <li>\u26d4 Variable zero padding variants allowed.</li> </ul> </li> <li>\ud83d\udc7d D03 - Flash operation, with<ul> <li>\u2705 circle,</li> <li>\u2705 rectangle,</li> <li>\u2705 obround,</li> <li>\u2705 polygon,</li> <li>\u274c macro.</li> <li>\u26d4 Variable zero padding variants allowed.</li> </ul> </li> </ul>"},{"location":"gerber/feature_support/rasterized_2d.html#regions","title":"Regions","text":"<ul> <li>\u2705 G36 - Starts a region statement.</li> <li>\u2705 G37 - Ends the region statement.</li> <li>\ud83d\udc7d Regions, with:<ul> <li>\ud83d\udc7d Line, aperture:<ul> <li>\u2705 circle,</li> <li>\u2705 rectangle,</li> <li>\u2705 obround,</li> <li>\u2705 polygon,</li> <li>\u274c macro.</li> </ul> </li> <li>\ud83d\udc7d Arc, aperture:<ul> <li>\u2705 circle,</li> <li>\u2705 rectangle,</li> <li>\u2705 obround,</li> <li>\u2705 polygon,</li> <li>\u274c macro.</li> </ul> </li> <li>\ud83d\udc7d Counter clockwise arc, aperture:<ul> <li>\u2705 circle,</li> <li>\u2705 rectangle,</li> <li>\u2705 obround,</li> <li>\u2705 polygon,</li> <li>\u274c macro.</li> </ul> </li> </ul> </li> </ul>"},{"location":"gerber/feature_support/rasterized_2d.html#macros","title":"Macros","text":"<ul> <li>\u26d4 Parameters.</li> <li>\u274c Primitives:<ul> <li>\u274c Code 0, Comment</li> <li>\u274c Code 1, Circle</li> <li>\u274c Code 20, Vector line</li> <li>\u274c Code 21, Center Line</li> <li>\u274c Code 4, Outline</li> <li>\u274c Code 5, Polygon</li> <li>\u274c Code 7, Thermal</li> </ul> </li> <li>\u274c Rotation around macro origin:<ul> <li>\u274c Code 0, Comment</li> <li>\u274c Code 1, Circle</li> <li>\u274c Code 20, Vector line</li> <li>\u274c Code 21, Center Line</li> <li>\u274c Code 4, Outline</li> <li>\u274c Code 5, Polygon</li> <li>\u274c Code 7, Thermal</li> </ul> </li> <li>\u26d4 Constants.</li> <li>\u26d4 Variables.</li> <li>\u26d4 Variable definitions.</li> </ul>"},{"location":"gerber/feature_support/rasterized_2d.html#aperture-blocks","title":"Aperture blocks","text":"<ul> <li>\u274c Nested Line, aperture:<ul> <li>\u274c circle,</li> <li>\u274c rectangle,</li> <li>\u274c obround,</li> <li>\u274c polygon,</li> <li>\u274c macro.</li> </ul> </li> <li>\u274c Nested Arc, aperture:<ul> <li>\u274c circle,</li> <li>\u274c rectangle,</li> <li>\u274c obround,</li> <li>\u274c polygon,</li> <li>\u274c macro.</li> </ul> </li> <li>\u274c Nested Counter clockwise arc, aperture:<ul> <li>\u274c circle,</li> <li>\u274c rectangle,</li> <li>\u274c obround,</li> <li>\u274c polygon,</li> <li>\u274c macro.</li> </ul> </li> <li>\u274c Nested Flash:<ul> <li>\u274c circle,</li> <li>\u274c rectangle,</li> <li>\u274c obround,</li> <li>\u274c polygon,</li> <li>\u274c macro.</li> </ul> </li> <li>\u274c Nested regions (missing macro support).</li> </ul>"},{"location":"gerber/feature_support/rasterized_2d.html#step-and-repeat","title":"Step and repeat","text":"<ul> <li>\u274c Nested Line, aperture:<ul> <li>\u274c circle,</li> <li>\u274c rectangle,</li> <li>\u274c obround,</li> <li>\u274c polygon,</li> <li>\u274c macro.</li> </ul> </li> <li>\u274c Nested Arc, aperture:<ul> <li>\u274c circle,</li> <li>\u274c rectangle,</li> <li>\u274c obround,</li> <li>\u274c polygon,</li> <li>\u274c macro.</li> </ul> </li> <li>\u274c Nested Counter clockwise arc, aperture:<ul> <li>\u274c circle,</li> <li>\u274c rectangle,</li> <li>\u274c obround,</li> <li>\u274c polygon,</li> <li>\u274c macro.</li> </ul> </li> <li>\u274c Nested Flash:<ul> <li>\u274c circle,</li> <li>\u274c rectangle,</li> <li>\u274c obround,</li> <li>\u274c polygon,</li> <li>\u274c macro.</li> </ul> </li> <li>\u274c Nested regions (missing macro support).</li> <li>\u274c Nested blocks (missing macro support).</li> </ul>"},{"location":"gerber/feature_support/rasterized_2d.html#supported-deprecated-gerber-features","title":"Supported DEPRECATED Gerber features","text":"<ul> <li>\u26d4 G54 - Select aperture. (Spec. 8.1.1)</li> <li>\u26d4 G55 - Prepare for flash. (Spec. 8.1.1)</li> <li>\u26d4 G70 - Set the 'Unit' to inch. (Spec. 8.1.1)</li> <li>\u26d4 G71 - Set the 'Unit' to mm. (Spec. 8.1.1)</li> <li>\u26d4 G90 - Set the 'Coordinate format' to 'Absolute notation'. (Spec. 8.1.1)</li> <li> <p>\u26d4 G91 - Set the 'Coordinate format' to 'Incremental notation'. (Spec. 8.1.1)</p> <ul> <li>Important: Incremental notation itself is not supported and is not planned     due to lack of test assets and expected complications during implementation.</li> </ul> </li> <li> <p>\u26d4 M00 - Program stop. (Spec. 8.1.1)</p> </li> <li>\u26d4 M01 - Optional stop. (Spec. 8.1.1)</li> <li>\u26d4 AS - Sets the 'Axes correspondence'. (Spec. 8.1.2)</li> <li>\u26d4 IN - Sets the name of the file image. (Spec. 8.1.3)</li> <li>\u26d4 IP - Sets the 'Image polarity'. (Spec. 8.1.4)</li> <li>\u274c IR - Sets 'Image rotation' graphics state parameter. (Spec. 8.1.5)</li> <li>\u26d4 LN - Loads a name. (Spec. 8.1.6)</li> <li>\u274c MI - Sets 'Image mirroring' graphics state parameter (Spec. 8.1.7)</li> <li>\u274c OF - Sets 'Image offset' graphics state parameter (Spec. 8.1.8)</li> <li>\u274c SF - Sets 'Scale factor' graphics state parameter (Spec. 8.1.9)</li> <li>\ud83d\udc7e G74 - Sets single quadrant mode. (Spec. 8.1.10)</li> <li>\ud83d\udeab Format Specification (FS) Options. (Spec. 8.2.1)</li> <li>\ud83d\udeab Rectangular aperture hole in standard apertures. (Spec. 8.2.2)</li> <li>\ud83d\udc7e Draws and arcs wit rectangular apertures. (Spec. 8.2.3)</li> <li>\u274c Macro Primitive Code 2, Vector Line. (Spec 8.2.4)</li> <li>\u274c Macro Primitive Code 22, Lower Left Line. (Spec 8.2.5)</li> <li>\u274c Macro Primitive Code 6, Moir\u00e9. (Spec 8.2.6)</li> <li>\u2705 Combining G01/G02/G03/G70/G71 and D01 in a single command. (Spec 8.3.1)</li> <li>\u2705 Combining G01/G02/G03/G70/G71 and D02 in a single command. (Spec 8.3.1)</li> <li>\u2705 Combining G01/G02/G03/G70/G71 and D03 in a single command. (Spec 8.3.1)</li> <li>\u26d4 Coordinate Data without Operation Code. (Spec 8.3.2)</li> <li>\u26d4 Style Variations in Command Codes. (Spec 8.3.3)</li> <li>\u274c Deprecated usage of SR. (Spec 8.3.4)</li> <li> <p>\u274c Deprecated Attribute Values. (Spec 8.4)</p> <ul> <li>Important: Incremental notation itself is not supported and is not planned     due to lack of test assets and expected complications during implementation.</li> </ul> </li> </ul> <p>PS. I had great time adding emoji to this table.</p>"},{"location":"gerber/feature_support/svgrenderer2.html","title":"SvgRenderer2 feature support","text":""},{"location":"gerber/feature_support/svgrenderer2.html#introduction","title":"Introduction","text":"<p><code>SvgRenderer2</code> is an experimental SVG backend for rendering of Gerber files. It operates on command buffers generated by <code>Parser2</code>.</p> Symbol Meaning \u2705 Feature implemented and usable. \ud83d\udea7 Work in progress. Related APIs can change. \ud83d\udeab Not planned, unless contributed or needed. \u274c Not implemented, but planned. \ud83d\udc7d Partially implemented. \ud83d\udc7e Bugged. \u26d4 Feature doesn't apply. Symbol Count \u2705 169 \ud83d\udea7 0 \ud83d\udeab 2 \u274c 7 \ud83d\udc7d 2 \ud83d\udc7e 0 total 185"},{"location":"gerber/feature_support/svgrenderer2.html#supported-gerber-x3-features","title":"Supported Gerber X3 features","text":""},{"location":"gerber/feature_support/svgrenderer2.html#general","title":"General","text":"<ul> <li>\u26d4 MO - Mode - Sets the unit to mm or inch.</li> <li>\u26d4 FS - Format specification:<ul> <li>\u26d4 absolute coordinates.</li> <li>\u26d4 incremental coordinates</li> <li>\u26d4 trailing zeros omission.</li> <li>\u26d4 leading zeros omission.</li> </ul> </li> <li>\u26d4 AD - Aperture define - Defines a template-based aperture, assigns a D code to it.<ul> <li>\u26d4 circle.</li> <li>\u26d4 rectangle.</li> <li>\u26d4 obround.</li> <li>\u26d4 polygon.</li> <li>\u26d4 Define macro.</li> </ul> </li> <li>\u26d4 AM - Aperture macro - Defines a macro aperture template.</li> <li>\u26d4 Dnn (nn\u226510) - Sets the current aperture to D code nn.</li> <li>\u26d4 G01 - Sets draw mode to linear.<ul> <li>\u26d4 Variable zero padding variants allowed.</li> </ul> </li> <li>\u26d4 G02 - Sets draw mode to clockwise circular.<ul> <li>\u26d4 Variable zero padding variants allowed.</li> </ul> </li> <li>\u26d4 G03 - Sets draw mode to counterclockwise circular.<ul> <li>\u26d4 Variable zero padding variants allowed.</li> </ul> </li> <li>\u274c LP - Load polarity (changes flag, not fully implemented).</li> <li>\u274c LM - Load mirroring (changes flag, not fully implemented).</li> <li>\u274c LR - Load rotation (changes flag, not fully implemented).</li> <li>\u274c LS - Load scaling (changes flag, not fully implemented).</li> <li>\u26d4 TF - Attribute on file.</li> <li>\u26d4 TA - Attribute on aperture.</li> <li>\u26d4 TO - Attribute on object.</li> <li>\u26d4 TD - Attribute delete.</li> <li>\u26d4 M02 - End of file.</li> </ul>"},{"location":"gerber/feature_support/svgrenderer2.html#d01-d02-d03","title":"D01, D02, D03","text":"<ul> <li>\ud83d\udc7d D01 - Plot operation, mode<ul> <li>\ud83d\udc7d Line, with:<ul> <li>\u2705 circle,</li> <li>\ud83d\udc7d rectangle,</li> <li>\ud83d\udc7d obround,</li> <li>\ud83d\udc7d polygon,</li> <li>\ud83d\udc7d macro.</li> </ul> </li> <li>\ud83d\udc7e Arc, with:<ul> <li>\ud83d\udc7e circle,</li> <li>\ud83d\udc7d rectangle,</li> <li>\ud83d\udc7d obround,</li> <li>\ud83d\udc7d polygon,</li> <li>\ud83d\udc7d macro.</li> </ul> </li> <li>\ud83d\udc7e Counter clockwise arc, with:<ul> <li>\ud83d\udc7e circle,</li> <li>\ud83d\udc7d rectangle,</li> <li>\ud83d\udc7d obround,</li> <li>\ud83d\udc7d polygon,</li> <li>\ud83d\udc7d macro.</li> </ul> </li> <li>\u26d4 Variable zero padding variants allowed.</li> </ul> </li> <li>\u26d4 D02 - Move operation<ul> <li>\u26d4 Variable zero padding variants allowed.</li> </ul> </li> <li>\ud83d\udc7d D03 - Flash operation, with<ul> <li>\u2705 circle,</li> <li>\u2705 rectangle,</li> <li>\u2705 obround,</li> <li>\u2705 polygon,</li> <li>\ud83d\udc7d macro.</li> <li>\u26d4 Variable zero padding variants allowed.</li> </ul> </li> </ul>"},{"location":"gerber/feature_support/svgrenderer2.html#regions","title":"Regions","text":"<ul> <li>\u2705 G36 - Starts a region statement.</li> <li>\u2705 G37 - Ends the region statement.</li> <li>\ud83d\udc7d Regions, with:<ul> <li>\ud83d\udc7d Line, aperture:<ul> <li>\u2705 circle,</li> <li>\u2705 rectangle,</li> <li>\u2705 obround,</li> <li>\u2705 polygon,</li> <li>\ud83d\udc7d macro.</li> </ul> </li> <li>\ud83d\udc7d Arc, aperture:<ul> <li>\u2705 circle,</li> <li>\u2705 rectangle,</li> <li>\u2705 obround,</li> <li>\u2705 polygon,</li> <li>\ud83d\udc7d macro.</li> </ul> </li> <li>\ud83d\udc7d Counter clockwise arc, aperture:<ul> <li>\u2705 circle,</li> <li>\u2705 rectangle,</li> <li>\u2705 obround,</li> <li>\u2705 polygon,</li> <li>\ud83d\udc7d macro.</li> </ul> </li> </ul> </li> </ul>"},{"location":"gerber/feature_support/svgrenderer2.html#macros","title":"Macros","text":"<ul> <li>\u26d4 Parameters.</li> <li>\ud83d\udc7d Primitives in definition:<ul> <li>\u2705 Code 1, Circle</li> <li>\u274c Code 2, Vector line</li> <li>\u2705 Code 4, Outline</li> <li>\u2705 Code 5, Polygon</li> <li>\u274c Code 6, Moire</li> <li>\u2705 Code 7, Thermal</li> <li>\u2705 Code 20, Vector line</li> <li>\u2705 Code 21, Center Line</li> <li>\u274c Code 22, Lower Left Line</li> </ul> </li> <li>\ud83d\udc7d Primitives in aperture instance:<ul> <li>\u2705 Code 1, Circle</li> <li>\u274c Code 2, Vector line</li> <li>\u2705 Code 4, Outline</li> <li>\u2705 Code 5, Polygon</li> <li>\u274c Code 6, Moire</li> <li>\u274c Code 7, Thermal</li> <li>\u2705 Code 20, Vector line</li> <li>\u2705 Code 21, Center Line</li> <li>\u274c Code 22, Lower Left Line</li> </ul> </li> <li>\u274c Rotation around macro origin:<ul> <li>\u274c Code 1, Circle</li> <li>\u274c Code 2, Vector line</li> <li>\u274c Code 4, Outline</li> <li>\u274c Code 5, Polygon</li> <li>\u274c Code 6, Moire</li> <li>\u274c Code 7, Thermal</li> <li>\u274c Code 20, Vector line</li> <li>\u274c Code 21, Center Line</li> <li>\u274c Code 22, Lower Left Line</li> </ul> </li> <li>\u26d4 Expressions.<ul> <li>\u26d4 Constants.</li> <li>\u26d4 Variables.</li> <li>\u26d4 Addition.</li> <li>\u26d4 Subtraction.</li> <li>\u26d4 Multiplication.</li> <li>\u26d4 Division.</li> <li>\u26d4 Unary + operator.</li> <li>\u26d4 Negation.</li> </ul> </li> <li>\u26d4 Variable definitions.</li> </ul>"},{"location":"gerber/feature_support/svgrenderer2.html#aperture-blocks","title":"Aperture blocks","text":"<ul> <li>\ud83d\udc7d Nested Line, aperture:<ul> <li>\u2705 circle,</li> <li>\u2705 rectangle,</li> <li>\u2705 obround,</li> <li>\u2705 polygon,</li> <li>\ud83d\udc7d macro.</li> </ul> </li> <li>\ud83d\udc7d Nested Arc, aperture:<ul> <li>\u2705 circle,</li> <li>\u2705 rectangle,</li> <li>\u2705 obround,</li> <li>\u2705 polygon,</li> <li>\ud83d\udc7d macro.</li> </ul> </li> <li>\ud83d\udc7d Nested Counter clockwise arc, aperture:<ul> <li>\u2705 circle,</li> <li>\u2705 rectangle,</li> <li>\u2705 obround,</li> <li>\u2705 polygon,</li> <li>\ud83d\udc7d macro.</li> </ul> </li> <li>\ud83d\udc7d Nested Flash:<ul> <li>\u2705 circle,</li> <li>\u2705 rectangle,</li> <li>\u2705 obround,</li> <li>\u2705 polygon,</li> <li>\ud83d\udc7d macro.</li> </ul> </li> <li>\ud83d\udc7d Nested regions (partial macro support).</li> </ul>"},{"location":"gerber/feature_support/svgrenderer2.html#step-and-repeat","title":"Step and repeat","text":"<ul> <li>\ud83d\udc7d Nested Line, aperture:<ul> <li>\u2705 circle,</li> <li>\u2705 rectangle,</li> <li>\u2705 obround,</li> <li>\u2705 polygon,</li> <li>\ud83d\udc7d macro.</li> </ul> </li> <li>\ud83d\udc7d Nested Arc, aperture:<ul> <li>\u2705 circle,</li> <li>\u2705 rectangle,</li> <li>\u2705 obround,</li> <li>\u2705 polygon,</li> <li>\ud83d\udc7d macro.</li> </ul> </li> <li>\ud83d\udc7d Nested Counter clockwise arc, aperture:<ul> <li>\u2705 circle,</li> <li>\u2705 rectangle,</li> <li>\u2705 obround,</li> <li>\u2705 polygon,</li> <li>\ud83d\udc7d macro.</li> </ul> </li> <li>\ud83d\udc7d Nested Flash:<ul> <li>\u2705 circle,</li> <li>\u2705 rectangle,</li> <li>\u2705 obround,</li> <li>\u2705 polygon,</li> <li>\ud83d\udc7d macro.</li> </ul> </li> <li>\ud83d\udc7d Nested regions (partial macro support).</li> <li>\ud83d\udc7d Nested blocks (partial macro support).</li> </ul>"},{"location":"gerber/feature_support/svgrenderer2.html#supported-deprecated-gerber-features","title":"Supported DEPRECATED Gerber features","text":"<ul> <li>\u26d4 G54 - Select aperture. (Spec. 8.1.1)</li> <li>\u26d4 G55 - Prepare for flash. (Spec. 8.1.1)</li> <li>\u26d4 G70 - Set the 'Unit' to inch. (Spec. 8.1.1)</li> <li>\u26d4 G71 - Set the 'Unit' to mm. (Spec. 8.1.1)</li> <li>\u26d4 G90 - Set the 'Coordinate format' to 'Absolute notation'. (Spec. 8.1.1)</li> <li> <p>\u26d4 G91 - Set the 'Coordinate format' to 'Incremental notation'. (Spec. 8.1.1)</p> <ul> <li>Important: Incremental notation itself is not supported and is not planned     due to lack of test assets and expected complications during implementation.</li> </ul> </li> <li> <p>\u26d4 M00 - Program stop. (Spec. 8.1.1)</p> </li> <li>\u26d4 M01 - Optional stop. (Spec. 8.1.1)</li> <li>\u26d4 AS - Sets the 'Axes correspondence'. (Spec. 8.1.2)</li> <li>\u26d4 IN - Sets the name of the file image. (Spec. 8.1.3)</li> <li>\u26d4 IP - Sets the 'Image polarity'. (Spec. 8.1.4)</li> <li>\u274c IR - Sets 'Image rotation' graphics state parameter. (Spec. 8.1.5)</li> <li>\u26d4 LN - Loads a name. (Spec. 8.1.6)</li> <li>\u274c MI - Sets 'Image mirroring' graphics state parameter (Spec. 8.1.7)</li> <li>\u274c OF - Sets 'Image offset' graphics state parameter (Spec. 8.1.8)</li> <li>\u274c SF - Sets 'Scale factor' graphics state parameter (Spec. 8.1.9)</li> <li>\u2705 G74 - Sets single quadrant mode. (Spec. 8.1.10)</li> <li>\ud83d\udeab Format Specification (FS) Options. (Spec. 8.2.1)</li> <li>\ud83d\udeab Rectangular aperture hole in standard apertures. (Spec. 8.2.2)</li> <li>\ud83d\udc7d Draws and arcs wit rectangular apertures. (Spec. 8.2.3)</li> <li>\u274c Macro Primitive Code 2, Vector Line. (Spec 8.2.4)</li> <li>\u274c Macro Primitive Code 22, Lower Left Line. (Spec 8.2.5)</li> <li>\u274c Macro Primitive Code 6, Moir\u00e9. (Spec 8.2.6)</li> <li>\u2705 Combining G01/G02/G03/G70/G71 and D01 in a single command. (Spec 8.3.1)</li> <li>\u2705 Combining G01/G02/G03/G70/G71 and D02 in a single command. (Spec 8.3.1)</li> <li>\u2705 Combining G01/G02/G03/G70/G71 and D03 in a single command. (Spec 8.3.1)</li> <li>\u26d4 Coordinate Data without Operation Code. (Spec 8.3.2)</li> <li>\u26d4 Style Variations in Command Codes. (Spec 8.3.3)</li> <li>\u274c Deprecated usage of SR. (Spec 8.3.4)</li> <li> <p>\u274c Deprecated Attribute Values. (Spec 8.4)</p> <ul> <li>Important: Incremental notation itself is not supported and is not planned     due to lack of test assets and expected complications during implementation.</li> </ul> </li> </ul> <p>PS. I had great time adding emoji to this table.</p>"},{"location":"gerber/feature_support/tokenizer.html","title":"Tokenizer feature support","text":""},{"location":"gerber/feature_support/tokenizer.html#introduction","title":"Introduction","text":"<p>Tokenizer class is responsible for converting input Gerber string into sequence of tokens suitable for consumption by Parser class. Tokenizer class is compatible with both Parser and Parser2 classes.</p> <p>Contributing</p> <p>Community contributions are always welcome.</p> Symbol Meaning \u2705 Feature implemented and usable. \ud83d\udea7 Work in progress. Related APIs can change. \ud83d\udeab Not planned, unless contributed or needed. \u274c Not implemented, but planned. \ud83d\udc7d Partially implemented. \ud83d\udc7e Bugged. - - Symbol Count \u2705 169 \ud83d\udea7 0 \ud83d\udeab 2 \u274c 7 \ud83d\udc7d 2 \ud83d\udc7e 0 total 185"},{"location":"gerber/feature_support/tokenizer.html#supported-gerber-x3-features","title":"Supported Gerber X3 features","text":""},{"location":"gerber/feature_support/tokenizer.html#general","title":"General","text":"<ul> <li>\u2705 MO - Mode - Sets the unit to mm or inch.</li> <li>\u2705 FS - Format specification:<ul> <li>\u2705 absolute coordinates.</li> <li>\u2705 incremental coordinates</li> <li>\u2705 trailing zeros omission.</li> <li>\u2705 leading zeros omission.</li> </ul> </li> <li>\u2705 AD - Aperture define - Defines a template-based aperture, assigns a D code to it.<ul> <li>\u2705 circle.</li> <li>\u2705 rectangle.</li> <li>\u2705 obround.</li> <li>\u2705 polygon.</li> <li>\u2705 Define macro.</li> </ul> </li> <li>\u2705 AM - Aperture macro - Defines a macro aperture template.</li> <li>\u2705 Dnn (nn\u226510) - Sets the current aperture to D code nn.</li> <li>\u2705 G01 - Sets draw mode to linear.<ul> <li>\u2705 Variable zero padding variants allowed.</li> </ul> </li> <li>\u2705 G02 - Sets draw mode to clockwise circular.<ul> <li>\u2705 Variable zero padding variants allowed.</li> </ul> </li> <li>\u2705 G03 - Sets draw mode to counterclockwise circular.<ul> <li>\u2705 Variable zero padding variants allowed.</li> </ul> </li> <li>\u2705 LP - Load polarity (changes flag, not fully implemented).</li> <li>\u2705 LM - Load mirroring (changes flag, not fully implemented).</li> <li>\u2705 LR - Load rotation (changes flag, not fully implemented).</li> <li>\u2705 LS - Load scaling (changes flag, not fully implemented).</li> <li>\u2705 TF - Attribute on file.</li> <li>\u2705 TA - Attribute on aperture.</li> <li>\u2705 TO - Attribute on object.</li> <li>\u2705 TD - Attribute delete.</li> <li>\u2705 M02 - End of file.</li> </ul>"},{"location":"gerber/feature_support/tokenizer.html#d01-d02-d03","title":"D01, D02, D03","text":"<ul> <li>\u2705 D01 - Plot operation, mode<ul> <li>\u2705 Line, with:<ul> <li>\u2705 circle,</li> <li>\u2705 rectangle,</li> <li>\u2705 obround,</li> <li>\u2705 polygon,</li> <li>\u2705 macro.</li> </ul> </li> <li>\u2705 Arc, with:<ul> <li>\u2705 circle,</li> <li>\u2705 rectangle,</li> <li>\u2705 obround,</li> <li>\u2705 polygon,</li> <li>\u2705 macro.</li> </ul> </li> <li>\u2705 Counter clockwise arc, with:<ul> <li>\u2705 circle,</li> <li>\u2705 rectangle,</li> <li>\u2705 obround,</li> <li>\u2705 polygon,</li> <li>\u2705 macro.</li> </ul> </li> <li>\u2705 Variable zero padding variants allowed.</li> </ul> </li> <li>\u2705 D02 - Move operation<ul> <li>\u2705 Variable zero padding variants allowed.</li> </ul> </li> <li>\u2705 D03 - Flash operation, with<ul> <li>\u2705 circle,</li> <li>\u2705 rectangle,</li> <li>\u2705 obround,</li> <li>\u2705 polygon,</li> <li>\u2705 macro.</li> <li>\u2705 Variable zero padding variants allowed.</li> </ul> </li> </ul>"},{"location":"gerber/feature_support/tokenizer.html#regions","title":"Regions","text":"<ul> <li>\u2705 G36 - Starts a region statement.</li> <li>\u2705 G37 - Ends the region statement.</li> <li>\u2705 Regions, with:<ul> <li>\u2705 Line, aperture:<ul> <li>\u2705 circle,</li> <li>\u2705 rectangle,</li> <li>\u2705 obround,</li> <li>\u2705 polygon,</li> <li>\u2705 macro.</li> </ul> </li> <li>\u2705 Arc, aperture:<ul> <li>\u2705 circle,</li> <li>\u2705 rectangle,</li> <li>\u2705 obround,</li> <li>\u2705 polygon,</li> <li>\u2705 macro.</li> </ul> </li> <li>\u2705 Counter clockwise arc, aperture:<ul> <li>\u2705 circle,</li> <li>\u2705 rectangle,</li> <li>\u2705 obround,</li> <li>\u2705 polygon,</li> <li>\u2705 macro.</li> </ul> </li> </ul> </li> </ul>"},{"location":"gerber/feature_support/tokenizer.html#macros","title":"Macros","text":"<ul> <li>\u2705 Parameters.</li> <li>\u2705 Primitives:<ul> <li>\u2705 Code 0, Comment</li> <li>\u2705 Code 1, Circle</li> <li>\u2705 Code 20, Vector line</li> <li>\u2705 Code 21, Center Line</li> <li>\u2705 Code 4, Outline</li> <li>\u2705 Code 5, Polygon</li> <li>\u2705 Code 7, Thermal</li> </ul> </li> <li>\u2705 Rotation around macro origin:<ul> <li>\u2705 Code 0, Comment</li> <li>\u2705 Code 1, Circle</li> <li>\u2705 Code 20, Vector line</li> <li>\u2705 Code 21, Center Line</li> <li>\u2705 Code 4, Outline</li> <li>\u2705 Code 5, Polygon</li> <li>\u2705 Code 7, Thermal</li> </ul> </li> <li>\u2705 Constants.</li> <li>\u2705 Variables.</li> <li>\u2705 Variable definitions.</li> </ul>"},{"location":"gerber/feature_support/tokenizer.html#aperture-blocks","title":"Aperture blocks","text":"<ul> <li>\u2705 Nested Line, aperture:<ul> <li>\u2705 circle,</li> <li>\u2705 rectangle,</li> <li>\u2705 obround,</li> <li>\u2705 polygon,</li> <li>\u2705 macro.</li> </ul> </li> <li>\u2705 Nested Arc, aperture:<ul> <li>\u2705 circle,</li> <li>\u2705 rectangle,</li> <li>\u2705 obround,</li> <li>\u2705 polygon,</li> <li>\u2705 macro.</li> </ul> </li> <li>\u2705 Nested Counter clockwise arc, aperture:<ul> <li>\u2705 circle,</li> <li>\u2705 rectangle,</li> <li>\u2705 obround,</li> <li>\u2705 polygon,</li> <li>\u2705 macro.</li> </ul> </li> <li>\u2705 Nested Flash:<ul> <li>\u2705 circle,</li> <li>\u2705 rectangle,</li> <li>\u2705 obround,</li> <li>\u2705 polygon,</li> <li>\u2705 macro.</li> </ul> </li> <li>\u2705 Nested regions (missing macro support).</li> </ul>"},{"location":"gerber/feature_support/tokenizer.html#step-and-repeat","title":"Step and repeat","text":"<ul> <li>\u2705 Nested Line, aperture:<ul> <li>\u2705 circle,</li> <li>\u2705 rectangle,</li> <li>\u2705 obround,</li> <li>\u2705 polygon,</li> <li>\u2705 macro.</li> </ul> </li> <li>\u2705 Nested Arc, aperture:<ul> <li>\u2705 circle,</li> <li>\u2705 rectangle,</li> <li>\u2705 obround,</li> <li>\u2705 polygon,</li> <li>\u2705 macro.</li> </ul> </li> <li>\u2705 Nested Counter clockwise arc, aperture:<ul> <li>\u2705 circle,</li> <li>\u2705 rectangle,</li> <li>\u2705 obround,</li> <li>\u2705 polygon,</li> <li>\u2705 macro.</li> </ul> </li> <li>\u2705 Nested Flash:<ul> <li>\u2705 circle,</li> <li>\u2705 rectangle,</li> <li>\u2705 obround,</li> <li>\u2705 polygon,</li> <li>\u2705 macro.</li> </ul> </li> <li>\u2705 Nested regions (missing macro support).</li> <li>\u2705 Nested blocks (missing macro support).</li> </ul>"},{"location":"gerber/feature_support/tokenizer.html#supported-deprecated-gerber-features","title":"Supported DEPRECATED Gerber features","text":"<ul> <li>\u2705 G54 - Select aperture. (Spec. 8.1.1)</li> <li>\u2705 G55 - Prepare for flash. (Spec. 8.1.1)</li> <li>\u2705 G70 - Set the 'Unit' to inch. (Spec. 8.1.1)</li> <li>\u2705 G71 - Set the 'Unit' to mm. (Spec. 8.1.1)</li> <li>\u2705 G90 - Set the 'Coordinate format' to 'Absolute notation'. (Spec. 8.1.1)</li> <li> <p>\u2705 G91 - Set the 'Coordinate format' to 'Incremental notation'. (Spec. 8.1.1)</p> <ul> <li>Important: Incremental notation itself is not supported and is not planned     due to lack of test assets and expected complications during implementation.</li> </ul> </li> <li> <p>\u2705 M00 - Program stop. (Spec. 8.1.1)</p> </li> <li>\u2705 M01 - Optional stop. (Spec. 8.1.1)</li> <li>\u2705 AS - Sets the 'Axes correspondence'. (Spec. 8.1.2)</li> <li>\u2705 IN - Sets the name of the file image. (Spec. 8.1.3)</li> <li>\u2705 IP - Sets the 'Image polarity'. (Spec. 8.1.4)</li> <li>\u2705 IR - Sets 'Image rotation' graphics state parameter. (Spec. 8.1.5)</li> <li>\u2705 LN - Loads a name. (Spec. 8.1.6)</li> <li>\u274c MI - Sets 'Image mirroring' graphics state parameter (Spec. 8.1.7)</li> <li>\ud83d\udc7d OF - Sets 'Image offset' graphics state parameter (Spec. 8.1.8)</li> <li>\u274c SF - Sets 'Scale factor' graphics state parameter (Spec. 8.1.9)</li> <li>\u2705 G74 - Sets single quadrant mode. (Spec. 8.1.10)</li> <li>\ud83d\udeab Format Specification (FS) Options. (Spec. 8.2.1)</li> <li>\ud83d\udeab Rectangular aperture hole in standard apertures. (Spec. 8.2.2)</li> <li>\u2705 Draws and arcs wit rectangular apertures. (Spec. 8.2.3)</li> <li>\u274c Macro Primitive Code 2, Vector Line. (Spec 8.2.4)</li> <li>\u274c Macro Primitive Code 22, Lower Left Line. (Spec 8.2.5)</li> <li>\u274c Macro Primitive Code 6, Moir\u00e9. (Spec 8.2.6)</li> <li>\u2705 Combining G01/G02/G03/G70/G71 and D01 in a single command. (Spec 8.3.1)</li> <li>\u2705 Combining G01/G02/G03/G70/G71 and D02 in a single command. (Spec 8.3.1)</li> <li>\u2705 Combining G01/G02/G03/G70/G71 and D03 in a single command. (Spec 8.3.1)</li> <li>\u2705 Coordinate Data without Operation Code. (Spec 8.3.2)</li> <li>\u2705 Style Variations in Command Codes. (Spec 8.3.3)</li> <li>\u274c Deprecated usage of SR. (Spec 8.3.4)</li> <li> <p>\u274c Deprecated Attribute Values. (Spec 8.4)</p> <ul> <li>Important: Incremental notation itself is not supported and is not planned     due to lack of test assets and expected complications during implementation.</li> </ul> </li> </ul> <p>PS. I had great time adding emoji to this table.</p>"},{"location":"gerber/introspection/0_usage.html","title":"Usage","text":""},{"location":"gerber/introspection/0_usage.html#introduction","title":"Introduction","text":"<p>Since release 2.2.0 PyGerber offers interface designed for Gerber code introspection based on <code>Parser2</code> class and visitor pattern. API is build around <code>Parser2HooksBase</code> class from <code>pygerber.gerberx3.parser2.parser2hooks_base</code> module and descendant classes passed to <code>Parser2</code> class. <code>Parser2</code> visits all tokens in Gerber AST created by <code>Tokenizer</code> and invokes particular hooks from provided hooks class. <code>Parser2HooksBase</code> itself doesn't implement any Gerber specific behaviors. It is just a collection of classes with empty hook methods which can be used to implement behaviors explained in The Gerber Format Specification. PyGerber provides such implementation in form of <code>Parser2Hooks</code> class, available in <code>pygerber.gerberx3.parser2.parser2</code> module.</p>"},{"location":"gerber/introspection/0_usage.html#minimal-example","title":"Minimal example","text":"<p>Let's consider very simple example in which we are interested in extracting all comments from Gerber code. Of course for such task it would be just enough to use regular expressions, but thanks to simplicity of this task it will be easier to perceive how hooks work.</p> test/examples/introspect_minimal_example.py<pre><code>\"\"\"Example for introspection with selective inheritance from Parser2HooksBase and Parser2Hooks.\"\"\"\nfrom __future__ import annotations\n\nfrom pygerber.gerberx3.parser2.context2 import Parser2Context, Parser2ContextOptions\nfrom pygerber.gerberx3.parser2.parser2 import Parser2, Parser2Options\nfrom pygerber.gerberx3.parser2.parser2hooks import Parser2Hooks\nfrom pygerber.gerberx3.tokenizer.tokenizer import Tokenizer\nfrom pygerber.gerberx3.tokenizer.tokens.g04_comment import Comment\n\n\nclass CustomHooks(Parser2Hooks):\n    def __init__(self) -&gt; None:\n        super().__init__()\n        self.comments: list[str] = []\n\n    class CommentTokenHooks(Parser2Hooks.CommentTokenHooks):\n        hooks: CustomHooks\n\n        def on_parser_visit_token(\n            self,\n            token: Comment,\n            context: Parser2Context,\n        ) -&gt; None:\n            self.hooks.comments.append(token.content)\n            return super().on_parser_visit_token(token, context)\n\n\nGERBER_SOURCE = r\"\"\"\nG04 Ucamco ex. 2: Shapes*           G04 A comment                                                            *\nG04 Ucamco ex. 2: Shapes*           G04 Comment                                                              *\n%MOMM*%                             G04 Units are mm                                                         *\n%FSLAX36Y36*%                       G04 Format specification:                                                *\n                                    G04  Leading zeros omitted                                               *\n                                    G04  Absolute coordinates                                                *\n                                    G04  Coordinates in 3 integer and 6 fractional digits.                   *\n%TF.FileFunction,Other,Sample*%     G04 Attribute: the is not a PCB layer, it is just an                     *\n                                    G04 example                                                              *\nG04 Define Apertures*               G04 Comment                                                              *\n%AMTHERMAL80*                       G04 Define the aperture macro 'THERMAL80'                                *\n7,0,0,0.800,0.550,0.125,45*%        G04 Use thermal primitive in the macro                                   *\n%ADD10C,0.1*%                       G04 Define aperture 10 as a circle with diameter 0.1 mm                  *\n%ADD11C,0.6*%                       G04 Define aperture 11 as a circle with diameter 0.6 mm                  *\n%ADD12R,0.6X0.6*%                   G04 Define aperture 12 as a rectangle with size 0.6 x 0.6 mm             *\n%ADD13R,0.4X1.00*%                  G04 Define aperture 13 as a rectangle with size 0.4 x 1 mm               *\n%ADD14R,1.00X0.4*%                  G04 Define aperture 14 as a rectangle with size 1 x 0.4 mm               *\n%ADD15O,0.4X01.00*%                 G04 Define aperture 15 as an obround with size 0.4 x 1 mm                *\n%ADD16P,1.00X3*%                    G04 Define aperture 16 as a polygon with 3 vertices and                  *\n                                    G04 circumscribed circle with diameter 1 mm                              *\n%ADD19THERMAL80*%                   G04 Define aperture 19 as an instance of macro aperture                  *\n                                    G04 'THERMAL80' defined earlier                                          *\nG04 Start image generation*         G04 A comment                                                            *\nD10*                                G04 Select aperture 10 as current aperture                               *\nX0Y2500000D02*                      G04 Set the current point to (0, 2.5) mm                                 *\nG01*                                G04 Set linear plot mode                                                 *\nX0Y0D01*                            G04 Create draw with the current aperture                                *\nX2500000Y0D01*                      G04 Create draw with the current aperture                                *\nX10000000Y10000000D02*              G04 Set the current point                                                *\nX15000000D01*                       G04 Create draw with the current aperture                                *\nX20000000Y15000000D01*              G04 Create draw with the current aperture                                *\nX25000000D02*                       G04 Set the current point.                                               *\nY10000000D01*                       G04 Create draw with the current aperture                                *\nD11*                                G04 Select aperture 11 as current aperture                               *\nX10000000Y10000000D03*              G04 Create flash with the current aperture (11) at (10, 10).             *\nX20000000D03*                       G04 Create a flash with the current aperture at (20, 10).                *\nM02*                                G04 End of file                                                          *\n\"\"\"\n\n\ndef main() -&gt; None:\n    tokenizer = Tokenizer()\n    ast = tokenizer.tokenize(GERBER_SOURCE)\n    hooks = CustomHooks()\n    parser = Parser2(\n        Parser2Options(context_options=Parser2ContextOptions(hooks=hooks)),\n    )\n    parser.parse(ast)\n\n    for comment in hooks.comments:\n        print(comment)\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>As you can see in snippet above, to inject custom hooks class one must create nested options structure. Design decision to nest configuration like this, was made to allow maximal customization of all parts of the <code>Parser2</code>. Indeed at each level there are few options useful in specific situations. But as for now, let's focus on hooks themselves.</p> <p>It's important to notice that hook method <code>on_parser_visit_token()</code> is overrode in nested class, <code>CommentTokenHooks</code>, which inherits from <code>Parser2Hooks</code>. There are hooks which are defined directly in hooks class, but they are more general, eg. for handling exceptions. All hooks specific to particular tokens are defined in nested classes named in way indicating what token they are concerned with, eg. <code>DefineApertureObroundTokenHooks</code>, <code>ImagePolarityTokenHooks</code>.</p> <p>Output of this code will look like this:</p> <pre><code> Ucamco ex. 2: Shapes\n A comment\n Ucamco ex. 2: Shapes\n Comment\n Units are mm\n Format specification:\n  Leading zeros omitted\n  Absolute coordinates\n  Coordinates in 3 integer and 6 fractional digits.\n Attribute: the is not a PCB layer, it is just an\n example\n Define Apertures\n Comment\n Define the aperture macro 'THERMAL80'\n Use thermal primitive in the macro\n Define aperture 10 as a circle with diameter 0.1 mm\n Define aperture 11 as a circle with diameter 0.6 mm\n Define aperture 12 as a rectangle with size 0.6 x 0.6 mm\n Define aperture 13 as a rectangle with size 0.4 x 1 mm\n Define aperture 14 as a rectangle with size 1 x 0.4 mm\n Define aperture 15 as an obround with size 0.4 x 1 mm\n Define aperture 16 as a polygon with 3 vertices and\n circumscribed circle with diameter 1 mm\n Define aperture 19 as an instance of macro aperture\n 'THERMAL80' defined earlier\n Start image generation\n A comment\n Select aperture 10 as current aperture\n Set the current point to (0, 2.5) mm\n Set linear plot mode\n Create draw with the current aperture\n Create draw with the current aperture\n Set the current point\n Create draw with the current aperture\n Create draw with the current aperture\n Set the current point.\n Create draw with the current aperture\n Select aperture 11 as current aperture\n Create flash with the current aperture (11) at (10, 10).\n Create a flash with the current aperture at (20, 10).\n</code></pre> <p>Notice that every line starts with one space, as everything directly after G04 statement is considered a comment, including leading spaces.</p>"},{"location":"gerber/introspection/0_usage.html#mixed-inheritance","title":"Mixed inheritance","text":"<p>By default <code>Parser2</code> is using <code>Parser2Hooks</code>, however, for some use cases it may be more beneficial to use <code>Parser2HooksBase</code> class to reduce time required to traverse single Gerber file. This is the case when one needs only selected Gerber features, eg. attribute support. In such case, you can create new <code>Parser2HooksBase</code> derived class and for some hook classes inherit from <code>Parser2Hooks</code> nested classes.</p> <p>For example let's assume we want to extract attributes of all apertures in Gerber file. To do it we need a working attribute cumulation logic, but at the same time let's try to minimize time required to parse file by using only these parts of Parser2Hooks which are necessary.</p> test/examples/introspect_mixed_inheritance.py<pre><code>\"\"\"Example for introspection with selective inheritance from Parser2HooksBase and Parser2Hooks.\"\"\"\nfrom __future__ import annotations\n\nfrom pygerber.gerberx3.parser2.attributes2 import ApertureAttributes\nfrom pygerber.gerberx3.parser2.context2 import Parser2Context, Parser2ContextOptions\nfrom pygerber.gerberx3.parser2.parser2 import (\n    Parser2,\n    Parser2OnErrorAction,\n    Parser2Options,\n)\nfrom pygerber.gerberx3.parser2.parser2hooks import Parser2Hooks\nfrom pygerber.gerberx3.parser2.parser2hooks_base import DefineAnyT, Parser2HooksBase\nfrom pygerber.gerberx3.tokenizer.aperture_id import ApertureID\nfrom pygerber.gerberx3.tokenizer.tokenizer import Tokenizer\n\n\nclass CustomHooks(Parser2HooksBase):\n    def __init__(self) -&gt; None:\n        super().__init__()\n        self.aperture_attributes: dict[ApertureID, ApertureAttributes] = {}\n\n    class ApertureAttributeHooks(Parser2Hooks.ApertureAttributeHooks):\n        pass\n\n    class FileAttributeHooks(Parser2Hooks.FileAttributeHooks):\n        pass\n\n    class ObjectAttributeHooks(Parser2Hooks.ObjectAttributeHooks):\n        pass\n\n    class DeleteAttributeHooks(Parser2Hooks.DeleteAttributeHooks):\n        pass\n\n    class DefineApertureTokenHooks(Parser2HooksBase.DefineApertureTokenHooks):\n        hooks: CustomHooks\n\n        def on_parser_visit_token(\n            self,\n            token: DefineAnyT,\n            context: Parser2Context,\n        ) -&gt; None:\n            self.hooks.aperture_attributes[\n                token.aperture_id\n            ] = context.aperture_attributes\n            return super().on_parser_visit_token(token, context)\n\n\nGERBER_SOURCE = r\"\"\"\n%TF.GenerationSoftware,KiCad,Pcbnew,5.1.5-52549c5~84~ubuntu18.04.1*%\n%TF.CreationDate,2020-02-11T15:54:30+02:00*%\n%TF.ProjectId,A64-OlinuXino_Rev_G,4136342d-4f6c-4696-9e75-58696e6f5f52,G*%\n%TF.SameCoordinates,Original*%\n%TF.FileFunction,Copper,L6,Bot*%\n%TF.FilePolarity,Positive*%\n%FSLAX46Y46*%\nG04 Gerber Fmt 4.6, Leading zero omitted, Abs format (unit mm)*\nG04 Created by KiCad (PCBNEW 5.1.5-52549c5~84~ubuntu18.04.1) date 2020-02-11 15:54:30*\n%MOMM*%\n%LPD*%\nG04 APERTURE LIST*\n%TA.AperFunction,EtchedComponent*%\n%ADD10C,0.508000*%\n%TD*%\n%TA.AperFunction,EtchedComponent*%\n%ADD11C,0.254000*%\n%TD*%\n%TA.AperFunction,ComponentPad*%\n%ADD12O,2.800000X2.000000*%\n%TD*%\n%TA.AperFunction,ComponentPad*%\n%ADD13C,1.650000*%\nM02*\n\"\"\"\n\n\ndef main() -&gt; None:\n    tokenizer = Tokenizer()\n    ast = tokenizer.tokenize(GERBER_SOURCE)\n    hooks = CustomHooks()\n    parser = Parser2(\n        Parser2Options(\n            context_options=Parser2ContextOptions(hooks=hooks),\n            on_update_drawing_state_error=Parser2OnErrorAction.UseHook,\n        ),\n    )\n    parser.parse(ast)\n\n    for aperture, attributes in hooks.aperture_attributes.items():\n        print(aperture)\n        print(attributes)\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>Output of this code will look like this:</p> <pre><code>D10\nApertureAttributes({'.AperFunction': 'EtchedComponent'})\nD11\nApertureAttributes({'.AperFunction': 'EtchedComponent'})\nD12\nApertureAttributes({'.AperFunction': 'ComponentPad'})\nD13\nApertureAttributes({'.AperFunction': 'ComponentPad'})\n</code></pre> <p>Beware that there are some potential risks when using such approach. Tokens often rely on other tokens defined before them (eg. <code>CoordinateFormat</code> relies on <code>UnitMode</code>). For example in this case we can't inherit from <code>Parser2Hooks.DefineApertureCircleTokenHooks</code>, as we are not including implementation of <code>UnitModeTokenHooks</code>, so define would complain about draw units not being set, by throwing <code>pygerber.gerberx3.parser2.errors2.UnitNotSet2Error</code>.</p>"},{"location":"gerber/introspection/0_usage.html#error-handling","title":"Error handling","text":"<p>Parser2 hooks provide a way to handle errors before they are propagated to Parser2 and cause parse interruption. However, to enable this behavior one must explicitly enable it by setting <code>on_update_drawing_state_error</code> parameter to <code>Parser2OnErrorAction.UseHook</code>.</p> <pre><code>Parser2(\n    Parser2Options(\n        context_options=Parser2ContextOptions(hooks=hooks),\n        on_update_drawing_state_error=Parser2OnErrorAction.UseHook,\n    ),\n)\n</code></pre> <p>This option gives parser a chance to recover from error by passing it to one of two hooks: <code>on_parser_error()</code> on <code>on_other_error()</code>. First one is used to handle exceptions are not descendants of <code>pygerber.gerberx3.parser2.errors2.Parser2Error</code>, which are expected to be thrown by parser related code, mostly when encountering unrecoverable Gerber standard violations. They are \"unrecoverable\" in a sense that we can't make a good general assumption what should we do with it. <code>pygerber.gerberx3.parser2.errors2.UnitNotSet2Error</code> is an example of such an error, raised when attempting to interpret Gerber coordinates before unit of distance was set (inch/millimeter), which leaves units as undefined and neither inch nor millimeter is a good default in general case, but one of them can be a good default in some specific environments.</p> test/examples/introspect_handle_no_unit.py<pre><code>\"\"\"Example for introspection with selective inheritance from Parser2HooksBase and Parser2Hooks.\"\"\"\nfrom __future__ import annotations\n\nfrom pygerber.gerberx3.parser2.context2 import Parser2Context, Parser2ContextOptions\nfrom pygerber.gerberx3.parser2.errors2 import Parser2Error, UnitNotSet2Error\nfrom pygerber.gerberx3.parser2.parser2 import (\n    Parser2,\n    Parser2OnErrorAction,\n    Parser2Options,\n)\nfrom pygerber.gerberx3.parser2.parser2hooks import Parser2Hooks\nfrom pygerber.gerberx3.state_enums import Unit\nfrom pygerber.gerberx3.tokenizer.tokenizer import Tokenizer\n\n\nclass CustomHooks(Parser2Hooks):\n    def on_parser_error(self, context: Parser2Context, error: Parser2Error) -&gt; None:\n        if isinstance(error, UnitNotSet2Error):\n            context.set_draw_units(Unit.Inches)\n        return super().on_parser_error(context, error)\n\n\nGERBER_SOURCE = r\"\"\"\n%FSLAX46Y46*%\nG04 Let's not include MO command. *\n%LPD*%\nG04 APERTURE LIST*\n%TA.AperFunction,EtchedComponent*%\n%ADD10C,0.508000*%\n%TD*%\n%TA.AperFunction,EtchedComponent*%\n%ADD11C,0.254000*%\n%TD*%\n%TA.AperFunction,ComponentPad*%\n%ADD12O,2.800000X2.000000*%\n%TD*%\n%TA.AperFunction,ComponentPad*%\n%ADD13C,1.650000*%\nM02*\n\"\"\"\n\n\ndef main() -&gt; None:\n    tokenizer = Tokenizer()\n    ast = tokenizer.tokenize(GERBER_SOURCE)\n    hooks = CustomHooks()\n    parser = Parser2(\n        Parser2Options(\n            context_options=Parser2ContextOptions(hooks=hooks),\n            on_update_drawing_state_error=Parser2OnErrorAction.UseHook,\n        ),\n    )\n    parser.parse(ast)\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"gerber/introspection/1_ihooks_reference.html","title":"Parser2HooksBase Reference","text":""},{"location":"gerber/introspection/1_ihooks_reference.html#pygerber.gerberx3.parser2.parser2hooks_base","title":"parser2hooks_base","text":"<p>Parser hooks interface class, for Gerber AST parser, version 2.</p>"},{"location":"gerber/introspection/1_ihooks_reference.html#pygerber.gerberx3.parser2.parser2hooks_base.TokenHooksBase","title":"TokenHooksBase","text":"<p>             Bases: <code>Generic[TokenT]</code></p> <p>Class for creating token visit hooks.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class TokenHooksBase(Generic[TokenT]):\n    \"\"\"Class for creating token visit hooks.\"\"\"\n\n    def __init__(self, hooks: Parser2HooksBase) -&gt; None:\n        self.hooks = hooks\n\n    def post_hooks_init(self) -&gt; None:\n        \"\"\"Called after all hooks are assigned.\"\"\"\n\n    def pre_parser_visit_token(\n        self,\n        token: TokenT,\n        context: Parser2Context,\n    ) -&gt; None:\n        \"\"\"Called before parser visits a token.\n\n        Parameters\n        ----------\n        token: TokenT\n            The token that will be visited.\n        context : Parser2Context\n            The context object containing information about the parser state.\n        \"\"\"\n\n    def on_parser_visit_token(\n        self,\n        token: TokenT,\n        context: Parser2Context,\n    ) -&gt; None:\n        \"\"\"Called when parser visits a token.\n\n        This hook should perform all changes on context implicated by token type.\n\n        Parameters\n        ----------\n        token: TokenT\n            The token that is being visited.\n        context : Parser2Context\n            The context object containing information about the parser state.\n        \"\"\"\n\n    def post_parser_visit_token(\n        self,\n        token: TokenT,\n        context: Parser2Context,\n    ) -&gt; None:\n        \"\"\"Called after parser visits a token.\n\n        Parameters\n        ----------\n        token: TokenT\n            The token that was visited.\n        context : Parser2Context\n            The context object containing information about the parser state.\n        \"\"\"\n</code></pre>"},{"location":"gerber/introspection/1_ihooks_reference.html#pygerber.gerberx3.parser2.parser2hooks_base.TokenHooksBase.post_hooks_init","title":"post_hooks_init","text":"<pre><code>post_hooks_init() -&gt; None\n</code></pre> <p>Called after all hooks are assigned.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>def post_hooks_init(self) -&gt; None:\n    \"\"\"Called after all hooks are assigned.\"\"\"\n</code></pre>"},{"location":"gerber/introspection/1_ihooks_reference.html#pygerber.gerberx3.parser2.parser2hooks_base.TokenHooksBase.pre_parser_visit_token","title":"pre_parser_visit_token","text":"<pre><code>pre_parser_visit_token(\n    token: TokenT, context: Parser2Context\n) -&gt; None\n</code></pre> <p>Called before parser visits a token.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>TokenT</code> <p>The token that will be visited.</p> required <code>context</code> <code>Parser2Context</code> <p>The context object containing information about the parser state.</p> required Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>def pre_parser_visit_token(\n    self,\n    token: TokenT,\n    context: Parser2Context,\n) -&gt; None:\n    \"\"\"Called before parser visits a token.\n\n    Parameters\n    ----------\n    token: TokenT\n        The token that will be visited.\n    context : Parser2Context\n        The context object containing information about the parser state.\n    \"\"\"\n</code></pre>"},{"location":"gerber/introspection/1_ihooks_reference.html#pygerber.gerberx3.parser2.parser2hooks_base.TokenHooksBase.on_parser_visit_token","title":"on_parser_visit_token","text":"<pre><code>on_parser_visit_token(\n    token: TokenT, context: Parser2Context\n) -&gt; None\n</code></pre> <p>Called when parser visits a token.</p> <p>This hook should perform all changes on context implicated by token type.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>TokenT</code> <p>The token that is being visited.</p> required <code>context</code> <code>Parser2Context</code> <p>The context object containing information about the parser state.</p> required Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>def on_parser_visit_token(\n    self,\n    token: TokenT,\n    context: Parser2Context,\n) -&gt; None:\n    \"\"\"Called when parser visits a token.\n\n    This hook should perform all changes on context implicated by token type.\n\n    Parameters\n    ----------\n    token: TokenT\n        The token that is being visited.\n    context : Parser2Context\n        The context object containing information about the parser state.\n    \"\"\"\n</code></pre>"},{"location":"gerber/introspection/1_ihooks_reference.html#pygerber.gerberx3.parser2.parser2hooks_base.TokenHooksBase.post_parser_visit_token","title":"post_parser_visit_token","text":"<pre><code>post_parser_visit_token(\n    token: TokenT, context: Parser2Context\n) -&gt; None\n</code></pre> <p>Called after parser visits a token.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>TokenT</code> <p>The token that was visited.</p> required <code>context</code> <code>Parser2Context</code> <p>The context object containing information about the parser state.</p> required Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>def post_parser_visit_token(\n    self,\n    token: TokenT,\n    context: Parser2Context,\n) -&gt; None:\n    \"\"\"Called after parser visits a token.\n\n    Parameters\n    ----------\n    token: TokenT\n        The token that was visited.\n    context : Parser2Context\n        The context object containing information about the parser state.\n    \"\"\"\n</code></pre>"},{"location":"gerber/introspection/1_ihooks_reference.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase","title":"Parser2HooksBase","text":"<p>Collection of overridable hooks for Gerber AST parser, version 2.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class Parser2HooksBase:\n    \"\"\"Collection of overridable hooks for Gerber AST parser, version 2.\"\"\"\n\n    def __init__(self) -&gt; None:  # noqa: PLR0915\n        super().__init__()\n        self.macro_begin = self.MacroBeginTokenHooks(self)\n        self.macro_code_1_circle = self.MacroCode1CircleTokenHooks(self)\n        self.macro_code_2_vector_line = self.MacroCode2VectorLineTokenHooks(self)\n        self.macro_code_4_outline = self.MacroCode4OutlineTokenHooks(self)\n        self.macro_code_5_polygon = self.MacroCode5PolygonTokenHooks(self)\n        self.macro_code_6_moire = self.MacroCode6MoireTokenHooks(self)\n        self.macro_code_7_thermal = self.MacroCode7ThermalTokenHooks(self)\n        self.macro_code_20_vector_line = self.MacroCode20VectorLineTokenHooks(self)\n        self.macro_code_21_center_line = self.MacroCode21CenterLineTokenHooks(self)\n        self.macro_code_22_lower_left_line = self.MacroCode22LowerLeftLineTokenHooks(\n            self,\n        )\n        self.macro_variable_assignment = self.MacroVariableAssignment(self)\n        self.macro_definition = self.MacroDefinitionTokenHooks(self)\n        self.macro_eval = self.MacroEvalHooks()\n\n        self.end_block_aperture = self.EndBlockApertureTokenHooks(self)\n        self.begin_block_aperture = self.BeginBlockApertureTokenHooks(self)\n\n        self.define_circle_aperture = self.DefineApertureCircleTokenHooks(self)\n        self.define_rectangle_aperture = self.DefineApertureRectangleTokenHooks(self)\n        self.define_obround_aperture = self.DefineApertureObroundTokenHooks(self)\n        self.define_polygon_aperture = self.DefineAperturePolygonTokenHooks(self)\n        self.define_macro_aperture = self.DefineApertureMacroTokenHooks(self)\n        self.define_aperture = self.DefineApertureTokenHooks(self)\n\n        self.axis_select = self.AxisSelectTokenHooksTokenHooks(self)\n\n        self.command_draw = self.CommandDrawTokenHooks(self)\n        self.command_move = self.CommandMoveTokenHooks(self)\n        self.command_flash = self.CommandFlashTokenHooks(self)\n\n        self.select_aperture = self.SelectApertureTokenHooks(self)\n        self.coordinate_format = self.CoordinateFormatTokenHooks(self)\n\n        self.set_linear = self.SetLinearTokenHooks(self)\n        self.set_clockwise_circular = self.SetClockwiseCircularTokenHooks(self)\n        self.set_counter_clockwise_circular = (\n            self.SetCounterClockwiseCircularTokenHooks(self)\n        )\n\n        self.comment = self.CommentTokenHooks(self)\n        self.begin_region = self.BeginRegionTokenHooks(self)\n        self.end_region = self.EndRegionTokenHooks(self)\n        self.prepare_select_aperture = self.PrepareSelectApertureTokenHooks(self)\n        self.set_unit_inch = self.SetUnitInchTokenHooks(self)\n        self.set_unit_millimeters = self.SetUnitMillimetersTokenHooks(self)\n\n        self.set_single_quadrant_mode = self.SetSingleQuadrantModeTokenHooks(self)\n        self.set_multi_quadrant_mode = self.SetMultiQuadrantModeTokenHooks(self)\n\n        self.set_coordinate_absolute = self.SetCoordinateAbsoluteTokenHooks(self)\n        self.set_coordinate_incremental = self.SetCoordinateIncrementalTokenHooks(self)\n\n        self.image_name = self.ImageNameTokenHooks(self)\n        self.invalid_token = self.InvalidTokenHooks(self)\n        self.image_polarity = self.ImagePolarityTokenHooks(self)\n        self.load_name = self.LoadNameTokenHooks(self)\n\n        self.load_mirroring = self.LoadMirroringTokenHooks(self)\n        self.load_polarity = self.LoadPolarityTokenHooks(self)\n        self.load_rotation = self.LoadRotationTokenHooks(self)\n        self.load_scaling = self.LoadScalingTokenHooks(self)\n\n        self.program_stop = self.ProgramStopTokenHooks(self)\n        self.optional_stop = self.OptionalStopTokenHooks(self)\n        self.end_of_file = self.EndOfFileTokenHooks(self)\n        self.unit_mode = self.UnitModeTokenHooks(self)\n        self.image_offset = self.ImageOffsetTokenHooks(self)\n\n        self.step_repeat_begin = self.StepRepeatBeginTokenHooks(self)\n        self.step_repeat_end = self.StepRepeatEndTokenHooks(self)\n\n        self.aperture_attribute = self.ApertureAttributeHooks(self)\n        self.delete_attribute = self.DeleteAttributeHooks(self)\n        self.file_attribute = self.FileAttributeHooks(self)\n        self.object_attribute = self.ObjectAttributeHooks(self)\n\n        self._call_post_hooks_init()\n\n    def _call_post_hooks_init(self) -&gt; None:  # noqa: PLR0915\n        self.macro_begin.post_hooks_init()\n        self.macro_code_1_circle.post_hooks_init()\n        self.macro_code_2_vector_line.post_hooks_init()\n        self.macro_code_4_outline.post_hooks_init()\n        self.macro_code_5_polygon.post_hooks_init()\n        self.macro_code_6_moire.post_hooks_init()\n        self.macro_code_7_thermal.post_hooks_init()\n        self.macro_code_20_vector_line.post_hooks_init()\n        self.macro_code_21_center_line.post_hooks_init()\n        self.macro_code_22_lower_left_line.post_hooks_init()\n        self.macro_variable_assignment.post_hooks_init()\n        self.macro_definition.post_hooks_init()\n\n        self.end_block_aperture.post_hooks_init()\n        self.begin_block_aperture.post_hooks_init()\n\n        self.define_circle_aperture.post_hooks_init()\n        self.define_rectangle_aperture.post_hooks_init()\n        self.define_obround_aperture.post_hooks_init()\n        self.define_polygon_aperture.post_hooks_init()\n        self.define_macro_aperture.post_hooks_init()\n        self.define_aperture.post_hooks_init()\n\n        self.axis_select.post_hooks_init()\n\n        self.command_draw.post_hooks_init()\n        self.command_move.post_hooks_init()\n        self.command_flash.post_hooks_init()\n\n        self.select_aperture.post_hooks_init()\n        self.coordinate_format.post_hooks_init()\n\n        self.set_linear.post_hooks_init()\n        self.set_clockwise_circular.post_hooks_init()\n        self.set_counter_clockwise_circular.post_hooks_init()\n\n        self.comment.post_hooks_init()\n        self.begin_region.post_hooks_init()\n        self.end_region.post_hooks_init()\n        self.prepare_select_aperture.post_hooks_init()\n\n        self.set_unit_inch.post_hooks_init()\n        self.set_unit_millimeters.post_hooks_init()\n\n        self.set_single_quadrant_mode.post_hooks_init()\n        self.set_multi_quadrant_mode.post_hooks_init()\n\n        self.set_coordinate_absolute.post_hooks_init()\n        self.set_coordinate_incremental.post_hooks_init()\n\n        self.image_name.post_hooks_init()\n        self.invalid_token.post_hooks_init()\n        self.image_polarity.post_hooks_init()\n        self.load_name.post_hooks_init()\n\n        self.load_mirroring.post_hooks_init()\n        self.load_polarity.post_hooks_init()\n        self.load_rotation.post_hooks_init()\n        self.load_scaling.post_hooks_init()\n\n        self.program_stop.post_hooks_init()\n        self.optional_stop.post_hooks_init()\n        self.end_of_file.post_hooks_init()\n        self.unit_mode.post_hooks_init()\n        self.image_offset.post_hooks_init()\n\n        self.step_repeat_begin.post_hooks_init()\n        self.step_repeat_end.post_hooks_init()\n\n        self.aperture_attribute.post_hooks_init()\n        self.delete_attribute.post_hooks_init()\n        self.file_attribute.post_hooks_init()\n        self.object_attribute.post_hooks_init()\n\n    def on_parser_init(self, parser: Parser2) -&gt; None:\n        \"\"\"Called after parser initialization.\"\"\"\n\n    def pre_parse(self, context: Parser2Context) -&gt; None:\n        \"\"\"Called before parsing starts.\"\"\"\n\n    def post_parse(self, context: Parser2Context) -&gt; None:\n        \"\"\"Called after parsing starts.\"\"\"\n\n    def on_parser_error(self, context: Parser2Context, error: Parser2Error) -&gt; None:\n        \"\"\"Called when parsing error is thrown.\"\"\"\n\n    def on_other_error(self, context: Parser2Context, error: Exception) -&gt; None:\n        \"\"\"Called when other error is thrown.\"\"\"\n\n    def pre_parser_visit_any_token(self, context: Parser2Context) -&gt; None:\n        \"\"\"Called before parser visits any token.\"\"\"\n\n    def post_parser_visit_any_token(self, context: Parser2Context) -&gt; None:\n        \"\"\"Called after parser visits any token.\"\"\"\n\n    class MacroBeginTokenHooks(TokenHooksBase[MacroBeginT]):\n        \"\"\"Hooks for visiting macro definition begin token (AM).\"\"\"\n\n    class MacroCode1CircleTokenHooks(TokenHooksBase[Code1CircleTokenT]):\n        \"\"\"Hooks for visiting macro primitive code 0 circle.\"\"\"\n\n    class MacroCode2VectorLineTokenHooks(TokenHooksBase[Code2VectorLineTokenT]):\n        \"\"\"Hooks for visiting macro primitive code 2 vector line.\"\"\"\n\n    class MacroCode4OutlineTokenHooks(TokenHooksBase[Code4OutlineTokenT]):\n        \"\"\"Hooks for visiting macro primitive code 4 outline.\"\"\"\n\n    class MacroCode5PolygonTokenHooks(TokenHooksBase[Code5PolygonTokenT]):\n        \"\"\"Hooks for visiting macro primitive code 5 polygon.\"\"\"\n\n    class MacroCode6MoireTokenHooks(TokenHooksBase[Code6MoireTokenT]):\n        \"\"\"Hooks for visiting macro primitive code 6 moire.\"\"\"\n\n    class MacroCode7ThermalTokenHooks(TokenHooksBase[Code7ThermalTokenT]):\n        \"\"\"Hooks for visiting macro primitive code 7 thermal.\"\"\"\n\n    class MacroCode20VectorLineTokenHooks(TokenHooksBase[Code20VectorLineTokenT]):\n        \"\"\"Hooks for visiting macro primitive code 20 vector line.\"\"\"\n\n    class MacroCode21CenterLineTokenHooks(TokenHooksBase[Code21CenterLineTokenT]):\n        \"\"\"Hooks for visiting macro primitive code 21 center line.\"\"\"\n\n    class MacroCode22LowerLeftLineTokenHooks(TokenHooksBase[Code22LowerLeftLineTokenT]):\n        \"\"\"Hooks for visiting macro primitive code 22 lower left line.\"\"\"\n\n    class MacroVariableAssignment(TokenHooksBase[MacroVariableAssignmentT]):\n        \"\"\"Hooks for visiting macro variable assignment token.\"\"\"\n\n    class MacroDefinitionTokenHooks(TokenHooksBase[MacroDefinitionT]):\n        \"\"\"Hooks for visiting macro definition token (AM).\"\"\"\n\n    class MacroEvalHooks:\n        \"\"\"Hooks called when evaluating macro aperture.\"\"\"\n\n        def on_code_1_circle(\n            self,\n            context: Parser2Context,\n            primitive: Code1Circle2,\n        ) -&gt; None:\n            \"\"\"Evaluate code 1 circle primitive.\"\"\"\n\n        def on_code_2_vector_line(\n            self,\n            context: Parser2Context,\n            primitive: Code2VectorLine2,\n        ) -&gt; None:\n            \"\"\"Evaluate code 2 vector line primitive.\"\"\"\n\n        def on_code_4_outline(\n            self,\n            context: Parser2Context,\n            primitive: Code4Outline2,\n        ) -&gt; None:\n            \"\"\"Evaluate code 4 outline primitive.\"\"\"\n\n        def on_code_5_polygon(\n            self,\n            context: Parser2Context,\n            primitive: Code5Polygon2,\n        ) -&gt; None:\n            \"\"\"Evaluate code 5 polygon primitive.\"\"\"\n\n        def on_code_6_moire(\n            self,\n            context: Parser2Context,\n            primitive: Code6Moire2,\n        ) -&gt; None:\n            \"\"\"Evaluate code 6 moire primitive.\"\"\"\n\n        def on_code_7_thermal(\n            self,\n            context: Parser2Context,\n            primitive: Code7Thermal2,\n        ) -&gt; None:\n            \"\"\"Evaluate code 7 thermal primitive.\"\"\"\n\n        def on_code_20_vector_line(\n            self,\n            context: Parser2Context,\n            primitive: Code20VectorLine2,\n        ) -&gt; None:\n            \"\"\"Evaluate code 20 vector line primitive.\"\"\"\n\n        def on_code_21_center_line(\n            self,\n            context: Parser2Context,\n            primitive: Code21CenterLine2,\n        ) -&gt; None:\n            \"\"\"Evaluate code 21 center line primitive.\"\"\"\n\n        def on_code_22_lower_left_line(\n            self,\n            context: Parser2Context,\n            primitive: Code22LowerLeftLine2,\n        ) -&gt; None:\n            \"\"\"Evaluate code 22 lower left line primitive.\"\"\"\n\n        def on_assignment(\n            self,\n            context: Parser2Context,\n            assignment: Assignment2,\n        ) -&gt; None:\n            \"\"\"Evaluate macro variable assignment statement.\"\"\"\n\n    class BeginBlockApertureTokenHooks(TokenHooksBase[BlockApertureBeginT]):\n        \"\"\"Hooks for visiting begin block aperture token (AB).\"\"\"\n\n    class EndBlockApertureTokenHooks(TokenHooksBase[BlockApertureEndT]):\n        \"\"\"Hooks for visiting end block aperture token (AB).\"\"\"\n\n    class DefineApertureCircleTokenHooks(TokenHooksBase[DefineCircleT]):\n        \"\"\"Hooks for visiting circle aperture definition token (ADD).\"\"\"\n\n    class DefineApertureRectangleTokenHooks(TokenHooksBase[DefineRectangleT]):\n        \"\"\"Hooks for visiting rectangle aperture definition token (ADD).\"\"\"\n\n    class DefineApertureObroundTokenHooks(TokenHooksBase[DefineObroundT]):\n        \"\"\"Hooks for visiting obround aperture definition token (ADD).\"\"\"\n\n    class DefineAperturePolygonTokenHooks(TokenHooksBase[DefinePolygonT]):\n        \"\"\"Hooks for visiting polygon aperture definition token (ADD).\"\"\"\n\n    class DefineApertureMacroTokenHooks(TokenHooksBase[DefineMacroT]):\n        \"\"\"Hooks for visiting macro aperture definition token (ADD).\"\"\"\n\n    class DefineApertureTokenHooks(TokenHooksBase[DefineAnyT]):\n        \"\"\"Hooks for visiting any aperture definition token (ADD).\"\"\"\n\n    class AxisSelectTokenHooksTokenHooks(TokenHooksBase[AxisSelectT]):\n        \"\"\"Hooks for visiting axis select token (AS).\"\"\"\n\n    class CommandDrawTokenHooks(TokenHooksBase[D01DrawT]):\n        \"\"\"Hooks for visiting draw token (D01).\"\"\"\n\n    class CommandMoveTokenHooks(TokenHooksBase[D02MoveT]):\n        \"\"\"Hooks for visiting move token (D02).\"\"\"\n\n    class CommandFlashTokenHooks(TokenHooksBase[D03FlashT]):\n        \"\"\"Hooks for visiting flash token (D03).\"\"\"\n\n    class SelectApertureTokenHooks(TokenHooksBase[DNNSelectApertureT]):\n        \"\"\"Hooks for visiting select aperture token (DNN).\"\"\"\n\n    class CoordinateFormatTokenHooks(TokenHooksBase[CoordinateFormatT]):\n        \"\"\"Hooks for visiting coordinate format token (FS).\"\"\"\n\n    class SetLinearTokenHooks(TokenHooksBase[SetLinearT]):\n        \"\"\"Hooks for visiting set linear token (G01).\"\"\"\n\n    class SetClockwiseCircularTokenHooks(TokenHooksBase[SetClockwiseCircularT]):\n        \"\"\"Hooks for visiting set clockwise circular token (G02).\"\"\"\n\n    class SetCounterClockwiseCircularTokenHooks(\n        TokenHooksBase[SetCounterclockwiseCircularT],\n    ):\n        \"\"\"Hooks for visiting set counter clockwise circular token (G03).\"\"\"\n\n    class CommentTokenHooks(TokenHooksBase[CommentT]):\n        \"\"\"Hooks for visiting comment token (G04).\"\"\"\n\n    class BeginRegionTokenHooks(TokenHooksBase[BeginRegionT]):\n        \"\"\"Hooks for visiting begin region token (G36).\"\"\"\n\n    class EndRegionTokenHooks(TokenHooksBase[EndRegionT]):\n        \"\"\"Hooks for visiting end region token (G37).\"\"\"\n\n    class PrepareSelectApertureTokenHooks(TokenHooksBase[G54SelectApertureT]):\n        \"\"\"Hooks for visiting prepare select aperture token (G54).\"\"\"\n\n    class SetUnitInchTokenHooks(TokenHooksBase[SetUnitInchT]):\n        \"\"\"Hooks for visiting set unit inch token (G70).\"\"\"\n\n    class SetUnitMillimetersTokenHooks(TokenHooksBase[SetUnitMillimetersT]):\n        \"\"\"Hooks for visiting set unit millimeters token (G71).\"\"\"\n\n    class SetSingleQuadrantModeTokenHooks(TokenHooksBase[SetSingleQuadrantModeT]):\n        \"\"\"Hooks for visiting set single-quadrant mode token (G74).\"\"\"\n\n    class SetMultiQuadrantModeTokenHooks(TokenHooksBase[SetMultiQuadrantModeT]):\n        \"\"\"Hooks for visiting set multi-quadrant mode token (G75).\"\"\"\n\n    class SetCoordinateAbsoluteTokenHooks(TokenHooksBase[SetAbsoluteNotationT]):\n        \"\"\"Hooks for visiting set coordinate absolute token (G90).\"\"\"\n\n    class SetCoordinateIncrementalTokenHooks(TokenHooksBase[SetIncrementalNotationT]):\n        \"\"\"Hooks for visiting set coordinate incremental token (G91).\"\"\"\n\n    class ImageNameTokenHooks(TokenHooksBase[ImageNameT]):\n        \"\"\"Hooks for visiting image name token (IN).\"\"\"\n\n    class InvalidTokenHooks(TokenHooksBase[InvalidTokenT]):\n        \"\"\"Hooks for visiting invalid token.\"\"\"\n\n    class ImagePolarityTokenHooks(TokenHooksBase[ImagePolarityT]):\n        \"\"\"Hooks for visiting image polarity token (IP).\"\"\"\n\n    class LoadMirroringTokenHooks(TokenHooksBase[LoadMirroringT]):\n        \"\"\"Hooks for visiting load mirroring token (LM).\"\"\"\n\n    class LoadNameTokenHooks(TokenHooksBase[LoadNameT]):\n        \"\"\"Hooks for visiting load name token (LN).\"\"\"\n\n    class LoadPolarityTokenHooks(TokenHooksBase[LoadPolarityT]):\n        \"\"\"Hooks for visiting load polarity token (LP).\"\"\"\n\n    class LoadRotationTokenHooks(TokenHooksBase[LoadRotationT]):\n        \"\"\"Hooks for visiting load rotation token (LR).\"\"\"\n\n    class LoadScalingTokenHooks(TokenHooksBase[LoadScalingT]):\n        \"\"\"Hooks for visiting load scaling token (LS).\"\"\"\n\n    class ProgramStopTokenHooks(TokenHooksBase[M00ProgramStopT]):\n        \"\"\"Hooks for visiting program stop token (M00).\"\"\"\n\n    class OptionalStopTokenHooks(TokenHooksBase[M01OptionalStopT]):\n        \"\"\"Hooks for visiting optional stop token (M01).\"\"\"\n\n    class EndOfFileTokenHooks(TokenHooksBase[M02EndOfFileT]):\n        \"\"\"Hooks for visiting end of file token (M02).\"\"\"\n\n    class UnitModeTokenHooks(TokenHooksBase[UnitModeT]):\n        \"\"\"Hooks for visiting unit mode token (MO).\"\"\"\n\n    class ImageOffsetTokenHooks(TokenHooksBase[ImageOffsetT]):\n        \"\"\"Hooks for visiting image offset token (OF).\"\"\"\n\n    class StepRepeatBeginTokenHooks(TokenHooksBase[StepRepeatBeginT]):\n        \"\"\"Hooks for visiting step and repeat begin token (SR).\"\"\"\n\n    class StepRepeatEndTokenHooks(TokenHooksBase[StepRepeatEndT]):\n        \"\"\"Hooks for visiting step and repeat end token (SR).\"\"\"\n\n    class ApertureAttributeHooks(TokenHooksBase[ApertureAttributeT]):\n        \"\"\"Hooks for visiting aperture attribute token (TA).\"\"\"\n\n    class DeleteAttributeHooks(TokenHooksBase[DeleteAttributeT]):\n        \"\"\"Hooks for visiting delete attribute token (TD).\"\"\"\n\n    class FileAttributeHooks(TokenHooksBase[FileAttributeT]):\n        \"\"\"Hooks for visiting file attribute token (TF).\"\"\"\n\n    class ObjectAttributeHooks(TokenHooksBase[ObjectAttributeT]):\n        \"\"\"Hooks for visiting object attribute token (TO).\"\"\"\n</code></pre>"},{"location":"gerber/introspection/1_ihooks_reference.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.MacroBeginTokenHooks","title":"MacroBeginTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[MacroBeginT]</code></p> <p>Hooks for visiting macro definition begin token (AM).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class MacroBeginTokenHooks(TokenHooksBase[MacroBeginT]):\n    \"\"\"Hooks for visiting macro definition begin token (AM).\"\"\"\n</code></pre>"},{"location":"gerber/introspection/1_ihooks_reference.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.MacroCode1CircleTokenHooks","title":"MacroCode1CircleTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[Code1CircleTokenT]</code></p> <p>Hooks for visiting macro primitive code 0 circle.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class MacroCode1CircleTokenHooks(TokenHooksBase[Code1CircleTokenT]):\n    \"\"\"Hooks for visiting macro primitive code 0 circle.\"\"\"\n</code></pre>"},{"location":"gerber/introspection/1_ihooks_reference.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.MacroCode2VectorLineTokenHooks","title":"MacroCode2VectorLineTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[Code2VectorLineTokenT]</code></p> <p>Hooks for visiting macro primitive code 2 vector line.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class MacroCode2VectorLineTokenHooks(TokenHooksBase[Code2VectorLineTokenT]):\n    \"\"\"Hooks for visiting macro primitive code 2 vector line.\"\"\"\n</code></pre>"},{"location":"gerber/introspection/1_ihooks_reference.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.MacroCode4OutlineTokenHooks","title":"MacroCode4OutlineTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[Code4OutlineTokenT]</code></p> <p>Hooks for visiting macro primitive code 4 outline.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class MacroCode4OutlineTokenHooks(TokenHooksBase[Code4OutlineTokenT]):\n    \"\"\"Hooks for visiting macro primitive code 4 outline.\"\"\"\n</code></pre>"},{"location":"gerber/introspection/1_ihooks_reference.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.MacroCode5PolygonTokenHooks","title":"MacroCode5PolygonTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[Code5PolygonTokenT]</code></p> <p>Hooks for visiting macro primitive code 5 polygon.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class MacroCode5PolygonTokenHooks(TokenHooksBase[Code5PolygonTokenT]):\n    \"\"\"Hooks for visiting macro primitive code 5 polygon.\"\"\"\n</code></pre>"},{"location":"gerber/introspection/1_ihooks_reference.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.MacroCode6MoireTokenHooks","title":"MacroCode6MoireTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[Code6MoireTokenT]</code></p> <p>Hooks for visiting macro primitive code 6 moire.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class MacroCode6MoireTokenHooks(TokenHooksBase[Code6MoireTokenT]):\n    \"\"\"Hooks for visiting macro primitive code 6 moire.\"\"\"\n</code></pre>"},{"location":"gerber/introspection/1_ihooks_reference.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.MacroCode7ThermalTokenHooks","title":"MacroCode7ThermalTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[Code7ThermalTokenT]</code></p> <p>Hooks for visiting macro primitive code 7 thermal.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class MacroCode7ThermalTokenHooks(TokenHooksBase[Code7ThermalTokenT]):\n    \"\"\"Hooks for visiting macro primitive code 7 thermal.\"\"\"\n</code></pre>"},{"location":"gerber/introspection/1_ihooks_reference.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.MacroCode20VectorLineTokenHooks","title":"MacroCode20VectorLineTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[Code20VectorLineTokenT]</code></p> <p>Hooks for visiting macro primitive code 20 vector line.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class MacroCode20VectorLineTokenHooks(TokenHooksBase[Code20VectorLineTokenT]):\n    \"\"\"Hooks for visiting macro primitive code 20 vector line.\"\"\"\n</code></pre>"},{"location":"gerber/introspection/1_ihooks_reference.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.MacroCode21CenterLineTokenHooks","title":"MacroCode21CenterLineTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[Code21CenterLineTokenT]</code></p> <p>Hooks for visiting macro primitive code 21 center line.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class MacroCode21CenterLineTokenHooks(TokenHooksBase[Code21CenterLineTokenT]):\n    \"\"\"Hooks for visiting macro primitive code 21 center line.\"\"\"\n</code></pre>"},{"location":"gerber/introspection/1_ihooks_reference.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.MacroCode22LowerLeftLineTokenHooks","title":"MacroCode22LowerLeftLineTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[Code22LowerLeftLineTokenT]</code></p> <p>Hooks for visiting macro primitive code 22 lower left line.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class MacroCode22LowerLeftLineTokenHooks(TokenHooksBase[Code22LowerLeftLineTokenT]):\n    \"\"\"Hooks for visiting macro primitive code 22 lower left line.\"\"\"\n</code></pre>"},{"location":"gerber/introspection/1_ihooks_reference.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.MacroVariableAssignment","title":"MacroVariableAssignment","text":"<p>             Bases: <code>TokenHooksBase[MacroVariableAssignmentT]</code></p> <p>Hooks for visiting macro variable assignment token.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class MacroVariableAssignment(TokenHooksBase[MacroVariableAssignmentT]):\n    \"\"\"Hooks for visiting macro variable assignment token.\"\"\"\n</code></pre>"},{"location":"gerber/introspection/1_ihooks_reference.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.MacroDefinitionTokenHooks","title":"MacroDefinitionTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[MacroDefinitionT]</code></p> <p>Hooks for visiting macro definition token (AM).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class MacroDefinitionTokenHooks(TokenHooksBase[MacroDefinitionT]):\n    \"\"\"Hooks for visiting macro definition token (AM).\"\"\"\n</code></pre>"},{"location":"gerber/introspection/1_ihooks_reference.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.MacroEvalHooks","title":"MacroEvalHooks","text":"<p>Hooks called when evaluating macro aperture.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class MacroEvalHooks:\n    \"\"\"Hooks called when evaluating macro aperture.\"\"\"\n\n    def on_code_1_circle(\n        self,\n        context: Parser2Context,\n        primitive: Code1Circle2,\n    ) -&gt; None:\n        \"\"\"Evaluate code 1 circle primitive.\"\"\"\n\n    def on_code_2_vector_line(\n        self,\n        context: Parser2Context,\n        primitive: Code2VectorLine2,\n    ) -&gt; None:\n        \"\"\"Evaluate code 2 vector line primitive.\"\"\"\n\n    def on_code_4_outline(\n        self,\n        context: Parser2Context,\n        primitive: Code4Outline2,\n    ) -&gt; None:\n        \"\"\"Evaluate code 4 outline primitive.\"\"\"\n\n    def on_code_5_polygon(\n        self,\n        context: Parser2Context,\n        primitive: Code5Polygon2,\n    ) -&gt; None:\n        \"\"\"Evaluate code 5 polygon primitive.\"\"\"\n\n    def on_code_6_moire(\n        self,\n        context: Parser2Context,\n        primitive: Code6Moire2,\n    ) -&gt; None:\n        \"\"\"Evaluate code 6 moire primitive.\"\"\"\n\n    def on_code_7_thermal(\n        self,\n        context: Parser2Context,\n        primitive: Code7Thermal2,\n    ) -&gt; None:\n        \"\"\"Evaluate code 7 thermal primitive.\"\"\"\n\n    def on_code_20_vector_line(\n        self,\n        context: Parser2Context,\n        primitive: Code20VectorLine2,\n    ) -&gt; None:\n        \"\"\"Evaluate code 20 vector line primitive.\"\"\"\n\n    def on_code_21_center_line(\n        self,\n        context: Parser2Context,\n        primitive: Code21CenterLine2,\n    ) -&gt; None:\n        \"\"\"Evaluate code 21 center line primitive.\"\"\"\n\n    def on_code_22_lower_left_line(\n        self,\n        context: Parser2Context,\n        primitive: Code22LowerLeftLine2,\n    ) -&gt; None:\n        \"\"\"Evaluate code 22 lower left line primitive.\"\"\"\n\n    def on_assignment(\n        self,\n        context: Parser2Context,\n        assignment: Assignment2,\n    ) -&gt; None:\n        \"\"\"Evaluate macro variable assignment statement.\"\"\"\n</code></pre>"},{"location":"gerber/introspection/1_ihooks_reference.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.MacroEvalHooks.on_code_1_circle","title":"on_code_1_circle","text":"<pre><code>on_code_1_circle(\n    context: Parser2Context, primitive: Code1Circle2\n) -&gt; None\n</code></pre> <p>Evaluate code 1 circle primitive.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>def on_code_1_circle(\n    self,\n    context: Parser2Context,\n    primitive: Code1Circle2,\n) -&gt; None:\n    \"\"\"Evaluate code 1 circle primitive.\"\"\"\n</code></pre>"},{"location":"gerber/introspection/1_ihooks_reference.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.MacroEvalHooks.on_code_2_vector_line","title":"on_code_2_vector_line","text":"<pre><code>on_code_2_vector_line(\n    context: Parser2Context, primitive: Code2VectorLine2\n) -&gt; None\n</code></pre> <p>Evaluate code 2 vector line primitive.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>def on_code_2_vector_line(\n    self,\n    context: Parser2Context,\n    primitive: Code2VectorLine2,\n) -&gt; None:\n    \"\"\"Evaluate code 2 vector line primitive.\"\"\"\n</code></pre>"},{"location":"gerber/introspection/1_ihooks_reference.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.MacroEvalHooks.on_code_4_outline","title":"on_code_4_outline","text":"<pre><code>on_code_4_outline(\n    context: Parser2Context, primitive: Code4Outline2\n) -&gt; None\n</code></pre> <p>Evaluate code 4 outline primitive.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>def on_code_4_outline(\n    self,\n    context: Parser2Context,\n    primitive: Code4Outline2,\n) -&gt; None:\n    \"\"\"Evaluate code 4 outline primitive.\"\"\"\n</code></pre>"},{"location":"gerber/introspection/1_ihooks_reference.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.MacroEvalHooks.on_code_5_polygon","title":"on_code_5_polygon","text":"<pre><code>on_code_5_polygon(\n    context: Parser2Context, primitive: Code5Polygon2\n) -&gt; None\n</code></pre> <p>Evaluate code 5 polygon primitive.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>def on_code_5_polygon(\n    self,\n    context: Parser2Context,\n    primitive: Code5Polygon2,\n) -&gt; None:\n    \"\"\"Evaluate code 5 polygon primitive.\"\"\"\n</code></pre>"},{"location":"gerber/introspection/1_ihooks_reference.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.MacroEvalHooks.on_code_6_moire","title":"on_code_6_moire","text":"<pre><code>on_code_6_moire(\n    context: Parser2Context, primitive: Code6Moire2\n) -&gt; None\n</code></pre> <p>Evaluate code 6 moire primitive.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>def on_code_6_moire(\n    self,\n    context: Parser2Context,\n    primitive: Code6Moire2,\n) -&gt; None:\n    \"\"\"Evaluate code 6 moire primitive.\"\"\"\n</code></pre>"},{"location":"gerber/introspection/1_ihooks_reference.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.MacroEvalHooks.on_code_7_thermal","title":"on_code_7_thermal","text":"<pre><code>on_code_7_thermal(\n    context: Parser2Context, primitive: Code7Thermal2\n) -&gt; None\n</code></pre> <p>Evaluate code 7 thermal primitive.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>def on_code_7_thermal(\n    self,\n    context: Parser2Context,\n    primitive: Code7Thermal2,\n) -&gt; None:\n    \"\"\"Evaluate code 7 thermal primitive.\"\"\"\n</code></pre>"},{"location":"gerber/introspection/1_ihooks_reference.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.MacroEvalHooks.on_code_20_vector_line","title":"on_code_20_vector_line","text":"<pre><code>on_code_20_vector_line(\n    context: Parser2Context, primitive: Code20VectorLine2\n) -&gt; None\n</code></pre> <p>Evaluate code 20 vector line primitive.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>def on_code_20_vector_line(\n    self,\n    context: Parser2Context,\n    primitive: Code20VectorLine2,\n) -&gt; None:\n    \"\"\"Evaluate code 20 vector line primitive.\"\"\"\n</code></pre>"},{"location":"gerber/introspection/1_ihooks_reference.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.MacroEvalHooks.on_code_21_center_line","title":"on_code_21_center_line","text":"<pre><code>on_code_21_center_line(\n    context: Parser2Context, primitive: Code21CenterLine2\n) -&gt; None\n</code></pre> <p>Evaluate code 21 center line primitive.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>def on_code_21_center_line(\n    self,\n    context: Parser2Context,\n    primitive: Code21CenterLine2,\n) -&gt; None:\n    \"\"\"Evaluate code 21 center line primitive.\"\"\"\n</code></pre>"},{"location":"gerber/introspection/1_ihooks_reference.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.MacroEvalHooks.on_code_22_lower_left_line","title":"on_code_22_lower_left_line","text":"<pre><code>on_code_22_lower_left_line(\n    context: Parser2Context, primitive: Code22LowerLeftLine2\n) -&gt; None\n</code></pre> <p>Evaluate code 22 lower left line primitive.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>def on_code_22_lower_left_line(\n    self,\n    context: Parser2Context,\n    primitive: Code22LowerLeftLine2,\n) -&gt; None:\n    \"\"\"Evaluate code 22 lower left line primitive.\"\"\"\n</code></pre>"},{"location":"gerber/introspection/1_ihooks_reference.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.MacroEvalHooks.on_assignment","title":"on_assignment","text":"<pre><code>on_assignment(\n    context: Parser2Context, assignment: Assignment2\n) -&gt; None\n</code></pre> <p>Evaluate macro variable assignment statement.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>def on_assignment(\n    self,\n    context: Parser2Context,\n    assignment: Assignment2,\n) -&gt; None:\n    \"\"\"Evaluate macro variable assignment statement.\"\"\"\n</code></pre>"},{"location":"gerber/introspection/1_ihooks_reference.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.BeginBlockApertureTokenHooks","title":"BeginBlockApertureTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[BlockApertureBeginT]</code></p> <p>Hooks for visiting begin block aperture token (AB).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class BeginBlockApertureTokenHooks(TokenHooksBase[BlockApertureBeginT]):\n    \"\"\"Hooks for visiting begin block aperture token (AB).\"\"\"\n</code></pre>"},{"location":"gerber/introspection/1_ihooks_reference.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.EndBlockApertureTokenHooks","title":"EndBlockApertureTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[BlockApertureEndT]</code></p> <p>Hooks for visiting end block aperture token (AB).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class EndBlockApertureTokenHooks(TokenHooksBase[BlockApertureEndT]):\n    \"\"\"Hooks for visiting end block aperture token (AB).\"\"\"\n</code></pre>"},{"location":"gerber/introspection/1_ihooks_reference.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.DefineApertureCircleTokenHooks","title":"DefineApertureCircleTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[DefineCircleT]</code></p> <p>Hooks for visiting circle aperture definition token (ADD).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class DefineApertureCircleTokenHooks(TokenHooksBase[DefineCircleT]):\n    \"\"\"Hooks for visiting circle aperture definition token (ADD).\"\"\"\n</code></pre>"},{"location":"gerber/introspection/1_ihooks_reference.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.DefineApertureRectangleTokenHooks","title":"DefineApertureRectangleTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[DefineRectangleT]</code></p> <p>Hooks for visiting rectangle aperture definition token (ADD).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class DefineApertureRectangleTokenHooks(TokenHooksBase[DefineRectangleT]):\n    \"\"\"Hooks for visiting rectangle aperture definition token (ADD).\"\"\"\n</code></pre>"},{"location":"gerber/introspection/1_ihooks_reference.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.DefineApertureObroundTokenHooks","title":"DefineApertureObroundTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[DefineObroundT]</code></p> <p>Hooks for visiting obround aperture definition token (ADD).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class DefineApertureObroundTokenHooks(TokenHooksBase[DefineObroundT]):\n    \"\"\"Hooks for visiting obround aperture definition token (ADD).\"\"\"\n</code></pre>"},{"location":"gerber/introspection/1_ihooks_reference.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.DefineAperturePolygonTokenHooks","title":"DefineAperturePolygonTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[DefinePolygonT]</code></p> <p>Hooks for visiting polygon aperture definition token (ADD).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class DefineAperturePolygonTokenHooks(TokenHooksBase[DefinePolygonT]):\n    \"\"\"Hooks for visiting polygon aperture definition token (ADD).\"\"\"\n</code></pre>"},{"location":"gerber/introspection/1_ihooks_reference.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.DefineApertureMacroTokenHooks","title":"DefineApertureMacroTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[DefineMacroT]</code></p> <p>Hooks for visiting macro aperture definition token (ADD).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class DefineApertureMacroTokenHooks(TokenHooksBase[DefineMacroT]):\n    \"\"\"Hooks for visiting macro aperture definition token (ADD).\"\"\"\n</code></pre>"},{"location":"gerber/introspection/1_ihooks_reference.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.DefineApertureTokenHooks","title":"DefineApertureTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[DefineAnyT]</code></p> <p>Hooks for visiting any aperture definition token (ADD).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class DefineApertureTokenHooks(TokenHooksBase[DefineAnyT]):\n    \"\"\"Hooks for visiting any aperture definition token (ADD).\"\"\"\n</code></pre>"},{"location":"gerber/introspection/1_ihooks_reference.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.AxisSelectTokenHooksTokenHooks","title":"AxisSelectTokenHooksTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[AxisSelectT]</code></p> <p>Hooks for visiting axis select token (AS).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class AxisSelectTokenHooksTokenHooks(TokenHooksBase[AxisSelectT]):\n    \"\"\"Hooks for visiting axis select token (AS).\"\"\"\n</code></pre>"},{"location":"gerber/introspection/1_ihooks_reference.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.CommandDrawTokenHooks","title":"CommandDrawTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[D01DrawT]</code></p> <p>Hooks for visiting draw token (D01).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class CommandDrawTokenHooks(TokenHooksBase[D01DrawT]):\n    \"\"\"Hooks for visiting draw token (D01).\"\"\"\n</code></pre>"},{"location":"gerber/introspection/1_ihooks_reference.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.CommandMoveTokenHooks","title":"CommandMoveTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[D02MoveT]</code></p> <p>Hooks for visiting move token (D02).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class CommandMoveTokenHooks(TokenHooksBase[D02MoveT]):\n    \"\"\"Hooks for visiting move token (D02).\"\"\"\n</code></pre>"},{"location":"gerber/introspection/1_ihooks_reference.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.CommandFlashTokenHooks","title":"CommandFlashTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[D03FlashT]</code></p> <p>Hooks for visiting flash token (D03).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class CommandFlashTokenHooks(TokenHooksBase[D03FlashT]):\n    \"\"\"Hooks for visiting flash token (D03).\"\"\"\n</code></pre>"},{"location":"gerber/introspection/1_ihooks_reference.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.SelectApertureTokenHooks","title":"SelectApertureTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[DNNSelectApertureT]</code></p> <p>Hooks for visiting select aperture token (DNN).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class SelectApertureTokenHooks(TokenHooksBase[DNNSelectApertureT]):\n    \"\"\"Hooks for visiting select aperture token (DNN).\"\"\"\n</code></pre>"},{"location":"gerber/introspection/1_ihooks_reference.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.CoordinateFormatTokenHooks","title":"CoordinateFormatTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[CoordinateFormatT]</code></p> <p>Hooks for visiting coordinate format token (FS).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class CoordinateFormatTokenHooks(TokenHooksBase[CoordinateFormatT]):\n    \"\"\"Hooks for visiting coordinate format token (FS).\"\"\"\n</code></pre>"},{"location":"gerber/introspection/1_ihooks_reference.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.SetLinearTokenHooks","title":"SetLinearTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[SetLinearT]</code></p> <p>Hooks for visiting set linear token (G01).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class SetLinearTokenHooks(TokenHooksBase[SetLinearT]):\n    \"\"\"Hooks for visiting set linear token (G01).\"\"\"\n</code></pre>"},{"location":"gerber/introspection/1_ihooks_reference.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.SetClockwiseCircularTokenHooks","title":"SetClockwiseCircularTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[SetClockwiseCircularT]</code></p> <p>Hooks for visiting set clockwise circular token (G02).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class SetClockwiseCircularTokenHooks(TokenHooksBase[SetClockwiseCircularT]):\n    \"\"\"Hooks for visiting set clockwise circular token (G02).\"\"\"\n</code></pre>"},{"location":"gerber/introspection/1_ihooks_reference.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.SetCounterClockwiseCircularTokenHooks","title":"SetCounterClockwiseCircularTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[SetCounterclockwiseCircularT]</code></p> <p>Hooks for visiting set counter clockwise circular token (G03).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class SetCounterClockwiseCircularTokenHooks(\n    TokenHooksBase[SetCounterclockwiseCircularT],\n):\n    \"\"\"Hooks for visiting set counter clockwise circular token (G03).\"\"\"\n</code></pre>"},{"location":"gerber/introspection/1_ihooks_reference.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.CommentTokenHooks","title":"CommentTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[CommentT]</code></p> <p>Hooks for visiting comment token (G04).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class CommentTokenHooks(TokenHooksBase[CommentT]):\n    \"\"\"Hooks for visiting comment token (G04).\"\"\"\n</code></pre>"},{"location":"gerber/introspection/1_ihooks_reference.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.BeginRegionTokenHooks","title":"BeginRegionTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[BeginRegionT]</code></p> <p>Hooks for visiting begin region token (G36).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class BeginRegionTokenHooks(TokenHooksBase[BeginRegionT]):\n    \"\"\"Hooks for visiting begin region token (G36).\"\"\"\n</code></pre>"},{"location":"gerber/introspection/1_ihooks_reference.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.EndRegionTokenHooks","title":"EndRegionTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[EndRegionT]</code></p> <p>Hooks for visiting end region token (G37).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class EndRegionTokenHooks(TokenHooksBase[EndRegionT]):\n    \"\"\"Hooks for visiting end region token (G37).\"\"\"\n</code></pre>"},{"location":"gerber/introspection/1_ihooks_reference.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.PrepareSelectApertureTokenHooks","title":"PrepareSelectApertureTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[G54SelectApertureT]</code></p> <p>Hooks for visiting prepare select aperture token (G54).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class PrepareSelectApertureTokenHooks(TokenHooksBase[G54SelectApertureT]):\n    \"\"\"Hooks for visiting prepare select aperture token (G54).\"\"\"\n</code></pre>"},{"location":"gerber/introspection/1_ihooks_reference.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.SetUnitInchTokenHooks","title":"SetUnitInchTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[SetUnitInchT]</code></p> <p>Hooks for visiting set unit inch token (G70).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class SetUnitInchTokenHooks(TokenHooksBase[SetUnitInchT]):\n    \"\"\"Hooks for visiting set unit inch token (G70).\"\"\"\n</code></pre>"},{"location":"gerber/introspection/1_ihooks_reference.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.SetUnitMillimetersTokenHooks","title":"SetUnitMillimetersTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[SetUnitMillimetersT]</code></p> <p>Hooks for visiting set unit millimeters token (G71).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class SetUnitMillimetersTokenHooks(TokenHooksBase[SetUnitMillimetersT]):\n    \"\"\"Hooks for visiting set unit millimeters token (G71).\"\"\"\n</code></pre>"},{"location":"gerber/introspection/1_ihooks_reference.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.SetSingleQuadrantModeTokenHooks","title":"SetSingleQuadrantModeTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[SetSingleQuadrantModeT]</code></p> <p>Hooks for visiting set single-quadrant mode token (G74).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class SetSingleQuadrantModeTokenHooks(TokenHooksBase[SetSingleQuadrantModeT]):\n    \"\"\"Hooks for visiting set single-quadrant mode token (G74).\"\"\"\n</code></pre>"},{"location":"gerber/introspection/1_ihooks_reference.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.SetMultiQuadrantModeTokenHooks","title":"SetMultiQuadrantModeTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[SetMultiQuadrantModeT]</code></p> <p>Hooks for visiting set multi-quadrant mode token (G75).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class SetMultiQuadrantModeTokenHooks(TokenHooksBase[SetMultiQuadrantModeT]):\n    \"\"\"Hooks for visiting set multi-quadrant mode token (G75).\"\"\"\n</code></pre>"},{"location":"gerber/introspection/1_ihooks_reference.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.SetCoordinateAbsoluteTokenHooks","title":"SetCoordinateAbsoluteTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[SetAbsoluteNotationT]</code></p> <p>Hooks for visiting set coordinate absolute token (G90).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class SetCoordinateAbsoluteTokenHooks(TokenHooksBase[SetAbsoluteNotationT]):\n    \"\"\"Hooks for visiting set coordinate absolute token (G90).\"\"\"\n</code></pre>"},{"location":"gerber/introspection/1_ihooks_reference.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.SetCoordinateIncrementalTokenHooks","title":"SetCoordinateIncrementalTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[SetIncrementalNotationT]</code></p> <p>Hooks for visiting set coordinate incremental token (G91).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class SetCoordinateIncrementalTokenHooks(TokenHooksBase[SetIncrementalNotationT]):\n    \"\"\"Hooks for visiting set coordinate incremental token (G91).\"\"\"\n</code></pre>"},{"location":"gerber/introspection/1_ihooks_reference.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.ImageNameTokenHooks","title":"ImageNameTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[ImageNameT]</code></p> <p>Hooks for visiting image name token (IN).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class ImageNameTokenHooks(TokenHooksBase[ImageNameT]):\n    \"\"\"Hooks for visiting image name token (IN).\"\"\"\n</code></pre>"},{"location":"gerber/introspection/1_ihooks_reference.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.InvalidTokenHooks","title":"InvalidTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[InvalidTokenT]</code></p> <p>Hooks for visiting invalid token.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class InvalidTokenHooks(TokenHooksBase[InvalidTokenT]):\n    \"\"\"Hooks for visiting invalid token.\"\"\"\n</code></pre>"},{"location":"gerber/introspection/1_ihooks_reference.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.ImagePolarityTokenHooks","title":"ImagePolarityTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[ImagePolarityT]</code></p> <p>Hooks for visiting image polarity token (IP).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class ImagePolarityTokenHooks(TokenHooksBase[ImagePolarityT]):\n    \"\"\"Hooks for visiting image polarity token (IP).\"\"\"\n</code></pre>"},{"location":"gerber/introspection/1_ihooks_reference.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.LoadMirroringTokenHooks","title":"LoadMirroringTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[LoadMirroringT]</code></p> <p>Hooks for visiting load mirroring token (LM).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class LoadMirroringTokenHooks(TokenHooksBase[LoadMirroringT]):\n    \"\"\"Hooks for visiting load mirroring token (LM).\"\"\"\n</code></pre>"},{"location":"gerber/introspection/1_ihooks_reference.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.LoadNameTokenHooks","title":"LoadNameTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[LoadNameT]</code></p> <p>Hooks for visiting load name token (LN).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class LoadNameTokenHooks(TokenHooksBase[LoadNameT]):\n    \"\"\"Hooks for visiting load name token (LN).\"\"\"\n</code></pre>"},{"location":"gerber/introspection/1_ihooks_reference.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.LoadPolarityTokenHooks","title":"LoadPolarityTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[LoadPolarityT]</code></p> <p>Hooks for visiting load polarity token (LP).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class LoadPolarityTokenHooks(TokenHooksBase[LoadPolarityT]):\n    \"\"\"Hooks for visiting load polarity token (LP).\"\"\"\n</code></pre>"},{"location":"gerber/introspection/1_ihooks_reference.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.LoadRotationTokenHooks","title":"LoadRotationTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[LoadRotationT]</code></p> <p>Hooks for visiting load rotation token (LR).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class LoadRotationTokenHooks(TokenHooksBase[LoadRotationT]):\n    \"\"\"Hooks for visiting load rotation token (LR).\"\"\"\n</code></pre>"},{"location":"gerber/introspection/1_ihooks_reference.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.LoadScalingTokenHooks","title":"LoadScalingTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[LoadScalingT]</code></p> <p>Hooks for visiting load scaling token (LS).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class LoadScalingTokenHooks(TokenHooksBase[LoadScalingT]):\n    \"\"\"Hooks for visiting load scaling token (LS).\"\"\"\n</code></pre>"},{"location":"gerber/introspection/1_ihooks_reference.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.ProgramStopTokenHooks","title":"ProgramStopTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[M00ProgramStopT]</code></p> <p>Hooks for visiting program stop token (M00).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class ProgramStopTokenHooks(TokenHooksBase[M00ProgramStopT]):\n    \"\"\"Hooks for visiting program stop token (M00).\"\"\"\n</code></pre>"},{"location":"gerber/introspection/1_ihooks_reference.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.OptionalStopTokenHooks","title":"OptionalStopTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[M01OptionalStopT]</code></p> <p>Hooks for visiting optional stop token (M01).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class OptionalStopTokenHooks(TokenHooksBase[M01OptionalStopT]):\n    \"\"\"Hooks for visiting optional stop token (M01).\"\"\"\n</code></pre>"},{"location":"gerber/introspection/1_ihooks_reference.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.EndOfFileTokenHooks","title":"EndOfFileTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[M02EndOfFileT]</code></p> <p>Hooks for visiting end of file token (M02).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class EndOfFileTokenHooks(TokenHooksBase[M02EndOfFileT]):\n    \"\"\"Hooks for visiting end of file token (M02).\"\"\"\n</code></pre>"},{"location":"gerber/introspection/1_ihooks_reference.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.UnitModeTokenHooks","title":"UnitModeTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[UnitModeT]</code></p> <p>Hooks for visiting unit mode token (MO).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class UnitModeTokenHooks(TokenHooksBase[UnitModeT]):\n    \"\"\"Hooks for visiting unit mode token (MO).\"\"\"\n</code></pre>"},{"location":"gerber/introspection/1_ihooks_reference.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.ImageOffsetTokenHooks","title":"ImageOffsetTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[ImageOffsetT]</code></p> <p>Hooks for visiting image offset token (OF).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class ImageOffsetTokenHooks(TokenHooksBase[ImageOffsetT]):\n    \"\"\"Hooks for visiting image offset token (OF).\"\"\"\n</code></pre>"},{"location":"gerber/introspection/1_ihooks_reference.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.StepRepeatBeginTokenHooks","title":"StepRepeatBeginTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[StepRepeatBeginT]</code></p> <p>Hooks for visiting step and repeat begin token (SR).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class StepRepeatBeginTokenHooks(TokenHooksBase[StepRepeatBeginT]):\n    \"\"\"Hooks for visiting step and repeat begin token (SR).\"\"\"\n</code></pre>"},{"location":"gerber/introspection/1_ihooks_reference.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.StepRepeatEndTokenHooks","title":"StepRepeatEndTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[StepRepeatEndT]</code></p> <p>Hooks for visiting step and repeat end token (SR).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class StepRepeatEndTokenHooks(TokenHooksBase[StepRepeatEndT]):\n    \"\"\"Hooks for visiting step and repeat end token (SR).\"\"\"\n</code></pre>"},{"location":"gerber/introspection/1_ihooks_reference.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.ApertureAttributeHooks","title":"ApertureAttributeHooks","text":"<p>             Bases: <code>TokenHooksBase[ApertureAttributeT]</code></p> <p>Hooks for visiting aperture attribute token (TA).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class ApertureAttributeHooks(TokenHooksBase[ApertureAttributeT]):\n    \"\"\"Hooks for visiting aperture attribute token (TA).\"\"\"\n</code></pre>"},{"location":"gerber/introspection/1_ihooks_reference.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.DeleteAttributeHooks","title":"DeleteAttributeHooks","text":"<p>             Bases: <code>TokenHooksBase[DeleteAttributeT]</code></p> <p>Hooks for visiting delete attribute token (TD).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class DeleteAttributeHooks(TokenHooksBase[DeleteAttributeT]):\n    \"\"\"Hooks for visiting delete attribute token (TD).\"\"\"\n</code></pre>"},{"location":"gerber/introspection/1_ihooks_reference.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.FileAttributeHooks","title":"FileAttributeHooks","text":"<p>             Bases: <code>TokenHooksBase[FileAttributeT]</code></p> <p>Hooks for visiting file attribute token (TF).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class FileAttributeHooks(TokenHooksBase[FileAttributeT]):\n    \"\"\"Hooks for visiting file attribute token (TF).\"\"\"\n</code></pre>"},{"location":"gerber/introspection/1_ihooks_reference.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.ObjectAttributeHooks","title":"ObjectAttributeHooks","text":"<p>             Bases: <code>TokenHooksBase[ObjectAttributeT]</code></p> <p>Hooks for visiting object attribute token (TO).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class ObjectAttributeHooks(TokenHooksBase[ObjectAttributeT]):\n    \"\"\"Hooks for visiting object attribute token (TO).\"\"\"\n</code></pre>"},{"location":"gerber/introspection/1_ihooks_reference.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.on_parser_init","title":"on_parser_init","text":"<pre><code>on_parser_init(parser: Parser2) -&gt; None\n</code></pre> <p>Called after parser initialization.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>def on_parser_init(self, parser: Parser2) -&gt; None:\n    \"\"\"Called after parser initialization.\"\"\"\n</code></pre>"},{"location":"gerber/introspection/1_ihooks_reference.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.pre_parse","title":"pre_parse","text":"<pre><code>pre_parse(context: Parser2Context) -&gt; None\n</code></pre> <p>Called before parsing starts.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>def pre_parse(self, context: Parser2Context) -&gt; None:\n    \"\"\"Called before parsing starts.\"\"\"\n</code></pre>"},{"location":"gerber/introspection/1_ihooks_reference.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.post_parse","title":"post_parse","text":"<pre><code>post_parse(context: Parser2Context) -&gt; None\n</code></pre> <p>Called after parsing starts.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>def post_parse(self, context: Parser2Context) -&gt; None:\n    \"\"\"Called after parsing starts.\"\"\"\n</code></pre>"},{"location":"gerber/introspection/1_ihooks_reference.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.on_parser_error","title":"on_parser_error","text":"<pre><code>on_parser_error(\n    context: Parser2Context, error: Parser2Error\n) -&gt; None\n</code></pre> <p>Called when parsing error is thrown.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>def on_parser_error(self, context: Parser2Context, error: Parser2Error) -&gt; None:\n    \"\"\"Called when parsing error is thrown.\"\"\"\n</code></pre>"},{"location":"gerber/introspection/1_ihooks_reference.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.on_other_error","title":"on_other_error","text":"<pre><code>on_other_error(\n    context: Parser2Context, error: Exception\n) -&gt; None\n</code></pre> <p>Called when other error is thrown.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>def on_other_error(self, context: Parser2Context, error: Exception) -&gt; None:\n    \"\"\"Called when other error is thrown.\"\"\"\n</code></pre>"},{"location":"gerber/introspection/1_ihooks_reference.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.pre_parser_visit_any_token","title":"pre_parser_visit_any_token","text":"<pre><code>pre_parser_visit_any_token(context: Parser2Context) -&gt; None\n</code></pre> <p>Called before parser visits any token.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>def pre_parser_visit_any_token(self, context: Parser2Context) -&gt; None:\n    \"\"\"Called before parser visits any token.\"\"\"\n</code></pre>"},{"location":"gerber/introspection/1_ihooks_reference.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.post_parser_visit_any_token","title":"post_parser_visit_any_token","text":"<pre><code>post_parser_visit_any_token(\n    context: Parser2Context,\n) -&gt; None\n</code></pre> <p>Called after parser visits any token.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>def post_parser_visit_any_token(self, context: Parser2Context) -&gt; None:\n    \"\"\"Called after parser visits any token.\"\"\"\n</code></pre>"},{"location":"gerber_specification/RS-274X.html","title":"RS-274X 2001-03","text":""},{"location":"gerber_specification/revision_2013_J1.html","title":"Revision 2013-J1","text":""},{"location":"gerber_specification/revision_2016_01.html","title":"Revision 2016-01","text":""},{"location":"gerber_specification/revision_2017_05.html","title":"Revision 2017-05","text":""},{"location":"gerber_specification/revision_2020_09.html","title":"Revision 2020-09","text":""},{"location":"gerber_specification/revision_2021_11.html","title":"Revision 2021-11","text":""},{"location":"gerber_specification/revision_2023_03.html","title":"Revision 2023-03","text":""},{"location":"gerber_specification/revision_2023_08.html","title":"Revision 2023-08","text":""},{"location":"reference/SUMMARY.html","title":"SUMMARY","text":"<ul> <li>pygerber<ul> <li>backend<ul> <li>abstract<ul> <li>aperture_handle</li> <li>backend_cls</li> <li>draw_commands<ul> <li>draw_arc</li> <li>draw_bounding_box</li> <li>draw_circle</li> <li>draw_command</li> <li>draw_paste</li> <li>draw_polygon</li> <li>draw_rectangle</li> <li>draw_region</li> <li>draw_vector_line</li> </ul> </li> <li>draw_commands_handle</li> <li>drawing_target</li> <li>errors</li> <li>result_handle</li> </ul> </li> <li>rasterized_2d<ul> <li>aperture_handle</li> <li>backend_cls</li> <li>color_scheme</li> <li>draw_commands<ul> <li>draw_arc</li> <li>draw_bounding_box</li> <li>draw_circle</li> <li>draw_paste</li> <li>draw_polygon</li> <li>draw_rectangle</li> <li>draw_region</li> <li>draw_vector_line</li> </ul> </li> <li>draw_commands_handle</li> <li>drawing_target</li> <li>errors</li> <li>image_tools</li> <li>result_handle</li> </ul> </li> </ul> </li> <li>common<ul> <li>error</li> <li>frozen_general_model</li> <li>general_model</li> <li>immutable_map_model</li> <li>position</li> <li>rgba</li> </ul> </li> <li>console<ul> <li>commands</li> <li>raster_2d_style</li> </ul> </li> <li>gerberx3<ul> <li>api<ul> <li>_errors</li> <li>_layers</li> </ul> </li> <li>language_server<ul> <li>_internals<ul> <li>document</li> <li>error</li> <li>errors</li> <li>server</li> </ul> </li> </ul> </li> <li>linter<ul> <li>diagnostic</li> </ul> </li> <li>math<ul> <li>bounding_box</li> <li>offset</li> <li>rotate_point</li> <li>vector_2d</li> </ul> </li> <li>optimizer<ul> <li>optimizer_pass</li> </ul> </li> <li>parser<ul> <li>errors</li> <li>parser</li> <li>state</li> </ul> </li> <li>parser2<ul> <li>apertures2<ul> <li>aperture2</li> <li>block2</li> <li>circle2</li> <li>macro2</li> <li>obround2</li> <li>polygon2</li> <li>rectangle2</li> </ul> </li> <li>attributes2</li> <li>command_buffer2</li> <li>commands2<ul> <li>aperture_draw_command2</li> <li>arc2</li> <li>buffer_command2</li> <li>command2</li> <li>flash2</li> <li>line2</li> <li>region2</li> </ul> </li> <li>context2</li> <li>errors2</li> <li>macro2<ul> <li>assignment2</li> <li>element2</li> <li>enums</li> <li>expressions2<ul> <li>binary2</li> <li>constant2</li> <li>expression2</li> <li>unary2</li> <li>variable_name</li> </ul> </li> <li>macro2</li> <li>point2</li> <li>primitives2<ul> <li>code_1_circle2</li> <li>code_20_vector_line2</li> <li>code_21_center_line2</li> <li>code_22_lower_left_line2</li> <li>code_2_vector_line2</li> <li>code_4_outline2</li> <li>code_5_polygon2</li> <li>code_6_moire2</li> <li>code_7_thermal2</li> <li>primitive2</li> </ul> </li> <li>statement2</li> <li>statement_buffer2</li> </ul> </li> <li>parser2</li> <li>parser2hooks</li> <li>parser2hooks_base</li> <li>state2</li> </ul> </li> <li>renderer2<ul> <li>abstract</li> <li>errors2</li> <li>svg</li> </ul> </li> <li>revisions</li> <li>state_enums</li> <li>tokenizer<ul> <li>aperture_id</li> <li>decorators</li> <li>errors</li> <li>grammar</li> <li>helpers<ul> <li>gerber_code_enum</li> </ul> </li> <li>tokenizer</li> <li>tokens<ul> <li>ab_block_aperture</li> <li>ad_define_aperture</li> <li>as_axis_select</li> <li>attribute_token</li> <li>bases<ul> <li>command</li> <li>extended_command</li> <li>gerber_code</li> <li>group</li> <li>token</li> <li>token_accessor</li> </ul> </li> <li>coordinate</li> <li>d01_draw</li> <li>d02_move</li> <li>d03_flash</li> <li>dnn_select_aperture</li> <li>end_of_expression</li> <li>fs_coordinate_format</li> <li>g01_set_linear</li> <li>g02_set_clockwise_circular</li> <li>g03_set_counterclockwise_circular</li> <li>g04_comment</li> <li>g36_begin_region</li> <li>g37_end_region</li> <li>g54_select_aperture</li> <li>g70_set_unit_inch</li> <li>g71_set_unit_mm</li> <li>g74_single_quadrant</li> <li>g75_multi_quadrant</li> <li>g90_set_coordinate_absolute</li> <li>g91_set_coordinate_incremental</li> <li>groups<ul> <li>ast</li> <li>statement</li> </ul> </li> <li>in_image_name</li> <li>invalid_token</li> <li>ip_image_polarity</li> <li>lm_load_mirroring</li> <li>ln_load_name</li> <li>lp_load_polarity</li> <li>lr_load_rotation</li> <li>ls_load_scaling</li> <li>m00_program_stop</li> <li>m01_optional_stop</li> <li>m02_end_of_file</li> <li>macro<ul> <li>am_macro</li> <li>expressions<ul> <li>binary</li> <li>errors</li> <li>macro_expression</li> <li>numeric_constant</li> <li>unary</li> <li>variable_name</li> </ul> </li> <li>macro_begin</li> <li>macro_context</li> <li>point</li> <li>statements<ul> <li>code_1_circle</li> <li>code_20_vector_line</li> <li>code_21_center_line</li> <li>code_22_lower_left_line</li> <li>code_2_vector_line</li> <li>code_4_outline</li> <li>code_5_polygon</li> <li>code_6_moire</li> <li>code_7_thermal</li> <li>comment</li> <li>primitive</li> <li>statement</li> <li>variable_assignment</li> </ul> </li> </ul> </li> <li>mo_unit_mode</li> <li>of_image_offset</li> <li>sr_step_repeat</li> <li>ta_aperture_attribute</li> <li>td_delete_attribute</li> <li>tf_file_attribute</li> <li>to_object_attribute</li> </ul> </li> </ul> </li> </ul> </li> <li>sequence_tools</li> <li>warnings</li> </ul> </li> </ul>"},{"location":"reference/pygerber/__init__.html","title":"init","text":""},{"location":"reference/pygerber/__init__.html#pygerber","title":"pygerber","text":"<p>Package for PCB formats visualization.</p>"},{"location":"reference/pygerber/sequence_tools.html","title":"sequence_tools","text":""},{"location":"reference/pygerber/sequence_tools.html#pygerber.sequence_tools","title":"sequence_tools","text":"<p>Convenience tools for operating on sequences.</p>"},{"location":"reference/pygerber/sequence_tools.html#pygerber.sequence_tools.flatten_list","title":"flatten_list","text":"<pre><code>flatten_list(sequence: list[T]) -&gt; list[T]\n</code></pre> <p>Flatten a sequence.</p> Source code in <code>src/pygerber/sequence_tools.py</code> <pre><code>def flatten_list(sequence: list[T]) -&gt; list[T]:\n    \"\"\"Flatten a sequence.\"\"\"\n    out = []\n\n    for item in sequence:\n        if isinstance(item, list):\n            out.extend(flatten_list(item))\n        else:\n            out.append(item)\n\n    return out\n</code></pre>"},{"location":"reference/pygerber/sequence_tools.html#pygerber.sequence_tools.flatten","title":"flatten","text":"<pre><code>flatten(sequence: Iterable[T]) -&gt; Iterable[T]\n</code></pre> <p>Flatten a sequence.</p> Source code in <code>src/pygerber/sequence_tools.py</code> <pre><code>def flatten(sequence: Iterable[T]) -&gt; Iterable[T]:\n    \"\"\"Flatten a sequence.\"\"\"\n    for item in sequence:\n        if isinstance(item, (list, tuple)):\n            yield from flatten(item)\n        else:\n            yield item\n</code></pre>"},{"location":"reference/pygerber/sequence_tools.html#pygerber.sequence_tools.unwrap","title":"unwrap","text":"<pre><code>unwrap(item: T) -&gt; T\n</code></pre> <p>Unwrap item wrapped in sequences.</p> Source code in <code>src/pygerber/sequence_tools.py</code> <pre><code>def unwrap(item: T) -&gt; T:\n    \"\"\"Unwrap item wrapped in sequences.\"\"\"\n    try:\n        while isinstance(item, (list, tuple, ParseResults)):\n            item = item[0]\n    except (TypeError, IndexError):\n        pass\n\n    return item\n</code></pre>"},{"location":"reference/pygerber/warnings.html","title":"warnings","text":""},{"location":"reference/pygerber/warnings.html#pygerber.warnings","title":"warnings","text":"<p>Tools for displaying warnings.</p>"},{"location":"reference/pygerber/warnings.html#pygerber.warnings.warn_deprecated_code","title":"warn_deprecated_code","text":"<pre><code>warn_deprecated_code(code: str, spec_section: str) -&gt; None\n</code></pre> <p>Display warning about deprecated code.</p> Source code in <code>src/pygerber/warnings.py</code> <pre><code>def warn_deprecated_code(code: str, spec_section: str) -&gt; None:\n    \"\"\"Display warning about deprecated code.\"\"\"\n    logging.warning(\n        \"Detected deprecated code: %s. \"\n        \"See section %s of The Gerber Layer Format Specification Revision \"\n        \"2023.03 - https://argmaster.github.io/pygerber/latest/gerber_specification/revision_2023_03.html\",\n        code,\n        spec_section,\n    )\n</code></pre>"},{"location":"reference/pygerber/backend/__init__.html","title":"init","text":""},{"location":"reference/pygerber/backend/__init__.html#pygerber.backend","title":"backend","text":"<p>Drawing backends for Gerber files rendering.</p>"},{"location":"reference/pygerber/backend/__init__.html#pygerber.backend.BackendName","title":"BackendName","text":"<p>             Bases: <code>Enum</code></p> <p>Available rendering modes.</p> Source code in <code>src/pygerber/backend/__init__.py</code> <pre><code>class BackendName(Enum):\n    \"\"\"Available rendering modes.\"\"\"\n\n    Rasterized2D = \"rasterized_2d\"\n    Vector2D = \"vector_2d\"\n    Model3D = \"model_3d\"\n\n    @staticmethod\n    def get_backend_class(backend: str | BackendName) -&gt; type[Backend]:\n        \"\"\"Return backend class.\"\"\"\n        if str(backend) == BackendName.Rasterized2D.value:\n            return Rasterized2DBackend\n\n        raise BackendNotSupportedError(str(backend))\n\n    def __str__(self) -&gt; str:\n        return self.value\n</code></pre>"},{"location":"reference/pygerber/backend/__init__.html#pygerber.backend.BackendName.get_backend_class","title":"get_backend_class  <code>staticmethod</code>","text":"<pre><code>get_backend_class(\n    backend: str | BackendName,\n) -&gt; type[Backend]\n</code></pre> <p>Return backend class.</p> Source code in <code>src/pygerber/backend/__init__.py</code> <pre><code>@staticmethod\ndef get_backend_class(backend: str | BackendName) -&gt; type[Backend]:\n    \"\"\"Return backend class.\"\"\"\n    if str(backend) == BackendName.Rasterized2D.value:\n        return Rasterized2DBackend\n\n    raise BackendNotSupportedError(str(backend))\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/__init__.html","title":"init","text":""},{"location":"reference/pygerber/backend/abstract/__init__.html#pygerber.backend.abstract","title":"abstract","text":"<p>Abstract classes for building drawing implementations.</p>"},{"location":"reference/pygerber/backend/abstract/aperture_handle.html","title":"aperture_handle","text":""},{"location":"reference/pygerber/backend/abstract/aperture_handle.html#pygerber.backend.abstract.aperture_handle","title":"aperture_handle","text":"<p>Module contains classes-handles to drawing apertures.</p>"},{"location":"reference/pygerber/backend/abstract/aperture_handle.html#pygerber.backend.abstract.aperture_handle.PrivateApertureHandle","title":"PrivateApertureHandle","text":"<p>Base class for creating Gerber X3 apertures.</p> Source code in <code>src/pygerber/backend/abstract/aperture_handle.py</code> <pre><code>class PrivateApertureHandle:\n    \"\"\"Base class for creating Gerber X3 apertures.\"\"\"\n\n    drawing_target: DrawingTarget\n    bounding_box: BoundingBox\n\n    def __init__(\n        self,\n        aperture_id: ApertureID,\n        private_id: int,\n        backend: Backend,\n    ) -&gt; None:\n        \"\"\"Initialize aperture handle.\"\"\"\n        self.aperture_id = aperture_id\n        self.private_id = private_id\n        self.backend = backend\n        self.aperture_draws: list[DrawCommand] = []\n        self.is_plain_circle = True\n\n    def add_draw(self, draw: DrawCommand) -&gt; None:\n        \"\"\"Add circle to aperture.\"\"\"\n        if self.is_plain_circle and (\n            not isinstance(draw, DrawCircle) or len(self.aperture_draws) &gt; 1\n        ):\n            self.is_plain_circle = False\n        self.aperture_draws.append(draw)\n\n    def __enter__(self) -&gt; None:\n        pass\n\n    def __exit__(\n        self,\n        exc_type: Optional[type[BaseException]],\n        exc_value: Optional[BaseException],\n        traceback: Optional[TracebackType],\n    ) -&gt; None:\n        if exc_type is None:\n            self.bounding_box = self.get_bounding_box()\n            self.coordinate_origin = self._get_coordinate_origin()\n            self.drawing_target = self._create_drawing_target()\n\n    def finalize_aperture_creation(self) -&gt; None:\n        \"\"\"Draw aperture and store result.\"\"\"\n        with self.drawing_target:\n            for aperture_draw in self.aperture_draws:\n                aperture_draw.draw(self.drawing_target)\n\n        self._post_drawing_hook()\n\n    def get_bounding_box(self) -&gt; BoundingBox:\n        \"\"\"Return bounding box of draw operation.\"\"\"\n        return self._bounding_box\n\n    @cached_property\n    def _bounding_box(self) -&gt; BoundingBox:\n        bbox: Optional[BoundingBox] = None\n\n        for aperture_draw in self.aperture_draws:\n            if bbox is not None:\n                bbox += aperture_draw.get_bounding_box()\n            else:\n                bbox = aperture_draw.get_bounding_box()\n\n        if bbox is not None:\n            return bbox\n\n        return BoundingBox.NULL\n\n    def _get_coordinate_origin(self) -&gt; Vector2D:\n        return self.bounding_box.get_min_vector()\n\n    @abstractmethod\n    def _create_drawing_target(self) -&gt; DrawingTarget:\n        \"\"\"Create drawing target object.\"\"\"\n\n    def _post_drawing_hook(self) -&gt; None:\n        \"\"\"Perform custom actions after drawing.\"\"\"\n\n    def get_public_handle(self) -&gt; PublicApertureHandle:\n        \"\"\"Return immutable aperture handle.\"\"\"\n        return PublicApertureHandle(\n            aperture_id=self.aperture_id,\n            private_id=self.private_id,\n        )\n\n    def get_line_width(self) -&gt; Offset:\n        \"\"\"Width of line made with this aperture.\"\"\"\n        box = self.get_bounding_box()\n        return (box.height + box.width) / 2\n\n    @abstractmethod\n    def dump_aperture(self, dest: Path) -&gt; None:\n        \"\"\"Save aperture to local file, mainly for debugging purposes.\"\"\"\n\n    def __str__(self) -&gt; str:\n        return (\n            f\"{self.__class__.__qualname__}(aperture_id={self.aperture_id}, \"\n            f\"private_id={self.private_id})\"\n        )\n\n    __repr__ = __str__\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/aperture_handle.html#pygerber.backend.abstract.aperture_handle.PrivateApertureHandle.__init__","title":"__init__","text":"<pre><code>__init__(\n    aperture_id: ApertureID,\n    private_id: int,\n    backend: Backend,\n) -&gt; None\n</code></pre> <p>Initialize aperture handle.</p> Source code in <code>src/pygerber/backend/abstract/aperture_handle.py</code> <pre><code>def __init__(\n    self,\n    aperture_id: ApertureID,\n    private_id: int,\n    backend: Backend,\n) -&gt; None:\n    \"\"\"Initialize aperture handle.\"\"\"\n    self.aperture_id = aperture_id\n    self.private_id = private_id\n    self.backend = backend\n    self.aperture_draws: list[DrawCommand] = []\n    self.is_plain_circle = True\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/aperture_handle.html#pygerber.backend.abstract.aperture_handle.PrivateApertureHandle.add_draw","title":"add_draw","text":"<pre><code>add_draw(draw: DrawCommand) -&gt; None\n</code></pre> <p>Add circle to aperture.</p> Source code in <code>src/pygerber/backend/abstract/aperture_handle.py</code> <pre><code>def add_draw(self, draw: DrawCommand) -&gt; None:\n    \"\"\"Add circle to aperture.\"\"\"\n    if self.is_plain_circle and (\n        not isinstance(draw, DrawCircle) or len(self.aperture_draws) &gt; 1\n    ):\n        self.is_plain_circle = False\n    self.aperture_draws.append(draw)\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/aperture_handle.html#pygerber.backend.abstract.aperture_handle.PrivateApertureHandle.finalize_aperture_creation","title":"finalize_aperture_creation","text":"<pre><code>finalize_aperture_creation() -&gt; None\n</code></pre> <p>Draw aperture and store result.</p> Source code in <code>src/pygerber/backend/abstract/aperture_handle.py</code> <pre><code>def finalize_aperture_creation(self) -&gt; None:\n    \"\"\"Draw aperture and store result.\"\"\"\n    with self.drawing_target:\n        for aperture_draw in self.aperture_draws:\n            aperture_draw.draw(self.drawing_target)\n\n    self._post_drawing_hook()\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/aperture_handle.html#pygerber.backend.abstract.aperture_handle.PrivateApertureHandle.get_bounding_box","title":"get_bounding_box","text":"<pre><code>get_bounding_box() -&gt; BoundingBox\n</code></pre> <p>Return bounding box of draw operation.</p> Source code in <code>src/pygerber/backend/abstract/aperture_handle.py</code> <pre><code>def get_bounding_box(self) -&gt; BoundingBox:\n    \"\"\"Return bounding box of draw operation.\"\"\"\n    return self._bounding_box\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/aperture_handle.html#pygerber.backend.abstract.aperture_handle.PrivateApertureHandle.get_public_handle","title":"get_public_handle","text":"<pre><code>get_public_handle() -&gt; PublicApertureHandle\n</code></pre> <p>Return immutable aperture handle.</p> Source code in <code>src/pygerber/backend/abstract/aperture_handle.py</code> <pre><code>def get_public_handle(self) -&gt; PublicApertureHandle:\n    \"\"\"Return immutable aperture handle.\"\"\"\n    return PublicApertureHandle(\n        aperture_id=self.aperture_id,\n        private_id=self.private_id,\n    )\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/aperture_handle.html#pygerber.backend.abstract.aperture_handle.PrivateApertureHandle.get_line_width","title":"get_line_width","text":"<pre><code>get_line_width() -&gt; Offset\n</code></pre> <p>Width of line made with this aperture.</p> Source code in <code>src/pygerber/backend/abstract/aperture_handle.py</code> <pre><code>def get_line_width(self) -&gt; Offset:\n    \"\"\"Width of line made with this aperture.\"\"\"\n    box = self.get_bounding_box()\n    return (box.height + box.width) / 2\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/aperture_handle.html#pygerber.backend.abstract.aperture_handle.PrivateApertureHandle.dump_aperture","title":"dump_aperture  <code>abstractmethod</code>","text":"<pre><code>dump_aperture(dest: Path) -&gt; None\n</code></pre> <p>Save aperture to local file, mainly for debugging purposes.</p> Source code in <code>src/pygerber/backend/abstract/aperture_handle.py</code> <pre><code>@abstractmethod\ndef dump_aperture(self, dest: Path) -&gt; None:\n    \"\"\"Save aperture to local file, mainly for debugging purposes.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/aperture_handle.html#pygerber.backend.abstract.aperture_handle.PublicApertureHandle","title":"PublicApertureHandle","text":"<p>             Bases: <code>FrozenGeneralModel</code></p> <p>Immutable handle to drawing aperture.</p> Source code in <code>src/pygerber/backend/abstract/aperture_handle.py</code> <pre><code>class PublicApertureHandle(FrozenGeneralModel):\n    \"\"\"Immutable handle to drawing aperture.\"\"\"\n\n    aperture_id: ApertureID\n    private_id: int\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/backend_cls.html","title":"backend_cls","text":""},{"location":"reference/pygerber/backend/abstract/backend_cls.html#pygerber.backend.abstract.backend_cls","title":"backend_cls","text":"<p>Class interface for visualizing gerber files.</p>"},{"location":"reference/pygerber/backend/abstract/backend_cls.html#pygerber.backend.abstract.backend_cls.BackendOptions","title":"BackendOptions","text":"<p>Additional configuration which can be passed to backend.</p> Source code in <code>src/pygerber/backend/abstract/backend_cls.py</code> <pre><code>class BackendOptions:\n    \"\"\"Additional configuration which can be passed to backend.\"\"\"\n\n    def __init__(\n        self,\n        dump_apertures: Optional[Path] = None,\n        *,\n        draw_region_outlines: bool = False,\n    ) -&gt; None:\n        \"\"\"Initialize options.\"\"\"\n        self.dump_apertures = dump_apertures\n        self.draw_region_outlines = draw_region_outlines\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/backend_cls.html#pygerber.backend.abstract.backend_cls.BackendOptions.__init__","title":"__init__","text":"<pre><code>__init__(\n    dump_apertures: Optional[Path] = None,\n    *,\n    draw_region_outlines: bool = False\n) -&gt; None\n</code></pre> <p>Initialize options.</p> Source code in <code>src/pygerber/backend/abstract/backend_cls.py</code> <pre><code>def __init__(\n    self,\n    dump_apertures: Optional[Path] = None,\n    *,\n    draw_region_outlines: bool = False,\n) -&gt; None:\n    \"\"\"Initialize options.\"\"\"\n    self.dump_apertures = dump_apertures\n    self.draw_region_outlines = draw_region_outlines\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/backend_cls.html#pygerber.backend.abstract.backend_cls.Backend","title":"Backend","text":"<p>             Bases: <code>ABC</code></p> <p>Drawing backend interface.</p> Source code in <code>src/pygerber/backend/abstract/backend_cls.py</code> <pre><code>class Backend(ABC):\n    \"\"\"Drawing backend interface.\"\"\"\n\n    handles: list[PrivateApertureHandle]\n    drawing_target: DrawingTarget\n    bounding_box: BoundingBox\n    coordinate_origin: Vector2D\n\n    options_class: ClassVar[type[BackendOptions]] = BackendOptions\n\n    def __init__(self, options: Optional[BackendOptions] = None) -&gt; None:\n        \"\"\"Initialize backend.\"\"\"\n        self.options = self.options_class() if options is None else options\n        self.handles = []\n\n    def create_aperture_handle(self, aperture_id: ApertureID) -&gt; PrivateApertureHandle:\n        \"\"\"Create new aperture handle.\"\"\"\n        handle = self.get_aperture_handle_cls()(\n            aperture_id=aperture_id,\n            private_id=len(self.handles),\n            backend=self,\n        )\n        self.handles.append(handle)\n        return handle\n\n    def get_private_aperture_handle(\n        self,\n        public_aperture_handle: PublicApertureHandle,\n    ) -&gt; PrivateApertureHandle:\n        \"\"\"Get private aperture handle.\"\"\"\n        return self.handles[public_aperture_handle.private_id]\n\n    def draw(self, draws: List[DrawCommand]) -&gt; ResultHandle:\n        \"\"\"Execute all draw actions to create visualization.\"\"\"\n        self.draws = draws\n\n        self.finalize_aperture_creation()\n        self.bounding_box = self._get_draws_bounding_box(draws)\n        self.coordinate_origin = self._get_coordinate_origin()\n        self.drawing_target = self._create_drawing_target()\n        self._pre_drawing_hook()\n\n        with self.drawing_target:\n            for draw_action in draws:\n                draw_action.draw(self.drawing_target)\n\n        self._post_drawing_hook()\n\n        return self.get_result_handle()\n\n    def finalize_aperture_creation(self) -&gt; None:\n        \"\"\"Apply draw operations to aperture handles.\"\"\"\n        for handle in self.handles:\n            handle.finalize_aperture_creation()\n\n    def _get_draws_bounding_box(self, draws: List[DrawCommand]) -&gt; BoundingBox:\n        bbox: Optional[BoundingBox] = None\n\n        for draw in draws:\n            if bbox is not None:\n                bbox += draw.get_bounding_box()\n            else:\n                bbox = draw.get_bounding_box()\n\n        if bbox is not None:\n            return bbox\n\n        return BoundingBox.NULL\n\n    def _get_coordinate_origin(self) -&gt; Vector2D:\n        return self.bounding_box.get_min_vector()\n\n    @abstractmethod\n    def _create_drawing_target(self) -&gt; DrawingTarget:\n        \"\"\"Create drawing target object.\"\"\"\n\n    def _pre_drawing_hook(self) -&gt; None:  # noqa: B027\n        \"\"\"Perform custom actions before drawing.\"\"\"\n\n    def _post_drawing_hook(self) -&gt; None:  # noqa: B027\n        \"\"\"Perform custom actions after drawing.\"\"\"\n\n    @abstractmethod\n    def get_result_handle(self) -&gt; ResultHandle:\n        \"\"\"Return result handle to visualization.\"\"\"\n\n    @abstractmethod\n    def get_aperture_handle_cls(self) -&gt; Type[PrivateApertureHandle]:\n        \"\"\"Get backend-specific implementation of aperture handle class.\"\"\"\n\n    @abstractmethod\n    def get_draw_circle_cls(self) -&gt; Type[DrawCircle]:\n        \"\"\"Get backend-specific implementation of aperture circle component class.\"\"\"\n\n    @abstractmethod\n    def get_draw_rectangle_cls(self) -&gt; Type[DrawRectangle]:\n        \"\"\"Get backend-specific implementation of aperture rectangle component class.\"\"\"\n\n    @abstractmethod\n    def get_draw_polygon_cls(self) -&gt; Type[DrawPolygon]:\n        \"\"\"Get backend-specific implementation of aperture polygon component class.\"\"\"\n\n    @abstractmethod\n    def get_draw_commands_handle_cls(self) -&gt; type[DrawCommandsHandle]:\n        \"\"\"Return backend-specific implementation of draw actions handle.\"\"\"\n\n    @abstractmethod\n    def get_draw_paste_cls(self) -&gt; type[DrawPaste]:\n        \"\"\"Return backend-specific implementation of draw paste.\"\"\"\n\n    @abstractmethod\n    def get_draw_region_cls(self) -&gt; type[DrawRegion]:\n        \"\"\"Return backend-specific implementation of draw action region.\"\"\"\n\n    @abstractmethod\n    def get_draw_vector_line_cls(self) -&gt; type[DrawVectorLine]:\n        \"\"\"Return backend-specific implementation of draw action line.\"\"\"\n\n    @abstractmethod\n    def get_draw_arc_cls(self) -&gt; type[DrawArc]:\n        \"\"\"Return backend-specific implementation of draw action arc.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/backend_cls.html#pygerber.backend.abstract.backend_cls.Backend.__init__","title":"__init__","text":"<pre><code>__init__(options: Optional[BackendOptions] = None) -&gt; None\n</code></pre> <p>Initialize backend.</p> Source code in <code>src/pygerber/backend/abstract/backend_cls.py</code> <pre><code>def __init__(self, options: Optional[BackendOptions] = None) -&gt; None:\n    \"\"\"Initialize backend.\"\"\"\n    self.options = self.options_class() if options is None else options\n    self.handles = []\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/backend_cls.html#pygerber.backend.abstract.backend_cls.Backend.create_aperture_handle","title":"create_aperture_handle","text":"<pre><code>create_aperture_handle(\n    aperture_id: ApertureID,\n) -&gt; PrivateApertureHandle\n</code></pre> <p>Create new aperture handle.</p> Source code in <code>src/pygerber/backend/abstract/backend_cls.py</code> <pre><code>def create_aperture_handle(self, aperture_id: ApertureID) -&gt; PrivateApertureHandle:\n    \"\"\"Create new aperture handle.\"\"\"\n    handle = self.get_aperture_handle_cls()(\n        aperture_id=aperture_id,\n        private_id=len(self.handles),\n        backend=self,\n    )\n    self.handles.append(handle)\n    return handle\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/backend_cls.html#pygerber.backend.abstract.backend_cls.Backend.get_private_aperture_handle","title":"get_private_aperture_handle","text":"<pre><code>get_private_aperture_handle(\n    public_aperture_handle: PublicApertureHandle,\n) -&gt; PrivateApertureHandle\n</code></pre> <p>Get private aperture handle.</p> Source code in <code>src/pygerber/backend/abstract/backend_cls.py</code> <pre><code>def get_private_aperture_handle(\n    self,\n    public_aperture_handle: PublicApertureHandle,\n) -&gt; PrivateApertureHandle:\n    \"\"\"Get private aperture handle.\"\"\"\n    return self.handles[public_aperture_handle.private_id]\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/backend_cls.html#pygerber.backend.abstract.backend_cls.Backend.draw","title":"draw","text":"<pre><code>draw(draws: List[DrawCommand]) -&gt; ResultHandle\n</code></pre> <p>Execute all draw actions to create visualization.</p> Source code in <code>src/pygerber/backend/abstract/backend_cls.py</code> <pre><code>def draw(self, draws: List[DrawCommand]) -&gt; ResultHandle:\n    \"\"\"Execute all draw actions to create visualization.\"\"\"\n    self.draws = draws\n\n    self.finalize_aperture_creation()\n    self.bounding_box = self._get_draws_bounding_box(draws)\n    self.coordinate_origin = self._get_coordinate_origin()\n    self.drawing_target = self._create_drawing_target()\n    self._pre_drawing_hook()\n\n    with self.drawing_target:\n        for draw_action in draws:\n            draw_action.draw(self.drawing_target)\n\n    self._post_drawing_hook()\n\n    return self.get_result_handle()\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/backend_cls.html#pygerber.backend.abstract.backend_cls.Backend.finalize_aperture_creation","title":"finalize_aperture_creation","text":"<pre><code>finalize_aperture_creation() -&gt; None\n</code></pre> <p>Apply draw operations to aperture handles.</p> Source code in <code>src/pygerber/backend/abstract/backend_cls.py</code> <pre><code>def finalize_aperture_creation(self) -&gt; None:\n    \"\"\"Apply draw operations to aperture handles.\"\"\"\n    for handle in self.handles:\n        handle.finalize_aperture_creation()\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/backend_cls.html#pygerber.backend.abstract.backend_cls.Backend.get_result_handle","title":"get_result_handle  <code>abstractmethod</code>","text":"<pre><code>get_result_handle() -&gt; ResultHandle\n</code></pre> <p>Return result handle to visualization.</p> Source code in <code>src/pygerber/backend/abstract/backend_cls.py</code> <pre><code>@abstractmethod\ndef get_result_handle(self) -&gt; ResultHandle:\n    \"\"\"Return result handle to visualization.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/backend_cls.html#pygerber.backend.abstract.backend_cls.Backend.get_aperture_handle_cls","title":"get_aperture_handle_cls  <code>abstractmethod</code>","text":"<pre><code>get_aperture_handle_cls() -&gt; Type[PrivateApertureHandle]\n</code></pre> <p>Get backend-specific implementation of aperture handle class.</p> Source code in <code>src/pygerber/backend/abstract/backend_cls.py</code> <pre><code>@abstractmethod\ndef get_aperture_handle_cls(self) -&gt; Type[PrivateApertureHandle]:\n    \"\"\"Get backend-specific implementation of aperture handle class.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/backend_cls.html#pygerber.backend.abstract.backend_cls.Backend.get_draw_circle_cls","title":"get_draw_circle_cls  <code>abstractmethod</code>","text":"<pre><code>get_draw_circle_cls() -&gt; Type[DrawCircle]\n</code></pre> <p>Get backend-specific implementation of aperture circle component class.</p> Source code in <code>src/pygerber/backend/abstract/backend_cls.py</code> <pre><code>@abstractmethod\ndef get_draw_circle_cls(self) -&gt; Type[DrawCircle]:\n    \"\"\"Get backend-specific implementation of aperture circle component class.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/backend_cls.html#pygerber.backend.abstract.backend_cls.Backend.get_draw_rectangle_cls","title":"get_draw_rectangle_cls  <code>abstractmethod</code>","text":"<pre><code>get_draw_rectangle_cls() -&gt; Type[DrawRectangle]\n</code></pre> <p>Get backend-specific implementation of aperture rectangle component class.</p> Source code in <code>src/pygerber/backend/abstract/backend_cls.py</code> <pre><code>@abstractmethod\ndef get_draw_rectangle_cls(self) -&gt; Type[DrawRectangle]:\n    \"\"\"Get backend-specific implementation of aperture rectangle component class.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/backend_cls.html#pygerber.backend.abstract.backend_cls.Backend.get_draw_polygon_cls","title":"get_draw_polygon_cls  <code>abstractmethod</code>","text":"<pre><code>get_draw_polygon_cls() -&gt; Type[DrawPolygon]\n</code></pre> <p>Get backend-specific implementation of aperture polygon component class.</p> Source code in <code>src/pygerber/backend/abstract/backend_cls.py</code> <pre><code>@abstractmethod\ndef get_draw_polygon_cls(self) -&gt; Type[DrawPolygon]:\n    \"\"\"Get backend-specific implementation of aperture polygon component class.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/backend_cls.html#pygerber.backend.abstract.backend_cls.Backend.get_draw_commands_handle_cls","title":"get_draw_commands_handle_cls  <code>abstractmethod</code>","text":"<pre><code>get_draw_commands_handle_cls() -&gt; type[DrawCommandsHandle]\n</code></pre> <p>Return backend-specific implementation of draw actions handle.</p> Source code in <code>src/pygerber/backend/abstract/backend_cls.py</code> <pre><code>@abstractmethod\ndef get_draw_commands_handle_cls(self) -&gt; type[DrawCommandsHandle]:\n    \"\"\"Return backend-specific implementation of draw actions handle.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/backend_cls.html#pygerber.backend.abstract.backend_cls.Backend.get_draw_paste_cls","title":"get_draw_paste_cls  <code>abstractmethod</code>","text":"<pre><code>get_draw_paste_cls() -&gt; type[DrawPaste]\n</code></pre> <p>Return backend-specific implementation of draw paste.</p> Source code in <code>src/pygerber/backend/abstract/backend_cls.py</code> <pre><code>@abstractmethod\ndef get_draw_paste_cls(self) -&gt; type[DrawPaste]:\n    \"\"\"Return backend-specific implementation of draw paste.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/backend_cls.html#pygerber.backend.abstract.backend_cls.Backend.get_draw_region_cls","title":"get_draw_region_cls  <code>abstractmethod</code>","text":"<pre><code>get_draw_region_cls() -&gt; type[DrawRegion]\n</code></pre> <p>Return backend-specific implementation of draw action region.</p> Source code in <code>src/pygerber/backend/abstract/backend_cls.py</code> <pre><code>@abstractmethod\ndef get_draw_region_cls(self) -&gt; type[DrawRegion]:\n    \"\"\"Return backend-specific implementation of draw action region.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/backend_cls.html#pygerber.backend.abstract.backend_cls.Backend.get_draw_vector_line_cls","title":"get_draw_vector_line_cls  <code>abstractmethod</code>","text":"<pre><code>get_draw_vector_line_cls() -&gt; type[DrawVectorLine]\n</code></pre> <p>Return backend-specific implementation of draw action line.</p> Source code in <code>src/pygerber/backend/abstract/backend_cls.py</code> <pre><code>@abstractmethod\ndef get_draw_vector_line_cls(self) -&gt; type[DrawVectorLine]:\n    \"\"\"Return backend-specific implementation of draw action line.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/backend_cls.html#pygerber.backend.abstract.backend_cls.Backend.get_draw_arc_cls","title":"get_draw_arc_cls  <code>abstractmethod</code>","text":"<pre><code>get_draw_arc_cls() -&gt; type[DrawArc]\n</code></pre> <p>Return backend-specific implementation of draw action arc.</p> Source code in <code>src/pygerber/backend/abstract/backend_cls.py</code> <pre><code>@abstractmethod\ndef get_draw_arc_cls(self) -&gt; type[DrawArc]:\n    \"\"\"Return backend-specific implementation of draw action arc.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/draw_commands_handle.html","title":"draw_commands_handle","text":""},{"location":"reference/pygerber/backend/abstract/draw_commands_handle.html#pygerber.backend.abstract.draw_commands_handle","title":"draw_commands_handle","text":"<p>Contains class wrapping list of draw operations created by Gerber parser.</p>"},{"location":"reference/pygerber/backend/abstract/draw_commands_handle.html#pygerber.backend.abstract.draw_commands_handle.DrawCommandsHandle","title":"DrawCommandsHandle","text":"<p>List of drawing operations produced by Gerber parser.</p> Source code in <code>src/pygerber/backend/abstract/draw_commands_handle.py</code> <pre><code>class DrawCommandsHandle:\n    \"\"\"List of drawing operations produced by Gerber parser.\"\"\"\n\n    def __init__(self, draw_actions: List[DrawCommand], backend: Backend) -&gt; None:\n        \"\"\"Initialize drawing instructions.\"\"\"\n        self.draw_commands = draw_actions\n        self.backend = backend\n\n    def draw(self) -&gt; ResultHandle:\n        \"\"\"Create visualization based on drawing instructions.\"\"\"\n        return self.backend.draw(self.draw_commands)\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/draw_commands_handle.html#pygerber.backend.abstract.draw_commands_handle.DrawCommandsHandle.__init__","title":"__init__","text":"<pre><code>__init__(\n    draw_actions: List[DrawCommand], backend: Backend\n) -&gt; None\n</code></pre> <p>Initialize drawing instructions.</p> Source code in <code>src/pygerber/backend/abstract/draw_commands_handle.py</code> <pre><code>def __init__(self, draw_actions: List[DrawCommand], backend: Backend) -&gt; None:\n    \"\"\"Initialize drawing instructions.\"\"\"\n    self.draw_commands = draw_actions\n    self.backend = backend\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/draw_commands_handle.html#pygerber.backend.abstract.draw_commands_handle.DrawCommandsHandle.draw","title":"draw","text":"<pre><code>draw() -&gt; ResultHandle\n</code></pre> <p>Create visualization based on drawing instructions.</p> Source code in <code>src/pygerber/backend/abstract/draw_commands_handle.py</code> <pre><code>def draw(self) -&gt; ResultHandle:\n    \"\"\"Create visualization based on drawing instructions.\"\"\"\n    return self.backend.draw(self.draw_commands)\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/drawing_target.html","title":"drawing_target","text":""},{"location":"reference/pygerber/backend/abstract/drawing_target.html#pygerber.backend.abstract.drawing_target","title":"drawing_target","text":"<p>Target for Draw commands to draw into.</p>"},{"location":"reference/pygerber/backend/abstract/drawing_target.html#pygerber.backend.abstract.drawing_target.DrawingTarget","title":"DrawingTarget","text":"<p>Target for Draw commands to draw into.</p> Source code in <code>src/pygerber/backend/abstract/drawing_target.py</code> <pre><code>class DrawingTarget:\n    \"\"\"Target for Draw commands to draw into.\"\"\"\n\n    coordinate_origin: Vector2D\n    bounding_box: BoundingBox\n\n    def __init__(self, coordinate_origin: Vector2D, bounding_box: BoundingBox) -&gt; None:\n        \"\"\"Initialize drawing target.\"\"\"\n        self.coordinate_origin = coordinate_origin\n        self.bounding_box = bounding_box\n\n    def __enter__(self) -&gt; None:\n        pass\n\n    def __exit__(\n        self,\n        exc_type: Optional[type[BaseException]],\n        exc_value: Optional[BaseException],\n        traceback: Optional[TracebackType],\n    ) -&gt; None:\n        if exc_type is None:\n            self._finalize()\n\n    def _finalize(self) -&gt; None:\n        \"\"\"Call at the end of image modification.\n\n        After this call no modifications to image are allowed.\n        \"\"\"\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/drawing_target.html#pygerber.backend.abstract.drawing_target.DrawingTarget.__init__","title":"__init__","text":"<pre><code>__init__(\n    coordinate_origin: Vector2D, bounding_box: BoundingBox\n) -&gt; None\n</code></pre> <p>Initialize drawing target.</p> Source code in <code>src/pygerber/backend/abstract/drawing_target.py</code> <pre><code>def __init__(self, coordinate_origin: Vector2D, bounding_box: BoundingBox) -&gt; None:\n    \"\"\"Initialize drawing target.\"\"\"\n    self.coordinate_origin = coordinate_origin\n    self.bounding_box = bounding_box\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/errors.html","title":"errors","text":""},{"location":"reference/pygerber/backend/abstract/errors.html#pygerber.backend.abstract.errors","title":"errors","text":"<p>Base error classes used in this module.</p>"},{"location":"reference/pygerber/backend/abstract/errors.html#pygerber.backend.abstract.errors.BackendError","title":"BackendError","text":"<p>             Bases: <code>ValueError</code></p> <p>Base class for backend errors.</p> Source code in <code>src/pygerber/backend/abstract/errors.py</code> <pre><code>class BackendError(ValueError):\n    \"\"\"Base class for backend errors.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/errors.html#pygerber.backend.abstract.errors.BackendNotSupportedError","title":"BackendNotSupportedError","text":"<p>             Bases: <code>BackendError</code></p> <p>Raised when requesting backend which is not officially supported.</p> Source code in <code>src/pygerber/backend/abstract/errors.py</code> <pre><code>class BackendNotSupportedError(BackendError):\n    \"\"\"Raised when requesting backend which is not officially supported.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/result_handle.html","title":"result_handle","text":""},{"location":"reference/pygerber/backend/abstract/result_handle.html#pygerber.backend.abstract.result_handle","title":"result_handle","text":"<p>Module contains handle class to drawing instructions visualization.</p>"},{"location":"reference/pygerber/backend/abstract/result_handle.html#pygerber.backend.abstract.result_handle.ResultHandle","title":"ResultHandle","text":"<p>             Bases: <code>ABC</code></p> <p>Handle to drawing instructions visualization.</p> Source code in <code>src/pygerber/backend/abstract/result_handle.py</code> <pre><code>class ResultHandle(ABC):\n    \"\"\"Handle to drawing instructions visualization.\"\"\"\n\n    @abstractmethod\n    def save(\n        self,\n        dest: Path | str | BytesIO,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"Save result to destination.\n\n        All additional parameters are passed to underlying saving system.\n        For more details see documentation of concrete implementations.\n        \"\"\"\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/result_handle.html#pygerber.backend.abstract.result_handle.ResultHandle.save","title":"save  <code>abstractmethod</code>","text":"<pre><code>save(dest: Path | str | BytesIO, **kwargs: Any) -&gt; None\n</code></pre> <p>Save result to destination.</p> <p>All additional parameters are passed to underlying saving system. For more details see documentation of concrete implementations.</p> Source code in <code>src/pygerber/backend/abstract/result_handle.py</code> <pre><code>@abstractmethod\ndef save(\n    self,\n    dest: Path | str | BytesIO,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"Save result to destination.\n\n    All additional parameters are passed to underlying saving system.\n    For more details see documentation of concrete implementations.\n    \"\"\"\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/draw_commands/__init__.html","title":"init","text":""},{"location":"reference/pygerber/backend/abstract/draw_commands/__init__.html#pygerber.backend.abstract.draw_commands","title":"draw_commands","text":"<p>Draw operations for constructing apertures.</p>"},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_arc.html","title":"draw_arc","text":""},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_arc.html#pygerber.backend.abstract.draw_commands.draw_arc","title":"draw_arc","text":"<p>Base class for creating components for aperture creation.</p>"},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_arc.html#pygerber.backend.abstract.draw_commands.draw_arc.DrawArc","title":"DrawArc","text":"<p>             Bases: <code>DrawCommand</code></p> <p>Description of aperture component.</p> Source code in <code>src/pygerber/backend/abstract/draw_commands/draw_arc.py</code> <pre><code>class DrawArc(DrawCommand):\n    \"\"\"Description of aperture component.\"\"\"\n\n    start_position: Vector2D\n    dx_dy_center: Vector2D\n    end_position: Vector2D\n    width: Offset\n\n    is_clockwise: bool\n    is_multi_quadrant: bool\n\n    def __init__(  # noqa: PLR0913\n        self,\n        backend: Backend,\n        polarity: Polarity,\n        start_position: Vector2D,\n        dx_dy_center: Vector2D,\n        end_position: Vector2D,\n        width: Offset,\n        *,\n        is_clockwise: bool,\n        is_multi_quadrant: bool,\n    ) -&gt; None:\n        \"\"\"Initialize draw command.\"\"\"\n        super().__init__(backend, polarity)\n        self.start_position = start_position\n        self.dx_dy_center = dx_dy_center\n        self.end_position = end_position\n        self.width = width\n        self.is_clockwise = is_clockwise\n        self.is_multi_quadrant = is_multi_quadrant\n\n    @property\n    def arc_center_absolute(self) -&gt; Vector2D:\n        \"\"\"Return absolute coordinates of arc center point.\"\"\"\n        return self.start_position + self.dx_dy_center\n\n    @property\n    def arc_space_arc_center(self) -&gt; Vector2D:\n        \"\"\"Return arc center coordinates relative to arc center.\"\"\"\n        return self.arc_center_absolute - self.arc_center_absolute\n\n    @property\n    def arc_space_start_position(self) -&gt; Vector2D:\n        \"\"\"Return arc start coordinates relative to arc center.\"\"\"\n        return self.start_position - self.arc_center_absolute\n\n    @property\n    def arc_space_end_position(self) -&gt; Vector2D:\n        \"\"\"Return arc end coordinates relative to arc center.\"\"\"\n        return self.end_position - self.arc_center_absolute\n\n    @property\n    def arc_radius(self) -&gt; Offset:\n        \"\"\"Return arc radius.\"\"\"\n        return self.dx_dy_center.length()\n\n    def get_bounding_box(self) -&gt; BoundingBox:\n        \"\"\"Return bounding box of draw operation.\"\"\"\n        return self._bounding_box\n\n    @cached_property\n    def _bounding_box(self) -&gt; BoundingBox:\n        vertex_box = BoundingBox.from_diameter(self.width)\n        radius = self.arc_radius\n        return (vertex_box + (self.arc_center_absolute + radius)) + (\n            vertex_box + (self.arc_center_absolute - radius)\n        )\n\n    def _calculate_angles(self) -&gt; tuple[float, float]:\n        angle_start = self.arc_space_start_position.angle_between_clockwise(\n            Vector2D.UNIT_Y,\n        )\n        angle_end = self.arc_space_end_position.angle_between_clockwise(Vector2D.UNIT_Y)\n\n        if self.is_multi_quadrant and angle_start == angle_end:\n            angle_start = 0\n            angle_end = 360\n\n        elif self.is_clockwise:\n            angle_start, angle_end = angle_end, angle_start\n\n        return angle_start, angle_end\n\n    def calculate_arc_points(self) -&gt; Generator[Vector2D, None, None]:\n        \"\"\"Calculate points on arc.\"\"\"\n        angle_start, angle_end = self._calculate_angles()\n\n        angle_step = 1\n        angle_min = min(angle_start, angle_end)\n        angle_max = max(angle_start, angle_end)\n\n        angle_current = angle_min\n\n        yield self.arc_center_absolute\n\n        while angle_current &lt; (angle_max + angle_step):\n            yield self.arc_center_absolute + Vector2D(\n                x=self.arc_radius * math.cos(math.radians(angle_current)),\n                y=self.arc_radius * math.sin(math.radians(angle_current)),\n            )\n            angle_current += angle_step\n\n        yield self.arc_center_absolute\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_arc.html#pygerber.backend.abstract.draw_commands.draw_arc.DrawArc.arc_center_absolute","title":"arc_center_absolute  <code>property</code>","text":"<pre><code>arc_center_absolute: Vector2D\n</code></pre> <p>Return absolute coordinates of arc center point.</p>"},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_arc.html#pygerber.backend.abstract.draw_commands.draw_arc.DrawArc.arc_space_arc_center","title":"arc_space_arc_center  <code>property</code>","text":"<pre><code>arc_space_arc_center: Vector2D\n</code></pre> <p>Return arc center coordinates relative to arc center.</p>"},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_arc.html#pygerber.backend.abstract.draw_commands.draw_arc.DrawArc.arc_space_start_position","title":"arc_space_start_position  <code>property</code>","text":"<pre><code>arc_space_start_position: Vector2D\n</code></pre> <p>Return arc start coordinates relative to arc center.</p>"},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_arc.html#pygerber.backend.abstract.draw_commands.draw_arc.DrawArc.arc_space_end_position","title":"arc_space_end_position  <code>property</code>","text":"<pre><code>arc_space_end_position: Vector2D\n</code></pre> <p>Return arc end coordinates relative to arc center.</p>"},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_arc.html#pygerber.backend.abstract.draw_commands.draw_arc.DrawArc.arc_radius","title":"arc_radius  <code>property</code>","text":"<pre><code>arc_radius: Offset\n</code></pre> <p>Return arc radius.</p>"},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_arc.html#pygerber.backend.abstract.draw_commands.draw_arc.DrawArc.__init__","title":"__init__","text":"<pre><code>__init__(\n    backend: Backend,\n    polarity: Polarity,\n    start_position: Vector2D,\n    dx_dy_center: Vector2D,\n    end_position: Vector2D,\n    width: Offset,\n    *,\n    is_clockwise: bool,\n    is_multi_quadrant: bool\n) -&gt; None\n</code></pre> <p>Initialize draw command.</p> Source code in <code>src/pygerber/backend/abstract/draw_commands/draw_arc.py</code> <pre><code>def __init__(  # noqa: PLR0913\n    self,\n    backend: Backend,\n    polarity: Polarity,\n    start_position: Vector2D,\n    dx_dy_center: Vector2D,\n    end_position: Vector2D,\n    width: Offset,\n    *,\n    is_clockwise: bool,\n    is_multi_quadrant: bool,\n) -&gt; None:\n    \"\"\"Initialize draw command.\"\"\"\n    super().__init__(backend, polarity)\n    self.start_position = start_position\n    self.dx_dy_center = dx_dy_center\n    self.end_position = end_position\n    self.width = width\n    self.is_clockwise = is_clockwise\n    self.is_multi_quadrant = is_multi_quadrant\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_arc.html#pygerber.backend.abstract.draw_commands.draw_arc.DrawArc.get_bounding_box","title":"get_bounding_box","text":"<pre><code>get_bounding_box() -&gt; BoundingBox\n</code></pre> <p>Return bounding box of draw operation.</p> Source code in <code>src/pygerber/backend/abstract/draw_commands/draw_arc.py</code> <pre><code>def get_bounding_box(self) -&gt; BoundingBox:\n    \"\"\"Return bounding box of draw operation.\"\"\"\n    return self._bounding_box\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_arc.html#pygerber.backend.abstract.draw_commands.draw_arc.DrawArc.calculate_arc_points","title":"calculate_arc_points","text":"<pre><code>calculate_arc_points() -&gt; Generator[Vector2D, None, None]\n</code></pre> <p>Calculate points on arc.</p> Source code in <code>src/pygerber/backend/abstract/draw_commands/draw_arc.py</code> <pre><code>def calculate_arc_points(self) -&gt; Generator[Vector2D, None, None]:\n    \"\"\"Calculate points on arc.\"\"\"\n    angle_start, angle_end = self._calculate_angles()\n\n    angle_step = 1\n    angle_min = min(angle_start, angle_end)\n    angle_max = max(angle_start, angle_end)\n\n    angle_current = angle_min\n\n    yield self.arc_center_absolute\n\n    while angle_current &lt; (angle_max + angle_step):\n        yield self.arc_center_absolute + Vector2D(\n            x=self.arc_radius * math.cos(math.radians(angle_current)),\n            y=self.arc_radius * math.sin(math.radians(angle_current)),\n        )\n        angle_current += angle_step\n\n    yield self.arc_center_absolute\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_bounding_box.html","title":"draw_bounding_box","text":""},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_bounding_box.html#pygerber.backend.abstract.draw_commands.draw_bounding_box","title":"draw_bounding_box","text":"<p>BoundingBox component for creating apertures.</p>"},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_bounding_box.html#pygerber.backend.abstract.draw_commands.draw_bounding_box.DrawBoundingBox","title":"DrawBoundingBox","text":"<p>             Bases: <code>DrawCommand</code></p> <p>Description of BoundingBox component.</p> Source code in <code>src/pygerber/backend/abstract/draw_commands/draw_bounding_box.py</code> <pre><code>class DrawBoundingBox(DrawCommand):\n    \"\"\"Description of BoundingBox component.\"\"\"\n\n    bounding_box: BoundingBox\n    outline_padding: Offset\n\n    def __init__(\n        self,\n        backend: Backend,\n        polarity: Polarity,\n        bounding_box: BoundingBox,\n        outline_padding: Offset,\n    ) -&gt; None:\n        \"\"\"Initialize draw command.\"\"\"\n        super().__init__(backend, polarity)\n        self.bounding_box = bounding_box\n        self.outline_padding = outline_padding\n\n    def get_bounding_box(self) -&gt; BoundingBox:\n        \"\"\"Return bounding box of draw operation.\"\"\"\n        return self._bounding_box\n\n    @cached_property\n    def _bounding_box(self) -&gt; BoundingBox:\n        return self.bounding_box + self.outline_padding\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_bounding_box.html#pygerber.backend.abstract.draw_commands.draw_bounding_box.DrawBoundingBox.__init__","title":"__init__","text":"<pre><code>__init__(\n    backend: Backend,\n    polarity: Polarity,\n    bounding_box: BoundingBox,\n    outline_padding: Offset,\n) -&gt; None\n</code></pre> <p>Initialize draw command.</p> Source code in <code>src/pygerber/backend/abstract/draw_commands/draw_bounding_box.py</code> <pre><code>def __init__(\n    self,\n    backend: Backend,\n    polarity: Polarity,\n    bounding_box: BoundingBox,\n    outline_padding: Offset,\n) -&gt; None:\n    \"\"\"Initialize draw command.\"\"\"\n    super().__init__(backend, polarity)\n    self.bounding_box = bounding_box\n    self.outline_padding = outline_padding\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_bounding_box.html#pygerber.backend.abstract.draw_commands.draw_bounding_box.DrawBoundingBox.get_bounding_box","title":"get_bounding_box","text":"<pre><code>get_bounding_box() -&gt; BoundingBox\n</code></pre> <p>Return bounding box of draw operation.</p> Source code in <code>src/pygerber/backend/abstract/draw_commands/draw_bounding_box.py</code> <pre><code>def get_bounding_box(self) -&gt; BoundingBox:\n    \"\"\"Return bounding box of draw operation.\"\"\"\n    return self._bounding_box\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_circle.html","title":"draw_circle","text":""},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_circle.html#pygerber.backend.abstract.draw_commands.draw_circle","title":"draw_circle","text":"<p>Circle component for creating apertures.</p>"},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_circle.html#pygerber.backend.abstract.draw_commands.draw_circle.DrawCircle","title":"DrawCircle","text":"<p>             Bases: <code>DrawCommand</code></p> <p>Description of circle aperture component.</p> Source code in <code>src/pygerber/backend/abstract/draw_commands/draw_circle.py</code> <pre><code>class DrawCircle(DrawCommand):\n    \"\"\"Description of circle aperture component.\"\"\"\n\n    center_position: Vector2D\n    diameter: Offset\n\n    def __init__(\n        self,\n        backend: Backend,\n        polarity: Polarity,\n        center_position: Vector2D,\n        diameter: Offset,\n    ) -&gt; None:\n        \"\"\"Initialize draw command.\"\"\"\n        super().__init__(backend, polarity)\n        self.center_position = center_position\n        self.diameter = diameter\n\n    def get_bounding_box(self) -&gt; BoundingBox:\n        \"\"\"Return bounding box of draw operation.\"\"\"\n        return self._bounding_box\n\n    @cached_property\n    def _bounding_box(self) -&gt; BoundingBox:\n        return BoundingBox.from_diameter(self.diameter) + self.center_position\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_circle.html#pygerber.backend.abstract.draw_commands.draw_circle.DrawCircle.__init__","title":"__init__","text":"<pre><code>__init__(\n    backend: Backend,\n    polarity: Polarity,\n    center_position: Vector2D,\n    diameter: Offset,\n) -&gt; None\n</code></pre> <p>Initialize draw command.</p> Source code in <code>src/pygerber/backend/abstract/draw_commands/draw_circle.py</code> <pre><code>def __init__(\n    self,\n    backend: Backend,\n    polarity: Polarity,\n    center_position: Vector2D,\n    diameter: Offset,\n) -&gt; None:\n    \"\"\"Initialize draw command.\"\"\"\n    super().__init__(backend, polarity)\n    self.center_position = center_position\n    self.diameter = diameter\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_circle.html#pygerber.backend.abstract.draw_commands.draw_circle.DrawCircle.get_bounding_box","title":"get_bounding_box","text":"<pre><code>get_bounding_box() -&gt; BoundingBox\n</code></pre> <p>Return bounding box of draw operation.</p> Source code in <code>src/pygerber/backend/abstract/draw_commands/draw_circle.py</code> <pre><code>def get_bounding_box(self) -&gt; BoundingBox:\n    \"\"\"Return bounding box of draw operation.\"\"\"\n    return self._bounding_box\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_command.html","title":"draw_command","text":""},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_command.html#pygerber.backend.abstract.draw_commands.draw_command","title":"draw_command","text":"<p>Base class for creating components for aperture creation.</p>"},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_command.html#pygerber.backend.abstract.draw_commands.draw_command.DrawCommand","title":"DrawCommand","text":"<p>             Bases: <code>ABC</code></p> <p>Description of aperture component.</p> Source code in <code>src/pygerber/backend/abstract/draw_commands/draw_command.py</code> <pre><code>class DrawCommand(ABC):\n    \"\"\"Description of aperture component.\"\"\"\n\n    backend: Backend\n    polarity: Polarity\n\n    def __init__(self, backend: Backend, polarity: Polarity) -&gt; None:\n        \"\"\"Initialize draw command.\"\"\"\n        self.backend = backend\n        self.polarity = polarity\n\n    @abstractmethod\n    def draw(self, target: DrawingTarget) -&gt; None:\n        \"\"\"Apply aperture draw component to handle.\"\"\"\n\n    @abstractmethod\n    def get_bounding_box(self) -&gt; BoundingBox:\n        \"\"\"Return bounding box of draw operation.\"\"\"\n\n    def __str__(self) -&gt; str:\n        return f\"{self.__class__.__qualname__}({self.polarity})\"\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_command.html#pygerber.backend.abstract.draw_commands.draw_command.DrawCommand.__init__","title":"__init__","text":"<pre><code>__init__(backend: Backend, polarity: Polarity) -&gt; None\n</code></pre> <p>Initialize draw command.</p> Source code in <code>src/pygerber/backend/abstract/draw_commands/draw_command.py</code> <pre><code>def __init__(self, backend: Backend, polarity: Polarity) -&gt; None:\n    \"\"\"Initialize draw command.\"\"\"\n    self.backend = backend\n    self.polarity = polarity\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_command.html#pygerber.backend.abstract.draw_commands.draw_command.DrawCommand.draw","title":"draw  <code>abstractmethod</code>","text":"<pre><code>draw(target: DrawingTarget) -&gt; None\n</code></pre> <p>Apply aperture draw component to handle.</p> Source code in <code>src/pygerber/backend/abstract/draw_commands/draw_command.py</code> <pre><code>@abstractmethod\ndef draw(self, target: DrawingTarget) -&gt; None:\n    \"\"\"Apply aperture draw component to handle.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_command.html#pygerber.backend.abstract.draw_commands.draw_command.DrawCommand.get_bounding_box","title":"get_bounding_box  <code>abstractmethod</code>","text":"<pre><code>get_bounding_box() -&gt; BoundingBox\n</code></pre> <p>Return bounding box of draw operation.</p> Source code in <code>src/pygerber/backend/abstract/draw_commands/draw_command.py</code> <pre><code>@abstractmethod\ndef get_bounding_box(self) -&gt; BoundingBox:\n    \"\"\"Return bounding box of draw operation.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_paste.html","title":"draw_paste","text":""},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_paste.html#pygerber.backend.abstract.draw_commands.draw_paste","title":"draw_paste","text":"<p>Base class for creating components for aperture creation.</p>"},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_paste.html#pygerber.backend.abstract.draw_commands.draw_paste.DrawPaste","title":"DrawPaste","text":"<p>             Bases: <code>DrawCommand</code></p> <p>Description of aperture component.</p> Source code in <code>src/pygerber/backend/abstract/draw_commands/draw_paste.py</code> <pre><code>class DrawPaste(DrawCommand):\n    \"\"\"Description of aperture component.\"\"\"\n\n    other: DrawingTarget\n    center_position: Vector2D\n\n    def __init__(\n        self,\n        backend: Backend,\n        polarity: Polarity,\n        other: DrawingTarget,\n        center_position: Vector2D,\n    ) -&gt; None:\n        \"\"\"Initialize draw command.\"\"\"\n        super().__init__(backend, polarity)\n        self.other = other\n        self.center_position = center_position\n\n    def get_bounding_box(self) -&gt; BoundingBox:\n        \"\"\"Return bounding box of draw operation.\"\"\"\n        return self._bounding_box\n\n    @cached_property\n    def _bounding_box(self) -&gt; BoundingBox:\n        return self.other.bounding_box + self.center_position\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_paste.html#pygerber.backend.abstract.draw_commands.draw_paste.DrawPaste.__init__","title":"__init__","text":"<pre><code>__init__(\n    backend: Backend,\n    polarity: Polarity,\n    other: DrawingTarget,\n    center_position: Vector2D,\n) -&gt; None\n</code></pre> <p>Initialize draw command.</p> Source code in <code>src/pygerber/backend/abstract/draw_commands/draw_paste.py</code> <pre><code>def __init__(\n    self,\n    backend: Backend,\n    polarity: Polarity,\n    other: DrawingTarget,\n    center_position: Vector2D,\n) -&gt; None:\n    \"\"\"Initialize draw command.\"\"\"\n    super().__init__(backend, polarity)\n    self.other = other\n    self.center_position = center_position\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_paste.html#pygerber.backend.abstract.draw_commands.draw_paste.DrawPaste.get_bounding_box","title":"get_bounding_box","text":"<pre><code>get_bounding_box() -&gt; BoundingBox\n</code></pre> <p>Return bounding box of draw operation.</p> Source code in <code>src/pygerber/backend/abstract/draw_commands/draw_paste.py</code> <pre><code>def get_bounding_box(self) -&gt; BoundingBox:\n    \"\"\"Return bounding box of draw operation.\"\"\"\n    return self._bounding_box\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_polygon.html","title":"draw_polygon","text":""},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_polygon.html#pygerber.backend.abstract.draw_commands.draw_polygon","title":"draw_polygon","text":"<p>Polygon component for creating apertures.</p>"},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_polygon.html#pygerber.backend.abstract.draw_commands.draw_polygon.DrawPolygon","title":"DrawPolygon","text":"<p>             Bases: <code>DrawCommand</code></p> <p>Description of polygon aperture component.</p> Source code in <code>src/pygerber/backend/abstract/draw_commands/draw_polygon.py</code> <pre><code>class DrawPolygon(DrawCommand):\n    \"\"\"Description of polygon aperture component.\"\"\"\n\n    center_position: Vector2D\n    outer_diameter: Offset\n    number_of_vertices: int\n    rotation: Decimal\n\n    def __init__(\n        self,\n        backend: Backend,\n        polarity: Polarity,\n        center_position: Vector2D,\n        outer_diameter: Offset,\n        number_of_vertices: int,\n        rotation: Decimal,\n    ) -&gt; None:\n        \"\"\"Initialize draw command.\"\"\"\n        super().__init__(backend, polarity)\n        self.center_position = center_position\n        self.outer_diameter = outer_diameter\n        self.number_of_vertices = number_of_vertices\n        self.rotation = rotation\n\n    def get_bounding_box(self) -&gt; BoundingBox:\n        \"\"\"Return bounding box of draw operation.\"\"\"\n        return self._bounding_box\n\n    @cached_property\n    def _bounding_box(self) -&gt; BoundingBox:\n        return BoundingBox.from_diameter(self.outer_diameter) + self.center_position\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_polygon.html#pygerber.backend.abstract.draw_commands.draw_polygon.DrawPolygon.__init__","title":"__init__","text":"<pre><code>__init__(\n    backend: Backend,\n    polarity: Polarity,\n    center_position: Vector2D,\n    outer_diameter: Offset,\n    number_of_vertices: int,\n    rotation: Decimal,\n) -&gt; None\n</code></pre> <p>Initialize draw command.</p> Source code in <code>src/pygerber/backend/abstract/draw_commands/draw_polygon.py</code> <pre><code>def __init__(\n    self,\n    backend: Backend,\n    polarity: Polarity,\n    center_position: Vector2D,\n    outer_diameter: Offset,\n    number_of_vertices: int,\n    rotation: Decimal,\n) -&gt; None:\n    \"\"\"Initialize draw command.\"\"\"\n    super().__init__(backend, polarity)\n    self.center_position = center_position\n    self.outer_diameter = outer_diameter\n    self.number_of_vertices = number_of_vertices\n    self.rotation = rotation\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_polygon.html#pygerber.backend.abstract.draw_commands.draw_polygon.DrawPolygon.get_bounding_box","title":"get_bounding_box","text":"<pre><code>get_bounding_box() -&gt; BoundingBox\n</code></pre> <p>Return bounding box of draw operation.</p> Source code in <code>src/pygerber/backend/abstract/draw_commands/draw_polygon.py</code> <pre><code>def get_bounding_box(self) -&gt; BoundingBox:\n    \"\"\"Return bounding box of draw operation.\"\"\"\n    return self._bounding_box\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_rectangle.html","title":"draw_rectangle","text":""},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_rectangle.html#pygerber.backend.abstract.draw_commands.draw_rectangle","title":"draw_rectangle","text":"<p>Rectangle component for creating apertures.</p>"},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_rectangle.html#pygerber.backend.abstract.draw_commands.draw_rectangle.DrawRectangle","title":"DrawRectangle","text":"<p>             Bases: <code>DrawCommand</code></p> <p>Description of rectangle aperture component.</p> Source code in <code>src/pygerber/backend/abstract/draw_commands/draw_rectangle.py</code> <pre><code>class DrawRectangle(DrawCommand):\n    \"\"\"Description of rectangle aperture component.\"\"\"\n\n    center_position: Vector2D\n    x_size: Offset\n    y_size: Offset\n\n    def __init__(\n        self,\n        backend: Backend,\n        polarity: Polarity,\n        center_position: Vector2D,\n        x_size: Offset,\n        y_size: Offset,\n    ) -&gt; None:\n        \"\"\"Initialize draw command.\"\"\"\n        super().__init__(backend, polarity)\n        self.center_position = center_position\n        self.x_size = x_size\n        self.y_size = y_size\n\n    def get_bounding_box(self) -&gt; BoundingBox:\n        \"\"\"Return bounding box of draw operation.\"\"\"\n        return self._bounding_box\n\n    @cached_property\n    def _bounding_box(self) -&gt; BoundingBox:\n        return (\n            BoundingBox.from_rectangle(self.x_size, self.y_size) + self.center_position\n        )\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_rectangle.html#pygerber.backend.abstract.draw_commands.draw_rectangle.DrawRectangle.__init__","title":"__init__","text":"<pre><code>__init__(\n    backend: Backend,\n    polarity: Polarity,\n    center_position: Vector2D,\n    x_size: Offset,\n    y_size: Offset,\n) -&gt; None\n</code></pre> <p>Initialize draw command.</p> Source code in <code>src/pygerber/backend/abstract/draw_commands/draw_rectangle.py</code> <pre><code>def __init__(\n    self,\n    backend: Backend,\n    polarity: Polarity,\n    center_position: Vector2D,\n    x_size: Offset,\n    y_size: Offset,\n) -&gt; None:\n    \"\"\"Initialize draw command.\"\"\"\n    super().__init__(backend, polarity)\n    self.center_position = center_position\n    self.x_size = x_size\n    self.y_size = y_size\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_rectangle.html#pygerber.backend.abstract.draw_commands.draw_rectangle.DrawRectangle.get_bounding_box","title":"get_bounding_box","text":"<pre><code>get_bounding_box() -&gt; BoundingBox\n</code></pre> <p>Return bounding box of draw operation.</p> Source code in <code>src/pygerber/backend/abstract/draw_commands/draw_rectangle.py</code> <pre><code>def get_bounding_box(self) -&gt; BoundingBox:\n    \"\"\"Return bounding box of draw operation.\"\"\"\n    return self._bounding_box\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_region.html","title":"draw_region","text":""},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_region.html#pygerber.backend.abstract.draw_commands.draw_region","title":"draw_region","text":"<p>Region component for creating apertures.</p>"},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_region.html#pygerber.backend.abstract.draw_commands.draw_region.DrawRegion","title":"DrawRegion","text":"<p>             Bases: <code>DrawCommand</code></p> <p>Description of Region aperture component.</p> Source code in <code>src/pygerber/backend/abstract/draw_commands/draw_region.py</code> <pre><code>class DrawRegion(DrawCommand):\n    \"\"\"Description of Region aperture component.\"\"\"\n\n    region_boundary_points: list[Vector2D]\n\n    def __init__(\n        self,\n        backend: Backend,\n        polarity: Polarity,\n        region_boundary_points: list[Vector2D],\n    ) -&gt; None:\n        \"\"\"Initialize draw command.\"\"\"\n        super().__init__(backend, polarity)\n        self.region_boundary_points = region_boundary_points\n\n    def get_bounding_box(self) -&gt; BoundingBox:\n        \"\"\"Return bounding box of draw operation.\"\"\"\n        return self._bounding_box\n\n    @cached_property\n    def _bounding_box(self) -&gt; BoundingBox:\n        box: Optional[BoundingBox] = None\n        for point in self.region_boundary_points:\n            if box is not None:\n                box = box.include_point(point)\n            else:\n                box = BoundingBox.NULL + point\n\n        if box is not None:\n            return box\n\n        return BoundingBox.NULL\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_region.html#pygerber.backend.abstract.draw_commands.draw_region.DrawRegion.__init__","title":"__init__","text":"<pre><code>__init__(\n    backend: Backend,\n    polarity: Polarity,\n    region_boundary_points: list[Vector2D],\n) -&gt; None\n</code></pre> <p>Initialize draw command.</p> Source code in <code>src/pygerber/backend/abstract/draw_commands/draw_region.py</code> <pre><code>def __init__(\n    self,\n    backend: Backend,\n    polarity: Polarity,\n    region_boundary_points: list[Vector2D],\n) -&gt; None:\n    \"\"\"Initialize draw command.\"\"\"\n    super().__init__(backend, polarity)\n    self.region_boundary_points = region_boundary_points\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_region.html#pygerber.backend.abstract.draw_commands.draw_region.DrawRegion.get_bounding_box","title":"get_bounding_box","text":"<pre><code>get_bounding_box() -&gt; BoundingBox\n</code></pre> <p>Return bounding box of draw operation.</p> Source code in <code>src/pygerber/backend/abstract/draw_commands/draw_region.py</code> <pre><code>def get_bounding_box(self) -&gt; BoundingBox:\n    \"\"\"Return bounding box of draw operation.\"\"\"\n    return self._bounding_box\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_vector_line.html","title":"draw_vector_line","text":""},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_vector_line.html#pygerber.backend.abstract.draw_commands.draw_vector_line","title":"draw_vector_line","text":""},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_vector_line.html#pygerber.backend.abstract.draw_commands.draw_vector_line--drawvectorline-module","title":"DrawVectorLine Module.","text":"<p>This module defines the base class for creating vector line components used in drawing creation. The main class, <code>DrawVectorLine</code>, represents a vector line defined by its start and end positions and width.</p>"},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_vector_line.html#pygerber.backend.abstract.draw_commands.draw_vector_line.DrawVectorLine","title":"DrawVectorLine","text":"<p>             Bases: <code>DrawCommand</code></p> <p>Represents a vector line component used in drawing creation. This class is defined by its start position, end position, and width.</p> Source code in <code>src/pygerber/backend/abstract/draw_commands/draw_vector_line.py</code> <pre><code>class DrawVectorLine(DrawCommand):\n    \"\"\"Represents a vector line component used in drawing creation.\n    This class is defined by its start position, end position, and width.\n    \"\"\"\n\n    start_position: Vector2D\n    end_position: Vector2D\n    width: Offset\n\n    def __init__(\n        self,\n        backend: Backend,\n        polarity: Polarity,\n        start_position: Vector2D,\n        end_position: Vector2D,\n        width: Offset,\n    ) -&gt; None:\n        \"\"\"Initialize draw command.\"\"\"\n        super().__init__(backend, polarity)\n        self.start_position = start_position\n        self.end_position = end_position\n        self.width = width\n\n    def get_bounding_box(self) -&gt; BoundingBox:\n        \"\"\"Return bounding box of draw operation.\"\"\"\n        vertex_box = BoundingBox.from_diameter(self.width)\n        return (vertex_box + self.start_position) + (vertex_box + self.end_position)\n\n    def __str__(self) -&gt; str:\n        return (\n            f\"{self.__class__.__qualname__}({self.polarity}) start: \"\n            \"{self.start_position} end: {self.end_position}\"\n        )\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_vector_line.html#pygerber.backend.abstract.draw_commands.draw_vector_line.DrawVectorLine.__init__","title":"__init__","text":"<pre><code>__init__(\n    backend: Backend,\n    polarity: Polarity,\n    start_position: Vector2D,\n    end_position: Vector2D,\n    width: Offset,\n) -&gt; None\n</code></pre> <p>Initialize draw command.</p> Source code in <code>src/pygerber/backend/abstract/draw_commands/draw_vector_line.py</code> <pre><code>def __init__(\n    self,\n    backend: Backend,\n    polarity: Polarity,\n    start_position: Vector2D,\n    end_position: Vector2D,\n    width: Offset,\n) -&gt; None:\n    \"\"\"Initialize draw command.\"\"\"\n    super().__init__(backend, polarity)\n    self.start_position = start_position\n    self.end_position = end_position\n    self.width = width\n</code></pre>"},{"location":"reference/pygerber/backend/abstract/draw_commands/draw_vector_line.html#pygerber.backend.abstract.draw_commands.draw_vector_line.DrawVectorLine.get_bounding_box","title":"get_bounding_box","text":"<pre><code>get_bounding_box() -&gt; BoundingBox\n</code></pre> <p>Return bounding box of draw operation.</p> Source code in <code>src/pygerber/backend/abstract/draw_commands/draw_vector_line.py</code> <pre><code>def get_bounding_box(self) -&gt; BoundingBox:\n    \"\"\"Return bounding box of draw operation.\"\"\"\n    vertex_box = BoundingBox.from_diameter(self.width)\n    return (vertex_box + self.start_position) + (vertex_box + self.end_position)\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/__init__.html","title":"init","text":""},{"location":"reference/pygerber/backend/rasterized_2d/__init__.html#pygerber.backend.rasterized_2d","title":"rasterized_2d","text":"<p>Backend implementation for rendering 2D rasterized images.</p>"},{"location":"reference/pygerber/backend/rasterized_2d/aperture_handle.html","title":"aperture_handle","text":""},{"location":"reference/pygerber/backend/rasterized_2d/aperture_handle.html#pygerber.backend.rasterized_2d.aperture_handle","title":"aperture_handle","text":"<p>Aperture Handle class which represents Gerber X3 aperture.</p>"},{"location":"reference/pygerber/backend/rasterized_2d/aperture_handle.html#pygerber.backend.rasterized_2d.aperture_handle.Rasterized2DPrivateApertureHandle","title":"Rasterized2DPrivateApertureHandle","text":"<p>             Bases: <code>PrivateApertureHandle</code></p> <p>Base class for creating Gerber X3 apertures.</p> Source code in <code>src/pygerber/backend/rasterized_2d/aperture_handle.py</code> <pre><code>class Rasterized2DPrivateApertureHandle(PrivateApertureHandle):\n    \"\"\"Base class for creating Gerber X3 apertures.\"\"\"\n\n    backend: Rasterized2DBackend\n    drawing_target: Rasterized2DDrawingTarget\n\n    def _create_drawing_target(self) -&gt; DrawingTarget:\n        \"\"\"Draw aperture and store result.\"\"\"\n        bbox = self.bounding_box\n        size = bbox.get_size().as_pixels(self.backend.dpi)\n\n        # Image must be at least 1x1, otherwise Pillow crashes while saving.\n        x, y = size\n        size = (max(x, 0) + 1, max(y, 0) + 1)\n\n        return Rasterized2DDrawingTarget(\n            coordinate_origin=self.coordinate_origin,\n            bounding_box=self.bounding_box,\n            target_image=Image.new(\n                mode=\"L\",\n                size=size,\n                color=Polarity.Background.get_2d_rasterized_color(),\n            ),\n        )\n\n    def _post_drawing_hook(self) -&gt; None:\n        dest = self.backend.options.dump_apertures\n        if dest is not None:\n            dest_aperture_subdir = dest / f\"{self.aperture_id}_{self.private_id}\"\n            dest_aperture_subdir.mkdir(0o777, parents=True, exist_ok=True)\n\n            self.drawing_target.target_image.save(\n                dest_aperture_subdir / \"target.png\",\n            )\n            self.drawing_target.mask_image.save(\n                dest_aperture_subdir / \"mask.png\",\n            )\n            self.drawing_target.image_polarity_clear.save(\n                dest_aperture_subdir / \"clear.png\",\n            )\n            self.drawing_target.image_polarity_dark.save(\n                dest_aperture_subdir / \"dark.png\",\n            )\n            self.drawing_target.image_polarity_region_clear.save(\n                dest_aperture_subdir / \"clear_region.png\",\n            )\n            self.drawing_target.image_polarity_region_dark.save(\n                dest_aperture_subdir / \"dark_region.png\",\n            )\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/backend_cls.html","title":"backend_cls","text":""},{"location":"reference/pygerber/backend/rasterized_2d/backend_cls.html#pygerber.backend.rasterized_2d.backend_cls","title":"backend_cls","text":"<p>Backend for rasterized rendering of Gerber files.</p>"},{"location":"reference/pygerber/backend/rasterized_2d/backend_cls.html#pygerber.backend.rasterized_2d.backend_cls.ColorMode","title":"ColorMode","text":"<p>             Bases: <code>Enum</code></p> <p>Enum which can be used to specify color mode.</p> Source code in <code>src/pygerber/backend/rasterized_2d/backend_cls.py</code> <pre><code>class ColorMode(Enum):\n    \"\"\"Enum which can be used to specify color mode.\"\"\"\n\n    RGBA = \"RGBA\"\n    RGB = \"RGB\"\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/backend_cls.html#pygerber.backend.rasterized_2d.backend_cls.Rasterized2DBackendOptions","title":"Rasterized2DBackendOptions","text":"<p>             Bases: <code>BackendOptions</code></p> <p>Additional configuration which can be passed to backend.</p> Source code in <code>src/pygerber/backend/rasterized_2d/backend_cls.py</code> <pre><code>class Rasterized2DBackendOptions(BackendOptions):\n    \"\"\"Additional configuration which can be passed to backend.\"\"\"\n\n    def __init__(\n        self,\n        dpi: int = 300,\n        color_scheme: ColorScheme = ColorScheme.DEFAULT_GRAYSCALE,\n        color_mode: ColorMode = ColorMode.RGBA,\n        dump_apertures: Optional[Path] = None,\n        *,\n        include_debug_padding: bool = False,\n        include_bounding_boxes: bool = False,\n        draw_region_outlines: bool = False,\n    ) -&gt; None:\n        \"\"\"Initialize options.\"\"\"\n        self.dpi = dpi\n        self.color_scheme = color_scheme\n        self.color_mode = color_mode\n        self.include_debug_padding = include_debug_padding\n        self.include_bounding_boxes = include_bounding_boxes\n        super().__init__(\n            dump_apertures=dump_apertures,\n            draw_region_outlines=draw_region_outlines,\n        )\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/backend_cls.html#pygerber.backend.rasterized_2d.backend_cls.Rasterized2DBackendOptions.__init__","title":"__init__","text":"<pre><code>__init__(\n    dpi: int = 300,\n    color_scheme: ColorScheme = ColorScheme.DEFAULT_GRAYSCALE,\n    color_mode: ColorMode = ColorMode.RGBA,\n    dump_apertures: Optional[Path] = None,\n    *,\n    include_debug_padding: bool = False,\n    include_bounding_boxes: bool = False,\n    draw_region_outlines: bool = False\n) -&gt; None\n</code></pre> <p>Initialize options.</p> Source code in <code>src/pygerber/backend/rasterized_2d/backend_cls.py</code> <pre><code>def __init__(\n    self,\n    dpi: int = 300,\n    color_scheme: ColorScheme = ColorScheme.DEFAULT_GRAYSCALE,\n    color_mode: ColorMode = ColorMode.RGBA,\n    dump_apertures: Optional[Path] = None,\n    *,\n    include_debug_padding: bool = False,\n    include_bounding_boxes: bool = False,\n    draw_region_outlines: bool = False,\n) -&gt; None:\n    \"\"\"Initialize options.\"\"\"\n    self.dpi = dpi\n    self.color_scheme = color_scheme\n    self.color_mode = color_mode\n    self.include_debug_padding = include_debug_padding\n    self.include_bounding_boxes = include_bounding_boxes\n    super().__init__(\n        dump_apertures=dump_apertures,\n        draw_region_outlines=draw_region_outlines,\n    )\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/backend_cls.html#pygerber.backend.rasterized_2d.backend_cls.Rasterized2DBackend","title":"Rasterized2DBackend","text":"<p>             Bases: <code>Backend</code></p> <p>Drawing backend interface.</p> Source code in <code>src/pygerber/backend/rasterized_2d/backend_cls.py</code> <pre><code>class Rasterized2DBackend(Backend):\n    \"\"\"Drawing backend interface.\"\"\"\n\n    options: Rasterized2DBackendOptions\n    drawing_target: Rasterized2DDrawingTarget\n\n    options_class: ClassVar[type[BackendOptions]] = Rasterized2DBackendOptions\n\n    def __init__(self, options: Rasterized2DBackendOptions | None = None) -&gt; None:\n        \"\"\"Initialize backend.\"\"\"\n        if options is not None and not isinstance(options, Rasterized2DBackendOptions):\n            msg = (  # type: ignore[unreachable]\n                \"Expected Rasterized2DBackendOptions or None as options, got \"\n                + str(\n                    type(options),\n                )\n            )\n            raise TypeError(msg)\n        super().__init__(options)\n\n    @property\n    def dpi(self) -&gt; int:\n        \"\"\"Return image DPI.\"\"\"\n        return self.options.dpi\n\n    def _create_drawing_target(self) -&gt; DrawingTarget:\n        \"\"\"Execute all draw actions to create visualization.\"\"\"\n        raw_bbox = self.bounding_box\n\n        if self.options.include_debug_padding:\n            bbox = raw_bbox + Decimal(1.0)\n        else:\n            bbox = raw_bbox\n\n        size = bbox.get_size()\n        coordinate_origin = bbox.get_min_vector()\n\n        image_size = size.as_pixels(self.dpi)\n        # Image must be at least 1x1, otherwise Pillow crashes while saving.\n        x, y = image_size\n        image_size = (max(x, 0) + 1, max(y, 0) + 1)\n\n        return Rasterized2DDrawingTarget(\n            coordinate_origin=coordinate_origin,\n            bounding_box=bbox,\n            target_image=Image.new(\n                mode=\"L\",\n                size=image_size,\n                color=Polarity.Background.get_2d_rasterized_color(),\n            ),\n        )\n\n    def _pre_drawing_hook(self) -&gt; None:\n        \"\"\"Perform custom actions after drawing.\"\"\"\n        if self.options.include_bounding_boxes:\n            self.draws.append(\n                Rasterized2DApertureDrawBoundingBox(\n                    backend=self,\n                    polarity=Polarity.DEBUG,\n                    bounding_box=self.bounding_box,\n                    outline_padding=Offset.from_pixels(1, self.dpi),\n                ),\n            )\n\n    def _post_drawing_hook(self) -&gt; None:\n        self._replace_image_colors()\n\n    def _replace_image_colors(self) -&gt; None:\n        img = self.drawing_target.target_image\n        color_map = self.options.color_scheme.get_grayscale_to_rgba_color_map()\n\n        np_img = np.array(img)\n\n        # Create an empty RGBA image with the same size as the original image\n        rgba_img: npt.NDArray[np.uint8] = np.zeros(\n            (img.height, img.width, 4),\n            dtype=np.uint8,\n        )\n\n        # For each grayscale value, set the corresponding RGBA value in the new image\n        for gray_value, rgba in color_map.items():\n            rgba_img[np_img == gray_value] = rgba\n\n        # Convert the resulting NumPy array back to a Pillow image\n        self.drawing_target.target_image = Image.fromarray(rgba_img, \"RGBA\")\n\n    def get_result_handle(self) -&gt; ResultHandle:\n        \"\"\"Return result handle to visualization.\"\"\"\n        return Rasterized2DResultHandle(self.drawing_target.target_image)\n\n    def get_aperture_handle_cls(self) -&gt; type[PrivateApertureHandle]:\n        \"\"\"Get backend-specific implementation of aperture handle class.\"\"\"\n        return Rasterized2DPrivateApertureHandle\n\n    def get_draw_circle_cls(self) -&gt; type[DrawCircle]:\n        \"\"\"Get backend-specific implementation of aperture circle component class.\"\"\"\n        return Rasterized2DApertureDrawCircle\n\n    def get_draw_rectangle_cls(self) -&gt; type[DrawRectangle]:\n        \"\"\"Get backend-specific implementation of aperture rectangle component class.\"\"\"\n        return Rasterized2DApertureDrawRectangle\n\n    def get_draw_polygon_cls(self) -&gt; type[DrawPolygon]:\n        \"\"\"Get backend-specific implementation of aperture polygon component class.\"\"\"\n        return Rasterized2DApertureDrawPolygon\n\n    def get_draw_commands_handle_cls(self) -&gt; type[DrawCommandsHandle]:\n        \"\"\"Return backend-specific implementation of draw actions handle.\"\"\"\n        return Rasterized2DDrawActionsHandle\n\n    def get_draw_paste_cls(self) -&gt; type[DrawPaste]:\n        \"\"\"Return backend-specific implementation of draw action flash.\"\"\"\n        return Rasterized2DDrawPaste\n\n    def get_draw_region_cls(self) -&gt; type[DrawRegion]:\n        \"\"\"Return backend-specific implementation of draw action region.\"\"\"\n        return Rasterized2DDrawRegion\n\n    def get_draw_vector_line_cls(self) -&gt; type[DrawVectorLine]:\n        \"\"\"Return backend-specific implementation of draw action line.\"\"\"\n        return Rasterized2DDrawVectorLine\n\n    def get_draw_arc_cls(self) -&gt; type[DrawArc]:\n        \"\"\"Return backend-specific implementation of draw action arc.\"\"\"\n        return Rasterized2DDrawArc\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/backend_cls.html#pygerber.backend.rasterized_2d.backend_cls.Rasterized2DBackend.dpi","title":"dpi  <code>property</code>","text":"<pre><code>dpi: int\n</code></pre> <p>Return image DPI.</p>"},{"location":"reference/pygerber/backend/rasterized_2d/backend_cls.html#pygerber.backend.rasterized_2d.backend_cls.Rasterized2DBackend.__init__","title":"__init__","text":"<pre><code>__init__(\n    options: Rasterized2DBackendOptions | None = None,\n) -&gt; None\n</code></pre> <p>Initialize backend.</p> Source code in <code>src/pygerber/backend/rasterized_2d/backend_cls.py</code> <pre><code>def __init__(self, options: Rasterized2DBackendOptions | None = None) -&gt; None:\n    \"\"\"Initialize backend.\"\"\"\n    if options is not None and not isinstance(options, Rasterized2DBackendOptions):\n        msg = (  # type: ignore[unreachable]\n            \"Expected Rasterized2DBackendOptions or None as options, got \"\n            + str(\n                type(options),\n            )\n        )\n        raise TypeError(msg)\n    super().__init__(options)\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/backend_cls.html#pygerber.backend.rasterized_2d.backend_cls.Rasterized2DBackend.get_result_handle","title":"get_result_handle","text":"<pre><code>get_result_handle() -&gt; ResultHandle\n</code></pre> <p>Return result handle to visualization.</p> Source code in <code>src/pygerber/backend/rasterized_2d/backend_cls.py</code> <pre><code>def get_result_handle(self) -&gt; ResultHandle:\n    \"\"\"Return result handle to visualization.\"\"\"\n    return Rasterized2DResultHandle(self.drawing_target.target_image)\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/backend_cls.html#pygerber.backend.rasterized_2d.backend_cls.Rasterized2DBackend.get_aperture_handle_cls","title":"get_aperture_handle_cls","text":"<pre><code>get_aperture_handle_cls() -&gt; type[PrivateApertureHandle]\n</code></pre> <p>Get backend-specific implementation of aperture handle class.</p> Source code in <code>src/pygerber/backend/rasterized_2d/backend_cls.py</code> <pre><code>def get_aperture_handle_cls(self) -&gt; type[PrivateApertureHandle]:\n    \"\"\"Get backend-specific implementation of aperture handle class.\"\"\"\n    return Rasterized2DPrivateApertureHandle\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/backend_cls.html#pygerber.backend.rasterized_2d.backend_cls.Rasterized2DBackend.get_draw_circle_cls","title":"get_draw_circle_cls","text":"<pre><code>get_draw_circle_cls() -&gt; type[DrawCircle]\n</code></pre> <p>Get backend-specific implementation of aperture circle component class.</p> Source code in <code>src/pygerber/backend/rasterized_2d/backend_cls.py</code> <pre><code>def get_draw_circle_cls(self) -&gt; type[DrawCircle]:\n    \"\"\"Get backend-specific implementation of aperture circle component class.\"\"\"\n    return Rasterized2DApertureDrawCircle\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/backend_cls.html#pygerber.backend.rasterized_2d.backend_cls.Rasterized2DBackend.get_draw_rectangle_cls","title":"get_draw_rectangle_cls","text":"<pre><code>get_draw_rectangle_cls() -&gt; type[DrawRectangle]\n</code></pre> <p>Get backend-specific implementation of aperture rectangle component class.</p> Source code in <code>src/pygerber/backend/rasterized_2d/backend_cls.py</code> <pre><code>def get_draw_rectangle_cls(self) -&gt; type[DrawRectangle]:\n    \"\"\"Get backend-specific implementation of aperture rectangle component class.\"\"\"\n    return Rasterized2DApertureDrawRectangle\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/backend_cls.html#pygerber.backend.rasterized_2d.backend_cls.Rasterized2DBackend.get_draw_polygon_cls","title":"get_draw_polygon_cls","text":"<pre><code>get_draw_polygon_cls() -&gt; type[DrawPolygon]\n</code></pre> <p>Get backend-specific implementation of aperture polygon component class.</p> Source code in <code>src/pygerber/backend/rasterized_2d/backend_cls.py</code> <pre><code>def get_draw_polygon_cls(self) -&gt; type[DrawPolygon]:\n    \"\"\"Get backend-specific implementation of aperture polygon component class.\"\"\"\n    return Rasterized2DApertureDrawPolygon\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/backend_cls.html#pygerber.backend.rasterized_2d.backend_cls.Rasterized2DBackend.get_draw_commands_handle_cls","title":"get_draw_commands_handle_cls","text":"<pre><code>get_draw_commands_handle_cls() -&gt; type[DrawCommandsHandle]\n</code></pre> <p>Return backend-specific implementation of draw actions handle.</p> Source code in <code>src/pygerber/backend/rasterized_2d/backend_cls.py</code> <pre><code>def get_draw_commands_handle_cls(self) -&gt; type[DrawCommandsHandle]:\n    \"\"\"Return backend-specific implementation of draw actions handle.\"\"\"\n    return Rasterized2DDrawActionsHandle\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/backend_cls.html#pygerber.backend.rasterized_2d.backend_cls.Rasterized2DBackend.get_draw_paste_cls","title":"get_draw_paste_cls","text":"<pre><code>get_draw_paste_cls() -&gt; type[DrawPaste]\n</code></pre> <p>Return backend-specific implementation of draw action flash.</p> Source code in <code>src/pygerber/backend/rasterized_2d/backend_cls.py</code> <pre><code>def get_draw_paste_cls(self) -&gt; type[DrawPaste]:\n    \"\"\"Return backend-specific implementation of draw action flash.\"\"\"\n    return Rasterized2DDrawPaste\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/backend_cls.html#pygerber.backend.rasterized_2d.backend_cls.Rasterized2DBackend.get_draw_region_cls","title":"get_draw_region_cls","text":"<pre><code>get_draw_region_cls() -&gt; type[DrawRegion]\n</code></pre> <p>Return backend-specific implementation of draw action region.</p> Source code in <code>src/pygerber/backend/rasterized_2d/backend_cls.py</code> <pre><code>def get_draw_region_cls(self) -&gt; type[DrawRegion]:\n    \"\"\"Return backend-specific implementation of draw action region.\"\"\"\n    return Rasterized2DDrawRegion\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/backend_cls.html#pygerber.backend.rasterized_2d.backend_cls.Rasterized2DBackend.get_draw_vector_line_cls","title":"get_draw_vector_line_cls","text":"<pre><code>get_draw_vector_line_cls() -&gt; type[DrawVectorLine]\n</code></pre> <p>Return backend-specific implementation of draw action line.</p> Source code in <code>src/pygerber/backend/rasterized_2d/backend_cls.py</code> <pre><code>def get_draw_vector_line_cls(self) -&gt; type[DrawVectorLine]:\n    \"\"\"Return backend-specific implementation of draw action line.\"\"\"\n    return Rasterized2DDrawVectorLine\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/backend_cls.html#pygerber.backend.rasterized_2d.backend_cls.Rasterized2DBackend.get_draw_arc_cls","title":"get_draw_arc_cls","text":"<pre><code>get_draw_arc_cls() -&gt; type[DrawArc]\n</code></pre> <p>Return backend-specific implementation of draw action arc.</p> Source code in <code>src/pygerber/backend/rasterized_2d/backend_cls.py</code> <pre><code>def get_draw_arc_cls(self) -&gt; type[DrawArc]:\n    \"\"\"Return backend-specific implementation of draw action arc.\"\"\"\n    return Rasterized2DDrawArc\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/color_scheme.html","title":"color_scheme","text":""},{"location":"reference/pygerber/backend/rasterized_2d/color_scheme.html#pygerber.backend.rasterized_2d.color_scheme","title":"color_scheme","text":"<p>ColorScheme class - utility for describing color schemes.</p>"},{"location":"reference/pygerber/backend/rasterized_2d/color_scheme.html#pygerber.backend.rasterized_2d.color_scheme.ColorScheme","title":"ColorScheme","text":"<p>             Bases: <code>FrozenGeneralModel</code></p> <p>Set of colors which should be used for rendering.</p> <p>ColorScheme class contains set of colors which should be used for different parts of rendered image. At the same time it also works as a container for predefined color schemes commonly used for parts of PCB.</p> <p>Predefined colors</p> <p>All predefined colors have two variants - normal one and one with \"*_ALPHA\" suffix. Those without suffix have solid background and are not intended for constructing multi-layer images out of them ie. they are not suitable for rendering a project consisting of separate copper, silk, pase mask and composing them into single image. For cases when rendered images are intended for stacking \"*_ALPHA\" schemes should be used, as background and transparent parts of image will be truly transparent.</p> Source code in <code>src/pygerber/backend/rasterized_2d/color_scheme.py</code> <pre><code>class ColorScheme(FrozenGeneralModel):\n    r\"\"\"Set of colors which should be used for rendering.\n\n    ColorScheme class contains set of colors which should be used for different parts\n    of rendered image. At the same time it also works as a container for predefined\n    color schemes commonly used for parts of PCB.\n\n    !!! info \"Predefined colors\"\n\n        All predefined colors have two variants - normal one and one with \"\\*_ALPHA\"\n        suffix. Those without suffix have solid background and are not intended for\n        constructing multi-layer images out of them ie. they are not suitable for\n        rendering a project consisting of separate copper, silk, pase mask and composing\n        them into single image. For cases when rendered images are intended for stacking\n        \"\\*_ALPHA\" schemes should be used, as background and transparent parts of image\n        will be truly transparent.\n\n    \"\"\"\n\n    SILK: ClassVar[ColorScheme]\n    \"\"\"Default color of silk layer.\n\n    This schema provided non-transparent background, which results in images which\n    can not be used for stacking on top of other layers, as they would completely\n    obscure them.\"\"\"\n\n    SILK_ALPHA: ClassVar[ColorScheme]\n    \"\"\"Default color of silk layer with alpha channel.\n\n    This schema provides transparent background. Images using this schema can be\n    stacked on top of each other without obscuring layers below.\"\"\"\n\n    COPPER: ClassVar[ColorScheme]\n    \"\"\"Default color of copper layer.\n\n    This schema provided non-transparent background, which results in images which\n    can not be used for stacking on top of other layers, as they would completely\n    obscure them.\"\"\"\n\n    COPPER_ALPHA: ClassVar[ColorScheme]\n    \"\"\"Default color of copper layer with alpha channel.\n\n    This schema provides transparent background. Images using this schema can be\n    stacked on top of each other without obscuring layers below.\"\"\"\n\n    PASTE_MASK: ClassVar[ColorScheme]\n    \"\"\"Default color of paste mask layer.\n\n    This schema provided non-transparent background, which results in images which\n    can not be used for stacking on top of other layers, as they would completely\n    obscure them.\"\"\"\n\n    PASTE_MASK_ALPHA: ClassVar[ColorScheme]\n    \"\"\"Default color of paste mask layer with alpha channel.\n\n    This schema provides transparent background. Images using this schema can be\n    stacked on top of each other without obscuring layers below.\"\"\"\n\n    SOLDER_MASK: ClassVar[ColorScheme]\n    \"\"\"Default color of solder mask layer.\n\n    This schema provided non-transparent background, which results in images which\n    can not be used for stacking on top of other layers, as they would completely\n    obscure them.\"\"\"\n\n    SOLDER_MASK_ALPHA: ClassVar[ColorScheme]\n    \"\"\"Default color of solder mask layer with alpha channel.\n\n    This schema provides transparent background. Images using this schema can be\n    stacked on top of each other without obscuring layers below.\"\"\"\n\n    DEFAULT_GRAYSCALE: ClassVar[ColorScheme]\n    \"\"\"Default color scheme for files which were not assigned other color scheme.\"\"\"\n\n    DEBUG_1: ClassVar[ColorScheme]\n    \"\"\"Debug color scheme.\"\"\"\n\n    DEBUG_1_ALPHA: ClassVar[ColorScheme]\n    \"\"\"Debug color scheme with alpha channel.\"\"\"\n\n    background_color: RGBA\n    \"\"\"Color used as empty image background.\"\"\"\n\n    clear_color: RGBA\n    \"\"\"Color used for clear draws.\"\"\"\n\n    solid_color: RGBA\n    \"\"\"Color used for solid draws.\"\"\"\n\n    clear_region_color: RGBA\n    \"\"\"Color used for clear region draws.\"\"\"\n\n    solid_region_color: RGBA\n    \"\"\"Color used for solid region draws.\"\"\"\n\n    debug_1_color: RGBA = RGBA.from_hex(\"#ababab\")\n    \"\"\"Color used for debug elements.\"\"\"\n\n    debug_2_color: RGBA = RGBA.from_hex(\"#7d7d7d\")\n    \"\"\"Color used for debug elements.\"\"\"\n\n    def get_grayscale_to_rgba_color_map(self) -&gt; dict[int, tuple[int, int, int, int]]:\n        \"\"\"Return grayscale to RGBA color map.\"\"\"\n        return {\n            Polarity.Dark.get_2d_rasterized_color(): self.solid_color.as_rgba_int(),\n            Polarity.Clear.get_2d_rasterized_color(): self.clear_color.as_rgba_int(),\n            Polarity.DarkRegion.get_2d_rasterized_color(): self.solid_region_color.as_rgba_int(),  # noqa: E501\n            Polarity.ClearRegion.get_2d_rasterized_color(): self.clear_region_color.as_rgba_int(),  # noqa: E501\n            Polarity.Background.get_2d_rasterized_color(): self.background_color.as_rgba_int(),  # noqa: E501\n            Polarity.DEBUG.get_2d_rasterized_color(): self.debug_1_color.as_rgba_int(),\n            Polarity.DEBUG2.get_2d_rasterized_color(): self.debug_2_color.as_rgba_int(),\n        }\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/color_scheme.html#pygerber.backend.rasterized_2d.color_scheme.ColorScheme.SILK","title":"SILK  <code>class-attribute</code>","text":"<pre><code>SILK: ColorScheme\n</code></pre> <p>Default color of silk layer.</p> <p>This schema provided non-transparent background, which results in images which can not be used for stacking on top of other layers, as they would completely obscure them.</p>"},{"location":"reference/pygerber/backend/rasterized_2d/color_scheme.html#pygerber.backend.rasterized_2d.color_scheme.ColorScheme.SILK_ALPHA","title":"SILK_ALPHA  <code>class-attribute</code>","text":"<pre><code>SILK_ALPHA: ColorScheme\n</code></pre> <p>Default color of silk layer with alpha channel.</p> <p>This schema provides transparent background. Images using this schema can be stacked on top of each other without obscuring layers below.</p>"},{"location":"reference/pygerber/backend/rasterized_2d/color_scheme.html#pygerber.backend.rasterized_2d.color_scheme.ColorScheme.COPPER","title":"COPPER  <code>class-attribute</code>","text":"<pre><code>COPPER: ColorScheme\n</code></pre> <p>Default color of copper layer.</p> <p>This schema provided non-transparent background, which results in images which can not be used for stacking on top of other layers, as they would completely obscure them.</p>"},{"location":"reference/pygerber/backend/rasterized_2d/color_scheme.html#pygerber.backend.rasterized_2d.color_scheme.ColorScheme.COPPER_ALPHA","title":"COPPER_ALPHA  <code>class-attribute</code>","text":"<pre><code>COPPER_ALPHA: ColorScheme\n</code></pre> <p>Default color of copper layer with alpha channel.</p> <p>This schema provides transparent background. Images using this schema can be stacked on top of each other without obscuring layers below.</p>"},{"location":"reference/pygerber/backend/rasterized_2d/color_scheme.html#pygerber.backend.rasterized_2d.color_scheme.ColorScheme.PASTE_MASK","title":"PASTE_MASK  <code>class-attribute</code>","text":"<pre><code>PASTE_MASK: ColorScheme\n</code></pre> <p>Default color of paste mask layer.</p> <p>This schema provided non-transparent background, which results in images which can not be used for stacking on top of other layers, as they would completely obscure them.</p>"},{"location":"reference/pygerber/backend/rasterized_2d/color_scheme.html#pygerber.backend.rasterized_2d.color_scheme.ColorScheme.PASTE_MASK_ALPHA","title":"PASTE_MASK_ALPHA  <code>class-attribute</code>","text":"<pre><code>PASTE_MASK_ALPHA: ColorScheme\n</code></pre> <p>Default color of paste mask layer with alpha channel.</p> <p>This schema provides transparent background. Images using this schema can be stacked on top of each other without obscuring layers below.</p>"},{"location":"reference/pygerber/backend/rasterized_2d/color_scheme.html#pygerber.backend.rasterized_2d.color_scheme.ColorScheme.SOLDER_MASK","title":"SOLDER_MASK  <code>class-attribute</code>","text":"<pre><code>SOLDER_MASK: ColorScheme\n</code></pre> <p>Default color of solder mask layer.</p> <p>This schema provided non-transparent background, which results in images which can not be used for stacking on top of other layers, as they would completely obscure them.</p>"},{"location":"reference/pygerber/backend/rasterized_2d/color_scheme.html#pygerber.backend.rasterized_2d.color_scheme.ColorScheme.SOLDER_MASK_ALPHA","title":"SOLDER_MASK_ALPHA  <code>class-attribute</code>","text":"<pre><code>SOLDER_MASK_ALPHA: ColorScheme\n</code></pre> <p>Default color of solder mask layer with alpha channel.</p> <p>This schema provides transparent background. Images using this schema can be stacked on top of each other without obscuring layers below.</p>"},{"location":"reference/pygerber/backend/rasterized_2d/color_scheme.html#pygerber.backend.rasterized_2d.color_scheme.ColorScheme.DEFAULT_GRAYSCALE","title":"DEFAULT_GRAYSCALE  <code>class-attribute</code>","text":"<pre><code>DEFAULT_GRAYSCALE: ColorScheme\n</code></pre> <p>Default color scheme for files which were not assigned other color scheme.</p>"},{"location":"reference/pygerber/backend/rasterized_2d/color_scheme.html#pygerber.backend.rasterized_2d.color_scheme.ColorScheme.DEBUG_1","title":"DEBUG_1  <code>class-attribute</code>","text":"<pre><code>DEBUG_1: ColorScheme\n</code></pre> <p>Debug color scheme.</p>"},{"location":"reference/pygerber/backend/rasterized_2d/color_scheme.html#pygerber.backend.rasterized_2d.color_scheme.ColorScheme.DEBUG_1_ALPHA","title":"DEBUG_1_ALPHA  <code>class-attribute</code>","text":"<pre><code>DEBUG_1_ALPHA: ColorScheme\n</code></pre> <p>Debug color scheme with alpha channel.</p>"},{"location":"reference/pygerber/backend/rasterized_2d/color_scheme.html#pygerber.backend.rasterized_2d.color_scheme.ColorScheme.background_color","title":"background_color  <code>instance-attribute</code>","text":"<pre><code>background_color: RGBA\n</code></pre> <p>Color used as empty image background.</p>"},{"location":"reference/pygerber/backend/rasterized_2d/color_scheme.html#pygerber.backend.rasterized_2d.color_scheme.ColorScheme.clear_color","title":"clear_color  <code>instance-attribute</code>","text":"<pre><code>clear_color: RGBA\n</code></pre> <p>Color used for clear draws.</p>"},{"location":"reference/pygerber/backend/rasterized_2d/color_scheme.html#pygerber.backend.rasterized_2d.color_scheme.ColorScheme.solid_color","title":"solid_color  <code>instance-attribute</code>","text":"<pre><code>solid_color: RGBA\n</code></pre> <p>Color used for solid draws.</p>"},{"location":"reference/pygerber/backend/rasterized_2d/color_scheme.html#pygerber.backend.rasterized_2d.color_scheme.ColorScheme.clear_region_color","title":"clear_region_color  <code>instance-attribute</code>","text":"<pre><code>clear_region_color: RGBA\n</code></pre> <p>Color used for clear region draws.</p>"},{"location":"reference/pygerber/backend/rasterized_2d/color_scheme.html#pygerber.backend.rasterized_2d.color_scheme.ColorScheme.solid_region_color","title":"solid_region_color  <code>instance-attribute</code>","text":"<pre><code>solid_region_color: RGBA\n</code></pre> <p>Color used for solid region draws.</p>"},{"location":"reference/pygerber/backend/rasterized_2d/color_scheme.html#pygerber.backend.rasterized_2d.color_scheme.ColorScheme.debug_1_color","title":"debug_1_color  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>debug_1_color: RGBA = from_hex('#ababab')\n</code></pre> <p>Color used for debug elements.</p>"},{"location":"reference/pygerber/backend/rasterized_2d/color_scheme.html#pygerber.backend.rasterized_2d.color_scheme.ColorScheme.debug_2_color","title":"debug_2_color  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>debug_2_color: RGBA = from_hex('#7d7d7d')\n</code></pre> <p>Color used for debug elements.</p>"},{"location":"reference/pygerber/backend/rasterized_2d/color_scheme.html#pygerber.backend.rasterized_2d.color_scheme.ColorScheme.get_grayscale_to_rgba_color_map","title":"get_grayscale_to_rgba_color_map","text":"<pre><code>get_grayscale_to_rgba_color_map() -&gt; (\n    dict[int, tuple[int, int, int, int]]\n)\n</code></pre> <p>Return grayscale to RGBA color map.</p> Source code in <code>src/pygerber/backend/rasterized_2d/color_scheme.py</code> <pre><code>def get_grayscale_to_rgba_color_map(self) -&gt; dict[int, tuple[int, int, int, int]]:\n    \"\"\"Return grayscale to RGBA color map.\"\"\"\n    return {\n        Polarity.Dark.get_2d_rasterized_color(): self.solid_color.as_rgba_int(),\n        Polarity.Clear.get_2d_rasterized_color(): self.clear_color.as_rgba_int(),\n        Polarity.DarkRegion.get_2d_rasterized_color(): self.solid_region_color.as_rgba_int(),  # noqa: E501\n        Polarity.ClearRegion.get_2d_rasterized_color(): self.clear_region_color.as_rgba_int(),  # noqa: E501\n        Polarity.Background.get_2d_rasterized_color(): self.background_color.as_rgba_int(),  # noqa: E501\n        Polarity.DEBUG.get_2d_rasterized_color(): self.debug_1_color.as_rgba_int(),\n        Polarity.DEBUG2.get_2d_rasterized_color(): self.debug_2_color.as_rgba_int(),\n    }\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/draw_commands_handle.html","title":"draw_commands_handle","text":""},{"location":"reference/pygerber/backend/rasterized_2d/draw_commands_handle.html#pygerber.backend.rasterized_2d.draw_commands_handle","title":"draw_commands_handle","text":"<p>Contains class wrapping list of draw operations created by Gerber parser.</p>"},{"location":"reference/pygerber/backend/rasterized_2d/draw_commands_handle.html#pygerber.backend.rasterized_2d.draw_commands_handle.Rasterized2DDrawActionsHandle","title":"Rasterized2DDrawActionsHandle","text":"<p>             Bases: <code>DrawCommandsHandle</code></p> <p>List of drawing operations produced by Gerber parser.</p> Source code in <code>src/pygerber/backend/rasterized_2d/draw_commands_handle.py</code> <pre><code>class Rasterized2DDrawActionsHandle(DrawCommandsHandle):\n    \"\"\"List of drawing operations produced by Gerber parser.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/drawing_target.html","title":"drawing_target","text":""},{"location":"reference/pygerber/backend/rasterized_2d/drawing_target.html#pygerber.backend.rasterized_2d.drawing_target","title":"drawing_target","text":"<p>Target for Draw commands to draw into.</p>"},{"location":"reference/pygerber/backend/rasterized_2d/drawing_target.html#pygerber.backend.rasterized_2d.drawing_target.Rasterized2DDrawingTarget","title":"Rasterized2DDrawingTarget","text":"<p>             Bases: <code>DrawingTarget</code></p> <p>Target for Draw commands to draw into.</p> Source code in <code>src/pygerber/backend/rasterized_2d/drawing_target.py</code> <pre><code>class Rasterized2DDrawingTarget(DrawingTarget):\n    \"\"\"Target for Draw commands to draw into.\"\"\"\n\n    target_image: Image.Image\n    _target_image_polarity_dark: Optional[Image.Image] = None\n    _target_image_polarity_clear: Optional[Image.Image] = None\n    _target_image_polarity_region_dark: Optional[Image.Image] = None\n    _target_image_polarity_region_clear: Optional[Image.Image] = None\n    _mask_image: Optional[Image.Image] = None\n\n    def __init__(\n        self,\n        coordinate_origin: Vector2D,\n        bounding_box: BoundingBox,\n        target_image: Image.Image,\n    ) -&gt; None:\n        \"\"\"Initialize drawing target.\"\"\"\n        super().__init__(coordinate_origin, bounding_box)\n        self.target_image = target_image\n        self._target_image_polarity_dark = None\n        self._target_image_polarity_clear = None\n        self._target_image_polarity_region_dark = None\n        self._target_image_polarity_region_clear = None\n        self._mask_image = None\n        self._is_finalized = False\n\n    @property\n    def image_draw(self) -&gt; ImageDraw.ImageDraw:\n        \"\"\"Acquire drawing interface.\"\"\"\n        return ImageDraw.Draw(self.target_image)\n\n    def _finalize(self) -&gt; None:\n        self._is_finalized = True\n\n    @property\n    def mask_image(self) -&gt; Image.Image:\n        \"\"\"Inverted aperture image.\"\"\"\n        if not self._is_finalized:\n            raise ApertureImageNotInitializedError\n\n        if self._mask_image is None:\n            self._mask_image = self.target_image.point(\n                lambda p: 255 if p &gt; GRAYSCALE_CENTER_VALUE else 0,\n            )\n\n        return self._mask_image\n\n    @property\n    def image_polarity_dark(self) -&gt; Image.Image:\n        \"\"\"Inverted aperture image.\"\"\"\n        if not self._is_finalized:\n            raise ApertureImageNotInitializedError\n\n        if self._target_image_polarity_dark is None:\n            color = Polarity.Dark.get_2d_rasterized_color()\n            self._target_image_polarity_dark = self.mask_image.point(\n                lambda p: color if p else 0,\n            )\n\n        return self._target_image_polarity_dark\n\n    @property\n    def image_polarity_clear(self) -&gt; Image.Image:\n        \"\"\"Inverted aperture image.\"\"\"\n        if not self._is_finalized:\n            raise ApertureImageNotInitializedError\n\n        if self._target_image_polarity_clear is None:\n            color = Polarity.Clear.get_2d_rasterized_color()\n            self._target_image_polarity_clear = self.mask_image.point(\n                lambda p: color if p else 0,\n            )\n\n        return self._target_image_polarity_clear\n\n    @property\n    def image_polarity_region_dark(self) -&gt; Image.Image:\n        \"\"\"Inverted aperture image.\"\"\"\n        if not self._is_finalized:\n            raise ApertureImageNotInitializedError\n\n        if self._target_image_polarity_region_dark is None:\n            color = Polarity.DarkRegion.get_2d_rasterized_color()\n            self._target_image_polarity_region_dark = self.mask_image.point(\n                lambda p: color if p else 0,\n            )\n\n        return self._target_image_polarity_region_dark\n\n    @property\n    def image_polarity_region_clear(self) -&gt; Image.Image:\n        \"\"\"Inverted aperture image.\"\"\"\n        if not self._is_finalized:\n            raise ApertureImageNotInitializedError\n\n        if self._target_image_polarity_region_clear is None:\n            color = Polarity.ClearRegion.get_2d_rasterized_color()\n            self._target_image_polarity_region_clear = self.mask_image.point(\n                lambda p: color if p else 0,\n            )\n\n        return self._target_image_polarity_region_clear\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/drawing_target.html#pygerber.backend.rasterized_2d.drawing_target.Rasterized2DDrawingTarget.image_draw","title":"image_draw  <code>property</code>","text":"<pre><code>image_draw: ImageDraw\n</code></pre> <p>Acquire drawing interface.</p>"},{"location":"reference/pygerber/backend/rasterized_2d/drawing_target.html#pygerber.backend.rasterized_2d.drawing_target.Rasterized2DDrawingTarget.mask_image","title":"mask_image  <code>property</code>","text":"<pre><code>mask_image: Image\n</code></pre> <p>Inverted aperture image.</p>"},{"location":"reference/pygerber/backend/rasterized_2d/drawing_target.html#pygerber.backend.rasterized_2d.drawing_target.Rasterized2DDrawingTarget.image_polarity_dark","title":"image_polarity_dark  <code>property</code>","text":"<pre><code>image_polarity_dark: Image\n</code></pre> <p>Inverted aperture image.</p>"},{"location":"reference/pygerber/backend/rasterized_2d/drawing_target.html#pygerber.backend.rasterized_2d.drawing_target.Rasterized2DDrawingTarget.image_polarity_clear","title":"image_polarity_clear  <code>property</code>","text":"<pre><code>image_polarity_clear: Image\n</code></pre> <p>Inverted aperture image.</p>"},{"location":"reference/pygerber/backend/rasterized_2d/drawing_target.html#pygerber.backend.rasterized_2d.drawing_target.Rasterized2DDrawingTarget.image_polarity_region_dark","title":"image_polarity_region_dark  <code>property</code>","text":"<pre><code>image_polarity_region_dark: Image\n</code></pre> <p>Inverted aperture image.</p>"},{"location":"reference/pygerber/backend/rasterized_2d/drawing_target.html#pygerber.backend.rasterized_2d.drawing_target.Rasterized2DDrawingTarget.image_polarity_region_clear","title":"image_polarity_region_clear  <code>property</code>","text":"<pre><code>image_polarity_region_clear: Image\n</code></pre> <p>Inverted aperture image.</p>"},{"location":"reference/pygerber/backend/rasterized_2d/drawing_target.html#pygerber.backend.rasterized_2d.drawing_target.Rasterized2DDrawingTarget.__init__","title":"__init__","text":"<pre><code>__init__(\n    coordinate_origin: Vector2D,\n    bounding_box: BoundingBox,\n    target_image: Image.Image,\n) -&gt; None\n</code></pre> <p>Initialize drawing target.</p> Source code in <code>src/pygerber/backend/rasterized_2d/drawing_target.py</code> <pre><code>def __init__(\n    self,\n    coordinate_origin: Vector2D,\n    bounding_box: BoundingBox,\n    target_image: Image.Image,\n) -&gt; None:\n    \"\"\"Initialize drawing target.\"\"\"\n    super().__init__(coordinate_origin, bounding_box)\n    self.target_image = target_image\n    self._target_image_polarity_dark = None\n    self._target_image_polarity_clear = None\n    self._target_image_polarity_region_dark = None\n    self._target_image_polarity_region_clear = None\n    self._mask_image = None\n    self._is_finalized = False\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/errors.html","title":"errors","text":""},{"location":"reference/pygerber/backend/rasterized_2d/errors.html#pygerber.backend.rasterized_2d.errors","title":"errors","text":"<p>Base error classes used in this module.</p>"},{"location":"reference/pygerber/backend/rasterized_2d/errors.html#pygerber.backend.rasterized_2d.errors.Rasterized2DBackendError","title":"Rasterized2DBackendError","text":"<p>             Bases: <code>BackendError</code></p> <p>Base class for backend errors.</p> Source code in <code>src/pygerber/backend/rasterized_2d/errors.py</code> <pre><code>class Rasterized2DBackendError(BackendError):\n    \"\"\"Base class for backend errors.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/errors.html#pygerber.backend.rasterized_2d.errors.ApertureImageNotInitializedError","title":"ApertureImageNotInitializedError","text":"<p>             Bases: <code>Rasterized2DBackendError</code></p> <p>Raised when aperture image is requested before it was initialized.</p> Source code in <code>src/pygerber/backend/rasterized_2d/errors.py</code> <pre><code>class ApertureImageNotInitializedError(Rasterized2DBackendError):\n    \"\"\"Raised when aperture image is requested before it was initialized.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/errors.html#pygerber.backend.rasterized_2d.errors.BackendImageNotInitializedError","title":"BackendImageNotInitializedError","text":"<p>             Bases: <code>Rasterized2DBackendError</code></p> <p>Raised when backend canvas image is requested before initialization.</p> Source code in <code>src/pygerber/backend/rasterized_2d/errors.py</code> <pre><code>class BackendImageNotInitializedError(Rasterized2DBackendError):\n    \"\"\"Raised when backend canvas image is requested before initialization.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/image_tools.html","title":"image_tools","text":""},{"location":"reference/pygerber/backend/rasterized_2d/image_tools.html#pygerber.backend.rasterized_2d.image_tools","title":"image_tools","text":"<p>Utils for image operations.</p>"},{"location":"reference/pygerber/backend/rasterized_2d/image_tools.html#pygerber.backend.rasterized_2d.image_tools.replace_color","title":"replace_color","text":"<pre><code>replace_color(\n    input_image: Image.Image,\n    original: tuple[int, ...] | int,\n    replacement: tuple[int, ...] | int,\n    *,\n    output_image_mode: str = \"RGBA\"\n) -&gt; Image.Image\n</code></pre> <p>Replace <code>original</code> color from input image with <code>replacement</code> color.</p> Source code in <code>src/pygerber/backend/rasterized_2d/image_tools.py</code> <pre><code>def replace_color(\n    input_image: Image.Image,\n    original: tuple[int, ...] | int,\n    replacement: tuple[int, ...] | int,\n    *,\n    output_image_mode: str = \"RGBA\",\n) -&gt; Image.Image:\n    \"\"\"Replace `original` color from input image with `replacement` color.\"\"\"\n    if input_image.mode != output_image_mode:\n        output_image = input_image.convert(output_image_mode)\n    else:\n        output_image = input_image.copy()\n\n    for x in range(input_image.width):\n        for y in range(input_image.height):\n            if input_image.getpixel((x, y)) == original:\n                output_image.putpixel((x, y), replacement)\n\n    return output_image\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/result_handle.html","title":"result_handle","text":""},{"location":"reference/pygerber/backend/rasterized_2d/result_handle.html#pygerber.backend.rasterized_2d.result_handle","title":"result_handle","text":"<p>Module contains handle class to drawing instructions visualization.</p>"},{"location":"reference/pygerber/backend/rasterized_2d/result_handle.html#pygerber.backend.rasterized_2d.result_handle.Rasterized2DResultHandle","title":"Rasterized2DResultHandle","text":"<p>             Bases: <code>ResultHandle</code></p> <p>Handle to drawing instructions visualization.</p> Source code in <code>src/pygerber/backend/rasterized_2d/result_handle.py</code> <pre><code>class Rasterized2DResultHandle(ResultHandle):\n    \"\"\"Handle to drawing instructions visualization.\"\"\"\n\n    def __init__(self, result: Image.Image) -&gt; None:\n        \"\"\"Initialize result handle.\n\n        Parameters\n        ----------\n        result : Image.Image\n            Image object containing finished Gerber image.\n        \"\"\"\n        super().__init__()\n        self.result = result\n\n    def save(\n        self,\n        dest: Path | str | BytesIO,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"Save result to destination.\n\n        Parameters\n        ----------\n        dest : Path | str | BytesIO\n            Write target.\n        **kwargs: Any\n            Extra parameters which will be passed to `Image.save()`.\n            For details see [Pillow documentation](https://pillow.readthedocs.io/en/stable/reference/Image.html#PIL.Image.Image.save).\n        \"\"\"\n        image = self.get_image()\n        if (isinstance(dest, Path) and dest.suffix in (\".jpg\", \"jpeg\")) or (\n            isinstance(dest, str) and (dest.endswith((\".jpg\", \".jpeg\")))\n        ):\n            image = image.convert(\"RGB\")\n        image.save(dest, **kwargs)\n\n    def get_image(self) -&gt; Image.Image:\n        \"\"\"Get result image object.\"\"\"\n        return self.result.transpose(Image.FLIP_TOP_BOTTOM)\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/result_handle.html#pygerber.backend.rasterized_2d.result_handle.Rasterized2DResultHandle.__init__","title":"__init__","text":"<pre><code>__init__(result: Image.Image) -&gt; None\n</code></pre> <p>Initialize result handle.</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>Image</code> <p>Image object containing finished Gerber image.</p> required Source code in <code>src/pygerber/backend/rasterized_2d/result_handle.py</code> <pre><code>def __init__(self, result: Image.Image) -&gt; None:\n    \"\"\"Initialize result handle.\n\n    Parameters\n    ----------\n    result : Image.Image\n        Image object containing finished Gerber image.\n    \"\"\"\n    super().__init__()\n    self.result = result\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/result_handle.html#pygerber.backend.rasterized_2d.result_handle.Rasterized2DResultHandle.save","title":"save","text":"<pre><code>save(dest: Path | str | BytesIO, **kwargs: Any) -&gt; None\n</code></pre> <p>Save result to destination.</p> <p>Parameters:</p> Name Type Description Default <code>dest</code> <code>Path | str | BytesIO</code> <p>Write target.</p> required <code>**kwargs</code> <code>Any</code> <p>Extra parameters which will be passed to <code>Image.save()</code>. For details see Pillow documentation.</p> <code>{}</code> Source code in <code>src/pygerber/backend/rasterized_2d/result_handle.py</code> <pre><code>def save(\n    self,\n    dest: Path | str | BytesIO,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"Save result to destination.\n\n    Parameters\n    ----------\n    dest : Path | str | BytesIO\n        Write target.\n    **kwargs: Any\n        Extra parameters which will be passed to `Image.save()`.\n        For details see [Pillow documentation](https://pillow.readthedocs.io/en/stable/reference/Image.html#PIL.Image.Image.save).\n    \"\"\"\n    image = self.get_image()\n    if (isinstance(dest, Path) and dest.suffix in (\".jpg\", \"jpeg\")) or (\n        isinstance(dest, str) and (dest.endswith((\".jpg\", \".jpeg\")))\n    ):\n        image = image.convert(\"RGB\")\n    image.save(dest, **kwargs)\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/result_handle.html#pygerber.backend.rasterized_2d.result_handle.Rasterized2DResultHandle.get_image","title":"get_image","text":"<pre><code>get_image() -&gt; Image.Image\n</code></pre> <p>Get result image object.</p> Source code in <code>src/pygerber/backend/rasterized_2d/result_handle.py</code> <pre><code>def get_image(self) -&gt; Image.Image:\n    \"\"\"Get result image object.\"\"\"\n    return self.result.transpose(Image.FLIP_TOP_BOTTOM)\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/draw_commands/__init__.html","title":"init","text":""},{"location":"reference/pygerber/backend/rasterized_2d/draw_commands/__init__.html#pygerber.backend.rasterized_2d.draw_commands","title":"draw_commands","text":"<p>Specialized implementations of draw operations for constructing apertures.</p>"},{"location":"reference/pygerber/backend/rasterized_2d/draw_commands/draw_arc.html","title":"draw_arc","text":""},{"location":"reference/pygerber/backend/rasterized_2d/draw_commands/draw_arc.html#pygerber.backend.rasterized_2d.draw_commands.draw_arc","title":"draw_arc","text":"<p>Class for drawing 2D rasterized vector lines.</p>"},{"location":"reference/pygerber/backend/rasterized_2d/draw_commands/draw_arc.html#pygerber.backend.rasterized_2d.draw_commands.draw_arc.Rasterized2DDrawArc","title":"Rasterized2DDrawArc","text":"<p>             Bases: <code>DrawArc</code></p> <p>Draw 2D rasterized vector line.</p> Source code in <code>src/pygerber/backend/rasterized_2d/draw_commands/draw_arc.py</code> <pre><code>class Rasterized2DDrawArc(DrawArc):\n    \"\"\"Draw 2D rasterized vector line.\"\"\"\n\n    backend: Rasterized2DBackend\n\n    def draw(self, target: DrawingTarget) -&gt; None:\n        \"\"\"Apply aperture draw component to handle.\"\"\"\n        if not isinstance(target, Rasterized2DDrawingTarget):\n            msg = f\"Expected Rasterized2DDrawingTarget got {type(target)}\"\n            raise TypeError(msg)\n\n        bbox = self.get_bounding_box() - target.coordinate_origin\n        pixel_box = bbox.as_pixel_box(self.backend.dpi)\n\n        angle_start, angle_end = self._calculate_angles()\n\n        width = self.width.as_pixels(self.backend.dpi)\n\n        target.image_draw.arc(\n            xy=pixel_box,\n            start=angle_start,\n            end=angle_end,\n            fill=self.polarity.get_2d_rasterized_color(),\n            width=width,\n        )\n        logging.debug(\"Adding %s to %s\", self.__class__.__qualname__, target)\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/draw_commands/draw_arc.html#pygerber.backend.rasterized_2d.draw_commands.draw_arc.Rasterized2DDrawArc.draw","title":"draw","text":"<pre><code>draw(target: DrawingTarget) -&gt; None\n</code></pre> <p>Apply aperture draw component to handle.</p> Source code in <code>src/pygerber/backend/rasterized_2d/draw_commands/draw_arc.py</code> <pre><code>def draw(self, target: DrawingTarget) -&gt; None:\n    \"\"\"Apply aperture draw component to handle.\"\"\"\n    if not isinstance(target, Rasterized2DDrawingTarget):\n        msg = f\"Expected Rasterized2DDrawingTarget got {type(target)}\"\n        raise TypeError(msg)\n\n    bbox = self.get_bounding_box() - target.coordinate_origin\n    pixel_box = bbox.as_pixel_box(self.backend.dpi)\n\n    angle_start, angle_end = self._calculate_angles()\n\n    width = self.width.as_pixels(self.backend.dpi)\n\n    target.image_draw.arc(\n        xy=pixel_box,\n        start=angle_start,\n        end=angle_end,\n        fill=self.polarity.get_2d_rasterized_color(),\n        width=width,\n    )\n    logging.debug(\"Adding %s to %s\", self.__class__.__qualname__, target)\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/draw_commands/draw_bounding_box.html","title":"draw_bounding_box","text":""},{"location":"reference/pygerber/backend/rasterized_2d/draw_commands/draw_bounding_box.html#pygerber.backend.rasterized_2d.draw_commands.draw_bounding_box","title":"draw_bounding_box","text":"<p>BoundingBox component for creating apertures.</p>"},{"location":"reference/pygerber/backend/rasterized_2d/draw_commands/draw_bounding_box.html#pygerber.backend.rasterized_2d.draw_commands.draw_bounding_box.Rasterized2DApertureDrawBoundingBox","title":"Rasterized2DApertureDrawBoundingBox","text":"<p>             Bases: <code>DrawBoundingBox</code></p> <p>Concrete implementation of DrawBoundingBox for rasterized 2D drawing.</p> Source code in <code>src/pygerber/backend/rasterized_2d/draw_commands/draw_bounding_box.py</code> <pre><code>class Rasterized2DApertureDrawBoundingBox(DrawBoundingBox):\n    \"\"\"Concrete implementation of DrawBoundingBox for rasterized 2D drawing.\"\"\"\n\n    backend: Rasterized2DBackend\n\n    def draw(self, target: DrawingTarget) -&gt; None:\n        \"\"\"Apply bounding box draw component to handle.\"\"\"\n        if not isinstance(target, Rasterized2DDrawingTarget):\n            msg = f\"Expected Rasterized2DDrawingTarget got {type(target)}\"\n            raise TypeError(msg)\n\n        box = self.get_bounding_box()\n        image_space_box = box - target.coordinate_origin\n        pixel_box = image_space_box.as_pixel_box(self.backend.dpi, dx_max=-1, dy_max=-1)\n\n        (min_x, min_y, max_x, max_y) = pixel_box\n        if (max_x - min_x &lt;= 0) or (max_y - min_y &lt;= 0):\n            logging.warning(\"Drawing zero surface bounding box. DPI may be too low.\")\n            return\n\n        target.image_draw.rectangle(\n            xy=pixel_box,\n            fill=None,\n            outline=self.polarity.get_2d_rasterized_color(),\n            width=1,\n        )\n        logging.debug(\"Adding %s to %s\", self.__class__.__qualname__, target)\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/draw_commands/draw_bounding_box.html#pygerber.backend.rasterized_2d.draw_commands.draw_bounding_box.Rasterized2DApertureDrawBoundingBox.draw","title":"draw","text":"<pre><code>draw(target: DrawingTarget) -&gt; None\n</code></pre> <p>Apply bounding box draw component to handle.</p> Source code in <code>src/pygerber/backend/rasterized_2d/draw_commands/draw_bounding_box.py</code> <pre><code>def draw(self, target: DrawingTarget) -&gt; None:\n    \"\"\"Apply bounding box draw component to handle.\"\"\"\n    if not isinstance(target, Rasterized2DDrawingTarget):\n        msg = f\"Expected Rasterized2DDrawingTarget got {type(target)}\"\n        raise TypeError(msg)\n\n    box = self.get_bounding_box()\n    image_space_box = box - target.coordinate_origin\n    pixel_box = image_space_box.as_pixel_box(self.backend.dpi, dx_max=-1, dy_max=-1)\n\n    (min_x, min_y, max_x, max_y) = pixel_box\n    if (max_x - min_x &lt;= 0) or (max_y - min_y &lt;= 0):\n        logging.warning(\"Drawing zero surface bounding box. DPI may be too low.\")\n        return\n\n    target.image_draw.rectangle(\n        xy=pixel_box,\n        fill=None,\n        outline=self.polarity.get_2d_rasterized_color(),\n        width=1,\n    )\n    logging.debug(\"Adding %s to %s\", self.__class__.__qualname__, target)\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/draw_commands/draw_circle.html","title":"draw_circle","text":""},{"location":"reference/pygerber/backend/rasterized_2d/draw_commands/draw_circle.html#pygerber.backend.rasterized_2d.draw_commands.draw_circle","title":"draw_circle","text":"<p>Circle component for creating apertures.</p>"},{"location":"reference/pygerber/backend/rasterized_2d/draw_commands/draw_circle.html#pygerber.backend.rasterized_2d.draw_commands.draw_circle.Rasterized2DApertureDrawCircle","title":"Rasterized2DApertureDrawCircle","text":"<p>             Bases: <code>DrawCircle</code></p> <p>Description of circle aperture component.</p> Source code in <code>src/pygerber/backend/rasterized_2d/draw_commands/draw_circle.py</code> <pre><code>class Rasterized2DApertureDrawCircle(DrawCircle):\n    \"\"\"Description of circle aperture component.\"\"\"\n\n    backend: Rasterized2DBackend\n\n    def draw(self, target: DrawingTarget) -&gt; None:\n        \"\"\"Apply aperture draw component to handle.\"\"\"\n        if not isinstance(target, Rasterized2DDrawingTarget):\n            msg = f\"Expected Rasterized2DDrawingTarget got {type(target)}\"\n            raise TypeError(msg)\n\n        box = self.get_bounding_box()\n        image_space_box = box - target.coordinate_origin\n        pixel_box = image_space_box.as_pixel_box(\n            self.backend.dpi,\n            dx_max=-2,\n            dy_max=-2,\n            dx_min=+1,\n            dy_min=+1,\n        )\n        (min_x, min_y, max_x, max_y) = pixel_box\n        if (max_x - min_x &lt;= 0) or (max_y - min_y &lt;= 0):\n            logging.warning(\n                \"Drawing zero surface circle. DPI may be too low. %s\",\n                pixel_box,\n            )\n\n        else:\n            target.image_draw.ellipse(\n                xy=pixel_box,\n                fill=self.polarity.get_2d_rasterized_color(),\n                outline=None,\n                width=0,\n            )\n            logging.debug(\"Adding %s to %s\", self.__class__.__qualname__, target)\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/draw_commands/draw_circle.html#pygerber.backend.rasterized_2d.draw_commands.draw_circle.Rasterized2DApertureDrawCircle.draw","title":"draw","text":"<pre><code>draw(target: DrawingTarget) -&gt; None\n</code></pre> <p>Apply aperture draw component to handle.</p> Source code in <code>src/pygerber/backend/rasterized_2d/draw_commands/draw_circle.py</code> <pre><code>def draw(self, target: DrawingTarget) -&gt; None:\n    \"\"\"Apply aperture draw component to handle.\"\"\"\n    if not isinstance(target, Rasterized2DDrawingTarget):\n        msg = f\"Expected Rasterized2DDrawingTarget got {type(target)}\"\n        raise TypeError(msg)\n\n    box = self.get_bounding_box()\n    image_space_box = box - target.coordinate_origin\n    pixel_box = image_space_box.as_pixel_box(\n        self.backend.dpi,\n        dx_max=-2,\n        dy_max=-2,\n        dx_min=+1,\n        dy_min=+1,\n    )\n    (min_x, min_y, max_x, max_y) = pixel_box\n    if (max_x - min_x &lt;= 0) or (max_y - min_y &lt;= 0):\n        logging.warning(\n            \"Drawing zero surface circle. DPI may be too low. %s\",\n            pixel_box,\n        )\n\n    else:\n        target.image_draw.ellipse(\n            xy=pixel_box,\n            fill=self.polarity.get_2d_rasterized_color(),\n            outline=None,\n            width=0,\n        )\n        logging.debug(\"Adding %s to %s\", self.__class__.__qualname__, target)\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/draw_commands/draw_paste.html","title":"draw_paste","text":""},{"location":"reference/pygerber/backend/rasterized_2d/draw_commands/draw_paste.html#pygerber.backend.rasterized_2d.draw_commands.draw_paste","title":"draw_paste","text":"<p>Base class for creating components for aperture creation.</p>"},{"location":"reference/pygerber/backend/rasterized_2d/draw_commands/draw_paste.html#pygerber.backend.rasterized_2d.draw_commands.draw_paste.Rasterized2DDrawPaste","title":"Rasterized2DDrawPaste","text":"<p>             Bases: <code>DrawPaste</code></p> <p>Description of aperture component.</p> Source code in <code>src/pygerber/backend/rasterized_2d/draw_commands/draw_paste.py</code> <pre><code>class Rasterized2DDrawPaste(DrawPaste):\n    \"\"\"Description of aperture component.\"\"\"\n\n    other: Rasterized2DDrawingTarget\n    backend: Rasterized2DBackend\n\n    def draw(self, target: DrawingTarget) -&gt; None:\n        \"\"\"Apply aperture draw component to handle.\"\"\"\n        if not isinstance(target, Rasterized2DDrawingTarget):\n            msg = f\"Expected Rasterized2DDrawingTarget got {type(target)}\"\n            raise TypeError(msg)\n\n        box = self.get_bounding_box()\n        image_space_box = box - target.coordinate_origin\n        pixel_box = image_space_box.get_min_vector().as_pixels(self.backend.dpi)\n\n        if self.polarity == Polarity.Dark:\n            im = self.other.image_polarity_dark\n\n        elif self.polarity == Polarity.Clear:\n            im = self.other.image_polarity_clear\n\n        elif self.polarity == Polarity.DarkRegion:\n            im = self.other.image_polarity_region_dark\n\n        elif self.polarity == Polarity.ClearRegion:\n            im = self.other.image_polarity_region_clear\n\n        else:\n            im = replace_color(\n                self.other.target_image,\n                Polarity.Dark.get_2d_rasterized_color(),\n                self.polarity.get_2d_rasterized_color(),\n                output_image_mode=\"L\",\n            )\n\n        target.target_image.paste(\n            im=im,\n            box=pixel_box,\n            mask=self.other.mask_image,\n        )\n        logging.debug(\"Adding %s to %s\", self.__class__.__qualname__, target)\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/draw_commands/draw_paste.html#pygerber.backend.rasterized_2d.draw_commands.draw_paste.Rasterized2DDrawPaste.draw","title":"draw","text":"<pre><code>draw(target: DrawingTarget) -&gt; None\n</code></pre> <p>Apply aperture draw component to handle.</p> Source code in <code>src/pygerber/backend/rasterized_2d/draw_commands/draw_paste.py</code> <pre><code>def draw(self, target: DrawingTarget) -&gt; None:\n    \"\"\"Apply aperture draw component to handle.\"\"\"\n    if not isinstance(target, Rasterized2DDrawingTarget):\n        msg = f\"Expected Rasterized2DDrawingTarget got {type(target)}\"\n        raise TypeError(msg)\n\n    box = self.get_bounding_box()\n    image_space_box = box - target.coordinate_origin\n    pixel_box = image_space_box.get_min_vector().as_pixels(self.backend.dpi)\n\n    if self.polarity == Polarity.Dark:\n        im = self.other.image_polarity_dark\n\n    elif self.polarity == Polarity.Clear:\n        im = self.other.image_polarity_clear\n\n    elif self.polarity == Polarity.DarkRegion:\n        im = self.other.image_polarity_region_dark\n\n    elif self.polarity == Polarity.ClearRegion:\n        im = self.other.image_polarity_region_clear\n\n    else:\n        im = replace_color(\n            self.other.target_image,\n            Polarity.Dark.get_2d_rasterized_color(),\n            self.polarity.get_2d_rasterized_color(),\n            output_image_mode=\"L\",\n        )\n\n    target.target_image.paste(\n        im=im,\n        box=pixel_box,\n        mask=self.other.mask_image,\n    )\n    logging.debug(\"Adding %s to %s\", self.__class__.__qualname__, target)\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/draw_commands/draw_polygon.html","title":"draw_polygon","text":""},{"location":"reference/pygerber/backend/rasterized_2d/draw_commands/draw_polygon.html#pygerber.backend.rasterized_2d.draw_commands.draw_polygon","title":"draw_polygon","text":"<p>Polygon component for creating apertures.</p>"},{"location":"reference/pygerber/backend/rasterized_2d/draw_commands/draw_polygon.html#pygerber.backend.rasterized_2d.draw_commands.draw_polygon.Rasterized2DApertureDrawPolygon","title":"Rasterized2DApertureDrawPolygon","text":"<p>             Bases: <code>DrawPolygon</code></p> <p>Description of polygon aperture component.</p> Source code in <code>src/pygerber/backend/rasterized_2d/draw_commands/draw_polygon.py</code> <pre><code>class Rasterized2DApertureDrawPolygon(DrawPolygon):\n    \"\"\"Description of polygon aperture component.\"\"\"\n\n    backend: Rasterized2DBackend\n\n    def draw(self, target: DrawingTarget) -&gt; None:\n        \"\"\"Apply aperture draw component to handle.\"\"\"\n        if not isinstance(target, Rasterized2DDrawingTarget):\n            msg = f\"Expected Rasterized2DDrawingTarget got {type(target)}\"\n            raise TypeError(msg)\n\n        box = self.get_bounding_box()\n        image_space_box = box - target.coordinate_origin\n        center = image_space_box.center.as_pixels(self.backend.dpi)\n\n        bounding_circle = (\n            *center,\n            (self.outer_diameter / 2).as_pixels(self.backend.dpi),\n        )\n        rotation = float(-self.rotation + Decimal(\"-90.0\"))\n\n        if self.number_of_vertices &lt; NUMBER_OF_VERTICES_IN_TRIANGLE:\n            logging.warning(\n                \"Drawing invalid polygon, number of vertices &lt; 3 (%s)\",\n                self.number_of_vertices,\n            )\n            return\n\n        (_, __, radius) = bounding_circle\n        if radius == 0:\n            logging.warning(\n                \"Drawing zero surface polygon. DPI may be too low. %s\",\n                bounding_circle,\n            )\n            return\n\n        target.image_draw.regular_polygon(\n            bounding_circle=bounding_circle,\n            n_sides=self.number_of_vertices,\n            rotation=rotation,\n            fill=self.polarity.get_2d_rasterized_color(),\n            outline=None,\n            width=0,\n        )\n        logging.debug(\"Adding %s to %s\", self.__class__.__qualname__, target)\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/draw_commands/draw_polygon.html#pygerber.backend.rasterized_2d.draw_commands.draw_polygon.Rasterized2DApertureDrawPolygon.draw","title":"draw","text":"<pre><code>draw(target: DrawingTarget) -&gt; None\n</code></pre> <p>Apply aperture draw component to handle.</p> Source code in <code>src/pygerber/backend/rasterized_2d/draw_commands/draw_polygon.py</code> <pre><code>def draw(self, target: DrawingTarget) -&gt; None:\n    \"\"\"Apply aperture draw component to handle.\"\"\"\n    if not isinstance(target, Rasterized2DDrawingTarget):\n        msg = f\"Expected Rasterized2DDrawingTarget got {type(target)}\"\n        raise TypeError(msg)\n\n    box = self.get_bounding_box()\n    image_space_box = box - target.coordinate_origin\n    center = image_space_box.center.as_pixels(self.backend.dpi)\n\n    bounding_circle = (\n        *center,\n        (self.outer_diameter / 2).as_pixels(self.backend.dpi),\n    )\n    rotation = float(-self.rotation + Decimal(\"-90.0\"))\n\n    if self.number_of_vertices &lt; NUMBER_OF_VERTICES_IN_TRIANGLE:\n        logging.warning(\n            \"Drawing invalid polygon, number of vertices &lt; 3 (%s)\",\n            self.number_of_vertices,\n        )\n        return\n\n    (_, __, radius) = bounding_circle\n    if radius == 0:\n        logging.warning(\n            \"Drawing zero surface polygon. DPI may be too low. %s\",\n            bounding_circle,\n        )\n        return\n\n    target.image_draw.regular_polygon(\n        bounding_circle=bounding_circle,\n        n_sides=self.number_of_vertices,\n        rotation=rotation,\n        fill=self.polarity.get_2d_rasterized_color(),\n        outline=None,\n        width=0,\n    )\n    logging.debug(\"Adding %s to %s\", self.__class__.__qualname__, target)\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/draw_commands/draw_rectangle.html","title":"draw_rectangle","text":""},{"location":"reference/pygerber/backend/rasterized_2d/draw_commands/draw_rectangle.html#pygerber.backend.rasterized_2d.draw_commands.draw_rectangle","title":"draw_rectangle","text":"<p>Rectangle component for creating apertures.</p>"},{"location":"reference/pygerber/backend/rasterized_2d/draw_commands/draw_rectangle.html#pygerber.backend.rasterized_2d.draw_commands.draw_rectangle.Rasterized2DApertureDrawRectangle","title":"Rasterized2DApertureDrawRectangle","text":"<p>             Bases: <code>DrawRectangle</code></p> <p>Description of rectangle aperture component.</p> Source code in <code>src/pygerber/backend/rasterized_2d/draw_commands/draw_rectangle.py</code> <pre><code>class Rasterized2DApertureDrawRectangle(DrawRectangle):\n    \"\"\"Description of rectangle aperture component.\"\"\"\n\n    backend: Rasterized2DBackend\n\n    def draw(self, target: DrawingTarget) -&gt; None:\n        \"\"\"Apply aperture draw component to handle.\"\"\"\n        if not isinstance(target, Rasterized2DDrawingTarget):\n            msg = f\"Expected Rasterized2DDrawingTarget got {type(target)}\"\n            raise TypeError(msg)\n\n        box = self.get_bounding_box()\n        image_space_box = box - target.coordinate_origin\n        pixel_box = image_space_box.as_pixel_box(\n            self.backend.dpi,\n        )\n\n        (min_x, min_y, max_x, max_y) = pixel_box\n        if (max_x - min_x &lt;= 0) or (max_y - min_y &lt;= 0):\n            logging.warning(\n                \"Drawing zero surface rectangle. DPI may be too low. %s\",\n                pixel_box,\n            )\n\n        else:\n            target.image_draw.rectangle(\n                xy=pixel_box,\n                fill=self.polarity.get_2d_rasterized_color(),\n                outline=None,\n                width=0,\n            )\n            logging.debug(\"Adding %s to %s\", self.__class__.__qualname__, target)\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/draw_commands/draw_rectangle.html#pygerber.backend.rasterized_2d.draw_commands.draw_rectangle.Rasterized2DApertureDrawRectangle.draw","title":"draw","text":"<pre><code>draw(target: DrawingTarget) -&gt; None\n</code></pre> <p>Apply aperture draw component to handle.</p> Source code in <code>src/pygerber/backend/rasterized_2d/draw_commands/draw_rectangle.py</code> <pre><code>def draw(self, target: DrawingTarget) -&gt; None:\n    \"\"\"Apply aperture draw component to handle.\"\"\"\n    if not isinstance(target, Rasterized2DDrawingTarget):\n        msg = f\"Expected Rasterized2DDrawingTarget got {type(target)}\"\n        raise TypeError(msg)\n\n    box = self.get_bounding_box()\n    image_space_box = box - target.coordinate_origin\n    pixel_box = image_space_box.as_pixel_box(\n        self.backend.dpi,\n    )\n\n    (min_x, min_y, max_x, max_y) = pixel_box\n    if (max_x - min_x &lt;= 0) or (max_y - min_y &lt;= 0):\n        logging.warning(\n            \"Drawing zero surface rectangle. DPI may be too low. %s\",\n            pixel_box,\n        )\n\n    else:\n        target.image_draw.rectangle(\n            xy=pixel_box,\n            fill=self.polarity.get_2d_rasterized_color(),\n            outline=None,\n            width=0,\n        )\n        logging.debug(\"Adding %s to %s\", self.__class__.__qualname__, target)\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/draw_commands/draw_region.html","title":"draw_region","text":""},{"location":"reference/pygerber/backend/rasterized_2d/draw_commands/draw_region.html#pygerber.backend.rasterized_2d.draw_commands.draw_region","title":"draw_region","text":"<p>Class for drawing 2D rasterized vector lines.</p>"},{"location":"reference/pygerber/backend/rasterized_2d/draw_commands/draw_region.html#pygerber.backend.rasterized_2d.draw_commands.draw_region.Rasterized2DDrawRegion","title":"Rasterized2DDrawRegion","text":"<p>             Bases: <code>DrawRegion</code></p> <p>Draw 2D rasterized vector line.</p> Source code in <code>src/pygerber/backend/rasterized_2d/draw_commands/draw_region.py</code> <pre><code>class Rasterized2DDrawRegion(DrawRegion):\n    \"\"\"Draw 2D rasterized vector line.\"\"\"\n\n    backend: Rasterized2DBackend\n\n    def draw(self, target: DrawingTarget) -&gt; None:\n        \"\"\"Apply aperture draw component to handle.\"\"\"\n        if not isinstance(target, Rasterized2DDrawingTarget):\n            msg = f\"Expected Rasterized2DDrawingTarget got {type(target)}\"\n            raise TypeError(msg)\n\n        boundary_points: list[tuple[int, int]] = []\n\n        for point in self.region_boundary_points:\n            pixel_point = (point - target.coordinate_origin).as_pixels(\n                self.backend.dpi,\n            )\n            boundary_points.append(pixel_point)\n\n        if len(boundary_points) &lt; NUMBER_OF_VERTICES_IN_TRIANGLE:\n            logging.warning(\n                \"Drawing invalid region, number of vertices &lt; 3 (%s)\",\n                len(boundary_points),\n            )\n            return\n\n        target.image_draw.polygon(\n            boundary_points,\n            fill=self.polarity.get_2d_rasterized_color(),\n        )\n        logging.debug(\"Adding %s to %s\", self.__class__.__qualname__, target)\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/draw_commands/draw_region.html#pygerber.backend.rasterized_2d.draw_commands.draw_region.Rasterized2DDrawRegion.draw","title":"draw","text":"<pre><code>draw(target: DrawingTarget) -&gt; None\n</code></pre> <p>Apply aperture draw component to handle.</p> Source code in <code>src/pygerber/backend/rasterized_2d/draw_commands/draw_region.py</code> <pre><code>def draw(self, target: DrawingTarget) -&gt; None:\n    \"\"\"Apply aperture draw component to handle.\"\"\"\n    if not isinstance(target, Rasterized2DDrawingTarget):\n        msg = f\"Expected Rasterized2DDrawingTarget got {type(target)}\"\n        raise TypeError(msg)\n\n    boundary_points: list[tuple[int, int]] = []\n\n    for point in self.region_boundary_points:\n        pixel_point = (point - target.coordinate_origin).as_pixels(\n            self.backend.dpi,\n        )\n        boundary_points.append(pixel_point)\n\n    if len(boundary_points) &lt; NUMBER_OF_VERTICES_IN_TRIANGLE:\n        logging.warning(\n            \"Drawing invalid region, number of vertices &lt; 3 (%s)\",\n            len(boundary_points),\n        )\n        return\n\n    target.image_draw.polygon(\n        boundary_points,\n        fill=self.polarity.get_2d_rasterized_color(),\n    )\n    logging.debug(\"Adding %s to %s\", self.__class__.__qualname__, target)\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/draw_commands/draw_vector_line.html","title":"draw_vector_line","text":""},{"location":"reference/pygerber/backend/rasterized_2d/draw_commands/draw_vector_line.html#pygerber.backend.rasterized_2d.draw_commands.draw_vector_line","title":"draw_vector_line","text":"<p>Class for drawing 2D rasterized vector lines.</p>"},{"location":"reference/pygerber/backend/rasterized_2d/draw_commands/draw_vector_line.html#pygerber.backend.rasterized_2d.draw_commands.draw_vector_line.Rasterized2DDrawVectorLine","title":"Rasterized2DDrawVectorLine","text":"<p>             Bases: <code>DrawVectorLine</code></p> <p>Draw 2D rasterized vector line.</p> Source code in <code>src/pygerber/backend/rasterized_2d/draw_commands/draw_vector_line.py</code> <pre><code>class Rasterized2DDrawVectorLine(DrawVectorLine):\n    \"\"\"Draw 2D rasterized vector line.\"\"\"\n\n    backend: Rasterized2DBackend\n\n    def draw(self, target: DrawingTarget) -&gt; None:\n        \"\"\"Apply aperture draw component to handle.\"\"\"\n        if not isinstance(target, Rasterized2DDrawingTarget):\n            msg = f\"Expected Rasterized2DDrawingTarget got {type(target)}\"\n            raise TypeError(msg)\n\n        start = (self.start_position - target.coordinate_origin).as_pixels(\n            self.backend.dpi,\n        )\n        end = (self.end_position - target.coordinate_origin).as_pixels(\n            self.backend.dpi,\n        )\n        width = self.width.as_pixels(self.backend.dpi)\n\n        target.image_draw.line(\n            (start, end),\n            fill=self.polarity.get_2d_rasterized_color(),\n            width=width,\n        )\n        logging.debug(\"Adding %s to %s\", self.__class__.__qualname__, target)\n</code></pre>"},{"location":"reference/pygerber/backend/rasterized_2d/draw_commands/draw_vector_line.html#pygerber.backend.rasterized_2d.draw_commands.draw_vector_line.Rasterized2DDrawVectorLine.draw","title":"draw","text":"<pre><code>draw(target: DrawingTarget) -&gt; None\n</code></pre> <p>Apply aperture draw component to handle.</p> Source code in <code>src/pygerber/backend/rasterized_2d/draw_commands/draw_vector_line.py</code> <pre><code>def draw(self, target: DrawingTarget) -&gt; None:\n    \"\"\"Apply aperture draw component to handle.\"\"\"\n    if not isinstance(target, Rasterized2DDrawingTarget):\n        msg = f\"Expected Rasterized2DDrawingTarget got {type(target)}\"\n        raise TypeError(msg)\n\n    start = (self.start_position - target.coordinate_origin).as_pixels(\n        self.backend.dpi,\n    )\n    end = (self.end_position - target.coordinate_origin).as_pixels(\n        self.backend.dpi,\n    )\n    width = self.width.as_pixels(self.backend.dpi)\n\n    target.image_draw.line(\n        (start, end),\n        fill=self.polarity.get_2d_rasterized_color(),\n        width=width,\n    )\n    logging.debug(\"Adding %s to %s\", self.__class__.__qualname__, target)\n</code></pre>"},{"location":"reference/pygerber/common/__init__.html","title":"init","text":""},{"location":"reference/pygerber/common/__init__.html#pygerber.common","title":"common","text":"<p>Common internal utilities of PyGerber library.</p>"},{"location":"reference/pygerber/common/error.html","title":"error","text":""},{"location":"reference/pygerber/common/error.html#pygerber.common.error","title":"error","text":"<p>Common exception related tools.</p>"},{"location":"reference/pygerber/common/error.html#pygerber.common.error.throw","title":"throw","text":"<pre><code>throw(exception: Exception) -&gt; NoReturn\n</code></pre> <p>Raise given exception.</p> Source code in <code>src/pygerber/common/error.py</code> <pre><code>def throw(exception: Exception) -&gt; NoReturn:\n    \"\"\"Raise given exception.\"\"\"\n    raise exception\n</code></pre>"},{"location":"reference/pygerber/common/frozen_general_model.html","title":"frozen_general_model","text":""},{"location":"reference/pygerber/common/frozen_general_model.html#pygerber.common.frozen_general_model","title":"frozen_general_model","text":"<p>Class based on pydantic BaseModel with common set of features.</p>"},{"location":"reference/pygerber/common/frozen_general_model.html#pygerber.common.frozen_general_model.FrozenGeneralModel","title":"FrozenGeneralModel","text":"<p>             Bases: <code>BaseModel</code></p> <p>Model with common set of general purpose features.</p> Source code in <code>src/pygerber/common/frozen_general_model.py</code> <pre><code>class FrozenGeneralModel(BaseModel):\n    \"\"\"Model with common set of general purpose features.\"\"\"\n\n    model_config = ConfigDict(\n        extra=\"forbid\",\n        frozen=True,\n        arbitrary_types_allowed=True,\n    )\n</code></pre>"},{"location":"reference/pygerber/common/general_model.html","title":"general_model","text":""},{"location":"reference/pygerber/common/general_model.html#pygerber.common.general_model","title":"general_model","text":"<p>Class based on pydantic BaseModel with common set of features.</p>"},{"location":"reference/pygerber/common/general_model.html#pygerber.common.general_model.GeneralModel","title":"GeneralModel","text":"<p>             Bases: <code>BaseModel</code></p> <p>Model with common set of general purpose features.</p> Source code in <code>src/pygerber/common/general_model.py</code> <pre><code>class GeneralModel(BaseModel):\n    \"\"\"Model with common set of general purpose features.\"\"\"\n\n    model_config = ConfigDict(\n        extra=\"forbid\",\n        frozen=False,\n        arbitrary_types_allowed=True,\n    )\n</code></pre>"},{"location":"reference/pygerber/common/immutable_map_model.html","title":"immutable_map_model","text":""},{"location":"reference/pygerber/common/immutable_map_model.html#pygerber.common.immutable_map_model","title":"immutable_map_model","text":"<p>Module contains model class wrapping immutable mapping.</p>"},{"location":"reference/pygerber/common/immutable_map_model.html#pygerber.common.immutable_map_model.ImmutableMapping","title":"ImmutableMapping","text":"<p>             Bases: <code>FrozenGeneralModel</code>, <code>Generic[KeyT, ValueT]</code></p> <p>Model class wrapping immutable dictionary.</p> Source code in <code>src/pygerber/common/immutable_map_model.py</code> <pre><code>class ImmutableMapping(FrozenGeneralModel, Generic[KeyT, ValueT]):\n    \"\"\"Model class wrapping immutable dictionary.\"\"\"\n\n    mapping: Mapping[KeyT, ValueT] = Field(\n        default_factory=lambda: MappingProxyType({}),\n    )\n\n    @field_validator(\"mapping\")\n    @classmethod\n    def _validate_mapping(cls, v: Mapping[str, str]) -&gt; Mapping[str, str]:\n        if isinstance(v, MappingProxyType):\n            return v\n        if isinstance(v, dict):\n            return MappingProxyType(v)\n        raise TypeError(type(v))\n\n    @field_serializer(\"mapping\", return_type=Dict[KeyT, ValueT])\n    def _serialize_mapping(\n        self,\n        mapping: Mapping[KeyT, ValueT],\n        _info: FieldSerializationInfo,\n    ) -&gt; Dict[KeyT, ValueT]:\n        \"\"\"Serialize model instance.\"\"\"\n        return dict(mapping)\n\n    def update(self, __key: KeyT, __value: ValueT) -&gt; Self:\n        \"\"\"Update underlying mapping.\"\"\"\n        return self.model_copy(\n            update={\n                \"mapping\": MappingProxyType(\n                    {\n                        **self.mapping,\n                        __key: __value,\n                    },\n                ),\n            },\n        )\n\n    def get(self, __key: KeyT, __default: Optional[ValueT] = None) -&gt; Optional[ValueT]:\n        \"\"\"Get item if exists or add it to mapping with __default value and return.\"\"\"\n        return self.mapping.get(__key, __default)\n\n    def delete(self, __key: KeyT) -&gt; Self:\n        \"\"\"Remove entry from mapping.\"\"\"\n        return self.model_copy(\n            update={\n                \"mapping\": MappingProxyType(\n                    {k: v for k, v in self.mapping.items() if (k != __key)},\n                ),\n            },\n        )\n</code></pre>"},{"location":"reference/pygerber/common/immutable_map_model.html#pygerber.common.immutable_map_model.ImmutableMapping.update","title":"update","text":"<pre><code>update(__key: KeyT, __value: ValueT) -&gt; Self\n</code></pre> <p>Update underlying mapping.</p> Source code in <code>src/pygerber/common/immutable_map_model.py</code> <pre><code>def update(self, __key: KeyT, __value: ValueT) -&gt; Self:\n    \"\"\"Update underlying mapping.\"\"\"\n    return self.model_copy(\n        update={\n            \"mapping\": MappingProxyType(\n                {\n                    **self.mapping,\n                    __key: __value,\n                },\n            ),\n        },\n    )\n</code></pre>"},{"location":"reference/pygerber/common/immutable_map_model.html#pygerber.common.immutable_map_model.ImmutableMapping.get","title":"get","text":"<pre><code>get(\n    __key: KeyT, __default: Optional[ValueT] = None\n) -&gt; Optional[ValueT]\n</code></pre> <p>Get item if exists or add it to mapping with __default value and return.</p> Source code in <code>src/pygerber/common/immutable_map_model.py</code> <pre><code>def get(self, __key: KeyT, __default: Optional[ValueT] = None) -&gt; Optional[ValueT]:\n    \"\"\"Get item if exists or add it to mapping with __default value and return.\"\"\"\n    return self.mapping.get(__key, __default)\n</code></pre>"},{"location":"reference/pygerber/common/immutable_map_model.html#pygerber.common.immutable_map_model.ImmutableMapping.delete","title":"delete","text":"<pre><code>delete(__key: KeyT) -&gt; Self\n</code></pre> <p>Remove entry from mapping.</p> Source code in <code>src/pygerber/common/immutable_map_model.py</code> <pre><code>def delete(self, __key: KeyT) -&gt; Self:\n    \"\"\"Remove entry from mapping.\"\"\"\n    return self.model_copy(\n        update={\n            \"mapping\": MappingProxyType(\n                {k: v for k, v in self.mapping.items() if (k != __key)},\n            ),\n        },\n    )\n</code></pre>"},{"location":"reference/pygerber/common/position.html","title":"position","text":""},{"location":"reference/pygerber/common/position.html#pygerber.common.position","title":"position","text":"<p>Contains tools for expressing positions in text.</p>"},{"location":"reference/pygerber/common/position.html#pygerber.common.position.Position","title":"Position  <code>dataclass</code>","text":"<p>Position of token in text in pyparsing scheme (lines starts from 1, columns also start from 1).</p> Source code in <code>src/pygerber/common/position.py</code> <pre><code>@dataclass\nclass Position:\n    \"\"\"Position of token in text in pyparsing scheme (lines starts from 1,\n    columns also start from 1).\n    \"\"\"\n\n    line: int\n    column: int\n\n    @classmethod\n    def from_vscode_position(cls, line: int, character: int) -&gt; Self:\n        \"\"\"Return position in pyparsing scheme from vscode scheme (lines starts from 0,\n        columns starts from 0).\n        \"\"\"\n        return cls(line + 1, character + 1)\n\n    def to_lspt(self) -&gt; lspt.Position:\n        \"\"\"Return position in pyparsing scheme from vscode scheme (lines starts from 1,\n        columns starts from 1).\n        \"\"\"\n        return lspt.Position(line=self.line - 1, character=self.column - 1)\n\n    def offset(self, line: int, column: int) -&gt; Self:\n        \"\"\"Create new Position offset by line and column.\"\"\"\n        return self.__class__(self.line + line, self.column + column)\n\n    def __str__(self) -&gt; str:\n        return f\"[line: {self.line}, col: {self.column}]\"\n\n    def __eq__(self, __value: object) -&gt; bool:\n        if not isinstance(__value, self.__class__):\n            return NotImplemented\n        return self.line == __value.line and self.column == __value.column\n\n    def __ne__(self, __value: object) -&gt; bool:\n        if not isinstance(__value, self.__class__):\n            return NotImplemented\n        return self.line != __value.line and self.column != __value.column\n\n    def __gt__(self, __value: object) -&gt; bool:\n        if not isinstance(__value, self.__class__):\n            return NotImplemented\n        return self.line &gt; __value.line or (\n            self.line == __value.line and self.column &gt; __value.column\n        )\n\n    def __ge__(self, __value: object) -&gt; bool:\n        if not isinstance(__value, self.__class__):\n            return NotImplemented\n        return self.line &gt;= __value.line or (\n            self.line == __value.line and self.column &gt;= __value.column\n        )\n\n    def __lt__(self, __value: object) -&gt; bool:\n        if not isinstance(__value, self.__class__):\n            return NotImplemented\n        return self.line &lt; __value.line or (\n            self.line == __value.line and self.column &lt; __value.column\n        )\n\n    def __le__(self, __value: object) -&gt; bool:\n        if not isinstance(__value, self.__class__):\n            return NotImplemented\n        return self.line &lt;= __value.line or (\n            self.line == __value.line and self.column &lt;= __value.column\n        )\n</code></pre>"},{"location":"reference/pygerber/common/position.html#pygerber.common.position.Position.from_vscode_position","title":"from_vscode_position  <code>classmethod</code>","text":"<pre><code>from_vscode_position(line: int, character: int) -&gt; Self\n</code></pre> <p>Return position in pyparsing scheme from vscode scheme (lines starts from 0, columns starts from 0).</p> Source code in <code>src/pygerber/common/position.py</code> <pre><code>@classmethod\ndef from_vscode_position(cls, line: int, character: int) -&gt; Self:\n    \"\"\"Return position in pyparsing scheme from vscode scheme (lines starts from 0,\n    columns starts from 0).\n    \"\"\"\n    return cls(line + 1, character + 1)\n</code></pre>"},{"location":"reference/pygerber/common/position.html#pygerber.common.position.Position.to_lspt","title":"to_lspt","text":"<pre><code>to_lspt() -&gt; lspt.Position\n</code></pre> <p>Return position in pyparsing scheme from vscode scheme (lines starts from 1, columns starts from 1).</p> Source code in <code>src/pygerber/common/position.py</code> <pre><code>def to_lspt(self) -&gt; lspt.Position:\n    \"\"\"Return position in pyparsing scheme from vscode scheme (lines starts from 1,\n    columns starts from 1).\n    \"\"\"\n    return lspt.Position(line=self.line - 1, character=self.column - 1)\n</code></pre>"},{"location":"reference/pygerber/common/position.html#pygerber.common.position.Position.offset","title":"offset","text":"<pre><code>offset(line: int, column: int) -&gt; Self\n</code></pre> <p>Create new Position offset by line and column.</p> Source code in <code>src/pygerber/common/position.py</code> <pre><code>def offset(self, line: int, column: int) -&gt; Self:\n    \"\"\"Create new Position offset by line and column.\"\"\"\n    return self.__class__(self.line + line, self.column + column)\n</code></pre>"},{"location":"reference/pygerber/common/rgba.html","title":"rgba","text":""},{"location":"reference/pygerber/common/rgba.html#pygerber.common.rgba","title":"rgba","text":"<p>RGBA colors are used for declaring visuals of rendering output.</p> <p>This module contains RGBA class which can be used to provide such color.</p>"},{"location":"reference/pygerber/common/rgba.html#pygerber.common.rgba.RGBA","title":"RGBA","text":"<p>             Bases: <code>FrozenGeneralModel</code></p> <p>Representation of RGBA color.</p> Source code in <code>src/pygerber/common/rgba.py</code> <pre><code>class RGBA(FrozenGeneralModel):\n    \"\"\"Representation of RGBA color.\"\"\"\n\n    r: Color = ColorField\n    g: Color = ColorField\n    b: Color = ColorField\n    a: Color = ColorField\n\n    @classmethod\n    def from_hex(cls, string: str) -&gt; Self:\n        \"\"\"Build RGBA color object from hexadecimal string.\n\n        Parameters\n        ----------\n        string : str\n            String containing color value. Accepted formats are `RRGGBBAA` and `RRGGBB`.\n            For latter, alpha value is assumed to be 0xFF. Formats are case insensitive.\n            `#` symbol prefix for hex string is accepted.\n\n        Returns\n        -------\n        RGBA\n            Color built from hexadecimal values.\n        \"\"\"\n        if string[0] == \"#\":\n            string = string[1:]\n\n        r, g, b, a = string[:2], string[2:4], string[4:6], string[6:]\n        if len(a) == 0:\n            a = \"FF\"\n\n        return cls(\n            r=int(r, base=16),\n            g=int(g, base=16),\n            b=int(b, base=16),\n            a=int(a, base=16),\n        )\n\n    @classmethod\n    def from_rgba(cls, r: int, g: int, b: int, a: int = 0xFF) -&gt; Self:\n        \"\"\"Build RGBA color object from reg, green, blue and alpha integer values.\n\n        Parameters\n        ----------\n        r : int\n            Red chanel value as integer from 0 to 255, inclusive.\n        g : int\n            Green chanel value as integer from 0 to 255, inclusive.\n        b : int\n            Blue chanel value as integer from 0 to 255, inclusive.\n        a : int, optional\n            Alpha chanel value as integer from 0 to 255, inclusive., by default 0xFF\n\n        Returns\n        -------\n        Self\n            Color built from r, g, b, a values.\n        \"\"\"\n        return cls(r=r, g=g, b=b, a=a)\n\n    @classmethod\n    def from_hsv(\n        cls,\n        h: int,\n        s: float,\n        v: float,\n        a: int = 255,\n    ) -&gt; Self:\n        \"\"\"Build RGBA color object from hue, saturation, value and alpha.\n\n        For extended information refer to Wikipedia: https://en.wikipedia.org/wiki/HSL_and_HSV\n\n        Parameters\n        ----------\n        h : int\n            Hue of color, integer in range 0 to 360 inclusive.\n        s : float\n            Saturation of color, float in range 0.0 to 100.0 inclusive.\n        v : float\n            Value of color, float in range 0.0 to 100.0 inclusive.\n        a : int\n            Alpha of color, int in range 0 to 255 inclusive.\n\n        Returns\n        -------\n        Self\n            Color built from h, s, v, a values.\n        \"\"\"\n        h %= 360\n        s /= 100\n        v /= 100\n\n        c = v * s\n        x = c * (1 - abs(((h / 60) % 2) - 1))\n        m = v - c\n\n        if 0 &lt;= h &lt; HSV_Q0_MAX_ANGLE_DEGREES:\n            r_, g_, b_ = c, x, 0.0\n        elif HSV_Q0_MAX_ANGLE_DEGREES &lt;= h &lt; HSV_Q1_MAX_ANGLE_DEGREES:\n            r_, g_, b_ = x, c, 0.0\n        elif HSV_Q1_MAX_ANGLE_DEGREES &lt;= h &lt; HSV_Q2_MAX_ANGLE_DEGREES:\n            r_, g_, b_ = 0.0, c, x\n        elif HSV_Q2_MAX_ANGLE_DEGREES &lt;= h &lt; HSV_Q3_MAX_ANGLE_DEGREES:\n            r_, g_, b_ = 0.0, x, c\n        elif HSV_Q3_MAX_ANGLE_DEGREES &lt;= h &lt; HSV_Q4_MAX_ANGLE_DEGREES:\n            r_, g_, b_ = x, 0.0, c\n        elif HSV_Q4_MAX_ANGLE_DEGREES &lt;= h &lt;= HSV_Q5_MAX_ANGLE_DEGREES:\n            r_, g_, b_ = c, 0.0, x\n        else:\n            raise ValueError(h)\n\n        return cls(\n            r=round((r_ + m) * 255),\n            g=round((g_ + m) * 255),\n            b=round((b_ + m) * 255),\n            a=a,\n        )\n\n    def as_rgba_int(self) -&gt; tuple[int, int, int, int]:\n        \"\"\"Return RGBA color as tuple of integers in range 0 to 255 inclusive.\"\"\"\n        return self.r, self.g, self.b, self.a\n\n    def as_rgba_float(self) -&gt; tuple[float, float, float, float]:\n        \"\"\"Return RGBA color as tuple of floats in range 0.0 to 1.0 inclusive.\"\"\"\n        return (\n            float(Decimal(self.r) / Decimal(255)),\n            float(Decimal(self.g) / Decimal(255)),\n            float(Decimal(self.b) / Decimal(255)),\n            float(Decimal(self.a) / Decimal(255)),\n        )\n\n    def to_hex(self) -&gt; str:\n        \"\"\"Return color as hexadecimal string.\"\"\"\n        r = f\"{self.r:0{2}x}\"\n        g = f\"{self.g:0{2}x}\"\n        b = f\"{self.b:0{2}x}\"\n        a = f\"{self.a:0{2}x}\"\n        return f\"#{r}{g}{b}{a}\"\n</code></pre>"},{"location":"reference/pygerber/common/rgba.html#pygerber.common.rgba.RGBA.from_hex","title":"from_hex  <code>classmethod</code>","text":"<pre><code>from_hex(string: str) -&gt; Self\n</code></pre> <p>Build RGBA color object from hexadecimal string.</p> <p>Parameters:</p> Name Type Description Default <code>string</code> <code>str</code> <p>String containing color value. Accepted formats are <code>RRGGBBAA</code> and <code>RRGGBB</code>. For latter, alpha value is assumed to be 0xFF. Formats are case insensitive. <code>#</code> symbol prefix for hex string is accepted.</p> required <p>Returns:</p> Type Description <code>RGBA</code> <p>Color built from hexadecimal values.</p> Source code in <code>src/pygerber/common/rgba.py</code> <pre><code>@classmethod\ndef from_hex(cls, string: str) -&gt; Self:\n    \"\"\"Build RGBA color object from hexadecimal string.\n\n    Parameters\n    ----------\n    string : str\n        String containing color value. Accepted formats are `RRGGBBAA` and `RRGGBB`.\n        For latter, alpha value is assumed to be 0xFF. Formats are case insensitive.\n        `#` symbol prefix for hex string is accepted.\n\n    Returns\n    -------\n    RGBA\n        Color built from hexadecimal values.\n    \"\"\"\n    if string[0] == \"#\":\n        string = string[1:]\n\n    r, g, b, a = string[:2], string[2:4], string[4:6], string[6:]\n    if len(a) == 0:\n        a = \"FF\"\n\n    return cls(\n        r=int(r, base=16),\n        g=int(g, base=16),\n        b=int(b, base=16),\n        a=int(a, base=16),\n    )\n</code></pre>"},{"location":"reference/pygerber/common/rgba.html#pygerber.common.rgba.RGBA.from_rgba","title":"from_rgba  <code>classmethod</code>","text":"<pre><code>from_rgba(r: int, g: int, b: int, a: int = 255) -&gt; Self\n</code></pre> <p>Build RGBA color object from reg, green, blue and alpha integer values.</p> <p>Parameters:</p> Name Type Description Default <code>r</code> <code>int</code> <p>Red chanel value as integer from 0 to 255, inclusive.</p> required <code>g</code> <code>int</code> <p>Green chanel value as integer from 0 to 255, inclusive.</p> required <code>b</code> <code>int</code> <p>Blue chanel value as integer from 0 to 255, inclusive.</p> required <code>a</code> <code>int</code> <p>Alpha chanel value as integer from 0 to 255, inclusive., by default 0xFF</p> <code>255</code> <p>Returns:</p> Type Description <code>Self</code> <p>Color built from r, g, b, a values.</p> Source code in <code>src/pygerber/common/rgba.py</code> <pre><code>@classmethod\ndef from_rgba(cls, r: int, g: int, b: int, a: int = 0xFF) -&gt; Self:\n    \"\"\"Build RGBA color object from reg, green, blue and alpha integer values.\n\n    Parameters\n    ----------\n    r : int\n        Red chanel value as integer from 0 to 255, inclusive.\n    g : int\n        Green chanel value as integer from 0 to 255, inclusive.\n    b : int\n        Blue chanel value as integer from 0 to 255, inclusive.\n    a : int, optional\n        Alpha chanel value as integer from 0 to 255, inclusive., by default 0xFF\n\n    Returns\n    -------\n    Self\n        Color built from r, g, b, a values.\n    \"\"\"\n    return cls(r=r, g=g, b=b, a=a)\n</code></pre>"},{"location":"reference/pygerber/common/rgba.html#pygerber.common.rgba.RGBA.from_hsv","title":"from_hsv  <code>classmethod</code>","text":"<pre><code>from_hsv(h: int, s: float, v: float, a: int = 255) -&gt; Self\n</code></pre> <p>Build RGBA color object from hue, saturation, value and alpha.</p> <p>For extended information refer to Wikipedia: https://en.wikipedia.org/wiki/HSL_and_HSV</p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>int</code> <p>Hue of color, integer in range 0 to 360 inclusive.</p> required <code>s</code> <code>float</code> <p>Saturation of color, float in range 0.0 to 100.0 inclusive.</p> required <code>v</code> <code>float</code> <p>Value of color, float in range 0.0 to 100.0 inclusive.</p> required <code>a</code> <code>int</code> <p>Alpha of color, int in range 0 to 255 inclusive.</p> <code>255</code> <p>Returns:</p> Type Description <code>Self</code> <p>Color built from h, s, v, a values.</p> Source code in <code>src/pygerber/common/rgba.py</code> <pre><code>@classmethod\ndef from_hsv(\n    cls,\n    h: int,\n    s: float,\n    v: float,\n    a: int = 255,\n) -&gt; Self:\n    \"\"\"Build RGBA color object from hue, saturation, value and alpha.\n\n    For extended information refer to Wikipedia: https://en.wikipedia.org/wiki/HSL_and_HSV\n\n    Parameters\n    ----------\n    h : int\n        Hue of color, integer in range 0 to 360 inclusive.\n    s : float\n        Saturation of color, float in range 0.0 to 100.0 inclusive.\n    v : float\n        Value of color, float in range 0.0 to 100.0 inclusive.\n    a : int\n        Alpha of color, int in range 0 to 255 inclusive.\n\n    Returns\n    -------\n    Self\n        Color built from h, s, v, a values.\n    \"\"\"\n    h %= 360\n    s /= 100\n    v /= 100\n\n    c = v * s\n    x = c * (1 - abs(((h / 60) % 2) - 1))\n    m = v - c\n\n    if 0 &lt;= h &lt; HSV_Q0_MAX_ANGLE_DEGREES:\n        r_, g_, b_ = c, x, 0.0\n    elif HSV_Q0_MAX_ANGLE_DEGREES &lt;= h &lt; HSV_Q1_MAX_ANGLE_DEGREES:\n        r_, g_, b_ = x, c, 0.0\n    elif HSV_Q1_MAX_ANGLE_DEGREES &lt;= h &lt; HSV_Q2_MAX_ANGLE_DEGREES:\n        r_, g_, b_ = 0.0, c, x\n    elif HSV_Q2_MAX_ANGLE_DEGREES &lt;= h &lt; HSV_Q3_MAX_ANGLE_DEGREES:\n        r_, g_, b_ = 0.0, x, c\n    elif HSV_Q3_MAX_ANGLE_DEGREES &lt;= h &lt; HSV_Q4_MAX_ANGLE_DEGREES:\n        r_, g_, b_ = x, 0.0, c\n    elif HSV_Q4_MAX_ANGLE_DEGREES &lt;= h &lt;= HSV_Q5_MAX_ANGLE_DEGREES:\n        r_, g_, b_ = c, 0.0, x\n    else:\n        raise ValueError(h)\n\n    return cls(\n        r=round((r_ + m) * 255),\n        g=round((g_ + m) * 255),\n        b=round((b_ + m) * 255),\n        a=a,\n    )\n</code></pre>"},{"location":"reference/pygerber/common/rgba.html#pygerber.common.rgba.RGBA.as_rgba_int","title":"as_rgba_int","text":"<pre><code>as_rgba_int() -&gt; tuple[int, int, int, int]\n</code></pre> <p>Return RGBA color as tuple of integers in range 0 to 255 inclusive.</p> Source code in <code>src/pygerber/common/rgba.py</code> <pre><code>def as_rgba_int(self) -&gt; tuple[int, int, int, int]:\n    \"\"\"Return RGBA color as tuple of integers in range 0 to 255 inclusive.\"\"\"\n    return self.r, self.g, self.b, self.a\n</code></pre>"},{"location":"reference/pygerber/common/rgba.html#pygerber.common.rgba.RGBA.as_rgba_float","title":"as_rgba_float","text":"<pre><code>as_rgba_float() -&gt; tuple[float, float, float, float]\n</code></pre> <p>Return RGBA color as tuple of floats in range 0.0 to 1.0 inclusive.</p> Source code in <code>src/pygerber/common/rgba.py</code> <pre><code>def as_rgba_float(self) -&gt; tuple[float, float, float, float]:\n    \"\"\"Return RGBA color as tuple of floats in range 0.0 to 1.0 inclusive.\"\"\"\n    return (\n        float(Decimal(self.r) / Decimal(255)),\n        float(Decimal(self.g) / Decimal(255)),\n        float(Decimal(self.b) / Decimal(255)),\n        float(Decimal(self.a) / Decimal(255)),\n    )\n</code></pre>"},{"location":"reference/pygerber/common/rgba.html#pygerber.common.rgba.RGBA.to_hex","title":"to_hex","text":"<pre><code>to_hex() -&gt; str\n</code></pre> <p>Return color as hexadecimal string.</p> Source code in <code>src/pygerber/common/rgba.py</code> <pre><code>def to_hex(self) -&gt; str:\n    \"\"\"Return color as hexadecimal string.\"\"\"\n    r = f\"{self.r:0{2}x}\"\n    g = f\"{self.g:0{2}x}\"\n    b = f\"{self.b:0{2}x}\"\n    a = f\"{self.a:0{2}x}\"\n    return f\"#{r}{g}{b}{a}\"\n</code></pre>"},{"location":"reference/pygerber/console/__init__.html","title":"init","text":""},{"location":"reference/pygerber/console/__init__.html#pygerber.console","title":"console","text":"<p>Console interface of PyGerber.</p>"},{"location":"reference/pygerber/console/commands.html","title":"commands","text":""},{"location":"reference/pygerber/console/commands.html#pygerber.console.commands","title":"commands","text":"<p>Command line commands of PyGerber.</p>"},{"location":"reference/pygerber/console/commands.html#pygerber.console.commands.main","title":"main","text":"<pre><code>main() -&gt; None\n</code></pre> <p>Command line interface of PyGerber, python implementation of Gerber X3/X2 standard with 2D rendering engine.</p> Source code in <code>src/pygerber/console/commands.py</code> <pre><code>@click.group(\"pygerber\")\n@click.version_option(version=pygerber.__version__)\ndef main() -&gt; None:\n    \"\"\"Command line interface of PyGerber, python implementation of Gerber X3/X2\n    standard with 2D rendering engine.\n    \"\"\"\n</code></pre>"},{"location":"reference/pygerber/console/commands.html#pygerber.console.commands.raster_2d","title":"raster_2d","text":"<pre><code>raster_2d(\n    source: TextIO,\n    style: str,\n    output: Path,\n    format_: Optional[str],\n    custom: Optional[str],\n    dpi: int,\n) -&gt; None\n</code></pre> <p>Render rasterized 2D image from Gerber X3/X2 SOURCE file.</p> <p>SOURCE - A path to the Gerber file to render.</p> <p>List of file formats supported by Pillow: https://pillow.readthedocs.io/en/stable/handbook/image-file-formats.html</p> <p>\b RGBA type documentation: https://argmaster.github.io/pygerber/latest/reference/pygerber/gerberx3/api/init.html#pygerber.common.rgba.RGBA.from_hex</p> Source code in <code>src/pygerber/console/commands.py</code> <pre><code>@main.command(\"raster-2d\")\n@click.argument(\"source\", type=click.File())\n@click.option(\n    \"-s\",\n    \"--style\",\n    default=\"copper\",\n    type=click.Choice(list(STYLE_TO_COLOR_SCHEME.keys()), case_sensitive=False),\n    help=\"Color style of the rendered image. When style is 'custom' then option \"\n    \"`--custom` must also be provided. Default is 'copper'.\",\n)\n@click.option(\n    \"-o\",\n    \"--output\",\n    type=Path,\n    default=\"output.png\",\n    help=\"Path to output file. File format will be inferred from extension, unless \"\n    \"`--format` is given. Default is 'output.png'\",\n)\n@click.option(\n    \"-f\",\n    \"--format\",\n    \"format_\",\n    type=str,\n    default=None,\n    help=\"Output image format. Can be omitted, then format will be inferred from file\"\n    \"extension or be one of formats supported by Pillow.\",\n)\n@click.option(\n    \"-c\",\n    \"--custom\",\n    type=str,\n    default=None,\n    help=\"String representing custom set of colors for rendering.\\n\"\n    \"Custom color should be a single string consisting of 5 or 7 valid hexadecimal \"\n    \"colors separated with commas. Any color which can be parsed by RGBA type is \"\n    \"accepted.\\n\"\n    \"Colors are assigned in order:\"\n    \"\\n\\n\"\n    \"- background_color\\n\\n\"\n    \"- clear_color\\n\\n\"\n    \"- solid_color\\n\\n\"\n    \"- clear_region_color\\n\\n\"\n    \"- solid_region_color\\n\\n\"\n    \"- debug_1_color (optional, by default #ABABAB)\\n\\n\"\n    \"- debug_2_color (optional, by default #7D7D7D)\\n\\n\"\n    \"\\n\\n\"\n    'eg. `\"000000,000000,FFFFFF,000000,FFFFFF\"`',\n)\n@click.option(\n    \"-d\",\n    \"--dpi\",\n    type=int,\n    default=1000,\n    help=\"DPI of output image, by default 1000.\",\n)\ndef raster_2d(\n    source: TextIO,\n    style: str,\n    output: Path,\n    format_: Optional[str],\n    custom: Optional[str],\n    dpi: int,\n) -&gt; None:\n    \"\"\"Render rasterized 2D image from Gerber X3/X2 SOURCE file.\n\n    SOURCE - A path to the Gerber file to render.\n\n    List of file formats supported by Pillow:\n    https://pillow.readthedocs.io/en/stable/handbook/image-file-formats.html\n\n    \\x08\n    RGBA type documentation:\n    https://argmaster.github.io/pygerber/latest/reference/pygerber/gerberx3/api/__init__.html#pygerber.common.rgba.RGBA.from_hex\n    \"\"\"  # noqa: D301\n    gerber_code = source.read()\n    Rasterized2DLayer(\n        options=Rasterized2DLayerParams(\n            source_code=gerber_code,\n            colors=get_color_scheme_from_style(style, custom),\n            dpi=dpi,\n        ),\n    ).render().save(output, format=format_)\n</code></pre>"},{"location":"reference/pygerber/console/raster_2d_style.html","title":"raster_2d_style","text":""},{"location":"reference/pygerber/console/raster_2d_style.html#pygerber.console.raster_2d_style","title":"raster_2d_style","text":"<p>Tool for converting style string to ColorScheme objects.</p>"},{"location":"reference/pygerber/console/raster_2d_style.html#pygerber.console.raster_2d_style.STYLE_TO_COLOR_SCHEME","title":"STYLE_TO_COLOR_SCHEME  <code>module-attribute</code>","text":"<pre><code>STYLE_TO_COLOR_SCHEME = {\n    \"silk\": SILK,\n    \"silk_alpha\": SILK_ALPHA,\n    \"copper\": COPPER,\n    \"copper_alpha\": COPPER_ALPHA,\n    \"paste_mask\": PASTE_MASK,\n    \"paste_mask_alpha\": PASTE_MASK_ALPHA,\n    \"solder_mask\": SOLDER_MASK,\n    \"solder_mask_alpha\": SOLDER_MASK_ALPHA,\n    \"default_grayscale\": DEFAULT_GRAYSCALE,\n    \"debug_1\": DEBUG_1,\n    CUSTOM_STYLE_OPTION: None,\n}\n</code></pre> <p>Map of known color styles to ColorScheme objects.</p>"},{"location":"reference/pygerber/console/raster_2d_style.html#pygerber.console.raster_2d_style.get_color_scheme_from_style","title":"get_color_scheme_from_style","text":"<pre><code>get_color_scheme_from_style(\n    style: str, custom: Optional[str] = None\n) -&gt; ColorScheme\n</code></pre> <p>Convert style string to ColorScheme object.</p> <p>Accepted values for style are any key from STYLE_TO_COLOR_SCHEME. When style is 'custom' then parameter custom must also be provided. Custom color should be a single string consisting of 5 or 7 valid hexadecimal colors separated with commas. Any color which can be parsed by RGBA type is accepted. Colors are assigned in order:</p> <ul> <li>background_color</li> <li>clear_color</li> <li>solid_color</li> <li>clear_region_color</li> <li>solid_region_color</li> <li>debug_1_color (optional, by default #ABABAB)</li> <li>debug_2_color (optional, by default #7D7D7D)</li> </ul> <p>eg. <code>\"000000,000000,FFFFFF,000000,FFFFFF\"</code></p> Source code in <code>src/pygerber/console/raster_2d_style.py</code> <pre><code>def get_color_scheme_from_style(\n    style: str,\n    custom: Optional[str] = None,\n) -&gt; ColorScheme:\n    \"\"\"Convert style string to ColorScheme object.\n\n    Accepted values for style are any key from STYLE_TO_COLOR_SCHEME. When style is\n    'custom' then parameter custom must also be provided.\n    Custom color should be a single string consisting of 5 or 7 valid hexadecimal colors\n    separated with commas. Any color which can be parsed by RGBA type is accepted.\n    Colors are assigned in order:\n\n    - background_color\n    - clear_color\n    - solid_color\n    - clear_region_color\n    - solid_region_color\n    - debug_1_color (optional, by default #ABABAB)\n    - debug_2_color (optional, by default #7D7D7D)\n\n    eg. `\"000000,000000,FFFFFF,000000,FFFFFF\"`\n    \"\"\"\n    if style == CUSTOM_STYLE_OPTION:\n        if custom is None:\n            msg = (\n                f\"When style is {CUSTOM_STYLE_OPTION!r} custom have to be a valid \"\n                \"custom scheme.\"\n            )\n            raise TypeError(msg)\n        return _construct_custom_scheme(custom)\n\n    color_scheme = STYLE_TO_COLOR_SCHEME[style]\n    if color_scheme is None:\n        # Can't happen - option 'custom' is picked by if above.\n        raise TypeError\n\n    return color_scheme\n</code></pre>"},{"location":"reference/pygerber/gerberx3/__init__.html","title":"init","text":""},{"location":"reference/pygerber/gerberx3/__init__.html#pygerber.gerberx3","title":"gerberx3","text":"<p>Package for Gerber X3 format visualization.</p>"},{"location":"reference/pygerber/gerberx3/revisions.html","title":"revisions","text":""},{"location":"reference/pygerber/gerberx3/revisions.html#pygerber.gerberx3.revisions","title":"revisions","text":"<p>Gerber format metadata.</p>"},{"location":"reference/pygerber/gerberx3/revisions.html#pygerber.gerberx3.revisions.Gerber","title":"Gerber","text":"<p>             Bases: <code>Enum</code></p> <p>Gerber specification major versions.</p> Source code in <code>src/pygerber/gerberx3/revisions.py</code> <pre><code>class Gerber(Enum):\n    \"\"\"Gerber specification major versions.\"\"\"\n\n    X1 = 0x01FF\n    X2 = 0x02FF\n    X3 = 0x03FF\n</code></pre>"},{"location":"reference/pygerber/gerberx3/revisions.html#pygerber.gerberx3.revisions.RevisionData","title":"RevisionData","text":"<p>             Bases: <code>FrozenGeneralModel</code></p> <p>Container for Gerber format revision metadata.</p> Source code in <code>src/pygerber/gerberx3/revisions.py</code> <pre><code>class RevisionData(FrozenGeneralModel):\n    \"\"\"Container for Gerber format revision metadata.\"\"\"\n\n    name: str\n    spec: Gerber\n</code></pre>"},{"location":"reference/pygerber/gerberx3/revisions.html#pygerber.gerberx3.revisions.Revision","title":"Revision","text":"<p>             Bases: <code>Enum</code></p> <p>List of known Gerber format revisions.</p> Source code in <code>src/pygerber/gerberx3/revisions.py</code> <pre><code>class Revision(Enum):\n    \"\"\"List of known Gerber format revisions.\"\"\"\n\n    Revision_Legacy = RevisionData(name=\"Revision Legacy\", spec=Gerber.X1)\n    # Gerber X2\n    Revision_2012_12 = RevisionData(name=\"Revision I1 (2012 12)\", spec=Gerber.X2)\n    Revision_2013_04 = RevisionData(name=\"Revision I2 (2013 04)\", spec=Gerber.X2)\n    Revision_2013_06 = RevisionData(name=\"Revision I3 (2013 06)\", spec=Gerber.X2)\n    Revision_2013_10 = RevisionData(name=\"Revision I4 (2013 10)\", spec=Gerber.X2)\n    Revision_2014_02 = RevisionData(name=\"Revision J1 (2014 02) - X2\", spec=Gerber.X2)\n    Revision_2014_07 = RevisionData(name=\"Revision J2 (2014 07)\", spec=Gerber.X2)\n    Revision_2014_10 = RevisionData(name=\"Revision J3 (2014 10)\", spec=Gerber.X2)\n    Revision_2015_02 = RevisionData(name=\"Revision J4 (2015 02)\", spec=Gerber.X2)\n    Revision_2015_06 = RevisionData(name=\"Revision 2015.06\", spec=Gerber.X2)\n    Revision_2015_07 = RevisionData(name=\"Revision 2015.07\", spec=Gerber.X2)\n    Revision_2015_10 = RevisionData(name=\"Revision 2015.10\", spec=Gerber.X2)\n    Revision_2016_01 = RevisionData(name=\"Revision 2016.01\", spec=Gerber.X2)\n    Revision_2016_04 = RevisionData(name=\"Revision 2016.04\", spec=Gerber.X2)\n    Revision_2016_06 = RevisionData(name=\"Revision 2016.06\", spec=Gerber.X2)\n    Revision_2016_09 = RevisionData(name=\"Revision 2016.09\", spec=Gerber.X2)\n    Revision_2016_11 = RevisionData(name=\"Revision 2016.11\", spec=Gerber.X2)\n    Revision_2016_12 = RevisionData(\n        name=\"Revision 2016.12 - Nested step and repeat\",\n        spec=Gerber.X2,\n    )\n    Revision_2017_03 = RevisionData(name=\"Revision 2017.03\", spec=Gerber.X2)\n    Revision_2017_05 = RevisionData(name=\"Revision 2017.05\", spec=Gerber.X2)\n    Revision_2017_11 = RevisionData(name=\"Revision 2017.11\", spec=Gerber.X2)\n    Revision_2018_05 = RevisionData(name=\"Revision 2018.05\", spec=Gerber.X2)\n    Revision_2018_06 = RevisionData(name=\"Revision 2018.06\", spec=Gerber.X2)\n    Revision_2018_09 = RevisionData(name=\"Revision 2018.09\", spec=Gerber.X2)\n    Revision_2018_11 = RevisionData(name=\"Revision 2018.11\", spec=Gerber.X2)\n    Revision_2019_06 = RevisionData(name=\"Revision 2019.06\", spec=Gerber.X2)\n    Revision_2019_09 = RevisionData(name=\"Revision 2019.09\", spec=Gerber.X2)\n    # Gerber X3\n    Revision_2020_09 = RevisionData(name=\"Revision 2020.09\", spec=Gerber.X3)\n    Revision_2021_02 = RevisionData(name=\"Revision 2021.02\", spec=Gerber.X3)\n    Revision_2021_04 = RevisionData(name=\"Revision 2021.04\", spec=Gerber.X3)\n    Revision_2021_11 = RevisionData(name=\"Revision 2021.11\", spec=Gerber.X3)\n    Revision_2022_02 = RevisionData(name=\"Revision 2022.02\", spec=Gerber.X3)\n    Revision_2023_03 = RevisionData(name=\"Revision 2023.03\", spec=Gerber.X3)\n    Revision_2023_08 = RevisionData(name=\"Revision 2023.08\", spec=Gerber.X3)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/revisions.html#pygerber.gerberx3.revisions.SpecSec","title":"SpecSec  <code>dataclass</code>","text":"<p>Gerber specification section.</p> Source code in <code>src/pygerber/gerberx3/revisions.py</code> <pre><code>@dataclass\nclass SpecSec:\n    \"\"\"Gerber specification section.\"\"\"\n\n    sec_id: str\n    name: str\n    page: int\n</code></pre>"},{"location":"reference/pygerber/gerberx3/revisions.html#pygerber.gerberx3.revisions.Revision202308","title":"Revision202308","text":"<p>             Bases: <code>Enum</code></p> <p>Enumeration of all known sections in Gerber specification, revision 2023.08.</p> Source code in <code>src/pygerber/gerberx3/revisions.py</code> <pre><code>class Revision202308(Enum):\n    \"\"\"Enumeration of all known sections in Gerber specification, revision 2023.08.\"\"\"\n\n    Contents = SpecSec(\"\", \"Contents\", 2)\n    Preface = SpecSec(\"\", \"Preface\", 7)\n    S_1 = SpecSec(\"1\", \"Introduction\", 8)\n    S_1_1 = SpecSec(\"1.1\", \"Scope and Target Audience\", 8)\n    S_1_2 = SpecSec(\"1.2\", \"Further Resources\", 8)\n    S_1_3 = SpecSec(\"1.3\", \"Reference Gerber Viewer\", 8)\n    S_1_4 = SpecSec(\"1.4\", \"Copyright and Intellectual Property\", 9)\n    S_2 = SpecSec(\"2\", \"Overview\", 10)\n    S_2_1 = SpecSec(\"2.1\", \"File Structure\", 10)\n    S_2_2 = SpecSec(\"2.2\", \"Apertures\", 10)\n    S_2_3 = SpecSec(\"2.3\", \"Graphical objects\", 11)\n    S_2_4 = SpecSec(\"2.4\", \"Draws and Arcs\", 12)\n    S_2_5 = SpecSec(\"2.5\", \"Operations (D01, D02, D03)\", 13)\n    S_2_6 = SpecSec(\"2.6\", \"Graphics State\", 16)\n    S_2_7 = SpecSec(\"2.7\", \"Polarity\", 13)\n    S_2_8 = SpecSec(\"2.8\", \"Blocks\", 14)\n    S_2_9 = SpecSec(\"2.9\", \"Attributes\", 14)\n    S_2_10 = SpecSec(\"2.10\", \"Commands Overview\", 18)\n    S_2_11 = SpecSec(\"2.11\", \"Processing a Gerber File\", 19)\n    S_2_12 = SpecSec(\"2.12\", \"Glossary\", 21)\n    S_2_13 = SpecSec(\"2.13\", \"Annotated Example Files\", 24)\n    S_2_13_1 = SpecSec(\"\", \"Example: Two Square Boxes\", 24)\n    S_2_13_2 = SpecSec(\"\", \"Example: Polarities and Apertures\", 26)\n    S_2_14 = SpecSec(\"2.14\", \"Conformance\", 30)\n    S_3 = SpecSec(\"3\", \"Syntax\", 31)\n    S_3_1 = SpecSec(\"3.1\", \"Character Set\", 31)\n    S_3_2 = SpecSec(\"3.2\", \"Grammar Syntax\", 31)\n    S_3_3 = SpecSec(\"3.3\", \"Commands\", 33)\n    S_3_4 = SpecSec(\"3.4\", \"Data Types\", 35)\n    S_3_4_1 = SpecSec(\"\", \"Integers\", 35)\n    S_3_4_2 = SpecSec(\"\", \"Decimals\", 35)\n    S_3_4_3 = SpecSec(\"\", \"Strings\", 35)\n    S_3_4_4 = SpecSec(\"\", \"Fields\", 36)\n    S_3_4_5 = SpecSec(\"\", \"Names\", 36)\n    S_3_5 = SpecSec(\"3.5\", \"Grammar of the Gerber Layer Format\", 37)\n    S_3_6 = SpecSec(\"3.6\", \"File Extension, MIME Type and UTI\", 43)\n    S_4 = SpecSec(\"4\", \"Graphics\", 44)\n    S_4_1 = SpecSec(\"4.1\", \"Comment (G04)\", 44)\n    S_4_2 = SpecSec(\"4.2\", \"Coordinate Commands\", 45)\n    S_4_2_1 = SpecSec(\"\", \"Unit (MO)\", 46)\n    S_4_2_2 = SpecSec(\"\", \"Format Specification (FS)\", 47)\n    S_4_3 = SpecSec(\"4.3\", \"Aperture Definition (AD)\", 48)\n    S_4_3_1 = SpecSec(\"\", \"AD Command\", 48)\n    S_4_3_2 = SpecSec(\"\", \"Zero-size Apertures\", 48)\n    S_4_3_3 = SpecSec(\"\", \"Examples\", 49)\n    S_4_4 = SpecSec(\"4.4\", \"Standard Aperture Templates\", 50)\n    S_4_4_1 = SpecSec(\"\", \"Overview\", 50)\n    S_4_4_2 = SpecSec(\"\", \"Circle\", 50)\n    S_4_4_3 = SpecSec(\"\", \"Rectangle\", 52)\n    S_4_4_4 = SpecSec(\"\", \"Obround\", 53)\n    S_4_4_5 = SpecSec(\"\", \"Polygon\", 54)\n    S_4_4_6 = SpecSec(\"\", \"Transparency of Holes\", 55)\n    S_4_5 = SpecSec(\"4.5\", \"Aperture Macro (AM)\", 56)\n    S_4_5_1 = SpecSec(\"\", \"Primitives\", 58)\n    S_4_5_2 = SpecSec(\"\", \"Exposure Parameter\", 67)\n    S_4_5_3 = SpecSec(\"\", \"Rotation Parameter\", 68)\n    S_4_5_4 = SpecSec(\"\", \"Macro Variables and Expressions\", 70)\n    S_4_5_5 = SpecSec(\"\", \"Examples\", 72)\n    S_4_6 = SpecSec(\"4.6\", \"Set Current Aperture (Dnn)\", 75)\n    S_4_7 = SpecSec(\"4.7\", \"Plot State Commands (G01,G02,G03,G75)\", 76)\n    S_4_7_1 = SpecSec(\"\", \"Linear Plotting (G01)\", 76)\n    S_4_7_2 = SpecSec(\"\", \"Circular Plotting (G02, G03, G75)\", 77)\n    S_4_8 = SpecSec(\"4.8\", \"Operations (D01/D02/D03)\", 81)\n    S_4_8_1 = SpecSec(\"\", \"Overview\", 81)\n    S_4_8_2 = SpecSec(\"\", \"Plot (D01)\", 83)\n    S_4_8_3 = SpecSec(\"\", \"Move (D02)\", 83)\n    S_4_8_4 = SpecSec(\"\", \"Flash (D03)\", 83)\n    S_4_8_5 = SpecSec(\"\", \"Example\", 84)\n    S_4_9 = SpecSec(\"4.9\", \"Aperture Transformations (LP, LM, LR, LS)\", 85)\n    S_4_9_1 = SpecSec(\"\", \"Overview\", 85)\n    S_4_9_2 = SpecSec(\"\", \"Load Polarity (LP)\", 87)\n    S_4_9_3 = SpecSec(\"\", \"Load Mirroring (LM)\", 87)\n    S_4_9_4 = SpecSec(\"\", \"Load Rotation (LR)\", 87)\n    S_4_9_5 = SpecSec(\"\", \"Load Scaling (LS)\", 88)\n    S_4_9_6 = SpecSec(\"\", \"Example\", 88)\n    S_4_10 = SpecSec(\"4.10\", \"Region Statement (G36/G37)\", 90)\n    S_4_10_1 = SpecSec(\"\", \"Region Overview\", 90)\n    S_4_10_2 = SpecSec(\"\", \"Region Statement Syntax\", 90)\n    S_4_10_3 = SpecSec(\"\", \"Valid Contours\", 91)\n    S_4_10_4 = SpecSec(\"\", \"Examples\", 93)\n    S_4_10_5 = SpecSec(\"\", \"Copper Pours, Power and Ground Planes\", 108)\n    S_4_11 = SpecSec(\"4.11\", \"Block Aperture (AB)\", 111)\n    S_4_11_1 = SpecSec(\"\", \"Overview of block apertures\", 111)\n    S_4_11_2 = SpecSec(\"\", \"AB Statement Syntax\", 111)\n    S_4_11_3 = SpecSec(\"\", \"Usage of Block Apertures\", 113)\n    S_4_11_4 = SpecSec(\"\", \"Example\", 114)\n    S_4_12 = SpecSec(\"4.12\", \"Step and Repeat (SR)\", 116)\n    S_4_13 = SpecSec(\"4.13\", \"End-of-file (M02)\", 119)\n    S_4_14 = SpecSec(\"4.14\", \"Numerical Accuracy\", 120)\n    S_4_14_1 = SpecSec(\"\", \"Visualization\", 120)\n    S_4_14_2 = SpecSec(\"\", \"Image Processing\", 120)\n    S_5 = SpecSec(\"5\", \"Attributes\", 122)\n    S_5_1 = SpecSec(\"5.1\", \"Attributes Overview\", 122)\n    S_5_2 = SpecSec(\"5.2\", \"File Attributes (TF)\", 124)\n    S_5_3 = SpecSec(\"5.3\", \"Aperture Attributes (TA)\", 124)\n    S_5_3_1 = SpecSec(\"\", \"Aperture Attributes on Regions\", 125)\n    S_5_4 = SpecSec(\"5.4\", \"Object Attributes (TO)\", 125)\n    S_5_5 = SpecSec(\"5.5\", \"Delete Attribute (TD)\", 126)\n    S_5_6 = SpecSec(\"5.6\", \"Standard Attributes\", 127)\n    S_5_6_1 = SpecSec(\"\", \"Overview\", 127)\n    S_5_6_2 = SpecSec(\"\", \".Part\", 129)\n    S_5_6_3 = SpecSec(\"\", \".FileFunction\", 130)\n    S_5_6_4 = SpecSec(\"\", \".FilePolarity\", 135)\n    S_5_6_5 = SpecSec(\"\", \".SameCoordinates\", 136)\n    S_5_6_6 = SpecSec(\"\", \".CreationDate\", 136)\n    S_5_6_7 = SpecSec(\"\", \".GenerationSoftware\", 137)\n    S_5_6_8 = SpecSec(\"\", \".ProjectId\", 137)\n    S_5_6_9 = SpecSec(\"\", \".MD5\", 138)\n    S_5_6_10 = SpecSec(\"\", \".AperFunction\", 139)\n    S_5_6_11 = SpecSec(\"\", \".DrillTolerance\", 147)\n    S_5_6_12 = SpecSec(\"\", \".FlashText\", 147)\n    S_5_6_13 = SpecSec(\"\", \".N (Net)\", 149)\n    S_5_6_14 = SpecSec(\"\", \".P (Pin)\", 151)\n    S_5_6_15 = SpecSec(\"\", \".C (Component Refdes)\", 152)\n    S_5_6_16 = SpecSec(\"\", \".Cxxx (Component Characteristics)\", 153)\n    S_5_7 = SpecSec(\"5.7\", \"Text in the Image\", 155)\n    S_5_8 = SpecSec(\"5.8\", \"Examples\", 156)\n    S_6 = SpecSec(\"6\", \"PCB Fabrication and Assembly Data\", 158)\n    S_6_1 = SpecSec(\"6.1\", \"Structure\", 158)\n    S_6_2 = SpecSec(\"6.2\", \"Mandatory Attributes\", 158)\n    S_6_3 = SpecSec(\"6.3\", \"Alignment\", 158)\n    S_6_4 = SpecSec(\"6.4\", \"Pads\", 158)\n    S_6_5 = SpecSec(\"6.5\", \"The Profile\", 158)\n    S_6_6 = SpecSec(\"6.6\", \"Drill/rout files\", 159)\n    S_6_6_1 = SpecSec(\"\", \"Backdrilling\", 159)\n    S_6_6_2 = SpecSec(\"\", \"Example Drill File\", 160)\n    S_6_7 = SpecSec(\"6.7\", \"Drawings and Data\", 163)\n    S_6_8 = SpecSec(\"6.8\", \"The CAD Netlist\", 164)\n    S_6_8_1 = SpecSec(\"\", \"Benefits of Including the CAD Netlist\", 164)\n    S_6_8_2 = SpecSec(\"\", \"IP Considerations\", 165)\n    S_6_9 = SpecSec(\"6.9\", \"PCB Assembly Data\", 166)\n    S_6_9_1 = SpecSec(\"\", \"Overview\", 166)\n    S_6_9_2 = SpecSec(\"\", \"Assembly Data Set\", 166)\n    S_6_9_3 = SpecSec(\"\", \"Annotated Example Component Layer\", 167)\n    S_7 = SpecSec(\"7\", \"Errors and Bad Practices\", 169)\n    S_7_1 = SpecSec(\"7.1\", \"Errors\", 169)\n    S_7_2 = SpecSec(\"7.2\", \"Bad Practices\", 171)\n    S_8 = SpecSec(\"8\", \"Deprecated Format Elements\", 173)\n    S_8_1 = SpecSec(\"8.1\", \"Deprecated Commands\", 173)\n    S_8_1_1 = SpecSec(\"\", \"Overview\", 173)\n    S_8_1_2 = SpecSec(\"\", \"Axis Select (AS)\", 175)\n    S_8_1_3 = SpecSec(\"\", \"Image Name (IN)\", 176)\n    S_8_1_4 = SpecSec(\"\", \"Image Polarity (IP)\", 177)\n    S_8_1_5 = SpecSec(\"\", \"Image Rotation (IR)\", 178)\n    S_8_1_6 = SpecSec(\"\", \"Load Name (LN)\", 179)\n    S_8_1_7 = SpecSec(\"\", \"Mirror Image (MI)\", 180)\n    S_8_1_8 = SpecSec(\"\", \"Offset (OF)\", 181)\n    S_8_1_9 = SpecSec(\"\", \"Scale Factor (SF)\", 182)\n    S_8_1_10 = SpecSec(\"\", \"Single-quadrant arc mode (G74)\", 183)\n    S_8_2 = SpecSec(\"8.2\", \"Deprecated Command Options\", 187)\n    S_8_2_1 = SpecSec(\"\", \"Format Specification (FS) Options\", 187)\n    S_8_2_2 = SpecSec(\"\", \"Rectangular Hole in Standard Apertures\", 188)\n    S_8_2_3 = SpecSec(\"\", \"Draws and Arcs with Rectangular Apertures\", 189)\n    S_8_2_4 = SpecSec(\"\", \"Macro Primitive Code 2, Vector Line\", 190)\n    S_8_2_5 = SpecSec(\"\", \"Macro Primitive Code 22, Lower Left Line\", 190)\n    S_8_2_6 = SpecSec(\"\", \"Macro Primitive Code 6, Moir\u00e9\", 191)\n    S_8_3 = SpecSec(\"8.3\", \"Deprecated Syntax Variations\", 192)\n    S_8_3_1 = SpecSec(\"\", \"Combining G01/G02/G03 and D01 in a single command.\", 192)\n    S_8_3_2 = SpecSec(\"\", \"Coordinate Data without Operation Code\", 192)\n    S_8_3_3 = SpecSec(\"\", \"Style Variations in Command Codes\", 192)\n    S_8_3_4 = SpecSec(\"\", \"Deprecated usage of SR\", 192)\n    S_8_4 = SpecSec(\"8.4\", \"Deprecated Attribute Values\", 193)\n    S_8_5 = SpecSec(\"8.5\", \"Standard Gerber (RS-274-D)\", 194)\n    S_9 = SpecSec(\"9\", \"References\", 195)\n    S_10 = SpecSec(\"10\", \"History\", 196)\n    S_11 = SpecSec(\"11\", \"Revisions\", 198)\n    S_11_1 = SpecSec(\"11.1\", \"Revision 2023.08\", 198)\n    S_11_2 = SpecSec(\"11.2\", \"Revision 2023.03\", 198)\n    S_11_3 = SpecSec(\"11.3\", \"Revision 2022.02\", 198)\n    S_11_4 = SpecSec(\"11.4\", \"Revision 2021.11\", 198)\n    S_11_5 = SpecSec(\"11.5\", \"Revision 2021.04\", 198)\n    S_11_6 = SpecSec(\"11.6\", \"Revision 2021.02 - Formal grammar\", 199)\n    S_11_7 = SpecSec(\"11.7\", \"Revision 2020.09 - X3\", 199)\n    S_11_8 = SpecSec(\"11.8\", \"Revision 2019.09\", 199)\n    S_11_9 = SpecSec(\"11.9\", \"Revision 2019.06\", 199)\n    S_11_10 = SpecSec(\"11.10\", \"Revision 2018.11\", 200)\n    S_11_11 = SpecSec(\"11.11\", \"Revision 2018.09\", 200)\n    S_11_12 = SpecSec(\"11.12\", \"Revision 2018.06\", 200)\n    S_11_13 = SpecSec(\"11.13\", \"Revision 2018.05\", 200)\n    S_11_14 = SpecSec(\"11.14\", \"Revision 2017.11\", 200)\n    S_11_15 = SpecSec(\"11.15\", \"Revision 2017.05\", 201)\n    S_11_16 = SpecSec(\"11.16\", \"Revision 2017.03\", 201)\n    S_11_17 = SpecSec(\"11.17\", \"Revision 2016.12 - Nested step and repeat\", 201)\n    S_11_18 = SpecSec(\"11.18\", \"Revision 2016.11\", 201)\n    S_11_19 = SpecSec(\"11.19\", \"Revision 2016.09\", 202)\n    S_11_20 = SpecSec(\"11.20\", \"Revision 2016.06\", 202)\n    S_11_21 = SpecSec(\"11.21\", \"Revision 2016.04\", 202)\n    S_11_22 = SpecSec(\"11.22\", \"Revision 2016.01\", 202)\n    S_11_23 = SpecSec(\"11.23\", \"Revision 2015.10\", 203)\n    S_11_24 = SpecSec(\"11.24\", \"Revision 2015.07\", 203)\n    S_11_25 = SpecSec(\"11.25\", \"Revision 2015.06\", 203)\n    S_11_26 = SpecSec(\"11.26\", \"Revision J3 (2014 10)\", 203)\n    S_11_27 = SpecSec(\"11.27\", \"Revision J4 (2015 02)\", 203)\n    S_11_28 = SpecSec(\"11.28\", \"Revision J2 (2014 07)\", 203)\n    S_11_29 = SpecSec(\"11.29\", \"Revision J1 (2014 02) - X2\", 204)\n    S_11_30 = SpecSec(\"11.30\", \"Revision I4 (2013 10)\", 204)\n    S_11_31 = SpecSec(\"11.31\", \"Revision I3 (2013 06)\", 204)\n    S_11_32 = SpecSec(\"11.32\", \"Revision I2 (2013 04)\", 204)\n    S_11_33 = SpecSec(\"11.33\", \"Revision I1 (2012 12)\", 204)\n\n    def get_url(self) -&gt; str:\n        \"\"\"Get url to this section.\"\"\"\n        return f\"{REVISION_2023_08_SOURCE_URL}page={self.value.page}\"\n\n    def get_sec_id(self) -&gt; str:\n        \"\"\"Get section id.\"\"\"\n        return self.value.sec_id or self.value.name\n</code></pre>"},{"location":"reference/pygerber/gerberx3/revisions.html#pygerber.gerberx3.revisions.Revision202308.get_url","title":"get_url","text":"<pre><code>get_url() -&gt; str\n</code></pre> <p>Get url to this section.</p> Source code in <code>src/pygerber/gerberx3/revisions.py</code> <pre><code>def get_url(self) -&gt; str:\n    \"\"\"Get url to this section.\"\"\"\n    return f\"{REVISION_2023_08_SOURCE_URL}page={self.value.page}\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/revisions.html#pygerber.gerberx3.revisions.Revision202308.get_sec_id","title":"get_sec_id","text":"<pre><code>get_sec_id() -&gt; str\n</code></pre> <p>Get section id.</p> Source code in <code>src/pygerber/gerberx3/revisions.py</code> <pre><code>def get_sec_id(self) -&gt; str:\n    \"\"\"Get section id.\"\"\"\n    return self.value.sec_id or self.value.name\n</code></pre>"},{"location":"reference/pygerber/gerberx3/state_enums.html","title":"state_enums","text":""},{"location":"reference/pygerber/gerberx3/state_enums.html#pygerber.gerberx3.state_enums","title":"state_enums","text":"<p>All state-defining enumerations.</p>"},{"location":"reference/pygerber/gerberx3/state_enums.html#pygerber.gerberx3.state_enums.DrawMode","title":"DrawMode","text":"<p>             Bases: <code>GerberCodeEnum</code></p> <p>Drawing mode.</p> Source code in <code>src/pygerber/gerberx3/state_enums.py</code> <pre><code>class DrawMode(GerberCodeEnum):\n    \"\"\"Drawing mode.\"\"\"\n\n    Linear = \"G01\"\n    \"\"\"In linear plot mode a D01 operation generates a linear segment, from the current\n    point to the (X, Y) coordinates in the command. The current point is then set to the\n    (X, Y) coordinates.Outside a region statement the segment is stroked with the\n    current aperture to create a draw graphical object. In a region statement the\n    segment is added to the contour under construction.\"\"\"\n\n    ClockwiseCircular = \"G02\"\n    \"\"\"In circular plot mode a D01 operation generates an arc segment, from the current\n    point to the (X, Y) coordinates in the command. The current point is then set to the\n    (X, Y) coordinates. Outside a region statement the segment is stroked with the\n    current aperture to create an arc graphical object. In a region statement the\n    segment is added to the contour under construction. For compatibility with older\n    versions of the Gerber format, a G75* must be issued before the first D01 in\n    circular mode.\"\"\"\n\n    CounterclockwiseCircular = \"G03\"\n    \"\"\"In circular plot mode a D01 operation generates an arc segment, from the current\n    point to the (X, Y) coordinates in the command. The current point is then set to the\n    (X, Y) coordinates. Outside a region statement the segment is stroked with the\n    current aperture to create an arc graphical object. In a region statement the\n    segment is added to the contour under construction. For compatibility with older\n    versions of the Gerber format, a G75* must be issued before the first D01 in\n    circular mode.\"\"\"\n\n    def to_human_readable(self) -&gt; str:\n        \"\"\"Convert to human friendly string.\"\"\"\n        return _to_what_draw_message[self]\n</code></pre>"},{"location":"reference/pygerber/gerberx3/state_enums.html#pygerber.gerberx3.state_enums.DrawMode.Linear","title":"Linear  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Linear = 'G01'\n</code></pre> <p>In linear plot mode a D01 operation generates a linear segment, from the current point to the (X, Y) coordinates in the command. The current point is then set to the (X, Y) coordinates.Outside a region statement the segment is stroked with the current aperture to create a draw graphical object. In a region statement the segment is added to the contour under construction.</p>"},{"location":"reference/pygerber/gerberx3/state_enums.html#pygerber.gerberx3.state_enums.DrawMode.ClockwiseCircular","title":"ClockwiseCircular  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ClockwiseCircular = 'G02'\n</code></pre> <p>In circular plot mode a D01 operation generates an arc segment, from the current point to the (X, Y) coordinates in the command. The current point is then set to the (X, Y) coordinates. Outside a region statement the segment is stroked with the current aperture to create an arc graphical object. In a region statement the segment is added to the contour under construction. For compatibility with older versions of the Gerber format, a G75* must be issued before the first D01 in circular mode.</p>"},{"location":"reference/pygerber/gerberx3/state_enums.html#pygerber.gerberx3.state_enums.DrawMode.CounterclockwiseCircular","title":"CounterclockwiseCircular  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CounterclockwiseCircular = 'G03'\n</code></pre> <p>In circular plot mode a D01 operation generates an arc segment, from the current point to the (X, Y) coordinates in the command. The current point is then set to the (X, Y) coordinates. Outside a region statement the segment is stroked with the current aperture to create an arc graphical object. In a region statement the segment is added to the contour under construction. For compatibility with older versions of the Gerber format, a G75* must be issued before the first D01 in circular mode.</p>"},{"location":"reference/pygerber/gerberx3/state_enums.html#pygerber.gerberx3.state_enums.DrawMode.to_human_readable","title":"to_human_readable","text":"<pre><code>to_human_readable() -&gt; str\n</code></pre> <p>Convert to human friendly string.</p> Source code in <code>src/pygerber/gerberx3/state_enums.py</code> <pre><code>def to_human_readable(self) -&gt; str:\n    \"\"\"Convert to human friendly string.\"\"\"\n    return _to_what_draw_message[self]\n</code></pre>"},{"location":"reference/pygerber/gerberx3/state_enums.html#pygerber.gerberx3.state_enums.Polarity","title":"Polarity","text":"<p>             Bases: <code>GerberCodeEnum</code></p> <p>Aperture polarity.</p> Source code in <code>src/pygerber/gerberx3/state_enums.py</code> <pre><code>class Polarity(GerberCodeEnum):\n    \"\"\"Aperture polarity.\"\"\"\n\n    Clear = \"C\"\n    Dark = \"D\"\n    ClearRegion = \"ClearRegion\"\n    DarkRegion = \"DarkRegion\"\n    Background = \"Background\"\n    DEBUG = \"DBG\"\n    DEBUG2 = \"DBG2\"\n\n    def invert(self) -&gt; Polarity:\n        \"\"\"Return opposite polarity.\"\"\"\n        return _polarity_invert_map[self]\n\n    def to_region_variant(self) -&gt; Polarity:\n        \"\"\"Return region variant of polarity.\"\"\"\n        return _to_region_variant_map[self]\n\n    def get_2d_rasterized_color(self) -&gt; int:\n        \"\"\"Get color for \"1\" mode image.\"\"\"\n        return _2d_rasterized_color_map[self]\n</code></pre>"},{"location":"reference/pygerber/gerberx3/state_enums.html#pygerber.gerberx3.state_enums.Polarity.invert","title":"invert","text":"<pre><code>invert() -&gt; Polarity\n</code></pre> <p>Return opposite polarity.</p> Source code in <code>src/pygerber/gerberx3/state_enums.py</code> <pre><code>def invert(self) -&gt; Polarity:\n    \"\"\"Return opposite polarity.\"\"\"\n    return _polarity_invert_map[self]\n</code></pre>"},{"location":"reference/pygerber/gerberx3/state_enums.html#pygerber.gerberx3.state_enums.Polarity.to_region_variant","title":"to_region_variant","text":"<pre><code>to_region_variant() -&gt; Polarity\n</code></pre> <p>Return region variant of polarity.</p> Source code in <code>src/pygerber/gerberx3/state_enums.py</code> <pre><code>def to_region_variant(self) -&gt; Polarity:\n    \"\"\"Return region variant of polarity.\"\"\"\n    return _to_region_variant_map[self]\n</code></pre>"},{"location":"reference/pygerber/gerberx3/state_enums.html#pygerber.gerberx3.state_enums.Polarity.get_2d_rasterized_color","title":"get_2d_rasterized_color","text":"<pre><code>get_2d_rasterized_color() -&gt; int\n</code></pre> <p>Get color for \"1\" mode image.</p> Source code in <code>src/pygerber/gerberx3/state_enums.py</code> <pre><code>def get_2d_rasterized_color(self) -&gt; int:\n    \"\"\"Get color for \"1\" mode image.\"\"\"\n    return _2d_rasterized_color_map[self]\n</code></pre>"},{"location":"reference/pygerber/gerberx3/state_enums.html#pygerber.gerberx3.state_enums.Mirroring","title":"Mirroring","text":"<p>             Bases: <code>GerberCodeEnum</code></p> <p>Aperture mirroring.</p> Source code in <code>src/pygerber/gerberx3/state_enums.py</code> <pre><code>class Mirroring(GerberCodeEnum):\n    \"\"\"Aperture mirroring.\"\"\"\n\n    NoMirroring = \"N\"\n    XY = \"XY\"\n    X = \"X\"\n    Y = \"Y\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/state_enums.html#pygerber.gerberx3.state_enums.Unit","title":"Unit","text":"<p>             Bases: <code>GerberCodeEnum</code></p> <p>Aperture unit.</p> Source code in <code>src/pygerber/gerberx3/state_enums.py</code> <pre><code>class Unit(GerberCodeEnum):\n    \"\"\"Aperture unit.\"\"\"\n\n    Millimeters = \"MM\"\n    Inches = \"IN\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/state_enums.html#pygerber.gerberx3.state_enums.ImagePolarityEnum","title":"ImagePolarityEnum","text":"<p>             Bases: <code>GerberCodeEnum</code></p> <p>Image polarity.</p>"},{"location":"reference/pygerber/gerberx3/state_enums.html#pygerber.gerberx3.state_enums.ImagePolarityEnum--image-polarity-ip","title":"Image Polarity (IP)","text":"<p>Note: The IP command is deprecated.</p> <p>The <code>IP</code> command is responsible for setting the polarity for the entire image. It is designed to be used only once, preferably at the very beginning of the file.</p>"},{"location":"reference/pygerber/gerberx3/state_enums.html#pygerber.gerberx3.state_enums.ImagePolarityEnum--7131-positive-image-polarity","title":"7.1.3.1 Positive Image Polarity","text":"<p>Under the positive image polarity: - The image is generated in accordance with the specifications provided elsewhere in     this document. - It's worth noting that, by default, image generation has always assumed a positive     image polarity.</p>"},{"location":"reference/pygerber/gerberx3/state_enums.html#pygerber.gerberx3.state_enums.ImagePolarityEnum--7132-negative-image-polarity","title":"7.1.3.2 Negative Image Polarity","text":"<p>When the negative image polarity is in use: - The intent is to produce an image that portrays clear areas against a dark     backdrop. - The initial state of the entire image plane is dark, as opposed to being clear. - The polarity effects between dark and clear regions are interchanged. Essentially,     what was dark becomes white and vice-versa. - For negative image polarity, the very first graphics object that gets produced     must possess a dark polarity. As a result, it takes on the role of clearing the     dark backdrop.</p> Source code in <code>src/pygerber/gerberx3/state_enums.py</code> <pre><code>class ImagePolarityEnum(GerberCodeEnum):\n    \"\"\"Image polarity.\n\n    ### Image Polarity (IP)\n\n    Note: The IP command is deprecated.\n\n    The `IP` command is responsible for setting the polarity for the entire image. It is\n    designed to be used only once, preferably at the very beginning of the file.\n\n    #### 7.1.3.1 Positive Image Polarity\n    Under the positive image polarity:\n    - The image is generated in accordance with the specifications provided elsewhere in\n        this document.\n    - It's worth noting that, by default, image generation has always assumed a positive\n        image polarity.\n\n    #### 7.1.3.2 Negative Image Polarity\n    When the negative image polarity is in use:\n    - The intent is to produce an image that portrays clear areas against a dark\n        backdrop.\n    - The initial state of the entire image plane is dark, as opposed to being clear.\n    - The polarity effects between dark and clear regions are interchanged. Essentially,\n        what was dark becomes white and vice-versa.\n    - For negative image polarity, the very first graphics object that gets produced\n        must possess a dark polarity. As a result, it takes on the role of clearing the\n        dark backdrop.\n    \"\"\"\n\n    POSITIVE = \"POS\"\n    NEGATIVE = \"NEG\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/state_enums.html#pygerber.gerberx3.state_enums.AxisCorrespondence","title":"AxisCorrespondence","text":"<p>             Bases: <code>GerberCodeEnum</code></p> <p>Possible values of AS command axis correspondence.</p> Source code in <code>src/pygerber/gerberx3/state_enums.py</code> <pre><code>class AxisCorrespondence(GerberCodeEnum):\n    \"\"\"Possible values of AS command axis correspondence.\"\"\"\n\n    AXBY = \"AXBY\"\n    AYBX = \"AYBX\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/__init__.html","title":"init","text":""},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api","title":"api","text":"<p><code>pygerber.gerberx3.api</code> module provides simple, high-level API for rendering Gerber X3/X2 files.</p>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.ColorScheme","title":"ColorScheme","text":"<p>             Bases: <code>FrozenGeneralModel</code></p> <p>Set of colors which should be used for rendering.</p> <p>ColorScheme class contains set of colors which should be used for different parts of rendered image. At the same time it also works as a container for predefined color schemes commonly used for parts of PCB.</p> <p>Predefined colors</p> <p>All predefined colors have two variants - normal one and one with \"*_ALPHA\" suffix. Those without suffix have solid background and are not intended for constructing multi-layer images out of them ie. they are not suitable for rendering a project consisting of separate copper, silk, pase mask and composing them into single image. For cases when rendered images are intended for stacking \"*_ALPHA\" schemes should be used, as background and transparent parts of image will be truly transparent.</p> Source code in <code>src/pygerber/backend/rasterized_2d/color_scheme.py</code> <pre><code>class ColorScheme(FrozenGeneralModel):\n    r\"\"\"Set of colors which should be used for rendering.\n\n    ColorScheme class contains set of colors which should be used for different parts\n    of rendered image. At the same time it also works as a container for predefined\n    color schemes commonly used for parts of PCB.\n\n    !!! info \"Predefined colors\"\n\n        All predefined colors have two variants - normal one and one with \"\\*_ALPHA\"\n        suffix. Those without suffix have solid background and are not intended for\n        constructing multi-layer images out of them ie. they are not suitable for\n        rendering a project consisting of separate copper, silk, pase mask and composing\n        them into single image. For cases when rendered images are intended for stacking\n        \"\\*_ALPHA\" schemes should be used, as background and transparent parts of image\n        will be truly transparent.\n\n    \"\"\"\n\n    SILK: ClassVar[ColorScheme]\n    \"\"\"Default color of silk layer.\n\n    This schema provided non-transparent background, which results in images which\n    can not be used for stacking on top of other layers, as they would completely\n    obscure them.\"\"\"\n\n    SILK_ALPHA: ClassVar[ColorScheme]\n    \"\"\"Default color of silk layer with alpha channel.\n\n    This schema provides transparent background. Images using this schema can be\n    stacked on top of each other without obscuring layers below.\"\"\"\n\n    COPPER: ClassVar[ColorScheme]\n    \"\"\"Default color of copper layer.\n\n    This schema provided non-transparent background, which results in images which\n    can not be used for stacking on top of other layers, as they would completely\n    obscure them.\"\"\"\n\n    COPPER_ALPHA: ClassVar[ColorScheme]\n    \"\"\"Default color of copper layer with alpha channel.\n\n    This schema provides transparent background. Images using this schema can be\n    stacked on top of each other without obscuring layers below.\"\"\"\n\n    PASTE_MASK: ClassVar[ColorScheme]\n    \"\"\"Default color of paste mask layer.\n\n    This schema provided non-transparent background, which results in images which\n    can not be used for stacking on top of other layers, as they would completely\n    obscure them.\"\"\"\n\n    PASTE_MASK_ALPHA: ClassVar[ColorScheme]\n    \"\"\"Default color of paste mask layer with alpha channel.\n\n    This schema provides transparent background. Images using this schema can be\n    stacked on top of each other without obscuring layers below.\"\"\"\n\n    SOLDER_MASK: ClassVar[ColorScheme]\n    \"\"\"Default color of solder mask layer.\n\n    This schema provided non-transparent background, which results in images which\n    can not be used for stacking on top of other layers, as they would completely\n    obscure them.\"\"\"\n\n    SOLDER_MASK_ALPHA: ClassVar[ColorScheme]\n    \"\"\"Default color of solder mask layer with alpha channel.\n\n    This schema provides transparent background. Images using this schema can be\n    stacked on top of each other without obscuring layers below.\"\"\"\n\n    DEFAULT_GRAYSCALE: ClassVar[ColorScheme]\n    \"\"\"Default color scheme for files which were not assigned other color scheme.\"\"\"\n\n    DEBUG_1: ClassVar[ColorScheme]\n    \"\"\"Debug color scheme.\"\"\"\n\n    DEBUG_1_ALPHA: ClassVar[ColorScheme]\n    \"\"\"Debug color scheme with alpha channel.\"\"\"\n\n    background_color: RGBA\n    \"\"\"Color used as empty image background.\"\"\"\n\n    clear_color: RGBA\n    \"\"\"Color used for clear draws.\"\"\"\n\n    solid_color: RGBA\n    \"\"\"Color used for solid draws.\"\"\"\n\n    clear_region_color: RGBA\n    \"\"\"Color used for clear region draws.\"\"\"\n\n    solid_region_color: RGBA\n    \"\"\"Color used for solid region draws.\"\"\"\n\n    debug_1_color: RGBA = RGBA.from_hex(\"#ababab\")\n    \"\"\"Color used for debug elements.\"\"\"\n\n    debug_2_color: RGBA = RGBA.from_hex(\"#7d7d7d\")\n    \"\"\"Color used for debug elements.\"\"\"\n\n    def get_grayscale_to_rgba_color_map(self) -&gt; dict[int, tuple[int, int, int, int]]:\n        \"\"\"Return grayscale to RGBA color map.\"\"\"\n        return {\n            Polarity.Dark.get_2d_rasterized_color(): self.solid_color.as_rgba_int(),\n            Polarity.Clear.get_2d_rasterized_color(): self.clear_color.as_rgba_int(),\n            Polarity.DarkRegion.get_2d_rasterized_color(): self.solid_region_color.as_rgba_int(),  # noqa: E501\n            Polarity.ClearRegion.get_2d_rasterized_color(): self.clear_region_color.as_rgba_int(),  # noqa: E501\n            Polarity.Background.get_2d_rasterized_color(): self.background_color.as_rgba_int(),  # noqa: E501\n            Polarity.DEBUG.get_2d_rasterized_color(): self.debug_1_color.as_rgba_int(),\n            Polarity.DEBUG2.get_2d_rasterized_color(): self.debug_2_color.as_rgba_int(),\n        }\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.ColorScheme.SILK","title":"SILK  <code>class-attribute</code>","text":"<pre><code>SILK: ColorScheme\n</code></pre> <p>Default color of silk layer.</p> <p>This schema provided non-transparent background, which results in images which can not be used for stacking on top of other layers, as they would completely obscure them.</p>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.ColorScheme.SILK_ALPHA","title":"SILK_ALPHA  <code>class-attribute</code>","text":"<pre><code>SILK_ALPHA: ColorScheme\n</code></pre> <p>Default color of silk layer with alpha channel.</p> <p>This schema provides transparent background. Images using this schema can be stacked on top of each other without obscuring layers below.</p>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.ColorScheme.COPPER","title":"COPPER  <code>class-attribute</code>","text":"<pre><code>COPPER: ColorScheme\n</code></pre> <p>Default color of copper layer.</p> <p>This schema provided non-transparent background, which results in images which can not be used for stacking on top of other layers, as they would completely obscure them.</p>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.ColorScheme.COPPER_ALPHA","title":"COPPER_ALPHA  <code>class-attribute</code>","text":"<pre><code>COPPER_ALPHA: ColorScheme\n</code></pre> <p>Default color of copper layer with alpha channel.</p> <p>This schema provides transparent background. Images using this schema can be stacked on top of each other without obscuring layers below.</p>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.ColorScheme.PASTE_MASK","title":"PASTE_MASK  <code>class-attribute</code>","text":"<pre><code>PASTE_MASK: ColorScheme\n</code></pre> <p>Default color of paste mask layer.</p> <p>This schema provided non-transparent background, which results in images which can not be used for stacking on top of other layers, as they would completely obscure them.</p>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.ColorScheme.PASTE_MASK_ALPHA","title":"PASTE_MASK_ALPHA  <code>class-attribute</code>","text":"<pre><code>PASTE_MASK_ALPHA: ColorScheme\n</code></pre> <p>Default color of paste mask layer with alpha channel.</p> <p>This schema provides transparent background. Images using this schema can be stacked on top of each other without obscuring layers below.</p>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.ColorScheme.SOLDER_MASK","title":"SOLDER_MASK  <code>class-attribute</code>","text":"<pre><code>SOLDER_MASK: ColorScheme\n</code></pre> <p>Default color of solder mask layer.</p> <p>This schema provided non-transparent background, which results in images which can not be used for stacking on top of other layers, as they would completely obscure them.</p>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.ColorScheme.SOLDER_MASK_ALPHA","title":"SOLDER_MASK_ALPHA  <code>class-attribute</code>","text":"<pre><code>SOLDER_MASK_ALPHA: ColorScheme\n</code></pre> <p>Default color of solder mask layer with alpha channel.</p> <p>This schema provides transparent background. Images using this schema can be stacked on top of each other without obscuring layers below.</p>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.ColorScheme.DEFAULT_GRAYSCALE","title":"DEFAULT_GRAYSCALE  <code>class-attribute</code>","text":"<pre><code>DEFAULT_GRAYSCALE: ColorScheme\n</code></pre> <p>Default color scheme for files which were not assigned other color scheme.</p>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.ColorScheme.DEBUG_1","title":"DEBUG_1  <code>class-attribute</code>","text":"<pre><code>DEBUG_1: ColorScheme\n</code></pre> <p>Debug color scheme.</p>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.ColorScheme.DEBUG_1_ALPHA","title":"DEBUG_1_ALPHA  <code>class-attribute</code>","text":"<pre><code>DEBUG_1_ALPHA: ColorScheme\n</code></pre> <p>Debug color scheme with alpha channel.</p>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.ColorScheme.background_color","title":"background_color  <code>instance-attribute</code>","text":"<pre><code>background_color: RGBA\n</code></pre> <p>Color used as empty image background.</p>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.ColorScheme.clear_color","title":"clear_color  <code>instance-attribute</code>","text":"<pre><code>clear_color: RGBA\n</code></pre> <p>Color used for clear draws.</p>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.ColorScheme.solid_color","title":"solid_color  <code>instance-attribute</code>","text":"<pre><code>solid_color: RGBA\n</code></pre> <p>Color used for solid draws.</p>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.ColorScheme.clear_region_color","title":"clear_region_color  <code>instance-attribute</code>","text":"<pre><code>clear_region_color: RGBA\n</code></pre> <p>Color used for clear region draws.</p>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.ColorScheme.solid_region_color","title":"solid_region_color  <code>instance-attribute</code>","text":"<pre><code>solid_region_color: RGBA\n</code></pre> <p>Color used for solid region draws.</p>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.ColorScheme.debug_1_color","title":"debug_1_color  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>debug_1_color: RGBA = from_hex('#ababab')\n</code></pre> <p>Color used for debug elements.</p>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.ColorScheme.debug_2_color","title":"debug_2_color  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>debug_2_color: RGBA = from_hex('#7d7d7d')\n</code></pre> <p>Color used for debug elements.</p>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.ColorScheme.get_grayscale_to_rgba_color_map","title":"get_grayscale_to_rgba_color_map","text":"<pre><code>get_grayscale_to_rgba_color_map() -&gt; (\n    dict[int, tuple[int, int, int, int]]\n)\n</code></pre> <p>Return grayscale to RGBA color map.</p> Source code in <code>src/pygerber/backend/rasterized_2d/color_scheme.py</code> <pre><code>def get_grayscale_to_rgba_color_map(self) -&gt; dict[int, tuple[int, int, int, int]]:\n    \"\"\"Return grayscale to RGBA color map.\"\"\"\n    return {\n        Polarity.Dark.get_2d_rasterized_color(): self.solid_color.as_rgba_int(),\n        Polarity.Clear.get_2d_rasterized_color(): self.clear_color.as_rgba_int(),\n        Polarity.DarkRegion.get_2d_rasterized_color(): self.solid_region_color.as_rgba_int(),  # noqa: E501\n        Polarity.ClearRegion.get_2d_rasterized_color(): self.clear_region_color.as_rgba_int(),  # noqa: E501\n        Polarity.Background.get_2d_rasterized_color(): self.background_color.as_rgba_int(),  # noqa: E501\n        Polarity.DEBUG.get_2d_rasterized_color(): self.debug_1_color.as_rgba_int(),\n        Polarity.DEBUG2.get_2d_rasterized_color(): self.debug_2_color.as_rgba_int(),\n    }\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.RGBA","title":"RGBA","text":"<p>             Bases: <code>FrozenGeneralModel</code></p> <p>Representation of RGBA color.</p> Source code in <code>src/pygerber/common/rgba.py</code> <pre><code>class RGBA(FrozenGeneralModel):\n    \"\"\"Representation of RGBA color.\"\"\"\n\n    r: Color = ColorField\n    g: Color = ColorField\n    b: Color = ColorField\n    a: Color = ColorField\n\n    @classmethod\n    def from_hex(cls, string: str) -&gt; Self:\n        \"\"\"Build RGBA color object from hexadecimal string.\n\n        Parameters\n        ----------\n        string : str\n            String containing color value. Accepted formats are `RRGGBBAA` and `RRGGBB`.\n            For latter, alpha value is assumed to be 0xFF. Formats are case insensitive.\n            `#` symbol prefix for hex string is accepted.\n\n        Returns\n        -------\n        RGBA\n            Color built from hexadecimal values.\n        \"\"\"\n        if string[0] == \"#\":\n            string = string[1:]\n\n        r, g, b, a = string[:2], string[2:4], string[4:6], string[6:]\n        if len(a) == 0:\n            a = \"FF\"\n\n        return cls(\n            r=int(r, base=16),\n            g=int(g, base=16),\n            b=int(b, base=16),\n            a=int(a, base=16),\n        )\n\n    @classmethod\n    def from_rgba(cls, r: int, g: int, b: int, a: int = 0xFF) -&gt; Self:\n        \"\"\"Build RGBA color object from reg, green, blue and alpha integer values.\n\n        Parameters\n        ----------\n        r : int\n            Red chanel value as integer from 0 to 255, inclusive.\n        g : int\n            Green chanel value as integer from 0 to 255, inclusive.\n        b : int\n            Blue chanel value as integer from 0 to 255, inclusive.\n        a : int, optional\n            Alpha chanel value as integer from 0 to 255, inclusive., by default 0xFF\n\n        Returns\n        -------\n        Self\n            Color built from r, g, b, a values.\n        \"\"\"\n        return cls(r=r, g=g, b=b, a=a)\n\n    @classmethod\n    def from_hsv(\n        cls,\n        h: int,\n        s: float,\n        v: float,\n        a: int = 255,\n    ) -&gt; Self:\n        \"\"\"Build RGBA color object from hue, saturation, value and alpha.\n\n        For extended information refer to Wikipedia: https://en.wikipedia.org/wiki/HSL_and_HSV\n\n        Parameters\n        ----------\n        h : int\n            Hue of color, integer in range 0 to 360 inclusive.\n        s : float\n            Saturation of color, float in range 0.0 to 100.0 inclusive.\n        v : float\n            Value of color, float in range 0.0 to 100.0 inclusive.\n        a : int\n            Alpha of color, int in range 0 to 255 inclusive.\n\n        Returns\n        -------\n        Self\n            Color built from h, s, v, a values.\n        \"\"\"\n        h %= 360\n        s /= 100\n        v /= 100\n\n        c = v * s\n        x = c * (1 - abs(((h / 60) % 2) - 1))\n        m = v - c\n\n        if 0 &lt;= h &lt; HSV_Q0_MAX_ANGLE_DEGREES:\n            r_, g_, b_ = c, x, 0.0\n        elif HSV_Q0_MAX_ANGLE_DEGREES &lt;= h &lt; HSV_Q1_MAX_ANGLE_DEGREES:\n            r_, g_, b_ = x, c, 0.0\n        elif HSV_Q1_MAX_ANGLE_DEGREES &lt;= h &lt; HSV_Q2_MAX_ANGLE_DEGREES:\n            r_, g_, b_ = 0.0, c, x\n        elif HSV_Q2_MAX_ANGLE_DEGREES &lt;= h &lt; HSV_Q3_MAX_ANGLE_DEGREES:\n            r_, g_, b_ = 0.0, x, c\n        elif HSV_Q3_MAX_ANGLE_DEGREES &lt;= h &lt; HSV_Q4_MAX_ANGLE_DEGREES:\n            r_, g_, b_ = x, 0.0, c\n        elif HSV_Q4_MAX_ANGLE_DEGREES &lt;= h &lt;= HSV_Q5_MAX_ANGLE_DEGREES:\n            r_, g_, b_ = c, 0.0, x\n        else:\n            raise ValueError(h)\n\n        return cls(\n            r=round((r_ + m) * 255),\n            g=round((g_ + m) * 255),\n            b=round((b_ + m) * 255),\n            a=a,\n        )\n\n    def as_rgba_int(self) -&gt; tuple[int, int, int, int]:\n        \"\"\"Return RGBA color as tuple of integers in range 0 to 255 inclusive.\"\"\"\n        return self.r, self.g, self.b, self.a\n\n    def as_rgba_float(self) -&gt; tuple[float, float, float, float]:\n        \"\"\"Return RGBA color as tuple of floats in range 0.0 to 1.0 inclusive.\"\"\"\n        return (\n            float(Decimal(self.r) / Decimal(255)),\n            float(Decimal(self.g) / Decimal(255)),\n            float(Decimal(self.b) / Decimal(255)),\n            float(Decimal(self.a) / Decimal(255)),\n        )\n\n    def to_hex(self) -&gt; str:\n        \"\"\"Return color as hexadecimal string.\"\"\"\n        r = f\"{self.r:0{2}x}\"\n        g = f\"{self.g:0{2}x}\"\n        b = f\"{self.b:0{2}x}\"\n        a = f\"{self.a:0{2}x}\"\n        return f\"#{r}{g}{b}{a}\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.RGBA.from_hex","title":"from_hex  <code>classmethod</code>","text":"<pre><code>from_hex(string: str) -&gt; Self\n</code></pre> <p>Build RGBA color object from hexadecimal string.</p> <p>Parameters:</p> Name Type Description Default <code>string</code> <code>str</code> <p>String containing color value. Accepted formats are <code>RRGGBBAA</code> and <code>RRGGBB</code>. For latter, alpha value is assumed to be 0xFF. Formats are case insensitive. <code>#</code> symbol prefix for hex string is accepted.</p> required <p>Returns:</p> Type Description <code>RGBA</code> <p>Color built from hexadecimal values.</p> Source code in <code>src/pygerber/common/rgba.py</code> <pre><code>@classmethod\ndef from_hex(cls, string: str) -&gt; Self:\n    \"\"\"Build RGBA color object from hexadecimal string.\n\n    Parameters\n    ----------\n    string : str\n        String containing color value. Accepted formats are `RRGGBBAA` and `RRGGBB`.\n        For latter, alpha value is assumed to be 0xFF. Formats are case insensitive.\n        `#` symbol prefix for hex string is accepted.\n\n    Returns\n    -------\n    RGBA\n        Color built from hexadecimal values.\n    \"\"\"\n    if string[0] == \"#\":\n        string = string[1:]\n\n    r, g, b, a = string[:2], string[2:4], string[4:6], string[6:]\n    if len(a) == 0:\n        a = \"FF\"\n\n    return cls(\n        r=int(r, base=16),\n        g=int(g, base=16),\n        b=int(b, base=16),\n        a=int(a, base=16),\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.RGBA.from_rgba","title":"from_rgba  <code>classmethod</code>","text":"<pre><code>from_rgba(r: int, g: int, b: int, a: int = 255) -&gt; Self\n</code></pre> <p>Build RGBA color object from reg, green, blue and alpha integer values.</p> <p>Parameters:</p> Name Type Description Default <code>r</code> <code>int</code> <p>Red chanel value as integer from 0 to 255, inclusive.</p> required <code>g</code> <code>int</code> <p>Green chanel value as integer from 0 to 255, inclusive.</p> required <code>b</code> <code>int</code> <p>Blue chanel value as integer from 0 to 255, inclusive.</p> required <code>a</code> <code>int</code> <p>Alpha chanel value as integer from 0 to 255, inclusive., by default 0xFF</p> <code>255</code> <p>Returns:</p> Type Description <code>Self</code> <p>Color built from r, g, b, a values.</p> Source code in <code>src/pygerber/common/rgba.py</code> <pre><code>@classmethod\ndef from_rgba(cls, r: int, g: int, b: int, a: int = 0xFF) -&gt; Self:\n    \"\"\"Build RGBA color object from reg, green, blue and alpha integer values.\n\n    Parameters\n    ----------\n    r : int\n        Red chanel value as integer from 0 to 255, inclusive.\n    g : int\n        Green chanel value as integer from 0 to 255, inclusive.\n    b : int\n        Blue chanel value as integer from 0 to 255, inclusive.\n    a : int, optional\n        Alpha chanel value as integer from 0 to 255, inclusive., by default 0xFF\n\n    Returns\n    -------\n    Self\n        Color built from r, g, b, a values.\n    \"\"\"\n    return cls(r=r, g=g, b=b, a=a)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.RGBA.from_hsv","title":"from_hsv  <code>classmethod</code>","text":"<pre><code>from_hsv(h: int, s: float, v: float, a: int = 255) -&gt; Self\n</code></pre> <p>Build RGBA color object from hue, saturation, value and alpha.</p> <p>For extended information refer to Wikipedia: https://en.wikipedia.org/wiki/HSL_and_HSV</p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>int</code> <p>Hue of color, integer in range 0 to 360 inclusive.</p> required <code>s</code> <code>float</code> <p>Saturation of color, float in range 0.0 to 100.0 inclusive.</p> required <code>v</code> <code>float</code> <p>Value of color, float in range 0.0 to 100.0 inclusive.</p> required <code>a</code> <code>int</code> <p>Alpha of color, int in range 0 to 255 inclusive.</p> <code>255</code> <p>Returns:</p> Type Description <code>Self</code> <p>Color built from h, s, v, a values.</p> Source code in <code>src/pygerber/common/rgba.py</code> <pre><code>@classmethod\ndef from_hsv(\n    cls,\n    h: int,\n    s: float,\n    v: float,\n    a: int = 255,\n) -&gt; Self:\n    \"\"\"Build RGBA color object from hue, saturation, value and alpha.\n\n    For extended information refer to Wikipedia: https://en.wikipedia.org/wiki/HSL_and_HSV\n\n    Parameters\n    ----------\n    h : int\n        Hue of color, integer in range 0 to 360 inclusive.\n    s : float\n        Saturation of color, float in range 0.0 to 100.0 inclusive.\n    v : float\n        Value of color, float in range 0.0 to 100.0 inclusive.\n    a : int\n        Alpha of color, int in range 0 to 255 inclusive.\n\n    Returns\n    -------\n    Self\n        Color built from h, s, v, a values.\n    \"\"\"\n    h %= 360\n    s /= 100\n    v /= 100\n\n    c = v * s\n    x = c * (1 - abs(((h / 60) % 2) - 1))\n    m = v - c\n\n    if 0 &lt;= h &lt; HSV_Q0_MAX_ANGLE_DEGREES:\n        r_, g_, b_ = c, x, 0.0\n    elif HSV_Q0_MAX_ANGLE_DEGREES &lt;= h &lt; HSV_Q1_MAX_ANGLE_DEGREES:\n        r_, g_, b_ = x, c, 0.0\n    elif HSV_Q1_MAX_ANGLE_DEGREES &lt;= h &lt; HSV_Q2_MAX_ANGLE_DEGREES:\n        r_, g_, b_ = 0.0, c, x\n    elif HSV_Q2_MAX_ANGLE_DEGREES &lt;= h &lt; HSV_Q3_MAX_ANGLE_DEGREES:\n        r_, g_, b_ = 0.0, x, c\n    elif HSV_Q3_MAX_ANGLE_DEGREES &lt;= h &lt; HSV_Q4_MAX_ANGLE_DEGREES:\n        r_, g_, b_ = x, 0.0, c\n    elif HSV_Q4_MAX_ANGLE_DEGREES &lt;= h &lt;= HSV_Q5_MAX_ANGLE_DEGREES:\n        r_, g_, b_ = c, 0.0, x\n    else:\n        raise ValueError(h)\n\n    return cls(\n        r=round((r_ + m) * 255),\n        g=round((g_ + m) * 255),\n        b=round((b_ + m) * 255),\n        a=a,\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.RGBA.as_rgba_int","title":"as_rgba_int","text":"<pre><code>as_rgba_int() -&gt; tuple[int, int, int, int]\n</code></pre> <p>Return RGBA color as tuple of integers in range 0 to 255 inclusive.</p> Source code in <code>src/pygerber/common/rgba.py</code> <pre><code>def as_rgba_int(self) -&gt; tuple[int, int, int, int]:\n    \"\"\"Return RGBA color as tuple of integers in range 0 to 255 inclusive.\"\"\"\n    return self.r, self.g, self.b, self.a\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.RGBA.as_rgba_float","title":"as_rgba_float","text":"<pre><code>as_rgba_float() -&gt; tuple[float, float, float, float]\n</code></pre> <p>Return RGBA color as tuple of floats in range 0.0 to 1.0 inclusive.</p> Source code in <code>src/pygerber/common/rgba.py</code> <pre><code>def as_rgba_float(self) -&gt; tuple[float, float, float, float]:\n    \"\"\"Return RGBA color as tuple of floats in range 0.0 to 1.0 inclusive.\"\"\"\n    return (\n        float(Decimal(self.r) / Decimal(255)),\n        float(Decimal(self.g) / Decimal(255)),\n        float(Decimal(self.b) / Decimal(255)),\n        float(Decimal(self.a) / Decimal(255)),\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.RGBA.to_hex","title":"to_hex","text":"<pre><code>to_hex() -&gt; str\n</code></pre> <p>Return color as hexadecimal string.</p> Source code in <code>src/pygerber/common/rgba.py</code> <pre><code>def to_hex(self) -&gt; str:\n    \"\"\"Return color as hexadecimal string.\"\"\"\n    r = f\"{self.r:0{2}x}\"\n    g = f\"{self.g:0{2}x}\"\n    b = f\"{self.b:0{2}x}\"\n    a = f\"{self.a:0{2}x}\"\n    return f\"#{r}{g}{b}{a}\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.GerberX3APIError","title":"GerberX3APIError","text":"<p>             Bases: <code>Exception</code></p> <p>Base class for API errors.</p> <p>Exceptions derived from this exception are exclusively raised in PyGerber's Gerber X3 high level API. This exception can be used in <code>try: ... except GerberX3APIError: ...</code> block to catch all exceptions raised by this API while allowing other exceptions to interrupt execution.</p> Source code in <code>src/pygerber/gerberx3/api/_errors.py</code> <pre><code>class GerberX3APIError(Exception):\n    \"\"\"Base class for API errors.\n\n    Exceptions derived from this exception are exclusively raised in PyGerber's Gerber\n    X3 high level API. This exception can be used in\n    `#!python try: ... except GerberX3APIError: ...` block to catch all exceptions\n    raised by this API while allowing other exceptions to interrupt execution.\n    \"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.MutuallyExclusiveViolationError","title":"MutuallyExclusiveViolationError","text":"<p>             Bases: <code>GerberX3APIError</code></p> <p>Raised when two or more of mutually exclusive parameters are provided.</p> <p><code>LayerParams</code> class accepts three mutually exclusive fields, <code>source_path</code>, <code>source_code</code> and <code>source_buffer</code> for providing source code to <code>Layer</code>. When more than one of those options is set, this exception will be raised.</p> Source code in <code>src/pygerber/gerberx3/api/_errors.py</code> <pre><code>class MutuallyExclusiveViolationError(GerberX3APIError):\n    \"\"\"Raised when two or more of mutually exclusive parameters are provided.\n\n    `LayerParams` class accepts three mutually exclusive fields, `source_path`,\n    `source_code` and `source_buffer` for providing source code to `Layer`.\n    When more than one of those options is set, this exception will be raised.\n    \"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.RenderingResultNotReadyError","title":"RenderingResultNotReadyError","text":"<p>             Bases: <code>GerberX3APIError</code></p> <p>Raised when RenderingResult is requested before it was rendered.</p> <p><code>Layer.get_rendering_result()</code> method can only be called after <code>Layer.render()</code>. Breaking this rule will cause this exception to be raised.</p> Source code in <code>src/pygerber/gerberx3/api/_errors.py</code> <pre><code>class RenderingResultNotReadyError(GerberX3APIError):\n    \"\"\"Raised when RenderingResult is requested before it was rendered.\n\n    `Layer.get_rendering_result()` method can only be called after `Layer.render()`.\n    Breaking this rule will cause this exception to be raised.\n    \"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.Layer","title":"Layer","text":"<p>Representation of Gerber X3 image layer.</p> <p>This is only abstract base class, please use one of its subclasses with rendering system guarantees.</p> Source code in <code>src/pygerber/gerberx3/api/_layers.py</code> <pre><code>class Layer:\n    \"\"\"Representation of Gerber X3 image layer.\n\n    This is only abstract base class, please use one of its subclasses with rendering\n    system guarantees.\n    \"\"\"\n\n    def __init__(self, options: LayerParams) -&gt; None:\n        \"\"\"Create PCB layer.\n\n        Parameters\n        ----------\n        options: LayerOptions\n            Configuration of layer.\n        \"\"\"\n        self.options = options\n\n        self.tokenizer = self._create_tokenizer()\n        self.backend = self._create_backend()\n        self.parser = self._create_parser()\n\n        self._rendering_result: Optional[RenderingResult] = None\n\n    def _create_tokenizer(self) -&gt; Tokenizer:\n        return Tokenizer()\n\n    @abstractmethod\n    def _create_backend(self) -&gt; Backend:\n        pass\n\n    def _create_parser(self) -&gt; Parser:\n        return Parser(\n            ParserOptions(\n                backend=self.backend,\n                on_update_drawing_state_error=self.options.parser_error,\n            ),\n        )\n\n    def render(self) -&gt; RenderingResult:\n        \"\"\"Render layer image.\"\"\"\n        stack = self.tokenizer.tokenize(self.options.get_source_code())\n        draw_commands = self.parser.parse(stack)\n\n        result_handle = draw_commands.draw()\n        properties = LayerProperties(\n            target_bounding_box=self.backend.drawing_target.bounding_box,\n            target_coordinate_origin=self.backend.drawing_target.coordinate_origin,\n            gerber_bounding_box=self.backend.bounding_box,\n            gerber_coordinate_origin=self.backend.coordinate_origin,\n        )\n\n        self._rendering_result = self._get_rendering_result_cls()(\n            result_handle=result_handle,\n            properties=properties,\n        )\n        return self._rendering_result\n\n    def _get_rendering_result_cls(self) -&gt; type[RenderingResult]:\n        return RenderingResult\n\n    def get_rendering_result(self) -&gt; RenderingResult:\n        \"\"\"Return result of rendering Gerber file.\"\"\"\n        if self._rendering_result is None:\n            msg = \"Use `render()` method to create result first.\"\n            raise RenderingResultNotReadyError(msg)\n\n        return self._rendering_result\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.Layer.__init__","title":"__init__","text":"<pre><code>__init__(options: LayerParams) -&gt; None\n</code></pre> <p>Create PCB layer.</p> <p>Parameters:</p> Name Type Description Default <code>options</code> <code>LayerParams</code> <p>Configuration of layer.</p> required Source code in <code>src/pygerber/gerberx3/api/_layers.py</code> <pre><code>def __init__(self, options: LayerParams) -&gt; None:\n    \"\"\"Create PCB layer.\n\n    Parameters\n    ----------\n    options: LayerOptions\n        Configuration of layer.\n    \"\"\"\n    self.options = options\n\n    self.tokenizer = self._create_tokenizer()\n    self.backend = self._create_backend()\n    self.parser = self._create_parser()\n\n    self._rendering_result: Optional[RenderingResult] = None\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.Layer.render","title":"render","text":"<pre><code>render() -&gt; RenderingResult\n</code></pre> <p>Render layer image.</p> Source code in <code>src/pygerber/gerberx3/api/_layers.py</code> <pre><code>def render(self) -&gt; RenderingResult:\n    \"\"\"Render layer image.\"\"\"\n    stack = self.tokenizer.tokenize(self.options.get_source_code())\n    draw_commands = self.parser.parse(stack)\n\n    result_handle = draw_commands.draw()\n    properties = LayerProperties(\n        target_bounding_box=self.backend.drawing_target.bounding_box,\n        target_coordinate_origin=self.backend.drawing_target.coordinate_origin,\n        gerber_bounding_box=self.backend.bounding_box,\n        gerber_coordinate_origin=self.backend.coordinate_origin,\n    )\n\n    self._rendering_result = self._get_rendering_result_cls()(\n        result_handle=result_handle,\n        properties=properties,\n    )\n    return self._rendering_result\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.Layer.get_rendering_result","title":"get_rendering_result","text":"<pre><code>get_rendering_result() -&gt; RenderingResult\n</code></pre> <p>Return result of rendering Gerber file.</p> Source code in <code>src/pygerber/gerberx3/api/_layers.py</code> <pre><code>def get_rendering_result(self) -&gt; RenderingResult:\n    \"\"\"Return result of rendering Gerber file.\"\"\"\n    if self._rendering_result is None:\n        msg = \"Use `render()` method to create result first.\"\n        raise RenderingResultNotReadyError(msg)\n\n    return self._rendering_result\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.LayerParams","title":"LayerParams","text":"<p>             Bases: <code>BaseModel</code></p> <p>Parameters for Layer object.</p> <p><code>source_path</code>, <code>source_code</code> and <code>source_buffer</code> are mutually exclusive. When more than one of them is provided to constructor, MutuallyExclusiveViolationError will be raised.</p> Source code in <code>src/pygerber/gerberx3/api/_layers.py</code> <pre><code>class LayerParams(BaseModel):\n    \"\"\"Parameters for Layer object.\n\n    `source_path`, `source_code` and `source_buffer` are mutually exclusive.\n    When more than one of them is provided to constructor,\n    MutuallyExclusiveViolationError will be raised.\n    \"\"\"\n\n    model_config = ConfigDict(arbitrary_types_allowed=True, extra=\"forbid\")\n\n    source_path: Optional[Union[Path, str]] = None\n    \"\"\"Path to source file containing Gerber code. It will be automatically loaded\n    from local storage, when provided. Mutually exclusive with `source_code` and\n    `source_buffer`.\n    \"\"\"\n\n    source_code: Optional[Union[str, bytes]] = None\n    \"\"\"Gerber source code. Mutually exclusive with `source_path` and `source_buffer`.\"\"\"\n\n    source_buffer: Optional[Union[StringIO, BytesIO]] = None\n    \"\"\"Buffer containing Gerber source code. Buffer pointer should be at the\n    beginning of the buffer. Mutually exclusive with `source_path` and\n    `source_code`.\"\"\"\n\n    parser_error: Union[\n        Callable[[Exception, Parser, Token], None],\n        ParserOnErrorAction,\n    ] = ParserOnErrorAction.Raise\n    \"\"\"Callback function or rule describing how to treat errors during parsing.\"\"\"\n\n    encoding: str = \"utf-8\"\n    \"\"\"Encoding of code, used when loading from file, decoding `source_code`\n    provided as bytes and reading `source_buffer` provided as BytesIO.\"\"\"\n\n    draw_region_outlines: bool = False\n    \"\"\"When drawing regions, after filling region, draw also outline of region with\n    apertures used for region outlines. This behavior is not expected by KiCAD by\n    default but may be useful in some scenarios.\"\"\"\n\n    @model_validator(mode=\"after\")\n    def _load_source_code(self) -&gt; Self:\n        \"\"\"Load source code.\n\n        Raises\n        ------\n        MutuallyExclusiveViolationError\n            When more than one of mutually exclusive `source_path`, `source_code` and\n            `source_buffer` is provided to constructor.\n        \"\"\"\n        if self.source_path:\n            if self.source_code or self.source_buffer:\n                msg = \"'source_code' and 'source_buffer' provided at once.\"\n                raise MutuallyExclusiveViolationError(msg)\n\n            self.source_code = (\n                Path(self.source_path or \"source.grb\")\n                .expanduser()\n                .resolve()\n                .read_text(encoding=self.encoding)\n            )\n            return self\n\n        if self.source_code:\n            if self.source_path or self.source_buffer:\n                msg = \"'source_path' and 'source_buffer' provided at once.\"\n                raise MutuallyExclusiveViolationError(msg)\n\n            self.source_code = (\n                self.source_code\n                if isinstance(self.source_code, str)\n                else self.source_code.decode(self.encoding)\n            )\n            return self\n\n        if self.source_buffer:\n            if self.source_path or self.source_code:\n                msg = \"'source_path' and 'source_buffer' provided at once.\"\n                raise MutuallyExclusiveViolationError(msg)\n\n            source_code = self.source_buffer.read()\n            if isinstance(source_code, bytes):\n                self.source_code = source_code.decode(encoding=\"utf-8\")\n            else:\n                self.source_code = source_code\n\n        return self\n\n    def get_source_code(self) -&gt; str:\n        \"\"\"Return source code of layer.\"\"\"\n        if not isinstance(self.source_code, str):\n            msg = f\"Expected {str} got {type(self.source_code)}.\"\n            raise TypeError(msg)\n\n        return self.source_code\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.LayerParams.source_path","title":"source_path  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>source_path: Optional[Union[Path, str]] = None\n</code></pre> <p>Path to source file containing Gerber code. It will be automatically loaded from local storage, when provided. Mutually exclusive with <code>source_code</code> and <code>source_buffer</code>.</p>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.LayerParams.source_code","title":"source_code  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>source_code: Optional[Union[str, bytes]] = None\n</code></pre> <p>Gerber source code. Mutually exclusive with <code>source_path</code> and <code>source_buffer</code>.</p>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.LayerParams.source_buffer","title":"source_buffer  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>source_buffer: Optional[Union[StringIO, BytesIO]] = None\n</code></pre> <p>Buffer containing Gerber source code. Buffer pointer should be at the beginning of the buffer. Mutually exclusive with <code>source_path</code> and <code>source_code</code>.</p>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.LayerParams.parser_error","title":"parser_error  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>parser_error: Union[\n    Callable[[Exception, Parser, Token], None],\n    ParserOnErrorAction,\n] = Raise\n</code></pre> <p>Callback function or rule describing how to treat errors during parsing.</p>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.LayerParams.encoding","title":"encoding  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>encoding: str = 'utf-8'\n</code></pre> <p>Encoding of code, used when loading from file, decoding <code>source_code</code> provided as bytes and reading <code>source_buffer</code> provided as BytesIO.</p>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.LayerParams.draw_region_outlines","title":"draw_region_outlines  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>draw_region_outlines: bool = False\n</code></pre> <p>When drawing regions, after filling region, draw also outline of region with apertures used for region outlines. This behavior is not expected by KiCAD by default but may be useful in some scenarios.</p>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.LayerParams.get_source_code","title":"get_source_code","text":"<pre><code>get_source_code() -&gt; str\n</code></pre> <p>Return source code of layer.</p> Source code in <code>src/pygerber/gerberx3/api/_layers.py</code> <pre><code>def get_source_code(self) -&gt; str:\n    \"\"\"Return source code of layer.\"\"\"\n    if not isinstance(self.source_code, str):\n        msg = f\"Expected {str} got {type(self.source_code)}.\"\n        raise TypeError(msg)\n\n    return self.source_code\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.LayerProperties","title":"LayerProperties","text":"<p>Properties of layer retrieved from Gerber source code.</p> Source code in <code>src/pygerber/gerberx3/api/_layers.py</code> <pre><code>class LayerProperties:\n    \"\"\"Properties of layer retrieved from Gerber source code.\"\"\"\n\n    target_bounding_box: BoundingBox\n    \"\"\"Bounding box of rendering target. May differ from coordinates used in Gerber\n    file as it uses rendering target coordinate space.\"\"\"\n\n    target_coordinate_origin: Vector2D\n    \"\"\"Offset of origin of coordinate system used by rendering target. Bottom left\n    corner of coordinate space of rendering target.\"\"\"\n\n    gerber_bounding_box: BoundingBox\n    \"\"\"Bounding box of drawing area in Gerber file coordinate space.\"\"\"\n\n    gerber_coordinate_origin: Vector2D\n    \"\"\"Origin of coordinate space of Gerber file. Equivalent to bottom left corner of\n    `gerber_bounding_box`.\n\n    Can be useful to determine how to align multiple Gerber files by calculating\n    how their coordinate origins are positioned in relation to each other.\"\"\"\n\n    def __init__(\n        self,\n        target_bounding_box: BoundingBox,\n        target_coordinate_origin: Vector2D,\n        gerber_bounding_box: BoundingBox,\n        gerber_coordinate_origin: Vector2D,\n    ) -&gt; None:\n        \"\"\"Initialize layer properties.\"\"\"\n        self.target_bounding_box = target_bounding_box\n        self.target_coordinate_origin = target_coordinate_origin\n\n        self.gerber_bounding_box = gerber_bounding_box\n        self.gerber_coordinate_origin = gerber_coordinate_origin\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.LayerProperties.target_bounding_box","title":"target_bounding_box  <code>instance-attribute</code>","text":"<pre><code>target_bounding_box: BoundingBox = target_bounding_box\n</code></pre> <p>Bounding box of rendering target. May differ from coordinates used in Gerber file as it uses rendering target coordinate space.</p>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.LayerProperties.target_coordinate_origin","title":"target_coordinate_origin  <code>instance-attribute</code>","text":"<pre><code>target_coordinate_origin: Vector2D = (\n    target_coordinate_origin\n)\n</code></pre> <p>Offset of origin of coordinate system used by rendering target. Bottom left corner of coordinate space of rendering target.</p>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.LayerProperties.gerber_bounding_box","title":"gerber_bounding_box  <code>instance-attribute</code>","text":"<pre><code>gerber_bounding_box: BoundingBox = gerber_bounding_box\n</code></pre> <p>Bounding box of drawing area in Gerber file coordinate space.</p>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.LayerProperties.gerber_coordinate_origin","title":"gerber_coordinate_origin  <code>instance-attribute</code>","text":"<pre><code>gerber_coordinate_origin: Vector2D = (\n    gerber_coordinate_origin\n)\n</code></pre> <p>Origin of coordinate space of Gerber file. Equivalent to bottom left corner of <code>gerber_bounding_box</code>.</p> <p>Can be useful to determine how to align multiple Gerber files by calculating how their coordinate origins are positioned in relation to each other.</p>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.LayerProperties.__init__","title":"__init__","text":"<pre><code>__init__(\n    target_bounding_box: BoundingBox,\n    target_coordinate_origin: Vector2D,\n    gerber_bounding_box: BoundingBox,\n    gerber_coordinate_origin: Vector2D,\n) -&gt; None\n</code></pre> <p>Initialize layer properties.</p> Source code in <code>src/pygerber/gerberx3/api/_layers.py</code> <pre><code>def __init__(\n    self,\n    target_bounding_box: BoundingBox,\n    target_coordinate_origin: Vector2D,\n    gerber_bounding_box: BoundingBox,\n    gerber_coordinate_origin: Vector2D,\n) -&gt; None:\n    \"\"\"Initialize layer properties.\"\"\"\n    self.target_bounding_box = target_bounding_box\n    self.target_coordinate_origin = target_coordinate_origin\n\n    self.gerber_bounding_box = gerber_bounding_box\n    self.gerber_coordinate_origin = gerber_coordinate_origin\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.Rasterized2DLayer","title":"Rasterized2DLayer","text":"<p>             Bases: <code>Layer</code></p> <p>Representation of Gerber X3 rasterized 2D image layer.</p> <p>Rasterized images can be saved in any image format supported by Pillow library. For full list of supported formats please refer to Pillow documentation.</p> Source code in <code>src/pygerber/gerberx3/api/_layers.py</code> <pre><code>class Rasterized2DLayer(Layer):\n    \"\"\"Representation of Gerber X3 rasterized 2D image layer.\n\n    Rasterized images can be saved in any image format supported by Pillow library.\n    For full list of supported formats please refer to\n    [Pillow documentation](https://pillow.readthedocs.io/en/stable/handbook/image-file-formats.html).\n    \"\"\"\n\n    options: Rasterized2DLayerParams\n\n    def __init__(self, options: Rasterized2DLayerParams) -&gt; None:\n        \"\"\"Initialize Layer object.\"\"\"\n        if not isinstance(options, Rasterized2DLayerParams):\n            msg = f\"Expected {Rasterized2DLayerParams} got {type(options)}.\"  # type: ignore[unreachable]\n            raise TypeError(msg)\n        super().__init__(options)\n\n    def _create_backend(self) -&gt; Backend:\n        return Rasterized2DBackend(\n            Rasterized2DBackendOptions(\n                dpi=self.options.dpi,\n                color_scheme=self.options.colors,\n                dump_apertures=self.options.debug_dump_apertures,\n                include_debug_padding=self.options.debug_include_extra_padding,\n                include_bounding_boxes=self.options.debug_include_bounding_boxes,\n                draw_region_outlines=self.options.draw_region_outlines,\n            ),\n        )\n\n    def _get_rendering_result_cls(self) -&gt; type[RenderingResult]:\n        return Rasterized2DRenderingResult\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.Rasterized2DLayer.__init__","title":"__init__","text":"<pre><code>__init__(options: Rasterized2DLayerParams) -&gt; None\n</code></pre> <p>Initialize Layer object.</p> Source code in <code>src/pygerber/gerberx3/api/_layers.py</code> <pre><code>def __init__(self, options: Rasterized2DLayerParams) -&gt; None:\n    \"\"\"Initialize Layer object.\"\"\"\n    if not isinstance(options, Rasterized2DLayerParams):\n        msg = f\"Expected {Rasterized2DLayerParams} got {type(options)}.\"  # type: ignore[unreachable]\n        raise TypeError(msg)\n    super().__init__(options)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.Rasterized2DLayerParams","title":"Rasterized2DLayerParams","text":"<p>             Bases: <code>LayerParams</code></p> <p>Parameters for Layer with 2D rendering.</p> <p><code>source_path</code>, <code>source_code</code> and <code>source_buffer</code> are mutually exclusive. When more than one of them is provided to constructor, MutuallyExclusiveViolationError will be raised.</p> Source code in <code>src/pygerber/gerberx3/api/_layers.py</code> <pre><code>class Rasterized2DLayerParams(LayerParams):\n    \"\"\"Parameters for Layer with 2D rendering.\n\n    `source_path`, `source_code` and `source_buffer` are mutually exclusive.\n    When more than one of them is provided to constructor,\n    MutuallyExclusiveViolationError will be raised.\n    \"\"\"\n\n    colors: ColorScheme\n    \"\"\"Colors to use for rendering of image.\"\"\"\n\n    dpi: int = 1000\n    \"\"\"DPI of output image.\"\"\"\n\n    debug_dump_apertures: Optional[Path] = None\n    \"\"\"Debug option - dump aperture images to files in given directory.\"\"\"\n\n    debug_include_extra_padding: bool = False\n    \"\"\"Debug option - include large extra padding on all rendering targets to simplify\n    tracking of mispositioned draw commands.\"\"\"\n\n    debug_include_bounding_boxes: bool = False\n    \"\"\"Debug option - include bounding boxes as square outlines on drawing targets\n    to simplify tracking of miscalculated bounding boxes.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.Rasterized2DLayerParams.colors","title":"colors  <code>instance-attribute</code>","text":"<pre><code>colors: ColorScheme\n</code></pre> <p>Colors to use for rendering of image.</p>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.Rasterized2DLayerParams.dpi","title":"dpi  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dpi: int = 1000\n</code></pre> <p>DPI of output image.</p>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.Rasterized2DLayerParams.debug_dump_apertures","title":"debug_dump_apertures  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>debug_dump_apertures: Optional[Path] = None\n</code></pre> <p>Debug option - dump aperture images to files in given directory.</p>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.Rasterized2DLayerParams.debug_include_extra_padding","title":"debug_include_extra_padding  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>debug_include_extra_padding: bool = False\n</code></pre> <p>Debug option - include large extra padding on all rendering targets to simplify tracking of mispositioned draw commands.</p>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.Rasterized2DLayerParams.debug_include_bounding_boxes","title":"debug_include_bounding_boxes  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>debug_include_bounding_boxes: bool = False\n</code></pre> <p>Debug option - include bounding boxes as square outlines on drawing targets to simplify tracking of miscalculated bounding boxes.</p>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.RenderingResult","title":"RenderingResult","text":"<p>Result of rendering of layer.</p> Source code in <code>src/pygerber/gerberx3/api/_layers.py</code> <pre><code>class RenderingResult:\n    \"\"\"Result of rendering of layer.\"\"\"\n\n    def __init__(\n        self,\n        properties: LayerProperties,\n        result_handle: ResultHandle,\n    ) -&gt; None:\n        \"\"\"Initialize rendering result object.\"\"\"\n        self._properties = properties\n        self._result_handle = result_handle\n\n    def save(\n        self,\n        dest: Path | str | BytesIO,\n        **options: Any,\n    ) -&gt; None:\n        \"\"\"Save result to specified file or buffer.\n\n        Parameters\n        ----------\n        dest : Path | str | BytesIO\n            Write target.\n        **options: Any\n            Extra parameters which will be passed to saving implementation.\n            When dest is BytesIO or alike, `format` option must be specified.\n            For Rasterized2D rendering options see [Pillow documentation](https://pillow.readthedocs.io/en/stable/reference/Image.html#PIL.Image.Image.save).\n        \"\"\"\n        self._result_handle.save(dest, **options)\n\n    def get_properties(self) -&gt; LayerProperties:\n        \"\"\"Get properties of layer.\"\"\"\n        return self._properties\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.RenderingResult.__init__","title":"__init__","text":"<pre><code>__init__(\n    properties: LayerProperties, result_handle: ResultHandle\n) -&gt; None\n</code></pre> <p>Initialize rendering result object.</p> Source code in <code>src/pygerber/gerberx3/api/_layers.py</code> <pre><code>def __init__(\n    self,\n    properties: LayerProperties,\n    result_handle: ResultHandle,\n) -&gt; None:\n    \"\"\"Initialize rendering result object.\"\"\"\n    self._properties = properties\n    self._result_handle = result_handle\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.RenderingResult.save","title":"save","text":"<pre><code>save(dest: Path | str | BytesIO, **options: Any) -&gt; None\n</code></pre> <p>Save result to specified file or buffer.</p> <p>Parameters:</p> Name Type Description Default <code>dest</code> <code>Path | str | BytesIO</code> <p>Write target.</p> required <code>**options</code> <code>Any</code> <p>Extra parameters which will be passed to saving implementation. When dest is BytesIO or alike, <code>format</code> option must be specified. For Rasterized2D rendering options see Pillow documentation.</p> <code>{}</code> Source code in <code>src/pygerber/gerberx3/api/_layers.py</code> <pre><code>def save(\n    self,\n    dest: Path | str | BytesIO,\n    **options: Any,\n) -&gt; None:\n    \"\"\"Save result to specified file or buffer.\n\n    Parameters\n    ----------\n    dest : Path | str | BytesIO\n        Write target.\n    **options: Any\n        Extra parameters which will be passed to saving implementation.\n        When dest is BytesIO or alike, `format` option must be specified.\n        For Rasterized2D rendering options see [Pillow documentation](https://pillow.readthedocs.io/en/stable/reference/Image.html#PIL.Image.Image.save).\n    \"\"\"\n    self._result_handle.save(dest, **options)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.RenderingResult.get_properties","title":"get_properties","text":"<pre><code>get_properties() -&gt; LayerProperties\n</code></pre> <p>Get properties of layer.</p> Source code in <code>src/pygerber/gerberx3/api/_layers.py</code> <pre><code>def get_properties(self) -&gt; LayerProperties:\n    \"\"\"Get properties of layer.\"\"\"\n    return self._properties\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.ApertureNotDefinedError","title":"ApertureNotDefinedError","text":"<p>             Bases: <code>ParserError</code></p> <p>Raised when undefined aperture is selected.</p> Source code in <code>src/pygerber/gerberx3/parser/errors.py</code> <pre><code>class ApertureNotDefinedError(ParserError):\n    \"\"\"Raised when undefined aperture is selected.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.ApertureNotSelectedError","title":"ApertureNotSelectedError","text":"<p>             Bases: <code>ParserError</code></p> <p>Raised when attempting to use aperture without selecting it first.</p> Source code in <code>src/pygerber/gerberx3/parser/errors.py</code> <pre><code>class ApertureNotSelectedError(ParserError):\n    \"\"\"Raised when attempting to use aperture without selecting it first.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.CoordinateFormatNotSetError","title":"CoordinateFormatNotSetError","text":"<p>             Bases: <code>ParserError</code></p> <p>Raised when coordinate parser is requested before coordinate format was set.</p> Source code in <code>src/pygerber/gerberx3/parser/errors.py</code> <pre><code>class CoordinateFormatNotSetError(ParserError):\n    \"\"\"Raised when coordinate parser is requested before coordinate format was set.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.ExitParsingProcessInterrupt","title":"ExitParsingProcessInterrupt","text":"<p>             Bases: <code>Exception</code></p> <p>Raised to stop parsing.</p> Source code in <code>src/pygerber/gerberx3/parser/errors.py</code> <pre><code>class ExitParsingProcessInterrupt(Exception):  # noqa: N818\n    \"\"\"Raised to stop parsing.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.IncrementalCoordinatesNotSupportedError","title":"IncrementalCoordinatesNotSupportedError","text":"<p>             Bases: <code>ParserError</code></p> <p>Raised when incremental coordinates are selected. (Spec. 8.2.1.2).</p> Source code in <code>src/pygerber/gerberx3/parser/errors.py</code> <pre><code>class IncrementalCoordinatesNotSupportedError(ParserError):\n    \"\"\"Raised when incremental coordinates are selected. (Spec. 8.2.1.2).\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.InvalidCoordinateLengthError","title":"InvalidCoordinateLengthError","text":"<p>             Bases: <code>ParserError</code></p> <p>Raised when coordinate string is too long.</p> Source code in <code>src/pygerber/gerberx3/parser/errors.py</code> <pre><code>class InvalidCoordinateLengthError(ParserError):\n    \"\"\"Raised when coordinate string is too long.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.OnUpdateDrawingStateError","title":"OnUpdateDrawingStateError","text":"<p>             Bases: <code>ParserError</code></p> <p>Raised when parser encounters fatal failure from non-parser specific exception during call to .update_drawing_state() call.</p> Source code in <code>src/pygerber/gerberx3/parser/errors.py</code> <pre><code>class OnUpdateDrawingStateError(ParserError):\n    \"\"\"Raised when parser encounters fatal failure from non-parser specific\n    exception during call to .update_drawing_state() call.\n    \"\"\"\n\n    def __init__(self, token: Token, *args: object) -&gt; None:\n        super().__init__(*args)\n        self.token = token\n\n    def __str__(self) -&gt; str:\n        return f\"{self.token} {self.token.get_token_position()}\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.ParserError","title":"ParserError","text":"<p>             Bases: <code>ValueError</code></p> <p>Base class for parser errors.</p> <p>Exceptions derived from this exception are exclusively raised in PyGerber's Gerber X3 Parser. This exception can be used in <code>try: ... except ParserError: ...</code> block to catch all exceptions raised by Parser while allowing other exceptions to interrupt execution.</p> Source code in <code>src/pygerber/gerberx3/parser/errors.py</code> <pre><code>class ParserError(ValueError):\n    \"\"\"Base class for parser errors.\n\n    Exceptions derived from this exception are exclusively raised in PyGerber's Gerber\n    X3 Parser. This exception can be used in\n    `#!python try: ... except ParserError: ...` block to catch all exceptions\n    raised by Parser while allowing other exceptions to interrupt execution.\n    \"\"\"\n\n    def get_message(self) -&gt; str:\n        \"\"\"Get parser error help message.\"\"\"\n        return f\"{self.__class__.__qualname__}: {self.__doc__}\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.ParserError.get_message","title":"get_message","text":"<pre><code>get_message() -&gt; str\n</code></pre> <p>Get parser error help message.</p> Source code in <code>src/pygerber/gerberx3/parser/errors.py</code> <pre><code>def get_message(self) -&gt; str:\n    \"\"\"Get parser error help message.\"\"\"\n    return f\"{self.__class__.__qualname__}: {self.__doc__}\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.ParserFatalError","title":"ParserFatalError","text":"<p>             Bases: <code>ParserError</code></p> <p>Raised when parser encounters fatal failure from non-parser specific exception.</p> Source code in <code>src/pygerber/gerberx3/parser/errors.py</code> <pre><code>class ParserFatalError(ParserError):\n    \"\"\"Raised when parser encounters fatal failure from non-parser specific\n    exception.\n    \"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.UnitNotSetError","title":"UnitNotSetError","text":"<p>             Bases: <code>ParserError</code></p> <p>Raised when operation which requires units to be set is executed before units are set.</p> Source code in <code>src/pygerber/gerberx3/parser/errors.py</code> <pre><code>class UnitNotSetError(ParserError):\n    \"\"\"Raised when operation which requires units to be set is executed before units\n    are set.\n    \"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.UnsupportedCoordinateTypeError","title":"UnsupportedCoordinateTypeError","text":"<p>             Bases: <code>ParserError</code></p> <p>Raised for unsupported coordinate types.</p> Source code in <code>src/pygerber/gerberx3/parser/errors.py</code> <pre><code>class UnsupportedCoordinateTypeError(ParserError):\n    \"\"\"Raised for unsupported coordinate types.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.ZeroOmissionNotSupportedError","title":"ZeroOmissionNotSupportedError","text":"<p>             Bases: <code>ParserError</code></p> <p>Raised when incremental coordinates are selected. (Spec. 8.2.1.2).</p> Source code in <code>src/pygerber/gerberx3/parser/errors.py</code> <pre><code>class ZeroOmissionNotSupportedError(ParserError):\n    \"\"\"Raised when incremental coordinates are selected. (Spec. 8.2.1.2).\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.ParserOnErrorAction","title":"ParserOnErrorAction","text":"<p>             Bases: <code>Enum</code></p> <p>Possible error actions.</p> Source code in <code>src/pygerber/gerberx3/parser/parser.py</code> <pre><code>class ParserOnErrorAction(Enum):\n    \"\"\"Possible error actions.\"\"\"\n\n    Ignore = \"ignore\"\n    \"\"\"Ignore parser errors. Errors which occurred will not be signaled. May yield\n    unexpected results for broken files, with missing draw commands or even more\n    significant errors.\"\"\"\n\n    Warn = \"warn\"\n    \"\"\"Warn on parser error. Parser will log warning message about what went wrong.\n    Best for supporting wide range of files without silently ignoring errors in code.\"\"\"\n\n    Raise = \"raise\"\n    \"\"\"Raise exception whenever parser encounters error. Will completely break out of\n    parsing process, making it impossible to render slightly malformed files.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.ParserOnErrorAction.Ignore","title":"Ignore  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Ignore = 'ignore'\n</code></pre> <p>Ignore parser errors. Errors which occurred will not be signaled. May yield unexpected results for broken files, with missing draw commands or even more significant errors.</p>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.ParserOnErrorAction.Warn","title":"Warn  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Warn = 'warn'\n</code></pre> <p>Warn on parser error. Parser will log warning message about what went wrong. Best for supporting wide range of files without silently ignoring errors in code.</p>"},{"location":"reference/pygerber/gerberx3/api/__init__.html#pygerber.gerberx3.api.ParserOnErrorAction.Raise","title":"Raise  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Raise = 'raise'\n</code></pre> <p>Raise exception whenever parser encounters error. Will completely break out of parsing process, making it impossible to render slightly malformed files.</p>"},{"location":"reference/pygerber/gerberx3/api/_errors.html","title":"_errors","text":""},{"location":"reference/pygerber/gerberx3/api/_errors.html#pygerber.gerberx3.api._errors","title":"_errors","text":"<p>Errors which may be called by API layer.</p>"},{"location":"reference/pygerber/gerberx3/api/_errors.html#pygerber.gerberx3.api._errors.GerberX3APIError","title":"GerberX3APIError","text":"<p>             Bases: <code>Exception</code></p> <p>Base class for API errors.</p> <p>Exceptions derived from this exception are exclusively raised in PyGerber's Gerber X3 high level API. This exception can be used in <code>try: ... except GerberX3APIError: ...</code> block to catch all exceptions raised by this API while allowing other exceptions to interrupt execution.</p> Source code in <code>src/pygerber/gerberx3/api/_errors.py</code> <pre><code>class GerberX3APIError(Exception):\n    \"\"\"Base class for API errors.\n\n    Exceptions derived from this exception are exclusively raised in PyGerber's Gerber\n    X3 high level API. This exception can be used in\n    `#!python try: ... except GerberX3APIError: ...` block to catch all exceptions\n    raised by this API while allowing other exceptions to interrupt execution.\n    \"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/_errors.html#pygerber.gerberx3.api._errors.RenderingResultNotReadyError","title":"RenderingResultNotReadyError","text":"<p>             Bases: <code>GerberX3APIError</code></p> <p>Raised when RenderingResult is requested before it was rendered.</p> <p><code>Layer.get_rendering_result()</code> method can only be called after <code>Layer.render()</code>. Breaking this rule will cause this exception to be raised.</p> Source code in <code>src/pygerber/gerberx3/api/_errors.py</code> <pre><code>class RenderingResultNotReadyError(GerberX3APIError):\n    \"\"\"Raised when RenderingResult is requested before it was rendered.\n\n    `Layer.get_rendering_result()` method can only be called after `Layer.render()`.\n    Breaking this rule will cause this exception to be raised.\n    \"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/_errors.html#pygerber.gerberx3.api._errors.MutuallyExclusiveViolationError","title":"MutuallyExclusiveViolationError","text":"<p>             Bases: <code>GerberX3APIError</code></p> <p>Raised when two or more of mutually exclusive parameters are provided.</p> <p><code>LayerParams</code> class accepts three mutually exclusive fields, <code>source_path</code>, <code>source_code</code> and <code>source_buffer</code> for providing source code to <code>Layer</code>. When more than one of those options is set, this exception will be raised.</p> Source code in <code>src/pygerber/gerberx3/api/_errors.py</code> <pre><code>class MutuallyExclusiveViolationError(GerberX3APIError):\n    \"\"\"Raised when two or more of mutually exclusive parameters are provided.\n\n    `LayerParams` class accepts three mutually exclusive fields, `source_path`,\n    `source_code` and `source_buffer` for providing source code to `Layer`.\n    When more than one of those options is set, this exception will be raised.\n    \"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/_layers.html","title":"_layers","text":""},{"location":"reference/pygerber/gerberx3/api/_layers.html#pygerber.gerberx3.api._layers","title":"_layers","text":"<p>High level API for rendering multi layer gerber projects.</p>"},{"location":"reference/pygerber/gerberx3/api/_layers.html#pygerber.gerberx3.api._layers.LayerParams","title":"LayerParams","text":"<p>             Bases: <code>BaseModel</code></p> <p>Parameters for Layer object.</p> <p><code>source_path</code>, <code>source_code</code> and <code>source_buffer</code> are mutually exclusive. When more than one of them is provided to constructor, MutuallyExclusiveViolationError will be raised.</p> Source code in <code>src/pygerber/gerberx3/api/_layers.py</code> <pre><code>class LayerParams(BaseModel):\n    \"\"\"Parameters for Layer object.\n\n    `source_path`, `source_code` and `source_buffer` are mutually exclusive.\n    When more than one of them is provided to constructor,\n    MutuallyExclusiveViolationError will be raised.\n    \"\"\"\n\n    model_config = ConfigDict(arbitrary_types_allowed=True, extra=\"forbid\")\n\n    source_path: Optional[Union[Path, str]] = None\n    \"\"\"Path to source file containing Gerber code. It will be automatically loaded\n    from local storage, when provided. Mutually exclusive with `source_code` and\n    `source_buffer`.\n    \"\"\"\n\n    source_code: Optional[Union[str, bytes]] = None\n    \"\"\"Gerber source code. Mutually exclusive with `source_path` and `source_buffer`.\"\"\"\n\n    source_buffer: Optional[Union[StringIO, BytesIO]] = None\n    \"\"\"Buffer containing Gerber source code. Buffer pointer should be at the\n    beginning of the buffer. Mutually exclusive with `source_path` and\n    `source_code`.\"\"\"\n\n    parser_error: Union[\n        Callable[[Exception, Parser, Token], None],\n        ParserOnErrorAction,\n    ] = ParserOnErrorAction.Raise\n    \"\"\"Callback function or rule describing how to treat errors during parsing.\"\"\"\n\n    encoding: str = \"utf-8\"\n    \"\"\"Encoding of code, used when loading from file, decoding `source_code`\n    provided as bytes and reading `source_buffer` provided as BytesIO.\"\"\"\n\n    draw_region_outlines: bool = False\n    \"\"\"When drawing regions, after filling region, draw also outline of region with\n    apertures used for region outlines. This behavior is not expected by KiCAD by\n    default but may be useful in some scenarios.\"\"\"\n\n    @model_validator(mode=\"after\")\n    def _load_source_code(self) -&gt; Self:\n        \"\"\"Load source code.\n\n        Raises\n        ------\n        MutuallyExclusiveViolationError\n            When more than one of mutually exclusive `source_path`, `source_code` and\n            `source_buffer` is provided to constructor.\n        \"\"\"\n        if self.source_path:\n            if self.source_code or self.source_buffer:\n                msg = \"'source_code' and 'source_buffer' provided at once.\"\n                raise MutuallyExclusiveViolationError(msg)\n\n            self.source_code = (\n                Path(self.source_path or \"source.grb\")\n                .expanduser()\n                .resolve()\n                .read_text(encoding=self.encoding)\n            )\n            return self\n\n        if self.source_code:\n            if self.source_path or self.source_buffer:\n                msg = \"'source_path' and 'source_buffer' provided at once.\"\n                raise MutuallyExclusiveViolationError(msg)\n\n            self.source_code = (\n                self.source_code\n                if isinstance(self.source_code, str)\n                else self.source_code.decode(self.encoding)\n            )\n            return self\n\n        if self.source_buffer:\n            if self.source_path or self.source_code:\n                msg = \"'source_path' and 'source_buffer' provided at once.\"\n                raise MutuallyExclusiveViolationError(msg)\n\n            source_code = self.source_buffer.read()\n            if isinstance(source_code, bytes):\n                self.source_code = source_code.decode(encoding=\"utf-8\")\n            else:\n                self.source_code = source_code\n\n        return self\n\n    def get_source_code(self) -&gt; str:\n        \"\"\"Return source code of layer.\"\"\"\n        if not isinstance(self.source_code, str):\n            msg = f\"Expected {str} got {type(self.source_code)}.\"\n            raise TypeError(msg)\n\n        return self.source_code\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/_layers.html#pygerber.gerberx3.api._layers.LayerParams.source_path","title":"source_path  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>source_path: Optional[Union[Path, str]] = None\n</code></pre> <p>Path to source file containing Gerber code. It will be automatically loaded from local storage, when provided. Mutually exclusive with <code>source_code</code> and <code>source_buffer</code>.</p>"},{"location":"reference/pygerber/gerberx3/api/_layers.html#pygerber.gerberx3.api._layers.LayerParams.source_code","title":"source_code  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>source_code: Optional[Union[str, bytes]] = None\n</code></pre> <p>Gerber source code. Mutually exclusive with <code>source_path</code> and <code>source_buffer</code>.</p>"},{"location":"reference/pygerber/gerberx3/api/_layers.html#pygerber.gerberx3.api._layers.LayerParams.source_buffer","title":"source_buffer  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>source_buffer: Optional[Union[StringIO, BytesIO]] = None\n</code></pre> <p>Buffer containing Gerber source code. Buffer pointer should be at the beginning of the buffer. Mutually exclusive with <code>source_path</code> and <code>source_code</code>.</p>"},{"location":"reference/pygerber/gerberx3/api/_layers.html#pygerber.gerberx3.api._layers.LayerParams.parser_error","title":"parser_error  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>parser_error: Union[\n    Callable[[Exception, Parser, Token], None],\n    ParserOnErrorAction,\n] = Raise\n</code></pre> <p>Callback function or rule describing how to treat errors during parsing.</p>"},{"location":"reference/pygerber/gerberx3/api/_layers.html#pygerber.gerberx3.api._layers.LayerParams.encoding","title":"encoding  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>encoding: str = 'utf-8'\n</code></pre> <p>Encoding of code, used when loading from file, decoding <code>source_code</code> provided as bytes and reading <code>source_buffer</code> provided as BytesIO.</p>"},{"location":"reference/pygerber/gerberx3/api/_layers.html#pygerber.gerberx3.api._layers.LayerParams.draw_region_outlines","title":"draw_region_outlines  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>draw_region_outlines: bool = False\n</code></pre> <p>When drawing regions, after filling region, draw also outline of region with apertures used for region outlines. This behavior is not expected by KiCAD by default but may be useful in some scenarios.</p>"},{"location":"reference/pygerber/gerberx3/api/_layers.html#pygerber.gerberx3.api._layers.LayerParams.get_source_code","title":"get_source_code","text":"<pre><code>get_source_code() -&gt; str\n</code></pre> <p>Return source code of layer.</p> Source code in <code>src/pygerber/gerberx3/api/_layers.py</code> <pre><code>def get_source_code(self) -&gt; str:\n    \"\"\"Return source code of layer.\"\"\"\n    if not isinstance(self.source_code, str):\n        msg = f\"Expected {str} got {type(self.source_code)}.\"\n        raise TypeError(msg)\n\n    return self.source_code\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/_layers.html#pygerber.gerberx3.api._layers.Layer","title":"Layer","text":"<p>Representation of Gerber X3 image layer.</p> <p>This is only abstract base class, please use one of its subclasses with rendering system guarantees.</p> Source code in <code>src/pygerber/gerberx3/api/_layers.py</code> <pre><code>class Layer:\n    \"\"\"Representation of Gerber X3 image layer.\n\n    This is only abstract base class, please use one of its subclasses with rendering\n    system guarantees.\n    \"\"\"\n\n    def __init__(self, options: LayerParams) -&gt; None:\n        \"\"\"Create PCB layer.\n\n        Parameters\n        ----------\n        options: LayerOptions\n            Configuration of layer.\n        \"\"\"\n        self.options = options\n\n        self.tokenizer = self._create_tokenizer()\n        self.backend = self._create_backend()\n        self.parser = self._create_parser()\n\n        self._rendering_result: Optional[RenderingResult] = None\n\n    def _create_tokenizer(self) -&gt; Tokenizer:\n        return Tokenizer()\n\n    @abstractmethod\n    def _create_backend(self) -&gt; Backend:\n        pass\n\n    def _create_parser(self) -&gt; Parser:\n        return Parser(\n            ParserOptions(\n                backend=self.backend,\n                on_update_drawing_state_error=self.options.parser_error,\n            ),\n        )\n\n    def render(self) -&gt; RenderingResult:\n        \"\"\"Render layer image.\"\"\"\n        stack = self.tokenizer.tokenize(self.options.get_source_code())\n        draw_commands = self.parser.parse(stack)\n\n        result_handle = draw_commands.draw()\n        properties = LayerProperties(\n            target_bounding_box=self.backend.drawing_target.bounding_box,\n            target_coordinate_origin=self.backend.drawing_target.coordinate_origin,\n            gerber_bounding_box=self.backend.bounding_box,\n            gerber_coordinate_origin=self.backend.coordinate_origin,\n        )\n\n        self._rendering_result = self._get_rendering_result_cls()(\n            result_handle=result_handle,\n            properties=properties,\n        )\n        return self._rendering_result\n\n    def _get_rendering_result_cls(self) -&gt; type[RenderingResult]:\n        return RenderingResult\n\n    def get_rendering_result(self) -&gt; RenderingResult:\n        \"\"\"Return result of rendering Gerber file.\"\"\"\n        if self._rendering_result is None:\n            msg = \"Use `render()` method to create result first.\"\n            raise RenderingResultNotReadyError(msg)\n\n        return self._rendering_result\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/_layers.html#pygerber.gerberx3.api._layers.Layer.__init__","title":"__init__","text":"<pre><code>__init__(options: LayerParams) -&gt; None\n</code></pre> <p>Create PCB layer.</p> <p>Parameters:</p> Name Type Description Default <code>options</code> <code>LayerParams</code> <p>Configuration of layer.</p> required Source code in <code>src/pygerber/gerberx3/api/_layers.py</code> <pre><code>def __init__(self, options: LayerParams) -&gt; None:\n    \"\"\"Create PCB layer.\n\n    Parameters\n    ----------\n    options: LayerOptions\n        Configuration of layer.\n    \"\"\"\n    self.options = options\n\n    self.tokenizer = self._create_tokenizer()\n    self.backend = self._create_backend()\n    self.parser = self._create_parser()\n\n    self._rendering_result: Optional[RenderingResult] = None\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/_layers.html#pygerber.gerberx3.api._layers.Layer.render","title":"render","text":"<pre><code>render() -&gt; RenderingResult\n</code></pre> <p>Render layer image.</p> Source code in <code>src/pygerber/gerberx3/api/_layers.py</code> <pre><code>def render(self) -&gt; RenderingResult:\n    \"\"\"Render layer image.\"\"\"\n    stack = self.tokenizer.tokenize(self.options.get_source_code())\n    draw_commands = self.parser.parse(stack)\n\n    result_handle = draw_commands.draw()\n    properties = LayerProperties(\n        target_bounding_box=self.backend.drawing_target.bounding_box,\n        target_coordinate_origin=self.backend.drawing_target.coordinate_origin,\n        gerber_bounding_box=self.backend.bounding_box,\n        gerber_coordinate_origin=self.backend.coordinate_origin,\n    )\n\n    self._rendering_result = self._get_rendering_result_cls()(\n        result_handle=result_handle,\n        properties=properties,\n    )\n    return self._rendering_result\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/_layers.html#pygerber.gerberx3.api._layers.Layer.get_rendering_result","title":"get_rendering_result","text":"<pre><code>get_rendering_result() -&gt; RenderingResult\n</code></pre> <p>Return result of rendering Gerber file.</p> Source code in <code>src/pygerber/gerberx3/api/_layers.py</code> <pre><code>def get_rendering_result(self) -&gt; RenderingResult:\n    \"\"\"Return result of rendering Gerber file.\"\"\"\n    if self._rendering_result is None:\n        msg = \"Use `render()` method to create result first.\"\n        raise RenderingResultNotReadyError(msg)\n\n    return self._rendering_result\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/_layers.html#pygerber.gerberx3.api._layers.LayerProperties","title":"LayerProperties","text":"<p>Properties of layer retrieved from Gerber source code.</p> Source code in <code>src/pygerber/gerberx3/api/_layers.py</code> <pre><code>class LayerProperties:\n    \"\"\"Properties of layer retrieved from Gerber source code.\"\"\"\n\n    target_bounding_box: BoundingBox\n    \"\"\"Bounding box of rendering target. May differ from coordinates used in Gerber\n    file as it uses rendering target coordinate space.\"\"\"\n\n    target_coordinate_origin: Vector2D\n    \"\"\"Offset of origin of coordinate system used by rendering target. Bottom left\n    corner of coordinate space of rendering target.\"\"\"\n\n    gerber_bounding_box: BoundingBox\n    \"\"\"Bounding box of drawing area in Gerber file coordinate space.\"\"\"\n\n    gerber_coordinate_origin: Vector2D\n    \"\"\"Origin of coordinate space of Gerber file. Equivalent to bottom left corner of\n    `gerber_bounding_box`.\n\n    Can be useful to determine how to align multiple Gerber files by calculating\n    how their coordinate origins are positioned in relation to each other.\"\"\"\n\n    def __init__(\n        self,\n        target_bounding_box: BoundingBox,\n        target_coordinate_origin: Vector2D,\n        gerber_bounding_box: BoundingBox,\n        gerber_coordinate_origin: Vector2D,\n    ) -&gt; None:\n        \"\"\"Initialize layer properties.\"\"\"\n        self.target_bounding_box = target_bounding_box\n        self.target_coordinate_origin = target_coordinate_origin\n\n        self.gerber_bounding_box = gerber_bounding_box\n        self.gerber_coordinate_origin = gerber_coordinate_origin\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/_layers.html#pygerber.gerberx3.api._layers.LayerProperties.target_bounding_box","title":"target_bounding_box  <code>instance-attribute</code>","text":"<pre><code>target_bounding_box: BoundingBox = target_bounding_box\n</code></pre> <p>Bounding box of rendering target. May differ from coordinates used in Gerber file as it uses rendering target coordinate space.</p>"},{"location":"reference/pygerber/gerberx3/api/_layers.html#pygerber.gerberx3.api._layers.LayerProperties.target_coordinate_origin","title":"target_coordinate_origin  <code>instance-attribute</code>","text":"<pre><code>target_coordinate_origin: Vector2D = (\n    target_coordinate_origin\n)\n</code></pre> <p>Offset of origin of coordinate system used by rendering target. Bottom left corner of coordinate space of rendering target.</p>"},{"location":"reference/pygerber/gerberx3/api/_layers.html#pygerber.gerberx3.api._layers.LayerProperties.gerber_bounding_box","title":"gerber_bounding_box  <code>instance-attribute</code>","text":"<pre><code>gerber_bounding_box: BoundingBox = gerber_bounding_box\n</code></pre> <p>Bounding box of drawing area in Gerber file coordinate space.</p>"},{"location":"reference/pygerber/gerberx3/api/_layers.html#pygerber.gerberx3.api._layers.LayerProperties.gerber_coordinate_origin","title":"gerber_coordinate_origin  <code>instance-attribute</code>","text":"<pre><code>gerber_coordinate_origin: Vector2D = (\n    gerber_coordinate_origin\n)\n</code></pre> <p>Origin of coordinate space of Gerber file. Equivalent to bottom left corner of <code>gerber_bounding_box</code>.</p> <p>Can be useful to determine how to align multiple Gerber files by calculating how their coordinate origins are positioned in relation to each other.</p>"},{"location":"reference/pygerber/gerberx3/api/_layers.html#pygerber.gerberx3.api._layers.LayerProperties.__init__","title":"__init__","text":"<pre><code>__init__(\n    target_bounding_box: BoundingBox,\n    target_coordinate_origin: Vector2D,\n    gerber_bounding_box: BoundingBox,\n    gerber_coordinate_origin: Vector2D,\n) -&gt; None\n</code></pre> <p>Initialize layer properties.</p> Source code in <code>src/pygerber/gerberx3/api/_layers.py</code> <pre><code>def __init__(\n    self,\n    target_bounding_box: BoundingBox,\n    target_coordinate_origin: Vector2D,\n    gerber_bounding_box: BoundingBox,\n    gerber_coordinate_origin: Vector2D,\n) -&gt; None:\n    \"\"\"Initialize layer properties.\"\"\"\n    self.target_bounding_box = target_bounding_box\n    self.target_coordinate_origin = target_coordinate_origin\n\n    self.gerber_bounding_box = gerber_bounding_box\n    self.gerber_coordinate_origin = gerber_coordinate_origin\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/_layers.html#pygerber.gerberx3.api._layers.RenderingResult","title":"RenderingResult","text":"<p>Result of rendering of layer.</p> Source code in <code>src/pygerber/gerberx3/api/_layers.py</code> <pre><code>class RenderingResult:\n    \"\"\"Result of rendering of layer.\"\"\"\n\n    def __init__(\n        self,\n        properties: LayerProperties,\n        result_handle: ResultHandle,\n    ) -&gt; None:\n        \"\"\"Initialize rendering result object.\"\"\"\n        self._properties = properties\n        self._result_handle = result_handle\n\n    def save(\n        self,\n        dest: Path | str | BytesIO,\n        **options: Any,\n    ) -&gt; None:\n        \"\"\"Save result to specified file or buffer.\n\n        Parameters\n        ----------\n        dest : Path | str | BytesIO\n            Write target.\n        **options: Any\n            Extra parameters which will be passed to saving implementation.\n            When dest is BytesIO or alike, `format` option must be specified.\n            For Rasterized2D rendering options see [Pillow documentation](https://pillow.readthedocs.io/en/stable/reference/Image.html#PIL.Image.Image.save).\n        \"\"\"\n        self._result_handle.save(dest, **options)\n\n    def get_properties(self) -&gt; LayerProperties:\n        \"\"\"Get properties of layer.\"\"\"\n        return self._properties\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/_layers.html#pygerber.gerberx3.api._layers.RenderingResult.__init__","title":"__init__","text":"<pre><code>__init__(\n    properties: LayerProperties, result_handle: ResultHandle\n) -&gt; None\n</code></pre> <p>Initialize rendering result object.</p> Source code in <code>src/pygerber/gerberx3/api/_layers.py</code> <pre><code>def __init__(\n    self,\n    properties: LayerProperties,\n    result_handle: ResultHandle,\n) -&gt; None:\n    \"\"\"Initialize rendering result object.\"\"\"\n    self._properties = properties\n    self._result_handle = result_handle\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/_layers.html#pygerber.gerberx3.api._layers.RenderingResult.save","title":"save","text":"<pre><code>save(dest: Path | str | BytesIO, **options: Any) -&gt; None\n</code></pre> <p>Save result to specified file or buffer.</p> <p>Parameters:</p> Name Type Description Default <code>dest</code> <code>Path | str | BytesIO</code> <p>Write target.</p> required <code>**options</code> <code>Any</code> <p>Extra parameters which will be passed to saving implementation. When dest is BytesIO or alike, <code>format</code> option must be specified. For Rasterized2D rendering options see Pillow documentation.</p> <code>{}</code> Source code in <code>src/pygerber/gerberx3/api/_layers.py</code> <pre><code>def save(\n    self,\n    dest: Path | str | BytesIO,\n    **options: Any,\n) -&gt; None:\n    \"\"\"Save result to specified file or buffer.\n\n    Parameters\n    ----------\n    dest : Path | str | BytesIO\n        Write target.\n    **options: Any\n        Extra parameters which will be passed to saving implementation.\n        When dest is BytesIO or alike, `format` option must be specified.\n        For Rasterized2D rendering options see [Pillow documentation](https://pillow.readthedocs.io/en/stable/reference/Image.html#PIL.Image.Image.save).\n    \"\"\"\n    self._result_handle.save(dest, **options)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/_layers.html#pygerber.gerberx3.api._layers.RenderingResult.get_properties","title":"get_properties","text":"<pre><code>get_properties() -&gt; LayerProperties\n</code></pre> <p>Get properties of layer.</p> Source code in <code>src/pygerber/gerberx3/api/_layers.py</code> <pre><code>def get_properties(self) -&gt; LayerProperties:\n    \"\"\"Get properties of layer.\"\"\"\n    return self._properties\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/_layers.html#pygerber.gerberx3.api._layers.Rasterized2DLayerParams","title":"Rasterized2DLayerParams","text":"<p>             Bases: <code>LayerParams</code></p> <p>Parameters for Layer with 2D rendering.</p> <p><code>source_path</code>, <code>source_code</code> and <code>source_buffer</code> are mutually exclusive. When more than one of them is provided to constructor, MutuallyExclusiveViolationError will be raised.</p> Source code in <code>src/pygerber/gerberx3/api/_layers.py</code> <pre><code>class Rasterized2DLayerParams(LayerParams):\n    \"\"\"Parameters for Layer with 2D rendering.\n\n    `source_path`, `source_code` and `source_buffer` are mutually exclusive.\n    When more than one of them is provided to constructor,\n    MutuallyExclusiveViolationError will be raised.\n    \"\"\"\n\n    colors: ColorScheme\n    \"\"\"Colors to use for rendering of image.\"\"\"\n\n    dpi: int = 1000\n    \"\"\"DPI of output image.\"\"\"\n\n    debug_dump_apertures: Optional[Path] = None\n    \"\"\"Debug option - dump aperture images to files in given directory.\"\"\"\n\n    debug_include_extra_padding: bool = False\n    \"\"\"Debug option - include large extra padding on all rendering targets to simplify\n    tracking of mispositioned draw commands.\"\"\"\n\n    debug_include_bounding_boxes: bool = False\n    \"\"\"Debug option - include bounding boxes as square outlines on drawing targets\n    to simplify tracking of miscalculated bounding boxes.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/_layers.html#pygerber.gerberx3.api._layers.Rasterized2DLayerParams.colors","title":"colors  <code>instance-attribute</code>","text":"<pre><code>colors: ColorScheme\n</code></pre> <p>Colors to use for rendering of image.</p>"},{"location":"reference/pygerber/gerberx3/api/_layers.html#pygerber.gerberx3.api._layers.Rasterized2DLayerParams.dpi","title":"dpi  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dpi: int = 1000\n</code></pre> <p>DPI of output image.</p>"},{"location":"reference/pygerber/gerberx3/api/_layers.html#pygerber.gerberx3.api._layers.Rasterized2DLayerParams.debug_dump_apertures","title":"debug_dump_apertures  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>debug_dump_apertures: Optional[Path] = None\n</code></pre> <p>Debug option - dump aperture images to files in given directory.</p>"},{"location":"reference/pygerber/gerberx3/api/_layers.html#pygerber.gerberx3.api._layers.Rasterized2DLayerParams.debug_include_extra_padding","title":"debug_include_extra_padding  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>debug_include_extra_padding: bool = False\n</code></pre> <p>Debug option - include large extra padding on all rendering targets to simplify tracking of mispositioned draw commands.</p>"},{"location":"reference/pygerber/gerberx3/api/_layers.html#pygerber.gerberx3.api._layers.Rasterized2DLayerParams.debug_include_bounding_boxes","title":"debug_include_bounding_boxes  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>debug_include_bounding_boxes: bool = False\n</code></pre> <p>Debug option - include bounding boxes as square outlines on drawing targets to simplify tracking of miscalculated bounding boxes.</p>"},{"location":"reference/pygerber/gerberx3/api/_layers.html#pygerber.gerberx3.api._layers.Rasterized2DLayer","title":"Rasterized2DLayer","text":"<p>             Bases: <code>Layer</code></p> <p>Representation of Gerber X3 rasterized 2D image layer.</p> <p>Rasterized images can be saved in any image format supported by Pillow library. For full list of supported formats please refer to Pillow documentation.</p> Source code in <code>src/pygerber/gerberx3/api/_layers.py</code> <pre><code>class Rasterized2DLayer(Layer):\n    \"\"\"Representation of Gerber X3 rasterized 2D image layer.\n\n    Rasterized images can be saved in any image format supported by Pillow library.\n    For full list of supported formats please refer to\n    [Pillow documentation](https://pillow.readthedocs.io/en/stable/handbook/image-file-formats.html).\n    \"\"\"\n\n    options: Rasterized2DLayerParams\n\n    def __init__(self, options: Rasterized2DLayerParams) -&gt; None:\n        \"\"\"Initialize Layer object.\"\"\"\n        if not isinstance(options, Rasterized2DLayerParams):\n            msg = f\"Expected {Rasterized2DLayerParams} got {type(options)}.\"  # type: ignore[unreachable]\n            raise TypeError(msg)\n        super().__init__(options)\n\n    def _create_backend(self) -&gt; Backend:\n        return Rasterized2DBackend(\n            Rasterized2DBackendOptions(\n                dpi=self.options.dpi,\n                color_scheme=self.options.colors,\n                dump_apertures=self.options.debug_dump_apertures,\n                include_debug_padding=self.options.debug_include_extra_padding,\n                include_bounding_boxes=self.options.debug_include_bounding_boxes,\n                draw_region_outlines=self.options.draw_region_outlines,\n            ),\n        )\n\n    def _get_rendering_result_cls(self) -&gt; type[RenderingResult]:\n        return Rasterized2DRenderingResult\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/_layers.html#pygerber.gerberx3.api._layers.Rasterized2DLayer.__init__","title":"__init__","text":"<pre><code>__init__(options: Rasterized2DLayerParams) -&gt; None\n</code></pre> <p>Initialize Layer object.</p> Source code in <code>src/pygerber/gerberx3/api/_layers.py</code> <pre><code>def __init__(self, options: Rasterized2DLayerParams) -&gt; None:\n    \"\"\"Initialize Layer object.\"\"\"\n    if not isinstance(options, Rasterized2DLayerParams):\n        msg = f\"Expected {Rasterized2DLayerParams} got {type(options)}.\"  # type: ignore[unreachable]\n        raise TypeError(msg)\n    super().__init__(options)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/_layers.html#pygerber.gerberx3.api._layers.Rasterized2DRenderingResult","title":"Rasterized2DRenderingResult","text":"<p>             Bases: <code>RenderingResult</code></p> <p>Result of rendering of layer.</p> Source code in <code>src/pygerber/gerberx3/api/_layers.py</code> <pre><code>class Rasterized2DRenderingResult(RenderingResult):\n    \"\"\"Result of rendering of layer.\"\"\"\n\n    _result_handle: Rasterized2DResultHandle\n\n    def get_image(self) -&gt; Image.Image:\n        \"\"\"Get rendered image object.\"\"\"\n        return self._result_handle.get_image()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/api/_layers.html#pygerber.gerberx3.api._layers.Rasterized2DRenderingResult.get_image","title":"get_image","text":"<pre><code>get_image() -&gt; Image.Image\n</code></pre> <p>Get rendered image object.</p> Source code in <code>src/pygerber/gerberx3/api/_layers.py</code> <pre><code>def get_image(self) -&gt; Image.Image:\n    \"\"\"Get rendered image object.\"\"\"\n    return self._result_handle.get_image()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/language_server/__init__.html","title":"init","text":""},{"location":"reference/pygerber/gerberx3/language_server/__init__.html#pygerber.gerberx3.language_server","title":"language_server","text":"<p>PyGerber's Gerber language server implementation.</p>"},{"location":"reference/pygerber/gerberx3/language_server/_internals/__init__.html","title":"init","text":""},{"location":"reference/pygerber/gerberx3/language_server/_internals/__init__.html#pygerber.gerberx3.language_server._internals","title":"_internals","text":"<p>PyGerber's Gerber language server implementation.</p>"},{"location":"reference/pygerber/gerberx3/language_server/_internals/document.html","title":"document","text":""},{"location":"reference/pygerber/gerberx3/language_server/_internals/document.html#pygerber.gerberx3.language_server._internals.document","title":"document","text":""},{"location":"reference/pygerber/gerberx3/language_server/_internals/document.html#pygerber.gerberx3.language_server._internals.document.Document","title":"Document","text":"<p>Represents single snapshot of a document.</p> Source code in <code>src/pygerber/gerberx3/language_server/_internals/document.py</code> <pre><code>class Document:\n    \"\"\"Represents single snapshot of a document.\"\"\"\n\n    def __init__(self, ls: LanguageServer, source: str, uri: str) -&gt; None:\n        self.ls = ls\n        self.source = source\n        self.uri = uri\n\n        self.tokenizer = Tokenizer()\n\n        self.ls.show_message_log(\n            f\"Created tokenizer for {uri}\",\n            lspt.MessageType.Info,\n        )\n\n        self.parser_error_diagnostics: list[diagnostic.Diagnostic] = []\n        self.options = ParserOptions(\n            on_update_drawing_state_error=self.on_update_drawing_state_error,\n        )\n        self.parser = StatePreservingParser(self.options)\n        self.ls.show_message_log(\n            f\"Created parser for {uri}\",\n            lspt.MessageType.Info,\n        )\n\n        self.ls.show_message_log(\n            f\"Started tokenizing {uri}\",\n            lspt.MessageType.Info,\n        )\n        self.ast = self.tokenizer.tokenize_resilient(self.source)\n        self.ls.show_message_log(\n            f\"Finished tokenizing {uri}\",\n            lspt.MessageType.Info,\n        )\n\n        self.ls.show_message_log(\n            f\"Started parsing {uri}\",\n            lspt.MessageType.Info,\n        )\n        self.parser.parse(self.ast)\n        self.ls.show_message_log(\n            f\"Finished parsing {self.uri}\",\n            lspt.MessageType.Info,\n        )\n\n    def on_update_drawing_state_error(\n        self,\n        exc: Exception,\n        _parser: Parser,\n        token: Token,\n    ) -&gt; None:\n        if isinstance(exc, ParserError):\n            message = exc.get_message()\n        else:\n            message = f\"{exc.__class__.__qualname__}: {exc}\"\n\n        self.parser_error_diagnostics.append(\n            diagnostic.Diagnostic(\n                range=(\n                    diagnostic.Range(\n                        start=token.get_token_position(),\n                        end=token.get_token_end_position(),\n                    )\n                ),\n                message=message,\n                severity=diagnostic.DiagnosticSeverity.Error,\n            ),\n        )\n        self.ls.show_message_log(\n            message,\n            lspt.MessageType.Info,\n        )\n\n        raise ExitParsingProcessInterrupt\n\n    def text_document_hover(self, params: lspt.HoverParams) -&gt; Optional[lspt.Hover]:\n        try:\n            ast = self.ast\n            token_accessor = ast.find_closest_token(\n                Position.from_vscode_position(\n                    params.position.line,\n                    params.position.character,\n                ),\n            )\n            if (token := token_accessor.token) is not None:\n                logging.info(\n                    \"Found token for hover location %s, %s\",\n                    params.position,\n                    token.get_token_position(),\n                )\n\n                return lspt.Hover(\n                    contents=lspt.MarkupContent(\n                        kind=lspt.MarkupKind.Markdown,\n                        value=token.get_hover_message(self.parser.get_state_at(token)),\n                    ),\n                )\n\n            logging.info(\n                \"Missing token for hover location %s\",\n                params.position,\n            )\n        except EmptyASTError:\n            logging.warning(\n                \"AST for this file is empty, couldn't determine hover message.\",\n            )\n        except Exception:\n            logging.exception(\"DOCUMENT HOVER CRASHED.\")\n\n        return None\n\n    def publish_diagnostics(self) -&gt; None:\n        \"\"\"Publish code diagnostics for this document.\"\"\"\n        diagnostics: list[Diagnostic] = []\n        for token in self.ast:\n            diagnostics.extend(token.get_token_diagnostics())\n\n        diagnostics.extend(self.parser_error_diagnostics)\n        self.ls.publish_diagnostics(self.uri, [d.to_lspt() for d in diagnostics])\n</code></pre>"},{"location":"reference/pygerber/gerberx3/language_server/_internals/document.html#pygerber.gerberx3.language_server._internals.document.Document.publish_diagnostics","title":"publish_diagnostics","text":"<pre><code>publish_diagnostics() -&gt; None\n</code></pre> <p>Publish code diagnostics for this document.</p> Source code in <code>src/pygerber/gerberx3/language_server/_internals/document.py</code> <pre><code>def publish_diagnostics(self) -&gt; None:\n    \"\"\"Publish code diagnostics for this document.\"\"\"\n    diagnostics: list[Diagnostic] = []\n    for token in self.ast:\n        diagnostics.extend(token.get_token_diagnostics())\n\n    diagnostics.extend(self.parser_error_diagnostics)\n    self.ls.publish_diagnostics(self.uri, [d.to_lspt() for d in diagnostics])\n</code></pre>"},{"location":"reference/pygerber/gerberx3/language_server/_internals/error.html","title":"error","text":""},{"location":"reference/pygerber/gerberx3/language_server/_internals/error.html#pygerber.gerberx3.language_server._internals.error","title":"error","text":""},{"location":"reference/pygerber/gerberx3/language_server/_internals/error.html#pygerber.gerberx3.language_server._internals.error.LanguageServerNotAvailableError","title":"LanguageServerNotAvailableError","text":"<p>             Bases: <code>RuntimeError</code></p> <p>Language server feature requires pygerber[language-server] extras.</p> Source code in <code>src/pygerber/gerberx3/language_server/_internals/error.py</code> <pre><code>class LanguageServerNotAvailableError(RuntimeError):\n    \"\"\"Language server feature requires pygerber[language-server] extras.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/language_server/_internals/errors.html","title":"errors","text":""},{"location":"reference/pygerber/gerberx3/language_server/_internals/errors.html#pygerber.gerberx3.language_server._internals.errors","title":"errors","text":"<p>All language server specific error classes.</p>"},{"location":"reference/pygerber/gerberx3/language_server/_internals/errors.html#pygerber.gerberx3.language_server._internals.errors.LanguageServerError","title":"LanguageServerError","text":"<p>             Bases: <code>RuntimeError</code></p> <p>Base class for errors raised by language server.</p> Source code in <code>src/pygerber/gerberx3/language_server/_internals/errors.py</code> <pre><code>class LanguageServerError(RuntimeError):\n    \"\"\"Base class for errors raised by language server.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/language_server/_internals/errors.html#pygerber.gerberx3.language_server._internals.errors.EmptyASTError","title":"EmptyASTError","text":"<p>             Bases: <code>LanguageServerError</code></p> <p>Error raised when AST is empty.</p> Source code in <code>src/pygerber/gerberx3/language_server/_internals/errors.py</code> <pre><code>class EmptyASTError(LanguageServerError):\n    \"\"\"Error raised when AST is empty.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/language_server/_internals/server.html","title":"server","text":""},{"location":"reference/pygerber/gerberx3/language_server/_internals/server.html#pygerber.gerberx3.language_server._internals.server","title":"server","text":"<p>PyGerber's Gerber language server implementation.</p>"},{"location":"reference/pygerber/gerberx3/language_server/_internals/server.html#pygerber.gerberx3.language_server._internals.server.get_language_server","title":"get_language_server","text":"<pre><code>get_language_server() -&gt; LanguageServer\n</code></pre> <p>Get instance of Gerber language server.</p> Source code in <code>src/pygerber/gerberx3/language_server/_internals/server.py</code> <pre><code>def get_language_server() -&gt; LanguageServer:  # noqa: C901\n    \"\"\"Get instance of Gerber language server.\"\"\"\n    if not IS_LANGUAGE_SERVER_FEATURE_AVAILABLE:\n        raise LanguageServerNotAvailableError\n\n    import lsprotocol.types as lspt\n    from pygls.server import LanguageServer\n\n    from pygerber.gerberx3.language_server._internals.document import Document\n\n    if TYPE_CHECKING:\n        from pygls import workspace\n\n    server = LanguageServer(\n        \"pygerber.gerberx3.language_server\",\n        f\"v{pygerber.__version__}\",\n        max_workers=1,\n    )\n\n    @server.feature(lspt.INITIALIZE)\n    def _initialize(params: lspt.InitializeParams) -&gt; None:\n        client_name = getattr(params.client_info, \"name\", \"Unknown\")\n        client_version = getattr(params.client_info, \"version\", \"Unknown\")\n        server.show_message_log(\n            \"Started PyGerber's Gerber Language Server version \"\n            f\"{pygerber.__version__} for {client_name} {client_version}.\",\n            lspt.MessageType.Info,\n        )\n\n    @server.feature(lspt.TEXT_DOCUMENT_DID_OPEN)\n    def _text_document_open(params: lspt.DidOpenTextDocumentParams) -&gt; None:\n        document = get_document(params.text_document.uri)\n        document.publish_diagnostics()\n\n    @server.feature(lspt.TEXT_DOCUMENT_DID_CHANGE)\n    def _text_document_change(params: lspt.DidOpenTextDocumentParams) -&gt; None:\n        document = get_document(params.text_document.uri)\n        document.publish_diagnostics()\n\n    cached_documents_map: dict[bytes, Document] = {}\n\n    def get_document(uri: str) -&gt; Document:\n        text_document: workspace.TextDocument = server.workspace.get_text_document(\n            uri,\n        )\n        digest_text_document = sha256(text_document.source.encode(\"utf-8\")).digest()\n        digest_uri = sha256(text_document.uri.encode(\"utf-8\")).digest()\n\n        document_id = digest_text_document + digest_uri\n        document = cached_documents_map.get(document_id)\n\n        if document is None:\n            if len(cached_documents_map) &gt; MAX_CACHE_SIZE:\n                cached_documents_map.popitem()\n\n            cached_documents_map[document_id] = Document(\n                server,\n                text_document.source,\n                uri,\n            )\n\n        return cached_documents_map[document_id]\n\n    @server.feature(lspt.TEXT_DOCUMENT_HOVER)\n    def _text_document_hover(params: lspt.HoverParams) -&gt; Optional[lspt.Hover]:\n        document = get_document(params.text_document.uri)\n        return document.text_document_hover(params)\n\n    @server.feature(\n        lspt.TEXT_DOCUMENT_COMPLETION,\n        lspt.CompletionOptions(trigger_characters=[\"G\"]),\n    )\n    def _text_document_completion(\n        _params: lspt.CompletionParams,\n    ) -&gt; lspt.CompletionList:\n        return lspt.CompletionList(\n            is_incomplete=False,\n            items=[\n                lspt.CompletionItem(\n                    label=f\"G{code}*\",\n                    kind=lspt.CompletionItemKind.Keyword,\n                )\n                for code in [\n                    \"01\",\n                    \"02\",\n                    \"03\",\n                    \"36\",\n                    \"37\",\n                    \"54\",\n                    \"55\",\n                    \"70\",\n                    \"71\",\n                    \"74\",\n                    \"75\",\n                    \"90\",\n                    \"91\",\n                ]\n            ],\n        )\n\n    return server\n</code></pre>"},{"location":"reference/pygerber/gerberx3/linter/__init__.html","title":"init","text":""},{"location":"reference/pygerber/gerberx3/linter/__init__.html#pygerber.gerberx3.linter","title":"linter","text":"<p>Code diagnostic logic.</p>"},{"location":"reference/pygerber/gerberx3/linter/diagnostic.html","title":"diagnostic","text":""},{"location":"reference/pygerber/gerberx3/linter/diagnostic.html#pygerber.gerberx3.linter.diagnostic","title":"diagnostic","text":"<p>Container for diagnostic info.</p>"},{"location":"reference/pygerber/gerberx3/linter/diagnostic.html#pygerber.gerberx3.linter.diagnostic.Location","title":"Location","text":"<p>             Bases: <code>FrozenGeneralModel</code></p> <p>Represents a location inside a resource, such as a line inside a text file.</p> Source code in <code>src/pygerber/gerberx3/linter/diagnostic.py</code> <pre><code>class Location(FrozenGeneralModel):\n    \"\"\"Represents a location inside a resource, such as a line\n    inside a text file.\n    \"\"\"\n\n    uri: str\n\n    range: Range  # noqa: A003\n\n    def __repr__(self) -&gt; str:\n        return f\"{self.uri}:{self.range!r}\"\n\n    def to_lspt(self) -&gt; lspt.Location:\n        \"\"\"Convert to corresponding language server protocol type.\"\"\"\n        return lspt.Location(uri=self.uri, range=self.range.to_lspt())\n</code></pre>"},{"location":"reference/pygerber/gerberx3/linter/diagnostic.html#pygerber.gerberx3.linter.diagnostic.Location.to_lspt","title":"to_lspt","text":"<pre><code>to_lspt() -&gt; lspt.Location\n</code></pre> <p>Convert to corresponding language server protocol type.</p> Source code in <code>src/pygerber/gerberx3/linter/diagnostic.py</code> <pre><code>def to_lspt(self) -&gt; lspt.Location:\n    \"\"\"Convert to corresponding language server protocol type.\"\"\"\n    return lspt.Location(uri=self.uri, range=self.range.to_lspt())\n</code></pre>"},{"location":"reference/pygerber/gerberx3/linter/diagnostic.html#pygerber.gerberx3.linter.diagnostic.DiagnosticRelatedInformation","title":"DiagnosticRelatedInformation","text":"<p>             Bases: <code>FrozenGeneralModel</code></p> <p>Represents a related message and source code location for a diagnostic. This should be used to point to code locations that cause or related to a diagnostics, e.g when duplicating a symbol in a scope.</p> Source code in <code>src/pygerber/gerberx3/linter/diagnostic.py</code> <pre><code>class DiagnosticRelatedInformation(FrozenGeneralModel):\n    \"\"\"Represents a related message and source code location for a diagnostic. This\n    should be used to point to code locations that cause or related to a diagnostics,\n    e.g when duplicating a symbol in a scope.\n    \"\"\"\n\n    location: Location\n    \"\"\"The location of this related diagnostic information.\"\"\"\n\n    message: str\n    \"\"\"The message of this related diagnostic information.\"\"\"\n\n    def to_lspt(self) -&gt; lspt.DiagnosticRelatedInformation:\n        \"\"\"Convert to corresponding language server protocol type.\"\"\"\n        return lspt.DiagnosticRelatedInformation(\n            location=self.location.to_lspt(),\n            message=self.message,\n        )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/linter/diagnostic.html#pygerber.gerberx3.linter.diagnostic.DiagnosticRelatedInformation.location","title":"location  <code>instance-attribute</code>","text":"<pre><code>location: Location\n</code></pre> <p>The location of this related diagnostic information.</p>"},{"location":"reference/pygerber/gerberx3/linter/diagnostic.html#pygerber.gerberx3.linter.diagnostic.DiagnosticRelatedInformation.message","title":"message  <code>instance-attribute</code>","text":"<pre><code>message: str\n</code></pre> <p>The message of this related diagnostic information.</p>"},{"location":"reference/pygerber/gerberx3/linter/diagnostic.html#pygerber.gerberx3.linter.diagnostic.DiagnosticRelatedInformation.to_lspt","title":"to_lspt","text":"<pre><code>to_lspt() -&gt; lspt.DiagnosticRelatedInformation\n</code></pre> <p>Convert to corresponding language server protocol type.</p> Source code in <code>src/pygerber/gerberx3/linter/diagnostic.py</code> <pre><code>def to_lspt(self) -&gt; lspt.DiagnosticRelatedInformation:\n    \"\"\"Convert to corresponding language server protocol type.\"\"\"\n    return lspt.DiagnosticRelatedInformation(\n        location=self.location.to_lspt(),\n        message=self.message,\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/linter/diagnostic.html#pygerber.gerberx3.linter.diagnostic.CodeDescription","title":"CodeDescription","text":"<p>             Bases: <code>FrozenGeneralModel</code></p> <p>Structure to capture a description for an error code.</p> <p>@since 3.16.0</p> Source code in <code>src/pygerber/gerberx3/linter/diagnostic.py</code> <pre><code>class CodeDescription(FrozenGeneralModel):\n    \"\"\"Structure to capture a description for an error code.\n\n    @since 3.16.0\n    \"\"\"\n\n    # Since: 3.16.0\n\n    href: str\n    \"\"\"An URI to open with more information about the diagnostic error.\"\"\"\n\n    def to_lspt(self) -&gt; lspt.CodeDescription:\n        \"\"\"Convert to corresponding language server protocol type.\"\"\"\n        return lspt.CodeDescription(href=self.href)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/linter/diagnostic.html#pygerber.gerberx3.linter.diagnostic.CodeDescription.href","title":"href  <code>instance-attribute</code>","text":"<pre><code>href: str\n</code></pre> <p>An URI to open with more information about the diagnostic error.</p>"},{"location":"reference/pygerber/gerberx3/linter/diagnostic.html#pygerber.gerberx3.linter.diagnostic.CodeDescription.to_lspt","title":"to_lspt","text":"<pre><code>to_lspt() -&gt; lspt.CodeDescription\n</code></pre> <p>Convert to corresponding language server protocol type.</p> Source code in <code>src/pygerber/gerberx3/linter/diagnostic.py</code> <pre><code>def to_lspt(self) -&gt; lspt.CodeDescription:\n    \"\"\"Convert to corresponding language server protocol type.\"\"\"\n    return lspt.CodeDescription(href=self.href)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/linter/diagnostic.html#pygerber.gerberx3.linter.diagnostic.DiagnosticSeverity","title":"DiagnosticSeverity","text":"<p>             Bases: <code>int</code>, <code>Enum</code></p> <p>The diagnostic's severity.</p> Source code in <code>src/pygerber/gerberx3/linter/diagnostic.py</code> <pre><code>@enum.unique\nclass DiagnosticSeverity(int, enum.Enum):\n    \"\"\"The diagnostic's severity.\"\"\"\n\n    Error = 1\n    \"\"\"Reports an error.\"\"\"\n    Warning = 2  # noqa: A003\n    \"\"\"Reports a warning.\"\"\"\n    Information = 3\n    \"\"\"Reports an information.\"\"\"\n    Hint = 4\n    \"\"\"Reports a hint.\"\"\"\n\n    def to_lspt(self) -&gt; lspt.DiagnosticSeverity:\n        \"\"\"Convert to corresponding language server protocol type.\"\"\"\n        return lspt.DiagnosticSeverity(self.value)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/linter/diagnostic.html#pygerber.gerberx3.linter.diagnostic.DiagnosticSeverity.Error","title":"Error  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Error = 1\n</code></pre> <p>Reports an error.</p>"},{"location":"reference/pygerber/gerberx3/linter/diagnostic.html#pygerber.gerberx3.linter.diagnostic.DiagnosticSeverity.Warning","title":"Warning  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Warning = 2\n</code></pre> <p>Reports a warning.</p>"},{"location":"reference/pygerber/gerberx3/linter/diagnostic.html#pygerber.gerberx3.linter.diagnostic.DiagnosticSeverity.Information","title":"Information  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Information = 3\n</code></pre> <p>Reports an information.</p>"},{"location":"reference/pygerber/gerberx3/linter/diagnostic.html#pygerber.gerberx3.linter.diagnostic.DiagnosticSeverity.Hint","title":"Hint  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Hint = 4\n</code></pre> <p>Reports a hint.</p>"},{"location":"reference/pygerber/gerberx3/linter/diagnostic.html#pygerber.gerberx3.linter.diagnostic.DiagnosticSeverity.to_lspt","title":"to_lspt","text":"<pre><code>to_lspt() -&gt; lspt.DiagnosticSeverity\n</code></pre> <p>Convert to corresponding language server protocol type.</p> Source code in <code>src/pygerber/gerberx3/linter/diagnostic.py</code> <pre><code>def to_lspt(self) -&gt; lspt.DiagnosticSeverity:\n    \"\"\"Convert to corresponding language server protocol type.\"\"\"\n    return lspt.DiagnosticSeverity(self.value)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/linter/diagnostic.html#pygerber.gerberx3.linter.diagnostic.Range","title":"Range","text":"<p>             Bases: <code>FrozenGeneralModel</code></p> <p>A range in a text document expressed as (zero-based) start and end positions.</p> <p>If you want to specify a range that contains a line including the line ending character(s) then use an end position denoting the start of the next line. For example: <pre><code>{\n    start: { line: 5, character: 23 }\n    end : { line 6, character : 0 }\n}\n</code></pre></p> Source code in <code>src/pygerber/gerberx3/linter/diagnostic.py</code> <pre><code>class Range(FrozenGeneralModel):\n    \"\"\"A range in a text document expressed as (zero-based) start and end positions.\n\n    If you want to specify a range that contains a line including the line ending\n    character(s) then use an end position denoting the start of the next line.\n    For example:\n    ```ts\n    {\n        start: { line: 5, character: 23 }\n        end : { line 6, character : 0 }\n    }\n    ```\n    \"\"\"\n\n    start: Position\n    \"\"\"The range's start position.\"\"\"\n\n    end: Position\n    \"\"\"The range's end position.\"\"\"\n\n    def __repr__(self) -&gt; str:\n        return f\"{self.start!r}-{self.end!r}\"\n\n    def to_lspt(self) -&gt; lspt.Range:\n        \"\"\"Convert to corresponding language server protocol type.\"\"\"\n        return lspt.Range(start=self.start.to_lspt(), end=self.end.to_lspt())\n</code></pre>"},{"location":"reference/pygerber/gerberx3/linter/diagnostic.html#pygerber.gerberx3.linter.diagnostic.Range.start","title":"start  <code>instance-attribute</code>","text":"<pre><code>start: Position\n</code></pre> <p>The range's start position.</p>"},{"location":"reference/pygerber/gerberx3/linter/diagnostic.html#pygerber.gerberx3.linter.diagnostic.Range.end","title":"end  <code>instance-attribute</code>","text":"<pre><code>end: Position\n</code></pre> <p>The range's end position.</p>"},{"location":"reference/pygerber/gerberx3/linter/diagnostic.html#pygerber.gerberx3.linter.diagnostic.Range.to_lspt","title":"to_lspt","text":"<pre><code>to_lspt() -&gt; lspt.Range\n</code></pre> <p>Convert to corresponding language server protocol type.</p> Source code in <code>src/pygerber/gerberx3/linter/diagnostic.py</code> <pre><code>def to_lspt(self) -&gt; lspt.Range:\n    \"\"\"Convert to corresponding language server protocol type.\"\"\"\n    return lspt.Range(start=self.start.to_lspt(), end=self.end.to_lspt())\n</code></pre>"},{"location":"reference/pygerber/gerberx3/linter/diagnostic.html#pygerber.gerberx3.linter.diagnostic.DiagnosticTag","title":"DiagnosticTag","text":"<p>             Bases: <code>int</code>, <code>Enum</code></p> <p>The diagnostic tags.</p> <p>@since 3.15.0</p> Source code in <code>src/pygerber/gerberx3/linter/diagnostic.py</code> <pre><code>@enum.unique\nclass DiagnosticTag(int, enum.Enum):\n    \"\"\"The diagnostic tags.\n\n    @since 3.15.0\n    \"\"\"\n\n    # Since: 3.15.0\n    Unnecessary = 1\n    \"\"\"Unused or unnecessary code.\n\n    Clients are allowed to render diagnostics with this tag faded out instead of having\n    an error squiggle.\"\"\"\n    Deprecated = 2\n    \"\"\"Deprecated or obsolete code.\n\n    Clients are allowed to rendered diagnostics with this tag strike through.\"\"\"\n\n    def to_lspt(self) -&gt; lspt.DiagnosticTag:\n        \"\"\"Convert to corresponding language server protocol type.\"\"\"\n        return lspt.DiagnosticTag(self.value)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/linter/diagnostic.html#pygerber.gerberx3.linter.diagnostic.DiagnosticTag.Unnecessary","title":"Unnecessary  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Unnecessary = 1\n</code></pre> <p>Unused or unnecessary code.</p> <p>Clients are allowed to render diagnostics with this tag faded out instead of having an error squiggle.</p>"},{"location":"reference/pygerber/gerberx3/linter/diagnostic.html#pygerber.gerberx3.linter.diagnostic.DiagnosticTag.Deprecated","title":"Deprecated  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Deprecated = 2\n</code></pre> <p>Deprecated or obsolete code.</p> <p>Clients are allowed to rendered diagnostics with this tag strike through.</p>"},{"location":"reference/pygerber/gerberx3/linter/diagnostic.html#pygerber.gerberx3.linter.diagnostic.DiagnosticTag.to_lspt","title":"to_lspt","text":"<pre><code>to_lspt() -&gt; lspt.DiagnosticTag\n</code></pre> <p>Convert to corresponding language server protocol type.</p> Source code in <code>src/pygerber/gerberx3/linter/diagnostic.py</code> <pre><code>def to_lspt(self) -&gt; lspt.DiagnosticTag:\n    \"\"\"Convert to corresponding language server protocol type.\"\"\"\n    return lspt.DiagnosticTag(self.value)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/linter/diagnostic.html#pygerber.gerberx3.linter.diagnostic.Diagnostic","title":"Diagnostic","text":"<p>             Bases: <code>FrozenGeneralModel</code></p> <p>Represents a diagnostic, such as a compiler error or warning. Diagnostic objects are only valid in the scope of a resource.</p> Source code in <code>src/pygerber/gerberx3/linter/diagnostic.py</code> <pre><code>class Diagnostic(FrozenGeneralModel):\n    \"\"\"Represents a diagnostic, such as a compiler error or warning. Diagnostic objects\n    are only valid in the scope of a resource.\n    \"\"\"\n\n    range: Range  # noqa: A003\n    \"\"\"The range at which the message applies\"\"\"\n\n    message: str\n    \"\"\"The diagnostic's message. It usually appears in the user interface\"\"\"\n\n    severity: Optional[DiagnosticSeverity] = Field(default=None)\n    \"\"\"The diagnostic's severity. Can be omitted. If omitted it is up to the\n    client to interpret diagnostics as error, warning, info or hint.\"\"\"\n\n    code: Optional[Union[int, str]] = Field(default=None)\n    \"\"\"The diagnostic's code, which usually appear in the user interface.\"\"\"\n\n    code_description: Optional[CodeDescription] = Field(default=None)\n    \"\"\"An optional property to describe the error code.\n    Requires the code field (above) to be present/not null.\n\n    @since 3.16.0\"\"\"\n    # Since: 3.16.0\n\n    source: Optional[str] = Field(default=None)\n    \"\"\"A human-readable string describing the source of this\n    diagnostic, e.g. 'typescript' or 'super lint'. It usually\n    appears in the user interface.\"\"\"\n\n    tags: Optional[List[DiagnosticTag]] = Field(default=None)\n    \"\"\"Additional metadata about the diagnostic.\n\n    @since 3.15.0\"\"\"\n    # Since: 3.15.0\n\n    related_information: Optional[List[DiagnosticRelatedInformation]] = Field(\n        default=None,\n    )\n    \"\"\"An array of related diagnostic information, e.g. when symbol-names within\n    a scope collide all definitions can be marked via this property.\"\"\"\n\n    data: Optional[Any] = Field(default=None)\n    \"\"\"A data entry field that is preserved between a `textDocument/publishDiagnostics`\n    notification and `textDocument/codeAction` request.\n\n    @since 3.16.0\"\"\"\n\n    def to_lspt(self) -&gt; lspt.Diagnostic:\n        \"\"\"Repack into language server protocol type.\"\"\"\n        return lspt.Diagnostic(\n            range=self.range.to_lspt(),\n            message=self.message,\n            severity=(\n                lspt.DiagnosticSeverity(self.severity.value) if self.severity else None\n            ),\n            code=self.code,\n            code_description=(\n                self.code_description.to_lspt() if self.code_description else None\n            ),\n            source=self.source,\n            tags=[t.to_lspt() for t in self.tags] if self.tags is not None else None,\n            related_information=(\n                [i.to_lspt() for i in self.related_information]\n                if self.related_information is not None\n                else None\n            ),\n        )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/linter/diagnostic.html#pygerber.gerberx3.linter.diagnostic.Diagnostic.range","title":"range  <code>instance-attribute</code>","text":"<pre><code>range: Range\n</code></pre> <p>The range at which the message applies</p>"},{"location":"reference/pygerber/gerberx3/linter/diagnostic.html#pygerber.gerberx3.linter.diagnostic.Diagnostic.message","title":"message  <code>instance-attribute</code>","text":"<pre><code>message: str\n</code></pre> <p>The diagnostic's message. It usually appears in the user interface</p>"},{"location":"reference/pygerber/gerberx3/linter/diagnostic.html#pygerber.gerberx3.linter.diagnostic.Diagnostic.severity","title":"severity  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>severity: Optional[DiagnosticSeverity] = Field(default=None)\n</code></pre> <p>The diagnostic's severity. Can be omitted. If omitted it is up to the client to interpret diagnostics as error, warning, info or hint.</p>"},{"location":"reference/pygerber/gerberx3/linter/diagnostic.html#pygerber.gerberx3.linter.diagnostic.Diagnostic.code","title":"code  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>code: Optional[Union[int, str]] = Field(default=None)\n</code></pre> <p>The diagnostic's code, which usually appear in the user interface.</p>"},{"location":"reference/pygerber/gerberx3/linter/diagnostic.html#pygerber.gerberx3.linter.diagnostic.Diagnostic.code_description","title":"code_description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>code_description: Optional[CodeDescription] = Field(\n    default=None\n)\n</code></pre> <p>An optional property to describe the error code. Requires the code field (above) to be present/not null.</p> <p>@since 3.16.0</p>"},{"location":"reference/pygerber/gerberx3/linter/diagnostic.html#pygerber.gerberx3.linter.diagnostic.Diagnostic.source","title":"source  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>source: Optional[str] = Field(default=None)\n</code></pre> <p>A human-readable string describing the source of this diagnostic, e.g. 'typescript' or 'super lint'. It usually appears in the user interface.</p>"},{"location":"reference/pygerber/gerberx3/linter/diagnostic.html#pygerber.gerberx3.linter.diagnostic.Diagnostic.tags","title":"tags  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tags: Optional[List[DiagnosticTag]] = Field(default=None)\n</code></pre> <p>Additional metadata about the diagnostic.</p> <p>@since 3.15.0</p>"},{"location":"reference/pygerber/gerberx3/linter/diagnostic.html#pygerber.gerberx3.linter.diagnostic.Diagnostic.related_information","title":"related_information  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>related_information: Optional[\n    List[DiagnosticRelatedInformation]\n] = Field(default=None)\n</code></pre> <p>An array of related diagnostic information, e.g. when symbol-names within a scope collide all definitions can be marked via this property.</p>"},{"location":"reference/pygerber/gerberx3/linter/diagnostic.html#pygerber.gerberx3.linter.diagnostic.Diagnostic.data","title":"data  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>data: Optional[Any] = Field(default=None)\n</code></pre> <p>A data entry field that is preserved between a <code>textDocument/publishDiagnostics</code> notification and <code>textDocument/codeAction</code> request.</p> <p>@since 3.16.0</p>"},{"location":"reference/pygerber/gerberx3/linter/diagnostic.html#pygerber.gerberx3.linter.diagnostic.Diagnostic.to_lspt","title":"to_lspt","text":"<pre><code>to_lspt() -&gt; lspt.Diagnostic\n</code></pre> <p>Repack into language server protocol type.</p> Source code in <code>src/pygerber/gerberx3/linter/diagnostic.py</code> <pre><code>def to_lspt(self) -&gt; lspt.Diagnostic:\n    \"\"\"Repack into language server protocol type.\"\"\"\n    return lspt.Diagnostic(\n        range=self.range.to_lspt(),\n        message=self.message,\n        severity=(\n            lspt.DiagnosticSeverity(self.severity.value) if self.severity else None\n        ),\n        code=self.code,\n        code_description=(\n            self.code_description.to_lspt() if self.code_description else None\n        ),\n        source=self.source,\n        tags=[t.to_lspt() for t in self.tags] if self.tags is not None else None,\n        related_information=(\n            [i.to_lspt() for i in self.related_information]\n            if self.related_information is not None\n            else None\n        ),\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/math/__init__.html","title":"init","text":""},{"location":"reference/pygerber/gerberx3/math/__init__.html#pygerber.gerberx3.math","title":"math","text":"<p>Module containing math utilities.</p>"},{"location":"reference/pygerber/gerberx3/math/bounding_box.html","title":"bounding_box","text":""},{"location":"reference/pygerber/gerberx3/math/bounding_box.html#pygerber.gerberx3.math.bounding_box","title":"bounding_box","text":"<p>Utility class for calculating bounding boxes of drawing elements.</p>"},{"location":"reference/pygerber/gerberx3/math/bounding_box.html#pygerber.gerberx3.math.bounding_box.BoundingBox","title":"BoundingBox","text":"<p>             Bases: <code>FrozenGeneralModel</code></p> <p>Class for calculating bounding boxes.</p> Source code in <code>src/pygerber/gerberx3/math/bounding_box.py</code> <pre><code>class BoundingBox(FrozenGeneralModel):\n    \"\"\"Class for calculating bounding boxes.\"\"\"\n\n    NULL: ClassVar[BoundingBox]\n\n    max_x: Offset = Field(default=Offset.NULL)\n    max_y: Offset = Field(default=Offset.NULL)\n\n    min_x: Offset = Field(default=Offset.NULL)\n    min_y: Offset = Field(default=Offset.NULL)\n\n    @classmethod\n    def from_diameter(cls, diameter: Offset) -&gt; BoundingBox:\n        \"\"\"Create a bounding box from a given diameter.\"\"\"\n        half_diameter = diameter / 2\n        return cls(\n            max_x=half_diameter,\n            max_y=half_diameter,\n            min_x=-half_diameter,\n            min_y=-half_diameter,\n        )\n\n    @classmethod\n    def from_rectangle(cls, x_size: Offset, y_size: Offset) -&gt; BoundingBox:\n        \"\"\"Create a bounding box from a given diameter.\"\"\"\n        half_x = x_size / 2\n        half_y = y_size / 2\n        return cls(\n            max_x=half_x,\n            max_y=half_y,\n            min_x=-half_x,\n            min_y=-half_y,\n        )\n\n    @property\n    def width(self) -&gt; Offset:\n        \"\"\"Return width of the bounding box.\"\"\"\n        return self.max_x - self.min_x\n\n    @property\n    def height(self) -&gt; Offset:\n        \"\"\"Return height of the bounding box.\"\"\"\n        return self.max_y - self.min_y\n\n    def get_size(self) -&gt; Vector2D:\n        \"\"\"Get bounding box size.\"\"\"\n        return Vector2D(x=self.width, y=self.height)\n\n    @property\n    def center(self) -&gt; Vector2D:\n        \"\"\"Return current center of the bounding box.\"\"\"\n        center_x = (self.max_x + self.min_x) / Offset(value=Decimal(2))\n        center_y = (self.max_y + self.min_y) / Offset(value=Decimal(2))\n        return Vector2D(x=center_x, y=center_y)\n\n    def get_min_vector(self) -&gt; Vector2D:\n        \"\"\"Return Vector2D of min_x and min_y.\"\"\"\n        return Vector2D(x=self.min_x, y=self.min_y)\n\n    def as_pixel_box(\n        self,\n        dpi: int,\n        *,\n        dx_max: int = 0,\n        dy_max: int = 0,\n        dx_min: int = 0,\n        dy_min: int = 0,\n    ) -&gt; PixelBox:\n        \"\"\"Return box as tuple of ints with order.\n\n        [x0, y0, x1, y1], where x1 &gt;= x0 and y1 &gt;= y0\n        \"\"\"\n        return PixelBox(\n            (\n                self.min_x.as_pixels(dpi) + dx_min,\n                self.min_y.as_pixels(dpi) + dy_min,\n                self.max_x.as_pixels(dpi) + dx_max,\n                self.max_y.as_pixels(dpi) + dy_max,\n            ),\n        )\n\n    def _operator(\n        self,\n        other: object,\n        op: Callable,\n    ) -&gt; BoundingBox:\n        if isinstance(other, Vector2D):\n            return BoundingBox(\n                max_x=op(self.max_x, other.x),\n                max_y=op(self.max_y, other.y),\n                min_x=op(self.min_x, other.x),\n                min_y=op(self.min_y, other.y),\n            )\n        if isinstance(other, (Offset, Decimal, int, float)):\n            return BoundingBox(\n                max_x=op(self.max_x, other),\n                max_y=op(self.max_y, other),\n                min_x=op(self.min_x, -other),\n                min_y=op(self.min_y, -other),\n            )\n        return NotImplemented\n\n    def __add__(self, other: object) -&gt; BoundingBox:\n        if isinstance(other, BoundingBox):\n            return BoundingBox(\n                max_x=max(self.max_x, other.max_x),\n                max_y=max(self.max_y, other.max_y),\n                min_x=min(self.min_x, other.min_x),\n                min_y=min(self.min_y, other.min_y),\n            )\n        return self._operator(other, operator.add)\n\n    def __sub__(self, other: object) -&gt; BoundingBox:\n        return self._operator(other, operator.sub)\n\n    def __mul__(self, other: object) -&gt; BoundingBox:\n        return self._operator(other, operator.mul)\n\n    def __truediv__(self, other: object) -&gt; BoundingBox:\n        return self._operator(other, operator.truediv)\n\n    def __str__(self) -&gt; str:\n        return (\n            f\"{self.__class__.__qualname__}(max_x={self.max_x}, max_y={self.max_y}, \"\n            f\"min_x={self.min_x}, min_y={self.min_y})\"\n        )\n\n    def include_point(self, point: Vector2D) -&gt; BoundingBox:\n        \"\"\"Include point in bounding box by extending bounding box overt the point.\"\"\"\n        # Check for the x-coordinate\n        new_max_x = max(self.max_x, point.x)\n        new_min_x = min(self.min_x, point.x)\n\n        # Check for the y-coordinate\n        new_max_y = max(self.max_y, point.y)\n        new_min_y = min(self.min_y, point.y)\n\n        return BoundingBox(\n            max_x=new_max_x,\n            max_y=new_max_y,\n            min_x=new_min_x,\n            min_y=new_min_y,\n        )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/math/bounding_box.html#pygerber.gerberx3.math.bounding_box.BoundingBox.width","title":"width  <code>property</code>","text":"<pre><code>width: Offset\n</code></pre> <p>Return width of the bounding box.</p>"},{"location":"reference/pygerber/gerberx3/math/bounding_box.html#pygerber.gerberx3.math.bounding_box.BoundingBox.height","title":"height  <code>property</code>","text":"<pre><code>height: Offset\n</code></pre> <p>Return height of the bounding box.</p>"},{"location":"reference/pygerber/gerberx3/math/bounding_box.html#pygerber.gerberx3.math.bounding_box.BoundingBox.center","title":"center  <code>property</code>","text":"<pre><code>center: Vector2D\n</code></pre> <p>Return current center of the bounding box.</p>"},{"location":"reference/pygerber/gerberx3/math/bounding_box.html#pygerber.gerberx3.math.bounding_box.BoundingBox.from_diameter","title":"from_diameter  <code>classmethod</code>","text":"<pre><code>from_diameter(diameter: Offset) -&gt; BoundingBox\n</code></pre> <p>Create a bounding box from a given diameter.</p> Source code in <code>src/pygerber/gerberx3/math/bounding_box.py</code> <pre><code>@classmethod\ndef from_diameter(cls, diameter: Offset) -&gt; BoundingBox:\n    \"\"\"Create a bounding box from a given diameter.\"\"\"\n    half_diameter = diameter / 2\n    return cls(\n        max_x=half_diameter,\n        max_y=half_diameter,\n        min_x=-half_diameter,\n        min_y=-half_diameter,\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/math/bounding_box.html#pygerber.gerberx3.math.bounding_box.BoundingBox.from_rectangle","title":"from_rectangle  <code>classmethod</code>","text":"<pre><code>from_rectangle(\n    x_size: Offset, y_size: Offset\n) -&gt; BoundingBox\n</code></pre> <p>Create a bounding box from a given diameter.</p> Source code in <code>src/pygerber/gerberx3/math/bounding_box.py</code> <pre><code>@classmethod\ndef from_rectangle(cls, x_size: Offset, y_size: Offset) -&gt; BoundingBox:\n    \"\"\"Create a bounding box from a given diameter.\"\"\"\n    half_x = x_size / 2\n    half_y = y_size / 2\n    return cls(\n        max_x=half_x,\n        max_y=half_y,\n        min_x=-half_x,\n        min_y=-half_y,\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/math/bounding_box.html#pygerber.gerberx3.math.bounding_box.BoundingBox.get_size","title":"get_size","text":"<pre><code>get_size() -&gt; Vector2D\n</code></pre> <p>Get bounding box size.</p> Source code in <code>src/pygerber/gerberx3/math/bounding_box.py</code> <pre><code>def get_size(self) -&gt; Vector2D:\n    \"\"\"Get bounding box size.\"\"\"\n    return Vector2D(x=self.width, y=self.height)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/math/bounding_box.html#pygerber.gerberx3.math.bounding_box.BoundingBox.get_min_vector","title":"get_min_vector","text":"<pre><code>get_min_vector() -&gt; Vector2D\n</code></pre> <p>Return Vector2D of min_x and min_y.</p> Source code in <code>src/pygerber/gerberx3/math/bounding_box.py</code> <pre><code>def get_min_vector(self) -&gt; Vector2D:\n    \"\"\"Return Vector2D of min_x and min_y.\"\"\"\n    return Vector2D(x=self.min_x, y=self.min_y)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/math/bounding_box.html#pygerber.gerberx3.math.bounding_box.BoundingBox.as_pixel_box","title":"as_pixel_box","text":"<pre><code>as_pixel_box(\n    dpi: int,\n    *,\n    dx_max: int = 0,\n    dy_max: int = 0,\n    dx_min: int = 0,\n    dy_min: int = 0\n) -&gt; PixelBox\n</code></pre> <p>Return box as tuple of ints with order.</p> <p>[x0, y0, x1, y1], where x1 &gt;= x0 and y1 &gt;= y0</p> Source code in <code>src/pygerber/gerberx3/math/bounding_box.py</code> <pre><code>def as_pixel_box(\n    self,\n    dpi: int,\n    *,\n    dx_max: int = 0,\n    dy_max: int = 0,\n    dx_min: int = 0,\n    dy_min: int = 0,\n) -&gt; PixelBox:\n    \"\"\"Return box as tuple of ints with order.\n\n    [x0, y0, x1, y1], where x1 &gt;= x0 and y1 &gt;= y0\n    \"\"\"\n    return PixelBox(\n        (\n            self.min_x.as_pixels(dpi) + dx_min,\n            self.min_y.as_pixels(dpi) + dy_min,\n            self.max_x.as_pixels(dpi) + dx_max,\n            self.max_y.as_pixels(dpi) + dy_max,\n        ),\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/math/bounding_box.html#pygerber.gerberx3.math.bounding_box.BoundingBox.include_point","title":"include_point","text":"<pre><code>include_point(point: Vector2D) -&gt; BoundingBox\n</code></pre> <p>Include point in bounding box by extending bounding box overt the point.</p> Source code in <code>src/pygerber/gerberx3/math/bounding_box.py</code> <pre><code>def include_point(self, point: Vector2D) -&gt; BoundingBox:\n    \"\"\"Include point in bounding box by extending bounding box overt the point.\"\"\"\n    # Check for the x-coordinate\n    new_max_x = max(self.max_x, point.x)\n    new_min_x = min(self.min_x, point.x)\n\n    # Check for the y-coordinate\n    new_max_y = max(self.max_y, point.y)\n    new_min_y = min(self.min_y, point.y)\n\n    return BoundingBox(\n        max_x=new_max_x,\n        max_y=new_max_y,\n        min_x=new_min_x,\n        min_y=new_min_y,\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/math/bounding_box.html#pygerber.gerberx3.math.bounding_box.PixelBox","title":"PixelBox","text":"<p>             Bases: <code>Tuple[int, int, int, int]</code></p> <p>Custom class for representing pixel boxes.</p> Source code in <code>src/pygerber/gerberx3/math/bounding_box.py</code> <pre><code>class PixelBox(Tuple[int, int, int, int]):\n    \"\"\"Custom class for representing pixel boxes.\"\"\"\n\n    __slots__ = ()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/math/offset.html","title":"offset","text":""},{"location":"reference/pygerber/gerberx3/math/offset.html#pygerber.gerberx3.math.offset","title":"offset","text":"<p>Offset representation used by drawing backend.</p>"},{"location":"reference/pygerber/gerberx3/math/offset.html#pygerber.gerberx3.math.offset.Offset","title":"Offset","text":"<p>             Bases: <code>FrozenGeneralModel</code></p> <p>Class representing offset in 2D space.</p> Source code in <code>src/pygerber/gerberx3/math/offset.py</code> <pre><code>class Offset(FrozenGeneralModel):\n    \"\"\"Class representing offset in 2D space.\"\"\"\n\n    NULL: ClassVar[Offset]\n\n    value: Decimal\n\n    @classmethod\n    def new(\n        cls,\n        value: Decimal | float | str | tuple[int, Sequence[int], int],\n        unit: Unit = Unit.Millimeters,\n    ) -&gt; Self:\n        \"\"\"Initialize offset with value.\"\"\"\n        # Gerber spec recommends using millimeters as unit, so they are used here too.\n        if unit == Unit.Millimeters:\n            value = Decimal(value)\n        else:\n            value = Decimal(value) * INCH_TO_MM_MULTIPLIER\n\n        return cls(value=value)\n\n    @classmethod\n    def from_pixels(\n        cls,\n        value: Decimal | float | str | tuple[int, Sequence[int], int],\n        dpi: int,\n    ) -&gt; Self:\n        \"\"\"Initialize offset with value.\"\"\"\n        # Gerber spec recommends using millimeters as unit, so they are used here too.\n        value = (Decimal(value) / dpi) * INCH_TO_MM_MULTIPLIER\n        return cls(value=value)\n\n    def as_millimeters(self) -&gt; Decimal:\n        \"\"\"Offset in millimeters.\"\"\"\n        return self.value\n\n    def as_inches(self) -&gt; Decimal:\n        \"\"\"Offset in millimeters.\"\"\"\n        return self.value * MM_TO_INCH_MULTIPLIER\n\n    def as_unit(self, unit: Unit) -&gt; Decimal:\n        \"\"\"Offset in specified unit.\"\"\"\n        if unit == Unit.Inches:\n            return self.as_inches()\n\n        return self.as_millimeters()\n\n    def as_pixels(self, dpi: int | Decimal) -&gt; int:\n        \"\"\"Offset in pixels with respect to drawing DPI.\"\"\"\n        return int(self.as_inches() * dpi)\n\n    def _compare(\n        self,\n        other: object,\n        op: Callable,\n    ) -&gt; bool:\n        if isinstance(other, Offset):\n            return op(self.value, other.value)  # type: ignore[no-any-return]\n        if isinstance(other, (Decimal, int, float, str)):\n            return op(self.value, Decimal(other))  # type: ignore[no-any-return]\n        return NotImplemented\n\n    def __eq__(self, other: object) -&gt; bool:\n        return self._compare(other, operator.eq)\n\n    def __lt__(self, other: object) -&gt; bool:\n        return self._compare(other, operator.lt)\n\n    def __le__(self, other: object) -&gt; bool:\n        return self._compare(other, operator.le)\n\n    def __gt__(self, other: object) -&gt; bool:\n        return self._compare(other, operator.gt)\n\n    def __ge__(self, other: object) -&gt; bool:\n        return self._compare(other, operator.ge)\n\n    def _operator(\n        self,\n        other: object,\n        op: Callable,\n    ) -&gt; Offset:\n        if isinstance(other, Offset):\n            return Offset(value=op(self.value, other.value))\n        if isinstance(other, (Decimal, int, float, str)):\n            return Offset(value=op(self.value, Decimal(other)))\n        return NotImplemented\n\n    def __add__(self, other: object) -&gt; Offset:\n        return self._operator(other, operator.add)\n\n    def __sub__(self, other: object) -&gt; Offset:\n        return self._operator(other, operator.sub)\n\n    def __mul__(self, other: object) -&gt; Offset:\n        return self._operator(other, operator.mul)\n\n    def __truediv__(self, other: object) -&gt; Offset:\n        return self._operator(other, operator.truediv)\n\n    def __neg__(self) -&gt; Offset:\n        return Offset(value=-self.value)\n\n    def _i_operator(\n        self,\n        other: object,\n        op: Callable,\n    ) -&gt; Self:\n        if isinstance(other, Offset):\n            return self.model_copy(\n                update={\n                    \"value\": op(self.value, other.value),\n                },\n            )\n        if isinstance(other, (Decimal, int, float, str)):\n            return self.model_copy(\n                update={\n                    \"value\": op(self.value, Decimal(other)),\n                },\n            )\n        return NotImplemented\n\n    def __iadd__(self, other: object) -&gt; Self:\n        return self._i_operator(other, operator.add)\n\n    def __isub__(self, other: object) -&gt; Self:\n        return self._i_operator(other, operator.sub)\n\n    def __imul__(self, other: object) -&gt; Self:\n        return self._i_operator(other, operator.mul)\n\n    def __itruediv__(self, other: object) -&gt; Self:\n        return self._i_operator(other, operator.truediv)\n\n    def __str__(self) -&gt; str:\n        return f\"Offset({float(self.value)})\"\n\n    __repr__ = __str__\n</code></pre>"},{"location":"reference/pygerber/gerberx3/math/offset.html#pygerber.gerberx3.math.offset.Offset.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(\n    value: Decimal\n    | float\n    | str\n    | tuple[int, Sequence[int], int],\n    unit: Unit = Unit.Millimeters,\n) -&gt; Self\n</code></pre> <p>Initialize offset with value.</p> Source code in <code>src/pygerber/gerberx3/math/offset.py</code> <pre><code>@classmethod\ndef new(\n    cls,\n    value: Decimal | float | str | tuple[int, Sequence[int], int],\n    unit: Unit = Unit.Millimeters,\n) -&gt; Self:\n    \"\"\"Initialize offset with value.\"\"\"\n    # Gerber spec recommends using millimeters as unit, so they are used here too.\n    if unit == Unit.Millimeters:\n        value = Decimal(value)\n    else:\n        value = Decimal(value) * INCH_TO_MM_MULTIPLIER\n\n    return cls(value=value)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/math/offset.html#pygerber.gerberx3.math.offset.Offset.from_pixels","title":"from_pixels  <code>classmethod</code>","text":"<pre><code>from_pixels(\n    value: Decimal\n    | float\n    | str\n    | tuple[int, Sequence[int], int],\n    dpi: int,\n) -&gt; Self\n</code></pre> <p>Initialize offset with value.</p> Source code in <code>src/pygerber/gerberx3/math/offset.py</code> <pre><code>@classmethod\ndef from_pixels(\n    cls,\n    value: Decimal | float | str | tuple[int, Sequence[int], int],\n    dpi: int,\n) -&gt; Self:\n    \"\"\"Initialize offset with value.\"\"\"\n    # Gerber spec recommends using millimeters as unit, so they are used here too.\n    value = (Decimal(value) / dpi) * INCH_TO_MM_MULTIPLIER\n    return cls(value=value)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/math/offset.html#pygerber.gerberx3.math.offset.Offset.as_millimeters","title":"as_millimeters","text":"<pre><code>as_millimeters() -&gt; Decimal\n</code></pre> <p>Offset in millimeters.</p> Source code in <code>src/pygerber/gerberx3/math/offset.py</code> <pre><code>def as_millimeters(self) -&gt; Decimal:\n    \"\"\"Offset in millimeters.\"\"\"\n    return self.value\n</code></pre>"},{"location":"reference/pygerber/gerberx3/math/offset.html#pygerber.gerberx3.math.offset.Offset.as_inches","title":"as_inches","text":"<pre><code>as_inches() -&gt; Decimal\n</code></pre> <p>Offset in millimeters.</p> Source code in <code>src/pygerber/gerberx3/math/offset.py</code> <pre><code>def as_inches(self) -&gt; Decimal:\n    \"\"\"Offset in millimeters.\"\"\"\n    return self.value * MM_TO_INCH_MULTIPLIER\n</code></pre>"},{"location":"reference/pygerber/gerberx3/math/offset.html#pygerber.gerberx3.math.offset.Offset.as_unit","title":"as_unit","text":"<pre><code>as_unit(unit: Unit) -&gt; Decimal\n</code></pre> <p>Offset in specified unit.</p> Source code in <code>src/pygerber/gerberx3/math/offset.py</code> <pre><code>def as_unit(self, unit: Unit) -&gt; Decimal:\n    \"\"\"Offset in specified unit.\"\"\"\n    if unit == Unit.Inches:\n        return self.as_inches()\n\n    return self.as_millimeters()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/math/offset.html#pygerber.gerberx3.math.offset.Offset.as_pixels","title":"as_pixels","text":"<pre><code>as_pixels(dpi: int | Decimal) -&gt; int\n</code></pre> <p>Offset in pixels with respect to drawing DPI.</p> Source code in <code>src/pygerber/gerberx3/math/offset.py</code> <pre><code>def as_pixels(self, dpi: int | Decimal) -&gt; int:\n    \"\"\"Offset in pixels with respect to drawing DPI.\"\"\"\n    return int(self.as_inches() * dpi)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/math/rotate_point.html","title":"rotate_point","text":""},{"location":"reference/pygerber/gerberx3/math/rotate_point.html#pygerber.gerberx3.math.rotate_point","title":"rotate_point","text":"<p>Tool for rotating point around center.</p>"},{"location":"reference/pygerber/gerberx3/math/rotate_point.html#pygerber.gerberx3.math.rotate_point.rotate_point","title":"rotate_point","text":"<pre><code>rotate_point(\n    center: Vector2D,\n    angle: Decimal | float,\n    point: Vector2D,\n) -&gt; Vector2D\n</code></pre> <p>Rotate point around center by given angle.</p> Source code in <code>src/pygerber/gerberx3/math/rotate_point.py</code> <pre><code>def rotate_point(center: Vector2D, angle: Decimal | float, point: Vector2D) -&gt; Vector2D:\n    \"\"\"Rotate point around center by given angle.\"\"\"\n    s = sin(angle)\n    c = cos(angle)\n\n    # Translate point back to origin\n    x, y = point.x, point.y\n    x -= center.x\n    y -= center.y\n\n    # Rotate point\n    x_new = x * c - y * s\n    y_new = x * s + y * c\n\n    # Translate point back\n    x = x_new + center.x\n    y = y_new + center.y\n\n    return Vector2D(x=x, y=y)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/math/vector_2d.html","title":"vector_2d","text":""},{"location":"reference/pygerber/gerberx3/math/vector_2d.html#pygerber.gerberx3.math.vector_2d","title":"vector_2d","text":"<p>Simple of 2D vector container class.</p>"},{"location":"reference/pygerber/gerberx3/math/vector_2d.html#pygerber.gerberx3.math.vector_2d.Vector2D","title":"Vector2D","text":"<p>             Bases: <code>FrozenGeneralModel</code></p> <p>Tuple wrapper for representing size with custom accessors.</p> Source code in <code>src/pygerber/gerberx3/math/vector_2d.py</code> <pre><code>class Vector2D(FrozenGeneralModel):\n    \"\"\"Tuple wrapper for representing size with custom accessors.\"\"\"\n\n    NULL: ClassVar[Vector2D]\n    UNIT_X: ClassVar[Vector2D]\n    UNIT_Y: ClassVar[Vector2D]\n\n    x: Offset\n    y: Offset\n\n    @classmethod\n    def new(\n        cls,\n        x: float | str | Decimal,\n        y: float | str | Decimal,\n        unit: Unit = Unit.Millimeters,\n    ) -&gt; Self:\n        \"\"\"Create new vector with default Offset constructor.\"\"\"\n        return cls(\n            x=Offset.new(Decimal(x), unit=unit),\n            y=Offset.new(Decimal(y), unit=unit),\n        )\n\n    def get_mirrored(self, mirror: Mirroring) -&gt; Self:\n        \"\"\"Get mirrored vector.\"\"\"\n        return self._GET_MIRRORED_DISPATCH_TABLE[mirror](self)\n\n    def _get_mirrored_x(self) -&gt; Self:\n        return self.model_copy(\n            update={\n                \"x\": -self.x,\n            },\n        )\n\n    def _get_mirrored_y(self) -&gt; Self:\n        return self.model_copy(\n            update={\n                \"y\": -self.y,\n            },\n        )\n\n    def _get_mirrored_xy(self) -&gt; Self:\n        return self.model_copy(\n            update={\n                \"x\": -self.x,\n                \"y\": -self.y,\n            },\n        )\n\n    _GET_MIRRORED_DISPATCH_TABLE: ClassVar[dict[Mirroring, Callable[[Self], Self]]] = {\n        Mirroring.NoMirroring: lambda s: s,\n        Mirroring.X: _get_mirrored_x,\n        Mirroring.Y: _get_mirrored_y,\n        Mirroring.XY: _get_mirrored_xy,\n    }\n\n    def as_pixels(self, dpi: int) -&gt; tuple[int, int]:\n        \"\"\"Return size as pixels using given DPI for conversion.\"\"\"\n        return (self.x.as_pixels(dpi), self.y.as_pixels(dpi))\n\n    def __eq__(self, other: object) -&gt; bool:\n        if isinstance(other, Vector2D):\n            return self.x == other.x and self.y == other.y\n        return NotImplemented\n\n    def _operator(\n        self,\n        other: object,\n        op: Callable,\n    ) -&gt; Vector2D:\n        if isinstance(other, Offset):\n            return Vector2D(\n                x=op(self.x, other),\n                y=op(self.y, other),\n            )\n        if isinstance(other, Vector2D):\n            return Vector2D(\n                x=op(self.x, other.x),\n                y=op(self.y, other.y),\n            )\n\n        if isinstance(other, (Decimal, int, float, str)):\n            return Vector2D(\n                x=op(self.x, Decimal(other)),\n                y=op(self.y, Decimal(other)),\n            )\n        return NotImplemented\n\n    def __add__(self, other: object) -&gt; Vector2D:\n        return self._operator(other, operator.add)\n\n    def __sub__(self, other: object) -&gt; Vector2D:\n        return self._operator(other, operator.sub)\n\n    def __mul__(self, other: object) -&gt; Vector2D:\n        return self._operator(other, operator.mul)\n\n    def __truediv__(self, other: object) -&gt; Vector2D:\n        return self._operator(other, operator.truediv)\n\n    def __neg__(self) -&gt; Vector2D:\n        return Vector2D(x=-self.x, y=-self.y)\n\n    def _i_operator(\n        self,\n        other: object,\n        op: Callable,\n    ) -&gt; Self:\n        if isinstance(other, Vector2D):\n            return self.model_copy(\n                update={\n                    \"x\": op(self.x, other.x),\n                    \"y\": op(self.y, other.y),\n                },\n            )\n        if isinstance(other, Offset):\n            return self.model_copy(\n                update={\n                    \"x\": op(self.x, other),\n                    \"y\": op(self.y, other),\n                },\n            )\n        if isinstance(other, (Decimal, int, float, str)):\n            return self.model_copy(\n                update={\n                    \"x\": op(self.x, Decimal(other)),\n                    \"y\": op(self.y, Decimal(other)),\n                },\n            )\n        return NotImplemented\n\n    def __iadd__(self, other: object) -&gt; Self:\n        return self._i_operator(other, operator.add)\n\n    def __isub__(self, other: object) -&gt; Self:\n        return self._i_operator(other, operator.sub)\n\n    def __imul__(self, other: object) -&gt; Self:\n        return self._i_operator(other, operator.mul)\n\n    def __itruediv__(self, other: object) -&gt; Self:\n        return self._i_operator(other, operator.truediv)\n\n    def __str__(self) -&gt; str:\n        return f\"{self.__class__.__qualname__}(x={self.x}, y={self.y})\"\n\n    def length(self) -&gt; Offset:\n        \"\"\"Return length of vector.\"\"\"\n        return Offset(value=((self.x * self.x).value + (self.y * self.y).value).sqrt())\n\n    def angle_between_clockwise(self, other: Vector2D) -&gt; float:\n        \"\"\"Calculate angle between two vectors in degrees clockwise.\n\n        (Bugged?)\n        \"\"\"\n        self_norm = self / self.length()\n        other_norm = other / other.length()\n\n        dot = other_norm.dot(self_norm)\n        determinant = self_norm.determinant(other_norm)\n\n        theta = math.atan2(float(dot.value), float(determinant.value))\n\n        return math.degrees(theta)\n\n    def angle_between(self, other: Vector2D) -&gt; float:\n        \"\"\"Calculate clockwise angle between two vectors in degrees clockwise.\n\n        Value returned is always between 0 and 360 (can be 0, never 360).\n        \"\"\"\n        return 360 - self.angle_between_cc(other)\n\n    def angle_between_cc(self, other: Vector2D) -&gt; float:\n        \"\"\"Calculate counter clockwise angle between two vectors in degrees.\n\n        Value returned is always between 0 and 360 (can be 0, never 360).\n        \"\"\"\n        v0 = self.normalize()\n        v1 = other.normalize()\n        angle_radians = math.atan2(\n            ((v0.x * v1.y) - (v1.x * v0.y)).value,  # determinant\n            ((v0.x * v1.x) + (v0.y * v1.y)).value,  # dot product\n        )\n        angle_degrees = math.degrees(angle_radians)\n        return angle_degrees + (360 * (angle_degrees &lt; 0))\n\n    def dot(self, other: Vector2D) -&gt; Offset:\n        \"\"\"Calculate dot product of two vectors.\"\"\"\n        return self.x * other.x + self.y * other.y\n\n    def determinant(self, other: Vector2D) -&gt; Offset:\n        \"\"\"Calculate determinant of matrix constructed from self and other.\"\"\"\n        return self.x * other.y - self.y * other.x\n\n    def perpendicular(self) -&gt; Vector2D:\n        \"\"\"Return perpendicular vector to self.\"\"\"\n        return Vector2D(x=self.y, y=-self.x)\n\n    def normalize(self) -&gt; Vector2D:\n        \"\"\"Return normalized (unit length) vector.\"\"\"\n        if self == Vector2D.NULL:\n            return Vector2D.UNIT_X\n\n        return self / self.length()\n\n    def as_float_tuple(self) -&gt; tuple[float, float]:\n        \"\"\"Return x, y Offset as tuple.\"\"\"\n        return (float(self.x.value), float(self.y.value))\n\n    def rotate_around_origin(self, angle_degrees: Decimal) -&gt; Vector2D:\n        \"\"\"Return vector rotated x degrees around origin.\"\"\"\n        angle_radians = math.radians(angle_degrees)\n        return Vector2D(\n            x=self.x * math.cos(angle_radians) - self.y * math.sin(angle_radians),\n            y=self.x * math.sin(angle_radians) + self.y * math.cos(angle_radians),\n        )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/math/vector_2d.html#pygerber.gerberx3.math.vector_2d.Vector2D.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(\n    x: float | str | Decimal,\n    y: float | str | Decimal,\n    unit: Unit = Unit.Millimeters,\n) -&gt; Self\n</code></pre> <p>Create new vector with default Offset constructor.</p> Source code in <code>src/pygerber/gerberx3/math/vector_2d.py</code> <pre><code>@classmethod\ndef new(\n    cls,\n    x: float | str | Decimal,\n    y: float | str | Decimal,\n    unit: Unit = Unit.Millimeters,\n) -&gt; Self:\n    \"\"\"Create new vector with default Offset constructor.\"\"\"\n    return cls(\n        x=Offset.new(Decimal(x), unit=unit),\n        y=Offset.new(Decimal(y), unit=unit),\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/math/vector_2d.html#pygerber.gerberx3.math.vector_2d.Vector2D.get_mirrored","title":"get_mirrored","text":"<pre><code>get_mirrored(mirror: Mirroring) -&gt; Self\n</code></pre> <p>Get mirrored vector.</p> Source code in <code>src/pygerber/gerberx3/math/vector_2d.py</code> <pre><code>def get_mirrored(self, mirror: Mirroring) -&gt; Self:\n    \"\"\"Get mirrored vector.\"\"\"\n    return self._GET_MIRRORED_DISPATCH_TABLE[mirror](self)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/math/vector_2d.html#pygerber.gerberx3.math.vector_2d.Vector2D.as_pixels","title":"as_pixels","text":"<pre><code>as_pixels(dpi: int) -&gt; tuple[int, int]\n</code></pre> <p>Return size as pixels using given DPI for conversion.</p> Source code in <code>src/pygerber/gerberx3/math/vector_2d.py</code> <pre><code>def as_pixels(self, dpi: int) -&gt; tuple[int, int]:\n    \"\"\"Return size as pixels using given DPI for conversion.\"\"\"\n    return (self.x.as_pixels(dpi), self.y.as_pixels(dpi))\n</code></pre>"},{"location":"reference/pygerber/gerberx3/math/vector_2d.html#pygerber.gerberx3.math.vector_2d.Vector2D.length","title":"length","text":"<pre><code>length() -&gt; Offset\n</code></pre> <p>Return length of vector.</p> Source code in <code>src/pygerber/gerberx3/math/vector_2d.py</code> <pre><code>def length(self) -&gt; Offset:\n    \"\"\"Return length of vector.\"\"\"\n    return Offset(value=((self.x * self.x).value + (self.y * self.y).value).sqrt())\n</code></pre>"},{"location":"reference/pygerber/gerberx3/math/vector_2d.html#pygerber.gerberx3.math.vector_2d.Vector2D.angle_between_clockwise","title":"angle_between_clockwise","text":"<pre><code>angle_between_clockwise(other: Vector2D) -&gt; float\n</code></pre> <p>Calculate angle between two vectors in degrees clockwise.</p> <p>(Bugged?)</p> Source code in <code>src/pygerber/gerberx3/math/vector_2d.py</code> <pre><code>def angle_between_clockwise(self, other: Vector2D) -&gt; float:\n    \"\"\"Calculate angle between two vectors in degrees clockwise.\n\n    (Bugged?)\n    \"\"\"\n    self_norm = self / self.length()\n    other_norm = other / other.length()\n\n    dot = other_norm.dot(self_norm)\n    determinant = self_norm.determinant(other_norm)\n\n    theta = math.atan2(float(dot.value), float(determinant.value))\n\n    return math.degrees(theta)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/math/vector_2d.html#pygerber.gerberx3.math.vector_2d.Vector2D.angle_between","title":"angle_between","text":"<pre><code>angle_between(other: Vector2D) -&gt; float\n</code></pre> <p>Calculate clockwise angle between two vectors in degrees clockwise.</p> <p>Value returned is always between 0 and 360 (can be 0, never 360).</p> Source code in <code>src/pygerber/gerberx3/math/vector_2d.py</code> <pre><code>def angle_between(self, other: Vector2D) -&gt; float:\n    \"\"\"Calculate clockwise angle between two vectors in degrees clockwise.\n\n    Value returned is always between 0 and 360 (can be 0, never 360).\n    \"\"\"\n    return 360 - self.angle_between_cc(other)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/math/vector_2d.html#pygerber.gerberx3.math.vector_2d.Vector2D.angle_between_cc","title":"angle_between_cc","text":"<pre><code>angle_between_cc(other: Vector2D) -&gt; float\n</code></pre> <p>Calculate counter clockwise angle between two vectors in degrees.</p> <p>Value returned is always between 0 and 360 (can be 0, never 360).</p> Source code in <code>src/pygerber/gerberx3/math/vector_2d.py</code> <pre><code>def angle_between_cc(self, other: Vector2D) -&gt; float:\n    \"\"\"Calculate counter clockwise angle between two vectors in degrees.\n\n    Value returned is always between 0 and 360 (can be 0, never 360).\n    \"\"\"\n    v0 = self.normalize()\n    v1 = other.normalize()\n    angle_radians = math.atan2(\n        ((v0.x * v1.y) - (v1.x * v0.y)).value,  # determinant\n        ((v0.x * v1.x) + (v0.y * v1.y)).value,  # dot product\n    )\n    angle_degrees = math.degrees(angle_radians)\n    return angle_degrees + (360 * (angle_degrees &lt; 0))\n</code></pre>"},{"location":"reference/pygerber/gerberx3/math/vector_2d.html#pygerber.gerberx3.math.vector_2d.Vector2D.dot","title":"dot","text":"<pre><code>dot(other: Vector2D) -&gt; Offset\n</code></pre> <p>Calculate dot product of two vectors.</p> Source code in <code>src/pygerber/gerberx3/math/vector_2d.py</code> <pre><code>def dot(self, other: Vector2D) -&gt; Offset:\n    \"\"\"Calculate dot product of two vectors.\"\"\"\n    return self.x * other.x + self.y * other.y\n</code></pre>"},{"location":"reference/pygerber/gerberx3/math/vector_2d.html#pygerber.gerberx3.math.vector_2d.Vector2D.determinant","title":"determinant","text":"<pre><code>determinant(other: Vector2D) -&gt; Offset\n</code></pre> <p>Calculate determinant of matrix constructed from self and other.</p> Source code in <code>src/pygerber/gerberx3/math/vector_2d.py</code> <pre><code>def determinant(self, other: Vector2D) -&gt; Offset:\n    \"\"\"Calculate determinant of matrix constructed from self and other.\"\"\"\n    return self.x * other.y - self.y * other.x\n</code></pre>"},{"location":"reference/pygerber/gerberx3/math/vector_2d.html#pygerber.gerberx3.math.vector_2d.Vector2D.perpendicular","title":"perpendicular","text":"<pre><code>perpendicular() -&gt; Vector2D\n</code></pre> <p>Return perpendicular vector to self.</p> Source code in <code>src/pygerber/gerberx3/math/vector_2d.py</code> <pre><code>def perpendicular(self) -&gt; Vector2D:\n    \"\"\"Return perpendicular vector to self.\"\"\"\n    return Vector2D(x=self.y, y=-self.x)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/math/vector_2d.html#pygerber.gerberx3.math.vector_2d.Vector2D.normalize","title":"normalize","text":"<pre><code>normalize() -&gt; Vector2D\n</code></pre> <p>Return normalized (unit length) vector.</p> Source code in <code>src/pygerber/gerberx3/math/vector_2d.py</code> <pre><code>def normalize(self) -&gt; Vector2D:\n    \"\"\"Return normalized (unit length) vector.\"\"\"\n    if self == Vector2D.NULL:\n        return Vector2D.UNIT_X\n\n    return self / self.length()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/math/vector_2d.html#pygerber.gerberx3.math.vector_2d.Vector2D.as_float_tuple","title":"as_float_tuple","text":"<pre><code>as_float_tuple() -&gt; tuple[float, float]\n</code></pre> <p>Return x, y Offset as tuple.</p> Source code in <code>src/pygerber/gerberx3/math/vector_2d.py</code> <pre><code>def as_float_tuple(self) -&gt; tuple[float, float]:\n    \"\"\"Return x, y Offset as tuple.\"\"\"\n    return (float(self.x.value), float(self.y.value))\n</code></pre>"},{"location":"reference/pygerber/gerberx3/math/vector_2d.html#pygerber.gerberx3.math.vector_2d.Vector2D.rotate_around_origin","title":"rotate_around_origin","text":"<pre><code>rotate_around_origin(angle_degrees: Decimal) -&gt; Vector2D\n</code></pre> <p>Return vector rotated x degrees around origin.</p> Source code in <code>src/pygerber/gerberx3/math/vector_2d.py</code> <pre><code>def rotate_around_origin(self, angle_degrees: Decimal) -&gt; Vector2D:\n    \"\"\"Return vector rotated x degrees around origin.\"\"\"\n    angle_radians = math.radians(angle_degrees)\n    return Vector2D(\n        x=self.x * math.cos(angle_radians) - self.y * math.sin(angle_radians),\n        y=self.x * math.sin(angle_radians) + self.y * math.cos(angle_radians),\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/optimizer/__init__.html","title":"init","text":""},{"location":"reference/pygerber/gerberx3/optimizer/__init__.html#pygerber.gerberx3.optimizer","title":"optimizer","text":"<p>Gerber code optimizer.</p>"},{"location":"reference/pygerber/gerberx3/optimizer/optimizer_pass/__init__.html","title":"optimizer_pass","text":""},{"location":"reference/pygerber/gerberx3/optimizer/optimizer_pass/__init__.html#pygerber.gerberx3.optimizer.optimizer_pass","title":"optimizer_pass","text":"<p>Namespace for optimizer passes.</p>"},{"location":"reference/pygerber/gerberx3/parser/__init__.html","title":"init","text":""},{"location":"reference/pygerber/gerberx3/parser/__init__.html#pygerber.gerberx3.parser","title":"parser","text":"<p>Gerber X3 parer.</p>"},{"location":"reference/pygerber/gerberx3/parser/errors.html","title":"errors","text":""},{"location":"reference/pygerber/gerberx3/parser/errors.html#pygerber.gerberx3.parser.errors","title":"errors","text":"<p>Base error classes used in this module.</p>"},{"location":"reference/pygerber/gerberx3/parser/errors.html#pygerber.gerberx3.parser.errors.ParserError","title":"ParserError","text":"<p>             Bases: <code>ValueError</code></p> <p>Base class for parser errors.</p> <p>Exceptions derived from this exception are exclusively raised in PyGerber's Gerber X3 Parser. This exception can be used in <code>try: ... except ParserError: ...</code> block to catch all exceptions raised by Parser while allowing other exceptions to interrupt execution.</p> Source code in <code>src/pygerber/gerberx3/parser/errors.py</code> <pre><code>class ParserError(ValueError):\n    \"\"\"Base class for parser errors.\n\n    Exceptions derived from this exception are exclusively raised in PyGerber's Gerber\n    X3 Parser. This exception can be used in\n    `#!python try: ... except ParserError: ...` block to catch all exceptions\n    raised by Parser while allowing other exceptions to interrupt execution.\n    \"\"\"\n\n    def get_message(self) -&gt; str:\n        \"\"\"Get parser error help message.\"\"\"\n        return f\"{self.__class__.__qualname__}: {self.__doc__}\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser/errors.html#pygerber.gerberx3.parser.errors.ParserError.get_message","title":"get_message","text":"<pre><code>get_message() -&gt; str\n</code></pre> <p>Get parser error help message.</p> Source code in <code>src/pygerber/gerberx3/parser/errors.py</code> <pre><code>def get_message(self) -&gt; str:\n    \"\"\"Get parser error help message.\"\"\"\n    return f\"{self.__class__.__qualname__}: {self.__doc__}\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser/errors.html#pygerber.gerberx3.parser.errors.ZeroOmissionNotSupportedError","title":"ZeroOmissionNotSupportedError","text":"<p>             Bases: <code>ParserError</code></p> <p>Raised when incremental coordinates are selected. (Spec. 8.2.1.2).</p> Source code in <code>src/pygerber/gerberx3/parser/errors.py</code> <pre><code>class ZeroOmissionNotSupportedError(ParserError):\n    \"\"\"Raised when incremental coordinates are selected. (Spec. 8.2.1.2).\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser/errors.html#pygerber.gerberx3.parser.errors.IncrementalCoordinatesNotSupportedError","title":"IncrementalCoordinatesNotSupportedError","text":"<p>             Bases: <code>ParserError</code></p> <p>Raised when incremental coordinates are selected. (Spec. 8.2.1.2).</p> Source code in <code>src/pygerber/gerberx3/parser/errors.py</code> <pre><code>class IncrementalCoordinatesNotSupportedError(ParserError):\n    \"\"\"Raised when incremental coordinates are selected. (Spec. 8.2.1.2).\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser/errors.html#pygerber.gerberx3.parser.errors.UnsupportedCoordinateTypeError","title":"UnsupportedCoordinateTypeError","text":"<p>             Bases: <code>ParserError</code></p> <p>Raised for unsupported coordinate types.</p> Source code in <code>src/pygerber/gerberx3/parser/errors.py</code> <pre><code>class UnsupportedCoordinateTypeError(ParserError):\n    \"\"\"Raised for unsupported coordinate types.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser/errors.html#pygerber.gerberx3.parser.errors.InvalidCoordinateLengthError","title":"InvalidCoordinateLengthError","text":"<p>             Bases: <code>ParserError</code></p> <p>Raised when coordinate string is too long.</p> Source code in <code>src/pygerber/gerberx3/parser/errors.py</code> <pre><code>class InvalidCoordinateLengthError(ParserError):\n    \"\"\"Raised when coordinate string is too long.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser/errors.html#pygerber.gerberx3.parser.errors.ParserFatalError","title":"ParserFatalError","text":"<p>             Bases: <code>ParserError</code></p> <p>Raised when parser encounters fatal failure from non-parser specific exception.</p> Source code in <code>src/pygerber/gerberx3/parser/errors.py</code> <pre><code>class ParserFatalError(ParserError):\n    \"\"\"Raised when parser encounters fatal failure from non-parser specific\n    exception.\n    \"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser/errors.html#pygerber.gerberx3.parser.errors.OnUpdateDrawingStateError","title":"OnUpdateDrawingStateError","text":"<p>             Bases: <code>ParserError</code></p> <p>Raised when parser encounters fatal failure from non-parser specific exception during call to .update_drawing_state() call.</p> Source code in <code>src/pygerber/gerberx3/parser/errors.py</code> <pre><code>class OnUpdateDrawingStateError(ParserError):\n    \"\"\"Raised when parser encounters fatal failure from non-parser specific\n    exception during call to .update_drawing_state() call.\n    \"\"\"\n\n    def __init__(self, token: Token, *args: object) -&gt; None:\n        super().__init__(*args)\n        self.token = token\n\n    def __str__(self) -&gt; str:\n        return f\"{self.token} {self.token.get_token_position()}\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser/errors.html#pygerber.gerberx3.parser.errors.UnitNotSetError","title":"UnitNotSetError","text":"<p>             Bases: <code>ParserError</code></p> <p>Raised when operation which requires units to be set is executed before units are set.</p> Source code in <code>src/pygerber/gerberx3/parser/errors.py</code> <pre><code>class UnitNotSetError(ParserError):\n    \"\"\"Raised when operation which requires units to be set is executed before units\n    are set.\n    \"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser/errors.html#pygerber.gerberx3.parser.errors.ApertureNotDefinedError","title":"ApertureNotDefinedError","text":"<p>             Bases: <code>ParserError</code></p> <p>Raised when undefined aperture is selected.</p> Source code in <code>src/pygerber/gerberx3/parser/errors.py</code> <pre><code>class ApertureNotDefinedError(ParserError):\n    \"\"\"Raised when undefined aperture is selected.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser/errors.html#pygerber.gerberx3.parser.errors.CoordinateFormatNotSetError","title":"CoordinateFormatNotSetError","text":"<p>             Bases: <code>ParserError</code></p> <p>Raised when coordinate parser is requested before coordinate format was set.</p> Source code in <code>src/pygerber/gerberx3/parser/errors.py</code> <pre><code>class CoordinateFormatNotSetError(ParserError):\n    \"\"\"Raised when coordinate parser is requested before coordinate format was set.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser/errors.html#pygerber.gerberx3.parser.errors.ApertureNotSelectedError","title":"ApertureNotSelectedError","text":"<p>             Bases: <code>ParserError</code></p> <p>Raised when attempting to use aperture without selecting it first.</p> Source code in <code>src/pygerber/gerberx3/parser/errors.py</code> <pre><code>class ApertureNotSelectedError(ParserError):\n    \"\"\"Raised when attempting to use aperture without selecting it first.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser/errors.html#pygerber.gerberx3.parser.errors.ExitParsingProcessInterrupt","title":"ExitParsingProcessInterrupt","text":"<p>             Bases: <code>Exception</code></p> <p>Raised to stop parsing.</p> Source code in <code>src/pygerber/gerberx3/parser/errors.py</code> <pre><code>class ExitParsingProcessInterrupt(Exception):  # noqa: N818\n    \"\"\"Raised to stop parsing.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser/parser.html","title":"parser","text":""},{"location":"reference/pygerber/gerberx3/parser/parser.html#pygerber.gerberx3.parser.parser","title":"parser","text":"<p>GerberX3 format parser.</p>"},{"location":"reference/pygerber/gerberx3/parser/parser.html#pygerber.gerberx3.parser.parser.Parser","title":"Parser","text":"<p>Gerber X3 parser object.</p> Source code in <code>src/pygerber/gerberx3/parser/parser.py</code> <pre><code>class Parser:\n    \"\"\"Gerber X3 parser object.\"\"\"\n\n    def __init__(\n        self,\n        options: Optional[ParserOptions] = None,\n    ) -&gt; None:\n        \"\"\"Initialize parser.\n\n        Parameters\n        ----------\n        options : ParserOptions | None\n            Additional options for modifying parser behavior.\n        \"\"\"\n        self.options = ParserOptions() if options is None else options\n        self.state = (\n            State()\n            if self.options.initial_state is None\n            else self.options.initial_state\n        )\n        self.draw_actions: list[DrawCommand] = []\n\n    @property\n    def backend(self) -&gt; Backend:\n        \"\"\"Get reference to backend object.\"\"\"\n        return self.options.backend\n\n    def parse(self, ast: AST) -&gt; DrawCommandsHandle:\n        \"\"\"Parse token stack.\"\"\"\n        for _ in self.parse_iter(ast):\n            pass\n\n        return self.get_draw_commands_handle()\n\n    def parse_iter(self, ast: AST) -&gt; Generator[tuple[Token, State], None, None]:\n        \"\"\"Iterate over tokens in stack and parse them.\"\"\"\n        self.state = (\n            State()\n            if self.options.initial_state is None\n            else self.options.initial_state\n        )\n        self.draw_actions = []\n\n        try:\n            for token in ast:\n                self._update_drawing_state(token)\n\n                yield token, self.state\n\n        except ExitParsingProcessInterrupt:\n            pass\n\n    def get_draw_commands_handle(self) -&gt; DrawCommandsHandle:\n        \"\"\"Return handle to drawing commands.\"\"\"\n        return self.backend.get_draw_commands_handle_cls()(\n            self.draw_actions,\n            self.backend,\n        )\n\n    def _update_drawing_state(self, token: Token) -&gt; None:\n        try:\n            self.state, actions = token.update_drawing_state(self.state, self.backend)\n            if actions is not None:\n                self.draw_actions.extend(actions)\n\n        except ExitParsingProcessInterrupt:\n            return\n\n        except Exception as e:  # noqa: BLE001\n            if self.options.on_update_drawing_state_error == ParserOnErrorAction.Ignore:\n                pass\n\n            elif (\n                self.options.on_update_drawing_state_error == ParserOnErrorAction.Raise\n            ):\n                if not isinstance(e, ParserError):\n                    raise OnUpdateDrawingStateError(token) from e\n\n                raise\n\n            elif self.options.on_update_drawing_state_error == ParserOnErrorAction.Warn:\n                logging.warning(\n                    \"Encountered fatal error during call to update_drawing_state() \"\n                    \"of '%s' token %s. Parser will skip this token and continue.\",\n                    token,\n                    token.get_token_position(),\n                )\n            else:\n                self.options.on_update_drawing_state_error(e, self, token)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser/parser.html#pygerber.gerberx3.parser.parser.Parser.backend","title":"backend  <code>property</code>","text":"<pre><code>backend: Backend\n</code></pre> <p>Get reference to backend object.</p>"},{"location":"reference/pygerber/gerberx3/parser/parser.html#pygerber.gerberx3.parser.parser.Parser.__init__","title":"__init__","text":"<pre><code>__init__(options: Optional[ParserOptions] = None) -&gt; None\n</code></pre> <p>Initialize parser.</p> <p>Parameters:</p> Name Type Description Default <code>options</code> <code>ParserOptions | None</code> <p>Additional options for modifying parser behavior.</p> <code>None</code> Source code in <code>src/pygerber/gerberx3/parser/parser.py</code> <pre><code>def __init__(\n    self,\n    options: Optional[ParserOptions] = None,\n) -&gt; None:\n    \"\"\"Initialize parser.\n\n    Parameters\n    ----------\n    options : ParserOptions | None\n        Additional options for modifying parser behavior.\n    \"\"\"\n    self.options = ParserOptions() if options is None else options\n    self.state = (\n        State()\n        if self.options.initial_state is None\n        else self.options.initial_state\n    )\n    self.draw_actions: list[DrawCommand] = []\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser/parser.html#pygerber.gerberx3.parser.parser.Parser.parse","title":"parse","text":"<pre><code>parse(ast: AST) -&gt; DrawCommandsHandle\n</code></pre> <p>Parse token stack.</p> Source code in <code>src/pygerber/gerberx3/parser/parser.py</code> <pre><code>def parse(self, ast: AST) -&gt; DrawCommandsHandle:\n    \"\"\"Parse token stack.\"\"\"\n    for _ in self.parse_iter(ast):\n        pass\n\n    return self.get_draw_commands_handle()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser/parser.html#pygerber.gerberx3.parser.parser.Parser.parse_iter","title":"parse_iter","text":"<pre><code>parse_iter(\n    ast: AST,\n) -&gt; Generator[tuple[Token, State], None, None]\n</code></pre> <p>Iterate over tokens in stack and parse them.</p> Source code in <code>src/pygerber/gerberx3/parser/parser.py</code> <pre><code>def parse_iter(self, ast: AST) -&gt; Generator[tuple[Token, State], None, None]:\n    \"\"\"Iterate over tokens in stack and parse them.\"\"\"\n    self.state = (\n        State()\n        if self.options.initial_state is None\n        else self.options.initial_state\n    )\n    self.draw_actions = []\n\n    try:\n        for token in ast:\n            self._update_drawing_state(token)\n\n            yield token, self.state\n\n    except ExitParsingProcessInterrupt:\n        pass\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser/parser.html#pygerber.gerberx3.parser.parser.Parser.get_draw_commands_handle","title":"get_draw_commands_handle","text":"<pre><code>get_draw_commands_handle() -&gt; DrawCommandsHandle\n</code></pre> <p>Return handle to drawing commands.</p> Source code in <code>src/pygerber/gerberx3/parser/parser.py</code> <pre><code>def get_draw_commands_handle(self) -&gt; DrawCommandsHandle:\n    \"\"\"Return handle to drawing commands.\"\"\"\n    return self.backend.get_draw_commands_handle_cls()(\n        self.draw_actions,\n        self.backend,\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser/parser.html#pygerber.gerberx3.parser.parser.StatePreservingParser","title":"StatePreservingParser","text":"<p>             Bases: <code>Parser</code></p> <p>Parser class which preserves all states for all tokens.</p> <p>Caution: High memory consumption.</p> Source code in <code>src/pygerber/gerberx3/parser/parser.py</code> <pre><code>class StatePreservingParser(Parser):\n    \"\"\"Parser class which preserves all states for all tokens.\n\n    Caution: High memory consumption.\n    \"\"\"\n\n    state_index: list[tuple[int, State]]\n\n    def __init__(self, options: ParserOptions | None = None) -&gt; None:\n        super().__init__(options)\n        self.state_index = []\n\n    def parse(self, ast: AST) -&gt; DrawCommandsHandle:\n        \"\"\"Parse token stack.\"\"\"\n        self.state_index = []\n        current_state = self.state\n\n        for token, state in self.parse_iter(ast):\n            if state != current_state:\n                self.state_index.append((token.location, state))\n\n        return self.get_draw_commands_handle()\n\n    def get_state_at(self, token: Token) -&gt; State:\n        \"\"\"Get state at given token.\n\n        Parser must have been already used to parse some AST.\n        \"\"\"\n        for location, state in self.state_index:\n            if location &lt;= token.location:\n                continue\n            return state\n\n        return self.state\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser/parser.html#pygerber.gerberx3.parser.parser.StatePreservingParser.parse","title":"parse","text":"<pre><code>parse(ast: AST) -&gt; DrawCommandsHandle\n</code></pre> <p>Parse token stack.</p> Source code in <code>src/pygerber/gerberx3/parser/parser.py</code> <pre><code>def parse(self, ast: AST) -&gt; DrawCommandsHandle:\n    \"\"\"Parse token stack.\"\"\"\n    self.state_index = []\n    current_state = self.state\n\n    for token, state in self.parse_iter(ast):\n        if state != current_state:\n            self.state_index.append((token.location, state))\n\n    return self.get_draw_commands_handle()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser/parser.html#pygerber.gerberx3.parser.parser.StatePreservingParser.get_state_at","title":"get_state_at","text":"<pre><code>get_state_at(token: Token) -&gt; State\n</code></pre> <p>Get state at given token.</p> <p>Parser must have been already used to parse some AST.</p> Source code in <code>src/pygerber/gerberx3/parser/parser.py</code> <pre><code>def get_state_at(self, token: Token) -&gt; State:\n    \"\"\"Get state at given token.\n\n    Parser must have been already used to parse some AST.\n    \"\"\"\n    for location, state in self.state_index:\n        if location &lt;= token.location:\n            continue\n        return state\n\n    return self.state\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser/parser.html#pygerber.gerberx3.parser.parser.ParserOnErrorAction","title":"ParserOnErrorAction","text":"<p>             Bases: <code>Enum</code></p> <p>Possible error actions.</p> Source code in <code>src/pygerber/gerberx3/parser/parser.py</code> <pre><code>class ParserOnErrorAction(Enum):\n    \"\"\"Possible error actions.\"\"\"\n\n    Ignore = \"ignore\"\n    \"\"\"Ignore parser errors. Errors which occurred will not be signaled. May yield\n    unexpected results for broken files, with missing draw commands or even more\n    significant errors.\"\"\"\n\n    Warn = \"warn\"\n    \"\"\"Warn on parser error. Parser will log warning message about what went wrong.\n    Best for supporting wide range of files without silently ignoring errors in code.\"\"\"\n\n    Raise = \"raise\"\n    \"\"\"Raise exception whenever parser encounters error. Will completely break out of\n    parsing process, making it impossible to render slightly malformed files.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser/parser.html#pygerber.gerberx3.parser.parser.ParserOnErrorAction.Ignore","title":"Ignore  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Ignore = 'ignore'\n</code></pre> <p>Ignore parser errors. Errors which occurred will not be signaled. May yield unexpected results for broken files, with missing draw commands or even more significant errors.</p>"},{"location":"reference/pygerber/gerberx3/parser/parser.html#pygerber.gerberx3.parser.parser.ParserOnErrorAction.Warn","title":"Warn  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Warn = 'warn'\n</code></pre> <p>Warn on parser error. Parser will log warning message about what went wrong. Best for supporting wide range of files without silently ignoring errors in code.</p>"},{"location":"reference/pygerber/gerberx3/parser/parser.html#pygerber.gerberx3.parser.parser.ParserOnErrorAction.Raise","title":"Raise  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Raise = 'raise'\n</code></pre> <p>Raise exception whenever parser encounters error. Will completely break out of parsing process, making it impossible to render slightly malformed files.</p>"},{"location":"reference/pygerber/gerberx3/parser/parser.html#pygerber.gerberx3.parser.parser.ParserOptions","title":"ParserOptions","text":"<p>Container class for Gerber parser options.</p> Source code in <code>src/pygerber/gerberx3/parser/parser.py</code> <pre><code>class ParserOptions:\n    \"\"\"Container class for Gerber parser options.\"\"\"\n\n    def __init__(\n        self,\n        backend: Backend | None = None,\n        initial_state: State | None = None,\n        on_update_drawing_state_error: Callable[[Exception, Parser, Token], None]\n        | ParserOnErrorAction = ParserOnErrorAction.Raise,\n    ) -&gt; None:\n        \"\"\"Initialize options.\"\"\"\n        self.backend = Rasterized2DBackend() if backend is None else backend\n        self.initial_state = initial_state\n        self.on_update_drawing_state_error = on_update_drawing_state_error\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser/parser.html#pygerber.gerberx3.parser.parser.ParserOptions.__init__","title":"__init__","text":"<pre><code>__init__(\n    backend: Backend | None = None,\n    initial_state: State | None = None,\n    on_update_drawing_state_error: Callable[\n        [Exception, Parser, Token], None\n    ]\n    | ParserOnErrorAction = ParserOnErrorAction.Raise,\n) -&gt; None\n</code></pre> <p>Initialize options.</p> Source code in <code>src/pygerber/gerberx3/parser/parser.py</code> <pre><code>def __init__(\n    self,\n    backend: Backend | None = None,\n    initial_state: State | None = None,\n    on_update_drawing_state_error: Callable[[Exception, Parser, Token], None]\n    | ParserOnErrorAction = ParserOnErrorAction.Raise,\n) -&gt; None:\n    \"\"\"Initialize options.\"\"\"\n    self.backend = Rasterized2DBackend() if backend is None else backend\n    self.initial_state = initial_state\n    self.on_update_drawing_state_error = on_update_drawing_state_error\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser/state.html","title":"state","text":""},{"location":"reference/pygerber/gerberx3/parser/state.html#pygerber.gerberx3.parser.state","title":"state","text":"<p>Global drawing state containing configuration which can be altered by tokens.</p>"},{"location":"reference/pygerber/gerberx3/parser/state.html#pygerber.gerberx3.parser.state.State","title":"State","text":"<p>             Bases: <code>FrozenGeneralModel</code></p> <p>GerberX3 interpreter state.</p> Source code in <code>src/pygerber/gerberx3/parser/state.py</code> <pre><code>class State(FrozenGeneralModel):\n    \"\"\"GerberX3 interpreter state.\"\"\"\n\n    current_position: Vector2D = Vector2D(x=Offset.NULL, y=Offset.NULL)\n\n    # MO | Mode | Sets the unit to mm or inch                           | 4.2.1\n    draw_units: Optional[Unit] = None\n    # FS | Format specification | Sets the coordinate format,           | 4.2.2\n    #    |                      | e.g. the number of decimals\n    coordinate_parser: Optional[CoordinateParser] = None\n    # Dnn | (nn\u226510) | Sets the current aperture to D code nn.           | 4.6\n    current_aperture: Optional[PublicApertureHandle] = None\n    # G01 | | Sets linear/circular mode to linear.                      | 4.7.1\n    # G02 | | Sets linear/circular mode to clockwise circular           | 4.7.2\n    # G03 | | Sets linear/circular mode to counterclockwise circular    | 4.7.3\n    draw_mode: DrawMode = DrawMode.Linear\n    # LP  | | Load polarity | Loads the polarity object transformation  | 4.9.2\n    #                       parameter.\n    polarity: Polarity = Polarity.Dark\n    # LM  | | Load mirroring | Loads the mirror object transformation   | 4.9.3\n    #                         parameter.\n    mirroring: Mirroring = Mirroring.NoMirroring\n    # LR  | Load rotation |  Loads the rotation object transformation   | 4.9.4\n    #                       parameter.\n    rotation: Decimal = Decimal(\"0.0\")\n\n    region_boundary_points: List[Vector2D] = Field(default_factory=list)\n    \"\"\"Points defining the shape of the region.\"\"\"\n\n    # LS  | Load scaling |   Loads the scale object transformation      | 4.9.5\n    #                       parameter\n    scaling: Decimal = Decimal(\"1.0\")\n    # G36 | |   Starts a region statement which creates a region by     | 4.10\n    #     | |   defining its contours.\n    # G37 | |   Ends the region statement.                              | 4.10\n    is_region: bool = False\n    # AB  | |   Aperture blockOpens a block aperture statement and      | 4.11\n    #     | |   assigns its aperture number or closes a block aperture  |\n    #     | |   statement.                                              |\n    is_aperture_block: bool = False\n    # SR  | |   Step and repeatOpen or closes a step and repeat         | 4.11\n    #     | |   statement.                                              |\n    is_step_and_repeat: bool = False\n    # TF  | |   Attribute on fileSet a file attribute.                  | 5.3\n    # TD  | |   Attribute deleteDelete one or all attributes in the     | 5.5\n    #     | |   dictionary.                                             |\n    file_attributes: Dict[str, str] = Field(default_factory=dict)\n    # G75 | |   Sets multi quadrant mode\n    # G74 | |   Sets single quadrant mode\n    is_multi_quadrant: bool = False\n\n    is_output_image_negation_required: bool = False\n    \"\"\"In Gerber specification deprecated IP command is mentioned.\n    It can set image polarity to either positive, the usual one, or to negative.\n    Under negative image polarity, image generation is different. Its purpose is to\n    create a negative image, clear areas in a dark background. The entire image plane\n    in the background is initially dark instead of clear. The effect of dark and clear\n    polarity is toggled. The entire image is simply reversed, dark becomes white and\n    vice versa.\n    This effect can be achieved by simply inverting colors of output image.\n    \"\"\"\n\n    apertures: Dict[ApertureID, PublicApertureHandle] = Field(default_factory=dict)\n    \"\"\"Collection of all apertures defined until given point in code.\"\"\"\n\n    macros: Dict[str, MacroDefinition] = Field(default_factory=dict)\n    \"\"\"Collection of all macros defined until given point in code.\"\"\"\n\n    def get_units(self) -&gt; Unit:\n        \"\"\"Get drawing unit or raise UnitNotSetError.\"\"\"\n        if self.draw_units is None:\n            raise UnitNotSetError\n        return self.draw_units\n\n    def get_coordinate_parser(self) -&gt; CoordinateParser:\n        \"\"\"Get coordinate parser or raise CoordinateFormatNotSetError.\"\"\"\n        if self.coordinate_parser is None:\n            raise CoordinateFormatNotSetError\n        return self.coordinate_parser\n\n    def get_current_aperture(self) -&gt; PublicApertureHandle:\n        \"\"\"Get current aperture or raise ApertureNotSelectedError.\"\"\"\n        if self.current_aperture is None:\n            raise ApertureNotSelectedError\n        return self.current_aperture\n\n    def parse_coordinate(self, coordinate: Coordinate) -&gt; Offset:\n        \"\"\"Parse, include substitution with current and conversion to Offset.\"\"\"\n        if coordinate.coordinate_type == CoordinateType.MISSING_X:\n            return self.current_position.x\n\n        if coordinate.coordinate_type == CoordinateType.MISSING_Y:\n            return self.current_position.y\n\n        if coordinate.coordinate_type == CoordinateType.MISSING_I:\n            return Offset.NULL\n\n        if coordinate.coordinate_type == CoordinateType.MISSING_J:\n            return Offset.NULL\n\n        return Offset.new(\n            self.get_coordinate_parser().parse(coordinate),\n            unit=self.get_units(),\n        )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser/state.html#pygerber.gerberx3.parser.state.State.region_boundary_points","title":"region_boundary_points  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>region_boundary_points: List[Vector2D] = Field(\n    default_factory=list\n)\n</code></pre> <p>Points defining the shape of the region.</p>"},{"location":"reference/pygerber/gerberx3/parser/state.html#pygerber.gerberx3.parser.state.State.is_output_image_negation_required","title":"is_output_image_negation_required  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>is_output_image_negation_required: bool = False\n</code></pre> <p>In Gerber specification deprecated IP command is mentioned. It can set image polarity to either positive, the usual one, or to negative. Under negative image polarity, image generation is different. Its purpose is to create a negative image, clear areas in a dark background. The entire image plane in the background is initially dark instead of clear. The effect of dark and clear polarity is toggled. The entire image is simply reversed, dark becomes white and vice versa. This effect can be achieved by simply inverting colors of output image.</p>"},{"location":"reference/pygerber/gerberx3/parser/state.html#pygerber.gerberx3.parser.state.State.apertures","title":"apertures  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>apertures: Dict[ApertureID, PublicApertureHandle] = Field(\n    default_factory=dict\n)\n</code></pre> <p>Collection of all apertures defined until given point in code.</p>"},{"location":"reference/pygerber/gerberx3/parser/state.html#pygerber.gerberx3.parser.state.State.macros","title":"macros  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>macros: Dict[str, MacroDefinition] = Field(\n    default_factory=dict\n)\n</code></pre> <p>Collection of all macros defined until given point in code.</p>"},{"location":"reference/pygerber/gerberx3/parser/state.html#pygerber.gerberx3.parser.state.State.get_units","title":"get_units","text":"<pre><code>get_units() -&gt; Unit\n</code></pre> <p>Get drawing unit or raise UnitNotSetError.</p> Source code in <code>src/pygerber/gerberx3/parser/state.py</code> <pre><code>def get_units(self) -&gt; Unit:\n    \"\"\"Get drawing unit or raise UnitNotSetError.\"\"\"\n    if self.draw_units is None:\n        raise UnitNotSetError\n    return self.draw_units\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser/state.html#pygerber.gerberx3.parser.state.State.get_coordinate_parser","title":"get_coordinate_parser","text":"<pre><code>get_coordinate_parser() -&gt; CoordinateParser\n</code></pre> <p>Get coordinate parser or raise CoordinateFormatNotSetError.</p> Source code in <code>src/pygerber/gerberx3/parser/state.py</code> <pre><code>def get_coordinate_parser(self) -&gt; CoordinateParser:\n    \"\"\"Get coordinate parser or raise CoordinateFormatNotSetError.\"\"\"\n    if self.coordinate_parser is None:\n        raise CoordinateFormatNotSetError\n    return self.coordinate_parser\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser/state.html#pygerber.gerberx3.parser.state.State.get_current_aperture","title":"get_current_aperture","text":"<pre><code>get_current_aperture() -&gt; PublicApertureHandle\n</code></pre> <p>Get current aperture or raise ApertureNotSelectedError.</p> Source code in <code>src/pygerber/gerberx3/parser/state.py</code> <pre><code>def get_current_aperture(self) -&gt; PublicApertureHandle:\n    \"\"\"Get current aperture or raise ApertureNotSelectedError.\"\"\"\n    if self.current_aperture is None:\n        raise ApertureNotSelectedError\n    return self.current_aperture\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser/state.html#pygerber.gerberx3.parser.state.State.parse_coordinate","title":"parse_coordinate","text":"<pre><code>parse_coordinate(coordinate: Coordinate) -&gt; Offset\n</code></pre> <p>Parse, include substitution with current and conversion to Offset.</p> Source code in <code>src/pygerber/gerberx3/parser/state.py</code> <pre><code>def parse_coordinate(self, coordinate: Coordinate) -&gt; Offset:\n    \"\"\"Parse, include substitution with current and conversion to Offset.\"\"\"\n    if coordinate.coordinate_type == CoordinateType.MISSING_X:\n        return self.current_position.x\n\n    if coordinate.coordinate_type == CoordinateType.MISSING_Y:\n        return self.current_position.y\n\n    if coordinate.coordinate_type == CoordinateType.MISSING_I:\n        return Offset.NULL\n\n    if coordinate.coordinate_type == CoordinateType.MISSING_J:\n        return Offset.NULL\n\n    return Offset.new(\n        self.get_coordinate_parser().parse(coordinate),\n        unit=self.get_units(),\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/__init__.html","title":"init","text":""},{"location":"reference/pygerber/gerberx3/parser2/__init__.html#pygerber.gerberx3.parser2","title":"parser2","text":"<p>Gerber AST parser, version 2.</p>"},{"location":"reference/pygerber/gerberx3/parser2/attributes2.html","title":"attributes2","text":""},{"location":"reference/pygerber/gerberx3/parser2/attributes2.html#pygerber.gerberx3.parser2.attributes2","title":"attributes2","text":"<p>Attribute dictionaries for Gerber X3 parser.</p>"},{"location":"reference/pygerber/gerberx3/parser2/attributes2.html#pygerber.gerberx3.parser2.attributes2.AttributesDictionary","title":"AttributesDictionary","text":"<p>             Bases: <code>ImmutableMapping[str, Optional[str]]</code></p> <p>Base class for container holding attributes.</p> Source code in <code>src/pygerber/gerberx3/parser2/attributes2.py</code> <pre><code>class AttributesDictionary(ImmutableMapping[str, Optional[str]]):\n    \"\"\"Base class for container holding attributes.\"\"\"\n\n    def __str__(self) -&gt; str:\n        return f\"{self.__class__.__qualname__}({self.mapping})\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/attributes2.html#pygerber.gerberx3.parser2.attributes2.StandardAttributeBase","title":"StandardAttributeBase","text":"<p>             Bases: <code>FrozenGeneralModel</code></p> <p>Class for wrapping standard attribute content.</p> Source code in <code>src/pygerber/gerberx3/parser2/attributes2.py</code> <pre><code>class StandardAttributeBase(FrozenGeneralModel):\n    \"\"\"Class for wrapping standard attribute content.\"\"\"\n\n    @classmethod\n    def parse(cls, content: str) -&gt; Self:\n        \"\"\"Parse attribute content.\"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/attributes2.html#pygerber.gerberx3.parser2.attributes2.StandardAttributeBase.parse","title":"parse  <code>classmethod</code>","text":"<pre><code>parse(content: str) -&gt; Self\n</code></pre> <p>Parse attribute content.</p> Source code in <code>src/pygerber/gerberx3/parser2/attributes2.py</code> <pre><code>@classmethod\ndef parse(cls, content: str) -&gt; Self:\n    \"\"\"Parse attribute content.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/attributes2.html#pygerber.gerberx3.parser2.attributes2.PartAttribute","title":"PartAttribute","text":"<p>             Bases: <code>StandardAttributeBase</code></p> <p>The value of the .Part file attribute identifies which part is described. The attribute - if present - must be defined in the header.</p> Source code in <code>src/pygerber/gerberx3/parser2/attributes2.py</code> <pre><code>class PartAttribute(StandardAttributeBase):\n    \"\"\"The value of the .Part file attribute identifies which part is described. The\n    attribute - if present - must be defined in the header.\n    \"\"\"\n\n    class Part(Enum):\n        \"\"\"Enumerate supported part types.\"\"\"\n\n        Single = \"Single\"\n        Array = \"Array\"\n        FabricationPanel = \"FabricationPanel\"\n        Coupon = \"Coupon\"\n        Other = \"Other\"\n\n    part: PartAttribute.Part\n    field: str = Field(default=\"\")\n\n    @classmethod\n    def parse(cls, content: str) -&gt; Self:\n        \"\"\"Return original content.\"\"\"\n        parts = dict(enumerate(content.split(\",\", 1)))\n        return cls(\n            part=cls.Part(parts[0]),\n            field=parts.get(1, \"\"),\n        )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/attributes2.html#pygerber.gerberx3.parser2.attributes2.PartAttribute.Part","title":"Part","text":"<p>             Bases: <code>Enum</code></p> <p>Enumerate supported part types.</p> Source code in <code>src/pygerber/gerberx3/parser2/attributes2.py</code> <pre><code>class Part(Enum):\n    \"\"\"Enumerate supported part types.\"\"\"\n\n    Single = \"Single\"\n    Array = \"Array\"\n    FabricationPanel = \"FabricationPanel\"\n    Coupon = \"Coupon\"\n    Other = \"Other\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/attributes2.html#pygerber.gerberx3.parser2.attributes2.PartAttribute.parse","title":"parse  <code>classmethod</code>","text":"<pre><code>parse(content: str) -&gt; Self\n</code></pre> <p>Return original content.</p> Source code in <code>src/pygerber/gerberx3/parser2/attributes2.py</code> <pre><code>@classmethod\ndef parse(cls, content: str) -&gt; Self:\n    \"\"\"Return original content.\"\"\"\n    parts = dict(enumerate(content.split(\",\", 1)))\n    return cls(\n        part=cls.Part(parts[0]),\n        field=parts.get(1, \"\"),\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/attributes2.html#pygerber.gerberx3.parser2.attributes2.GenerationSoftwareAttribute","title":"GenerationSoftwareAttribute","text":"<p>             Bases: <code>StandardAttributeBase</code></p> <p>Usually a Gerber file is part of a PCB project with a sequence of revisions. The purpose of the .ProjectId file attribute is to uniquely identify project and revision.This is especially important to check whether all files belong to the same revision. By its nature, these values can only be defined by the creator of the project and revision. The attribute - if present - must be defined in the header.</p> <p>The syntax is as follows:</p> <pre><code>%TF.ProjectId,&lt;Name&gt;,&lt;GUID&gt;,&lt;Revision&gt;*%\n</code></pre> Source code in <code>src/pygerber/gerberx3/parser2/attributes2.py</code> <pre><code>class GenerationSoftwareAttribute(StandardAttributeBase):\n    \"\"\"Usually a Gerber file is part of a PCB project with a sequence of revisions.\n    The purpose of the .ProjectId file attribute is to uniquely identify project and\n    revision.This is especially important to check whether all files belong to the same\n    revision. By its nature, these values can only be defined by the creator of the\n    project and revision. The attribute - if present - must be defined in the header.\n\n    The syntax is as follows:\n\n    ```\n    %TF.ProjectId,&lt;Name&gt;,&lt;GUID&gt;,&lt;Revision&gt;*%\n    ```\n    \"\"\"\n\n    name: str\n    guid: str\n    revision: str\n\n    @classmethod\n    def parse(cls, content: str) -&gt; Self:\n        \"\"\"Return original content.\"\"\"\n        items = dict(enumerate(content.split(\",\")))\n\n        if (name := items.get(0)) is None:\n            msg = \"Missing name field for .GenerationSoftware attribute.\"\n            raise MissingGuidFieldError(msg)\n\n        if (guid := items.get(1)) is None:\n            msg = \"Missing guid field for .GenerationSoftware attribute.\"\n            raise MissingGuidFieldError(msg)\n\n        if (revision := items.get(2)) is None:\n            msg = \"Missing revision field for .GenerationSoftware attribute.\"\n            raise MissingGuidFieldError(msg)\n\n        return cls(\n            name=name,\n            guid=guid,\n            revision=revision,\n        )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/attributes2.html#pygerber.gerberx3.parser2.attributes2.GenerationSoftwareAttribute.parse","title":"parse  <code>classmethod</code>","text":"<pre><code>parse(content: str) -&gt; Self\n</code></pre> <p>Return original content.</p> Source code in <code>src/pygerber/gerberx3/parser2/attributes2.py</code> <pre><code>@classmethod\ndef parse(cls, content: str) -&gt; Self:\n    \"\"\"Return original content.\"\"\"\n    items = dict(enumerate(content.split(\",\")))\n\n    if (name := items.get(0)) is None:\n        msg = \"Missing name field for .GenerationSoftware attribute.\"\n        raise MissingGuidFieldError(msg)\n\n    if (guid := items.get(1)) is None:\n        msg = \"Missing guid field for .GenerationSoftware attribute.\"\n        raise MissingGuidFieldError(msg)\n\n    if (revision := items.get(2)) is None:\n        msg = \"Missing revision field for .GenerationSoftware attribute.\"\n        raise MissingGuidFieldError(msg)\n\n    return cls(\n        name=name,\n        guid=guid,\n        revision=revision,\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/attributes2.html#pygerber.gerberx3.parser2.attributes2.FileAttributes","title":"FileAttributes","text":"<p>             Bases: <code>AttributesDictionary</code></p> <p>File attributes.</p> Source code in <code>src/pygerber/gerberx3/parser2/attributes2.py</code> <pre><code>class FileAttributes(AttributesDictionary):\n    \"\"\"File attributes.\"\"\"\n\n    @property\n    def Part(self) -&gt; Optional[str]:  # noqa: N802\n        \"\"\"Identifies the part the file represents, e.g. a single PCB.\n\n        Standard file attribute.\n        \"\"\"\n        return self.get(\".Part\")\n\n    @property\n    def FileFunction(self) -&gt; Optional[str]:  # noqa: N802\n        \"\"\"Identifies the file's function in the PCB, e.g. top copper layer.\n\n        Standard file attribute.\n        \"\"\"\n        return self.get(\".FileFunction\")\n\n    @property\n    def FilePolarity(self) -&gt; Optional[str]:  # noqa: N802\n        \"\"\"Positive or Negative. This defines whether the image represents the presence\n        or absence of material.\n\n        Standard file attribute.\n        \"\"\"\n        return self.get(\".FilePolarity\")\n\n    @property\n    def SameCoordinates(self) -&gt; Optional[str]:  # noqa: N802\n        \"\"\"All files in a fabrication data set with this attribute use the same\n        coordinates. In other words, they align.\n\n        Standard file attribute.\n        \"\"\"\n        return self.get(\".SameCoordinates\")\n\n    @property\n    def CreationDate(self) -&gt; Optional[datetime.datetime]:  # noqa: N802\n        \"\"\"Defines the creation date and time of the file.\n\n        Standard file attribute.\n        \"\"\"\n        if (val := self.get(\".CreationDate\")) is not None:\n            return datetime.datetime.fromisoformat(val)\n        return None\n\n    @property\n    def GenerationSoftware(self) -&gt; Optional[GenerationSoftwareAttribute]:  # noqa: N802\n        \"\"\"Identifies the software creating the file.\n\n        Standard file attribute.\n        \"\"\"\n        if (val := self.get(\".GenerationSoftware\")) is not None:\n            return GenerationSoftwareAttribute.parse(val)\n        return None\n\n    @property\n    def ProjectId(self) -&gt; Optional[str]:  # noqa: N802\n        \"\"\"Defines project and revisions.\n\n        Standard file attribute.\n        \"\"\"\n        return self.get(\".ProjectId\")\n\n    @property\n    def MD5(self) -&gt; Optional[str]:  # noqa: N802\n        \"\"\"Sets the MD5 file signature or checksum.\n\n        Standard file attribute.\n        \"\"\"\n        return self.get(\".MD5\")\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/attributes2.html#pygerber.gerberx3.parser2.attributes2.FileAttributes.Part","title":"Part  <code>property</code>","text":"<pre><code>Part: Optional[str]\n</code></pre> <p>Identifies the part the file represents, e.g. a single PCB.</p> <p>Standard file attribute.</p>"},{"location":"reference/pygerber/gerberx3/parser2/attributes2.html#pygerber.gerberx3.parser2.attributes2.FileAttributes.FileFunction","title":"FileFunction  <code>property</code>","text":"<pre><code>FileFunction: Optional[str]\n</code></pre> <p>Identifies the file's function in the PCB, e.g. top copper layer.</p> <p>Standard file attribute.</p>"},{"location":"reference/pygerber/gerberx3/parser2/attributes2.html#pygerber.gerberx3.parser2.attributes2.FileAttributes.FilePolarity","title":"FilePolarity  <code>property</code>","text":"<pre><code>FilePolarity: Optional[str]\n</code></pre> <p>Positive or Negative. This defines whether the image represents the presence or absence of material.</p> <p>Standard file attribute.</p>"},{"location":"reference/pygerber/gerberx3/parser2/attributes2.html#pygerber.gerberx3.parser2.attributes2.FileAttributes.SameCoordinates","title":"SameCoordinates  <code>property</code>","text":"<pre><code>SameCoordinates: Optional[str]\n</code></pre> <p>All files in a fabrication data set with this attribute use the same coordinates. In other words, they align.</p> <p>Standard file attribute.</p>"},{"location":"reference/pygerber/gerberx3/parser2/attributes2.html#pygerber.gerberx3.parser2.attributes2.FileAttributes.CreationDate","title":"CreationDate  <code>property</code>","text":"<pre><code>CreationDate: Optional[datetime]\n</code></pre> <p>Defines the creation date and time of the file.</p> <p>Standard file attribute.</p>"},{"location":"reference/pygerber/gerberx3/parser2/attributes2.html#pygerber.gerberx3.parser2.attributes2.FileAttributes.GenerationSoftware","title":"GenerationSoftware  <code>property</code>","text":"<pre><code>GenerationSoftware: Optional[GenerationSoftwareAttribute]\n</code></pre> <p>Identifies the software creating the file.</p> <p>Standard file attribute.</p>"},{"location":"reference/pygerber/gerberx3/parser2/attributes2.html#pygerber.gerberx3.parser2.attributes2.FileAttributes.ProjectId","title":"ProjectId  <code>property</code>","text":"<pre><code>ProjectId: Optional[str]\n</code></pre> <p>Defines project and revisions.</p> <p>Standard file attribute.</p>"},{"location":"reference/pygerber/gerberx3/parser2/attributes2.html#pygerber.gerberx3.parser2.attributes2.FileAttributes.MD5","title":"MD5  <code>property</code>","text":"<pre><code>MD5: Optional[str]\n</code></pre> <p>Sets the MD5 file signature or checksum.</p> <p>Standard file attribute.</p>"},{"location":"reference/pygerber/gerberx3/parser2/attributes2.html#pygerber.gerberx3.parser2.attributes2.AperFunctionAttribute","title":"AperFunctionAttribute","text":"<p>             Bases: <code>StandardAttributeBase</code></p> <p>Function of objects created with the apertures, e.g. SMD pad.</p> Source code in <code>src/pygerber/gerberx3/parser2/attributes2.py</code> <pre><code>class AperFunctionAttribute(StandardAttributeBase):\n    \"\"\"Function of objects created with the apertures, e.g. SMD pad.\"\"\"\n\n    class Function(Enum):\n        \"\"\"Type of drilling.\"\"\"\n\n        ViaDrill = \"ViaDrill\"\n        BackDrill = \"BackDrill\"\n        ComponentDrill = \"ComponentDrill\"\n        MechanicalDrill = \"MechanicalDrill\"\n        CastellatedDrill = \"CastellatedDrill\"\n        OtherDrill = \"OtherDrill\"\n        ComponentPad = \"ComponentPad\"\n        SMDPad = \"SMDPad\"\n        BGAPad = \"BGAPad\"\n        ConnectorPad = \"ConnectorPad\"\n        HeatsinkPad = \"HeatsinkPad\"\n        ViaPad = \"ViaPad\"\n        TestPad = \"TestPad\"\n        CastellatedPad = \"CastellatedPad\"\n        FiducialPad = \"FiducialPad\"\n        ThermalReliefPad = \"ThermalReliefPad\"\n        WasherPad = \"WasherPad\"\n        AntiPad = \"AntiPad\"\n        OtherPad = \"OtherPad\"\n        Conductor = \"Conductor\"\n        EtchedComponent = \"EtchedComponent\"\n        NonConductor = \"NonConductor\"\n        CopperBalancing = \"CopperBalancing\"\n        Border = \"Border\"\n        OtherCopper = \"OtherCopper\"\n        ComponentMain = \"ComponentMain\"\n        ComponentOutline = \"ComponentOutline\"\n        ComponentPin = \"ComponentPin\"\n        Profile = \"Profile\"\n        Material = \"Material\"\n        NonMaterial = \"NonMaterial\"\n        Other = \"Other\"\n\n    function: Optional[AperFunctionAttribute.Function]\n    field: str = Field(default=\"\")\n\n    @classmethod\n    def parse(cls, content: str) -&gt; Self:\n        \"\"\"Return original content.\"\"\"\n        parts = dict(enumerate(content.split(\",\", 1)))\n        return cls(\n            function=cls.Function(parts[0]),\n            field=parts.get(1, \"\"),\n        )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/attributes2.html#pygerber.gerberx3.parser2.attributes2.AperFunctionAttribute.Function","title":"Function","text":"<p>             Bases: <code>Enum</code></p> <p>Type of drilling.</p> Source code in <code>src/pygerber/gerberx3/parser2/attributes2.py</code> <pre><code>class Function(Enum):\n    \"\"\"Type of drilling.\"\"\"\n\n    ViaDrill = \"ViaDrill\"\n    BackDrill = \"BackDrill\"\n    ComponentDrill = \"ComponentDrill\"\n    MechanicalDrill = \"MechanicalDrill\"\n    CastellatedDrill = \"CastellatedDrill\"\n    OtherDrill = \"OtherDrill\"\n    ComponentPad = \"ComponentPad\"\n    SMDPad = \"SMDPad\"\n    BGAPad = \"BGAPad\"\n    ConnectorPad = \"ConnectorPad\"\n    HeatsinkPad = \"HeatsinkPad\"\n    ViaPad = \"ViaPad\"\n    TestPad = \"TestPad\"\n    CastellatedPad = \"CastellatedPad\"\n    FiducialPad = \"FiducialPad\"\n    ThermalReliefPad = \"ThermalReliefPad\"\n    WasherPad = \"WasherPad\"\n    AntiPad = \"AntiPad\"\n    OtherPad = \"OtherPad\"\n    Conductor = \"Conductor\"\n    EtchedComponent = \"EtchedComponent\"\n    NonConductor = \"NonConductor\"\n    CopperBalancing = \"CopperBalancing\"\n    Border = \"Border\"\n    OtherCopper = \"OtherCopper\"\n    ComponentMain = \"ComponentMain\"\n    ComponentOutline = \"ComponentOutline\"\n    ComponentPin = \"ComponentPin\"\n    Profile = \"Profile\"\n    Material = \"Material\"\n    NonMaterial = \"NonMaterial\"\n    Other = \"Other\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/attributes2.html#pygerber.gerberx3.parser2.attributes2.AperFunctionAttribute.parse","title":"parse  <code>classmethod</code>","text":"<pre><code>parse(content: str) -&gt; Self\n</code></pre> <p>Return original content.</p> Source code in <code>src/pygerber/gerberx3/parser2/attributes2.py</code> <pre><code>@classmethod\ndef parse(cls, content: str) -&gt; Self:\n    \"\"\"Return original content.\"\"\"\n    parts = dict(enumerate(content.split(\",\", 1)))\n    return cls(\n        function=cls.Function(parts[0]),\n        field=parts.get(1, \"\"),\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/attributes2.html#pygerber.gerberx3.parser2.attributes2.ApertureAttributes","title":"ApertureAttributes","text":"<p>             Bases: <code>AttributesDictionary</code></p> <p>Aperture attributes.</p> Source code in <code>src/pygerber/gerberx3/parser2/attributes2.py</code> <pre><code>class ApertureAttributes(AttributesDictionary):\n    \"\"\"Aperture attributes.\"\"\"\n\n    @property\n    def AperFunction(self) -&gt; Optional[AperFunctionAttribute]:  # noqa: N802\n        \"\"\"Function of objects created with the apertures, e.g. SMD pad.\"\"\"\n        if (val := self.get(\".AperFunction\")) is not None:\n            return AperFunctionAttribute.parse(val)\n        return None\n\n    @property\n    def DrillTolerance(self) -&gt; Optional[str]:  # noqa: N802\n        \"\"\"Tolerance of drill holes.\"\"\"\n        return self.get(\".DrillTolerance\")\n\n    @property\n    def FlashText(self) -&gt; Optional[str]:  # noqa: N802\n        \"\"\"Provides the source text and font for flashes representing text.\"\"\"\n        return self.get(\".FlashText\")\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/attributes2.html#pygerber.gerberx3.parser2.attributes2.ApertureAttributes.AperFunction","title":"AperFunction  <code>property</code>","text":"<pre><code>AperFunction: Optional[AperFunctionAttribute]\n</code></pre> <p>Function of objects created with the apertures, e.g. SMD pad.</p>"},{"location":"reference/pygerber/gerberx3/parser2/attributes2.html#pygerber.gerberx3.parser2.attributes2.ApertureAttributes.DrillTolerance","title":"DrillTolerance  <code>property</code>","text":"<pre><code>DrillTolerance: Optional[str]\n</code></pre> <p>Tolerance of drill holes.</p>"},{"location":"reference/pygerber/gerberx3/parser2/attributes2.html#pygerber.gerberx3.parser2.attributes2.ApertureAttributes.FlashText","title":"FlashText  <code>property</code>","text":"<pre><code>FlashText: Optional[str]\n</code></pre> <p>Provides the source text and font for flashes representing text.</p>"},{"location":"reference/pygerber/gerberx3/parser2/attributes2.html#pygerber.gerberx3.parser2.attributes2.PAttribute","title":"PAttribute","text":"<p>             Bases: <code>StandardAttributeBase</code></p> <p>The .P object attribute attaches the reference descriptor and pin number of a component pin to a pad on an outer copper layer or a ComponentPin in a component layer.</p> <p>The syntax is: <pre><code>&lt;.P Attribute&gt; = .P,&lt;refdes&gt;,&lt;number&gt;[,&lt;function&gt;]\n</code></pre></p> Source code in <code>src/pygerber/gerberx3/parser2/attributes2.py</code> <pre><code>class PAttribute(StandardAttributeBase):\n    \"\"\"The .P object attribute attaches the reference descriptor and pin number of a\n    component pin to a pad on an outer copper layer or a ComponentPin in a component\n    layer.\n\n    The syntax is:\n    ```\n    &lt;.P Attribute&gt; = .P,&lt;refdes&gt;,&lt;number&gt;[,&lt;function&gt;]\n    ```\n    \"\"\"\n\n    refdes: str\n    number: str\n    function: Optional[str]\n\n    @classmethod\n    def parse(cls, content: str) -&gt; Self:\n        \"\"\"Return original content.\"\"\"\n        parts = dict(enumerate(content.split(\",\")))\n        return cls(refdes=parts[0], number=parts[1], function=parts.get(2))\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/attributes2.html#pygerber.gerberx3.parser2.attributes2.PAttribute.parse","title":"parse  <code>classmethod</code>","text":"<pre><code>parse(content: str) -&gt; Self\n</code></pre> <p>Return original content.</p> Source code in <code>src/pygerber/gerberx3/parser2/attributes2.py</code> <pre><code>@classmethod\ndef parse(cls, content: str) -&gt; Self:\n    \"\"\"Return original content.\"\"\"\n    parts = dict(enumerate(content.split(\",\")))\n    return cls(refdes=parts[0], number=parts[1], function=parts.get(2))\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/attributes2.html#pygerber.gerberx3.parser2.attributes2.ObjectAttributes","title":"ObjectAttributes","text":"<p>             Bases: <code>AttributesDictionary</code></p> <p>Object attributes.</p> Source code in <code>src/pygerber/gerberx3/parser2/attributes2.py</code> <pre><code>class ObjectAttributes(AttributesDictionary):\n    \"\"\"Object attributes.\"\"\"\n\n    @property\n    def N(self) -&gt; Optional[str]:  # noqa: N802\n        \"\"\"The CAD net name of a conducting object, e.g. Clk13.\"\"\"\n        return self.get(\".N\")\n\n    @property\n    def P(self) -&gt; Optional[PAttribute]:  # noqa: N802\n        \"\"\"The pin number (or name) and reference descriptor of a component pad on an\n        outer layer, e.g. IC3,7.\n        \"\"\"\n        if (val := self.get(\".P\")) is not None:\n            return PAttribute.parse(val)\n        return None\n\n    @property\n    def C(self) -&gt; Optional[str]:  # noqa: N802\n        \"\"\"The component reference designator linked to an object, e.g. C2.\"\"\"\n        return self.get(\".C\")\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/attributes2.html#pygerber.gerberx3.parser2.attributes2.ObjectAttributes.N","title":"N  <code>property</code>","text":"<pre><code>N: Optional[str]\n</code></pre> <p>The CAD net name of a conducting object, e.g. Clk13.</p>"},{"location":"reference/pygerber/gerberx3/parser2/attributes2.html#pygerber.gerberx3.parser2.attributes2.ObjectAttributes.P","title":"P  <code>property</code>","text":"<pre><code>P: Optional[PAttribute]\n</code></pre> <p>The pin number (or name) and reference descriptor of a component pad on an outer layer, e.g. IC3,7.</p>"},{"location":"reference/pygerber/gerberx3/parser2/attributes2.html#pygerber.gerberx3.parser2.attributes2.ObjectAttributes.C","title":"C  <code>property</code>","text":"<pre><code>C: Optional[str]\n</code></pre> <p>The component reference designator linked to an object, e.g. C2.</p>"},{"location":"reference/pygerber/gerberx3/parser2/command_buffer2.html","title":"command_buffer2","text":""},{"location":"reference/pygerber/gerberx3/parser2/command_buffer2.html#pygerber.gerberx3.parser2.command_buffer2","title":"command_buffer2","text":"<p>Module contains definition of class for buffering draw commands.</p>"},{"location":"reference/pygerber/gerberx3/parser2/command_buffer2.html#pygerber.gerberx3.parser2.command_buffer2.CommandBuffer2","title":"CommandBuffer2","text":"<p>Container for buffering draw commands.</p> Source code in <code>src/pygerber/gerberx3/parser2/command_buffer2.py</code> <pre><code>class CommandBuffer2:\n    \"\"\"Container for buffering draw commands.\"\"\"\n\n    def __init__(self, commands: Optional[list[Command2]] = None) -&gt; None:\n        self.commands: list[Command2] = [] if commands is None else commands\n\n    @classmethod\n    def factory(cls, context: Parser2Context) -&gt; Self:  # noqa: ARG003\n        \"\"\"CommandBuffer2 factory.\"\"\"\n        return cls(commands=[])\n\n    def add_command(self, __command: Command2) -&gt; None:\n        \"\"\"Add draw command to command buffer.\"\"\"\n        self.commands.append(__command)\n\n    def get_readonly(self) -&gt; ReadonlyCommandBuffer2:\n        \"\"\"Make buffer read-only.\"\"\"\n        return ReadonlyCommandBuffer2(commands=self.commands)\n\n    def copy(self) -&gt; CommandBuffer2:\n        \"\"\"Create copy of command buffer.\"\"\"\n        return CommandBuffer2(commands=self.commands.copy())\n\n    def __iter__(self) -&gt; Iterator[Command2]:\n        \"\"\"Iterate over buffered draw commands.\"\"\"\n        yield from self.commands\n\n    def __getitem__(self, index: int) -&gt; Command2:\n        \"\"\"Get item by index from commands.\"\"\"\n        return self.commands[index]\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/command_buffer2.html#pygerber.gerberx3.parser2.command_buffer2.CommandBuffer2.factory","title":"factory  <code>classmethod</code>","text":"<pre><code>factory(context: Parser2Context) -&gt; Self\n</code></pre> <p>CommandBuffer2 factory.</p> Source code in <code>src/pygerber/gerberx3/parser2/command_buffer2.py</code> <pre><code>@classmethod\ndef factory(cls, context: Parser2Context) -&gt; Self:  # noqa: ARG003\n    \"\"\"CommandBuffer2 factory.\"\"\"\n    return cls(commands=[])\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/command_buffer2.html#pygerber.gerberx3.parser2.command_buffer2.CommandBuffer2.add_command","title":"add_command","text":"<pre><code>add_command(__command: Command2) -&gt; None\n</code></pre> <p>Add draw command to command buffer.</p> Source code in <code>src/pygerber/gerberx3/parser2/command_buffer2.py</code> <pre><code>def add_command(self, __command: Command2) -&gt; None:\n    \"\"\"Add draw command to command buffer.\"\"\"\n    self.commands.append(__command)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/command_buffer2.html#pygerber.gerberx3.parser2.command_buffer2.CommandBuffer2.get_readonly","title":"get_readonly","text":"<pre><code>get_readonly() -&gt; ReadonlyCommandBuffer2\n</code></pre> <p>Make buffer read-only.</p> Source code in <code>src/pygerber/gerberx3/parser2/command_buffer2.py</code> <pre><code>def get_readonly(self) -&gt; ReadonlyCommandBuffer2:\n    \"\"\"Make buffer read-only.\"\"\"\n    return ReadonlyCommandBuffer2(commands=self.commands)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/command_buffer2.html#pygerber.gerberx3.parser2.command_buffer2.CommandBuffer2.copy","title":"copy","text":"<pre><code>copy() -&gt; CommandBuffer2\n</code></pre> <p>Create copy of command buffer.</p> Source code in <code>src/pygerber/gerberx3/parser2/command_buffer2.py</code> <pre><code>def copy(self) -&gt; CommandBuffer2:\n    \"\"\"Create copy of command buffer.\"\"\"\n    return CommandBuffer2(commands=self.commands.copy())\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/command_buffer2.html#pygerber.gerberx3.parser2.command_buffer2.CommandBuffer2.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; Iterator[Command2]\n</code></pre> <p>Iterate over buffered draw commands.</p> Source code in <code>src/pygerber/gerberx3/parser2/command_buffer2.py</code> <pre><code>def __iter__(self) -&gt; Iterator[Command2]:\n    \"\"\"Iterate over buffered draw commands.\"\"\"\n    yield from self.commands\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/command_buffer2.html#pygerber.gerberx3.parser2.command_buffer2.CommandBuffer2.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(index: int) -&gt; Command2\n</code></pre> <p>Get item by index from commands.</p> Source code in <code>src/pygerber/gerberx3/parser2/command_buffer2.py</code> <pre><code>def __getitem__(self, index: int) -&gt; Command2:\n    \"\"\"Get item by index from commands.\"\"\"\n    return self.commands[index]\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/command_buffer2.html#pygerber.gerberx3.parser2.command_buffer2.ReadonlyCommandBuffer2","title":"ReadonlyCommandBuffer2","text":"<p>             Bases: <code>FrozenGeneralModel</code></p> <p>Read only command buffer proxy.</p> Source code in <code>src/pygerber/gerberx3/parser2/command_buffer2.py</code> <pre><code>class ReadonlyCommandBuffer2(FrozenGeneralModel):\n    \"\"\"Read only command buffer proxy.\"\"\"\n\n    commands: List[Command2] = Field(default_factory=list)\n\n    def __len__(self) -&gt; int:\n        \"\"\"Return length of buffered commands.\"\"\"\n        return len(self.commands)\n\n    def __iter__(self) -&gt; Iterator[Command2]:  # type: ignore[override]\n        \"\"\"Iterate over buffered draw commands.\"\"\"\n        yield from self.commands\n\n    def __getitem__(self, index: int) -&gt; Command2:\n        \"\"\"Get item by index from commands.\"\"\"\n        return self.commands[index]\n\n    def debug_buffer_to_json(self, indent: int = 4) -&gt; str:\n        \"\"\"Convert buffered draw commands to JSON.\"\"\"\n        command_chain = \",\\n\".join(c.command_to_json() for c in self)\n        return f\"[\\n{textwrap.indent(command_chain, ' ' * indent)}\\n]\"\n\n    def get_mirrored(self, mirror: Mirroring) -&gt; Self:\n        \"\"\"Get new command buffer with all commands mirrored.\"\"\"\n        return self.model_copy(\n            update={\"commands\": [c.get_mirrored(mirror) for c in self.commands]},\n        )\n\n    def get_transposed(self, vector: Vector2D) -&gt; Self:\n        \"\"\"Get new command buffer with all commands transposed.\"\"\"\n        return self.model_copy(\n            update={\"commands\": [c.get_transposed(vector) for c in self.commands]},\n        )\n\n    def get_bounding_box(self) -&gt; BoundingBox:\n        \"\"\"Get bounding box of command buffer.\"\"\"\n        bbox: Optional[BoundingBox] = None\n\n        for command in self:\n            if bbox is None:\n                bbox = command.get_bounding_box()\n            else:\n                bbox += command.get_bounding_box()\n\n        return BoundingBox.NULL if bbox is None else bbox\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/command_buffer2.html#pygerber.gerberx3.parser2.command_buffer2.ReadonlyCommandBuffer2.__len__","title":"__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre> <p>Return length of buffered commands.</p> Source code in <code>src/pygerber/gerberx3/parser2/command_buffer2.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Return length of buffered commands.\"\"\"\n    return len(self.commands)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/command_buffer2.html#pygerber.gerberx3.parser2.command_buffer2.ReadonlyCommandBuffer2.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; Iterator[Command2]\n</code></pre> <p>Iterate over buffered draw commands.</p> Source code in <code>src/pygerber/gerberx3/parser2/command_buffer2.py</code> <pre><code>def __iter__(self) -&gt; Iterator[Command2]:  # type: ignore[override]\n    \"\"\"Iterate over buffered draw commands.\"\"\"\n    yield from self.commands\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/command_buffer2.html#pygerber.gerberx3.parser2.command_buffer2.ReadonlyCommandBuffer2.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(index: int) -&gt; Command2\n</code></pre> <p>Get item by index from commands.</p> Source code in <code>src/pygerber/gerberx3/parser2/command_buffer2.py</code> <pre><code>def __getitem__(self, index: int) -&gt; Command2:\n    \"\"\"Get item by index from commands.\"\"\"\n    return self.commands[index]\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/command_buffer2.html#pygerber.gerberx3.parser2.command_buffer2.ReadonlyCommandBuffer2.debug_buffer_to_json","title":"debug_buffer_to_json","text":"<pre><code>debug_buffer_to_json(indent: int = 4) -&gt; str\n</code></pre> <p>Convert buffered draw commands to JSON.</p> Source code in <code>src/pygerber/gerberx3/parser2/command_buffer2.py</code> <pre><code>def debug_buffer_to_json(self, indent: int = 4) -&gt; str:\n    \"\"\"Convert buffered draw commands to JSON.\"\"\"\n    command_chain = \",\\n\".join(c.command_to_json() for c in self)\n    return f\"[\\n{textwrap.indent(command_chain, ' ' * indent)}\\n]\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/command_buffer2.html#pygerber.gerberx3.parser2.command_buffer2.ReadonlyCommandBuffer2.get_mirrored","title":"get_mirrored","text":"<pre><code>get_mirrored(mirror: Mirroring) -&gt; Self\n</code></pre> <p>Get new command buffer with all commands mirrored.</p> Source code in <code>src/pygerber/gerberx3/parser2/command_buffer2.py</code> <pre><code>def get_mirrored(self, mirror: Mirroring) -&gt; Self:\n    \"\"\"Get new command buffer with all commands mirrored.\"\"\"\n    return self.model_copy(\n        update={\"commands\": [c.get_mirrored(mirror) for c in self.commands]},\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/command_buffer2.html#pygerber.gerberx3.parser2.command_buffer2.ReadonlyCommandBuffer2.get_transposed","title":"get_transposed","text":"<pre><code>get_transposed(vector: Vector2D) -&gt; Self\n</code></pre> <p>Get new command buffer with all commands transposed.</p> Source code in <code>src/pygerber/gerberx3/parser2/command_buffer2.py</code> <pre><code>def get_transposed(self, vector: Vector2D) -&gt; Self:\n    \"\"\"Get new command buffer with all commands transposed.\"\"\"\n    return self.model_copy(\n        update={\"commands\": [c.get_transposed(vector) for c in self.commands]},\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/command_buffer2.html#pygerber.gerberx3.parser2.command_buffer2.ReadonlyCommandBuffer2.get_bounding_box","title":"get_bounding_box","text":"<pre><code>get_bounding_box() -&gt; BoundingBox\n</code></pre> <p>Get bounding box of command buffer.</p> Source code in <code>src/pygerber/gerberx3/parser2/command_buffer2.py</code> <pre><code>def get_bounding_box(self) -&gt; BoundingBox:\n    \"\"\"Get bounding box of command buffer.\"\"\"\n    bbox: Optional[BoundingBox] = None\n\n    for command in self:\n        if bbox is None:\n            bbox = command.get_bounding_box()\n        else:\n            bbox += command.get_bounding_box()\n\n    return BoundingBox.NULL if bbox is None else bbox\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html","title":"context2","text":""},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2","title":"context2","text":"<p>Gerber AST parser, version 2, parsing context.</p>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context","title":"Parser2Context","text":"<p>Context used by Gerber AST parser, version 2.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>class Parser2Context:\n    \"\"\"Context used by Gerber AST parser, version 2.\"\"\"\n\n    def __init__(self, options: Parser2ContextOptions | None = None) -&gt; None:\n        self.options = Parser2ContextOptions() if options is None else options\n        self.state: State2 = (\n            State2()\n            if self.options.initial_state is None\n            else self.options.initial_state\n        )\n        self.main_command_buffer: CommandBuffer2 = (\n            CommandBuffer2()\n            if self.options.initial_main_command_buffer is None\n            else self.options.initial_main_command_buffer\n        )\n        self.region_command_buffer: Optional[CommandBuffer2] = None\n        self.block_command_buffer_stack: list[CommandBuffer2] = []\n        self.block_state_stack: list[State2] = []\n        self.step_and_repeat_command_buffer: Optional[CommandBuffer2] = None\n        self.state_before_step_and_repeat: Optional[State2] = None\n        self.macro_statement_buffer: Optional[StatementBuffer2] = None\n        self.macro_eval_buffer: Optional[CommandBuffer2] = None\n        self.macro_variable_buffer: dict[str, Decimal] = {}\n        self.hooks: Parser2HooksBase = (\n            Parser2Hooks() if self.options.hooks is None else self.options.hooks\n        )\n        self.current_token: Optional[Token] = None\n        self.reached_program_stop: bool = False\n        self.reached_optional_stop: bool = False\n        self.reached_end_of_file: bool = False\n\n        self.file_attributes = FileAttributes()\n        self.aperture_attributes = ApertureAttributes()\n        self.object_attributes = ObjectAttributes()\n\n        self.macro_expressions = (\n            Parser2ContextMacroExpressionFactories()\n            if self.options.custom_macro_expression_factories is None\n            else self.options.custom_macro_expression_factories\n        )\n        self.apertures: dict[ApertureID, Aperture2] = {\n            REGION_OUTLINE_DEFAULT_APERTURE_ID: NoCircle2(\n                diameter=Offset.NULL,\n                hole_diameter=None,\n            ),\n        }\n\n    def push_block_command_buffer(self) -&gt; None:\n        \"\"\"Add new command buffer for block aperture draw commands.\"\"\"\n        self.block_command_buffer_stack.append(\n            CommandBuffer2()\n            if self.options.initial_block_command_buffer is None\n            else self.options.initial_block_command_buffer.copy(),\n        )\n\n    def pop_block_command_buffer(self) -&gt; CommandBuffer2:\n        \"\"\"Return latest block aperture command buffer and delete it from the stack.\"\"\"\n        if len(self.block_command_buffer_stack) == 0:\n            raise ReferencedNotInitializedBlockBufferError(self.current_token)\n        return self.block_command_buffer_stack.pop()\n\n    def first_block_command_buffer(self) -&gt; CommandBuffer2:\n        \"\"\"Return first (topmost) block aperture command buffer.\"\"\"\n        if len(self.block_command_buffer_stack) == 0:\n            raise ReferencedNotInitializedBlockBufferError(self.current_token)\n        return self.block_command_buffer_stack[-1]\n\n    def push_block_state(self) -&gt; None:\n        \"\"\"Add new command buffer for block aperture draw commands.\"\"\"\n        self.block_state_stack.append(self.state)\n\n    def pop_block_state(self) -&gt; State2:\n        \"\"\"Return latest block aperture command buffer and delete it from the stack.\"\"\"\n        if len(self.block_state_stack) == 0:\n            raise ReferencedNotInitializedBlockBufferError(self.current_token)\n        return self.block_state_stack.pop()\n\n    def set_region_command_buffer(self) -&gt; None:\n        \"\"\"Add new command buffer for block aperture draw commands.\"\"\"\n        self.region_command_buffer = (\n            CommandBuffer2()\n            if self.options.initial_region_command_buffer is None\n            else self.options.initial_region_command_buffer.copy()\n        )\n\n    def unset_region_command_buffer(self) -&gt; None:\n        \"\"\"Add new command buffer for block aperture draw commands.\"\"\"\n        self.region_command_buffer = None\n\n    def get_region_command_buffer(self) -&gt; CommandBuffer2:\n        \"\"\"Return latest block aperture command buffer and delete it from the stack.\"\"\"\n        if self.region_command_buffer is None:\n            raise RegionNotInitializedError(self.current_token)\n        return self.region_command_buffer\n\n    def set_step_and_repeat_command_buffer(self) -&gt; None:\n        \"\"\"Add new command buffer for block aperture draw commands.\"\"\"\n        self.step_and_repeat_command_buffer = (\n            CommandBuffer2()\n            if self.options.initial_region_command_buffer is None\n            else self.options.initial_region_command_buffer.copy()\n        )\n\n    def unset_step_and_repeat_command_buffer(self) -&gt; None:\n        \"\"\"Unset step and repeat command buffer.\"\"\"\n        self.step_and_repeat_command_buffer = None\n\n    def get_step_and_repeat_command_buffer(self) -&gt; CommandBuffer2:\n        \"\"\"Return step and repeat command buffer.\"\"\"\n        if self.step_and_repeat_command_buffer is None:\n            raise StepAndRepeatNotInitializedError(self.current_token)\n        return self.step_and_repeat_command_buffer\n\n    def get_state_before_step_and_repeat(self) -&gt; State2:\n        \"\"\"Return step and repeat command buffer.\"\"\"\n        if self.state_before_step_and_repeat is None:\n            raise StepAndRepeatNotInitializedError(self.current_token)\n        return self.state_before_step_and_repeat\n\n    def unset_state_before_step_and_repeat(self) -&gt; None:\n        \"\"\"Unset step and repeat command buffer.\"\"\"\n        self.state_before_step_and_repeat = None\n\n    def set_state_before_step_and_repeat(self) -&gt; None:\n        \"\"\"Add new command buffer for block aperture draw commands.\"\"\"\n        self.state_before_step_and_repeat = self.state\n\n    def reset_state_to_pre_step_and_repeat(self) -&gt; None:\n        \"\"\"Set state to state before step and repeat.\"\"\"\n        self.set_state(self.get_state_before_step_and_repeat())\n\n    def get_macro_statement_buffer(self) -&gt; StatementBuffer2:\n        \"\"\"Return macro statement buffer.\"\"\"\n        if self.macro_statement_buffer is None:\n            raise MacroNotInitializedError(self.current_token)\n        return self.macro_statement_buffer\n\n    def set_macro_statement_buffer(self) -&gt; None:\n        \"\"\"Add new command buffer for block aperture draw commands.\"\"\"\n        self.macro_statement_buffer = (\n            StatementBuffer2()\n            if self.options.initial_macro_statement_buffer is None\n            else self.options.initial_macro_statement_buffer\n        )\n\n    def unset_macro_statement_buffer(self) -&gt; None:\n        \"\"\"Unset step and repeat command buffer.\"\"\"\n        self.macro_statement_buffer = None\n\n    def get_macro_eval_buffer(self) -&gt; CommandBuffer2:\n        \"\"\"Return macro evaluation buffer.\"\"\"\n        if self.macro_eval_buffer is None:\n            raise MacroNotInitializedError(self.current_token)\n        return self.macro_eval_buffer\n\n    def set_macro_eval_buffer(self) -&gt; None:\n        \"\"\"Add new command buffer for block aperture draw commands.\"\"\"\n        self.macro_eval_buffer = (\n            CommandBuffer2()\n            if self.options.initial_macro_eval_buffer is None\n            else self.options.initial_macro_eval_buffer\n        )\n\n    def unset_macro_eval_buffer(self) -&gt; None:\n        \"\"\"Unset step and repeat command buffer.\"\"\"\n        self.macro_eval_buffer = None\n\n    def skip_token(self) -&gt; NoReturn:\n        \"\"\"Skip this token.\"\"\"\n        raise SkipTokenInterrupt\n\n    def halt_parser(self) -&gt; NoReturn:\n        \"\"\"Halt parsing process.\"\"\"\n        raise ExitParsingProcess2Interrupt\n\n    def get_hooks(self) -&gt; Parser2HooksBase:\n        \"\"\"Get hooks object.\"\"\"\n        return self.hooks\n\n    def get_current_token(self) -&gt; Optional[Token]:\n        \"\"\"Get current token object.\"\"\"\n        return self.current_token\n\n    def set_current_token(self, token: Token) -&gt; None:\n        \"\"\"Get current token object.\"\"\"\n        self.current_token = token\n\n    def set_state(self, state: State2) -&gt; None:\n        \"\"\"Set parser state.\"\"\"\n        self.state = state\n\n    def add_command(self, __command: Command2) -&gt; None:\n        \"\"\"Add draw command to command buffer.\"\"\"\n        if self.get_is_region():\n            self.get_region_command_buffer().add_command(__command)\n            return\n\n        if self.get_is_aperture_block():\n            self.first_block_command_buffer().add_command(__command)\n            return\n\n        if self.get_is_step_and_repeat():\n            self.get_step_and_repeat_command_buffer().add_command(__command)\n            return\n\n        self.main_command_buffer.add_command(__command)\n\n    def get_state(self) -&gt; State2:\n        \"\"\"Get parser state.\"\"\"\n        return self.state\n\n    def get_draw_units(self) -&gt; Unit:\n        \"\"\"Get draw_units property value.\"\"\"\n        return self.get_state().get_draw_units()\n\n    def set_draw_units(self, draw_units: Unit) -&gt; None:\n        \"\"\"Set the draw_units property value.\"\"\"\n        return self.set_state(self.get_state().set_draw_units(draw_units))\n\n    def get_coordinate_parser(self) -&gt; CoordinateParser:\n        \"\"\"Get coordinate_parser property value.\"\"\"\n        return self.get_state().get_coordinate_parser()\n\n    def set_coordinate_parser(self, coordinate_parser: CoordinateParser) -&gt; None:\n        \"\"\"Set the coordinate_parser property value.\"\"\"\n        return self.set_state(\n            self.get_state().set_coordinate_parser(coordinate_parser),\n        )\n\n    def get_polarity(self) -&gt; Polarity:\n        \"\"\"Get polarity property value.\"\"\"\n        return self.get_state().get_polarity()\n\n    def set_polarity(self, polarity: Polarity) -&gt; None:\n        \"\"\"Set the polarity property value.\"\"\"\n        return self.set_state(self.get_state().set_polarity(polarity))\n\n    def get_mirroring(self) -&gt; Mirroring:\n        \"\"\"Get mirroring property value.\"\"\"\n        return self.get_state().get_mirroring()\n\n    def set_mirroring(self, mirroring: Mirroring) -&gt; None:\n        \"\"\"Set the mirroring property value.\"\"\"\n        return self.set_state(self.get_state().set_mirroring(mirroring))\n\n    def get_rotation(self) -&gt; Decimal:\n        \"\"\"Get rotation property value.\"\"\"\n        return self.get_state().get_rotation()\n\n    def set_rotation(self, rotation: Decimal) -&gt; None:\n        \"\"\"Set the rotation property value.\"\"\"\n        return self.set_state(self.get_state().set_rotation(rotation))\n\n    def get_scaling(self) -&gt; Decimal:\n        \"\"\"Get scaling property value.\"\"\"\n        return self.get_state().get_scaling()\n\n    def set_scaling(self, scaling: Decimal) -&gt; None:\n        \"\"\"Set the scaling property value.\"\"\"\n        return self.set_state(self.get_state().set_scaling(scaling))\n\n    def get_is_output_image_negation_required(self) -&gt; bool:\n        \"\"\"Get is_output_image_negation_required property value.\"\"\"\n        return self.get_state().get_is_output_image_negation_required()\n\n    def set_is_output_image_negation_required(self, *, value: bool) -&gt; None:\n        \"\"\"Set the is_output_image_negation_required property value.\"\"\"\n        return self.set_state(\n            self.get_state().set_is_output_image_negation_required(value),\n        )\n\n    def get_image_name(self) -&gt; Optional[str]:\n        \"\"\"Get image_name property value.\"\"\"\n        return self.get_state().get_image_name()\n\n    def set_image_name(self, image_name: Optional[str]) -&gt; None:\n        \"\"\"Set the image_name property value.\"\"\"\n        return self.set_state(self.get_state().set_image_name(image_name))\n\n    def get_file_name(self) -&gt; Optional[str]:\n        \"\"\"Get file_name property value.\"\"\"\n        return self.get_state().get_file_name()\n\n    def set_file_name(self, file_name: Optional[str]) -&gt; None:\n        \"\"\"Set the file_name property value.\"\"\"\n        return self.set_state(self.get_state().set_file_name(file_name))\n\n    def get_axis_correspondence(self) -&gt; AxisCorrespondence:\n        \"\"\"Get axis_correspondence property value.\"\"\"\n        return self.get_state().get_axis_correspondence()\n\n    def set_axis_correspondence(self, axis_correspondence: AxisCorrespondence) -&gt; None:\n        \"\"\"Set the axis_correspondence property value.\"\"\"\n        return self.set_state(\n            self.get_state().set_axis_correspondence(axis_correspondence),\n        )\n\n    def get_draw_mode(self) -&gt; DrawMode:\n        \"\"\"Get draw_mode property value.\"\"\"\n        return self.get_state().get_draw_mode()\n\n    def set_draw_mode(self, draw_mode: DrawMode) -&gt; None:\n        \"\"\"Set the draw_mode property value.\"\"\"\n        return self.set_state(self.get_state().set_draw_mode(draw_mode))\n\n    def get_is_region(self) -&gt; bool:\n        \"\"\"Get is_region property value.\"\"\"\n        return self.get_state().get_is_region()\n\n    def set_is_region(self, is_region: bool) -&gt; None:  # noqa: FBT001\n        \"\"\"Set the is_region property value.\"\"\"\n        return self.set_state(self.get_state().set_is_region(is_region))\n\n    def get_is_aperture_block(self) -&gt; bool:\n        \"\"\"Get is_aperture_block property value.\"\"\"\n        return self.get_state().get_is_aperture_block()\n\n    def set_is_aperture_block(self, is_aperture_block: bool) -&gt; None:  # noqa: FBT001\n        \"\"\"Set the is_aperture_block property value.\"\"\"\n        return self.set_state(\n            self.get_state().set_is_aperture_block(is_aperture_block),\n        )\n\n    def get_aperture_block_id(self) -&gt; Optional[ApertureID]:\n        \"\"\"Get is_aperture_block property value.\"\"\"\n        return self.get_state().get_aperture_block_id()\n\n    def set_aperture_block_id(self, aperture_block_id: Optional[ApertureID]) -&gt; None:\n        \"\"\"Set the is_aperture_block property value.\"\"\"\n        return self.set_state(\n            self.get_state().set_aperture_block_id(aperture_block_id),\n        )\n\n    def get_is_multi_quadrant(self) -&gt; bool:\n        \"\"\"Get is_aperture_block property value.\"\"\"\n        return self.get_state().get_is_multi_quadrant()\n\n    def set_is_multi_quadrant(self, is_multi_quadrant: bool) -&gt; None:  # noqa: FBT001\n        \"\"\"Set the is_aperture_block property value.\"\"\"\n        return self.set_state(\n            self.get_state().set_is_multi_quadrant(is_multi_quadrant),\n        )\n\n    def get_is_step_and_repeat(self) -&gt; bool:\n        \"\"\"Get is_step_and_repeat property value.\"\"\"\n        return self.get_state().get_is_step_and_repeat()\n\n    def set_is_step_and_repeat(self, is_step_and_repeat: bool) -&gt; None:  # noqa: FBT001\n        \"\"\"Set the is_step_and_repeat property value.\"\"\"\n        return self.set_state(\n            self.get_state().set_is_step_and_repeat(is_step_and_repeat),\n        )\n\n    def get_x_repeat(self) -&gt; int:\n        \"\"\"Get x_step property value.\"\"\"\n        return self.get_state().get_x_repeat()\n\n    def set_x_repeat(self, x_repeat: int) -&gt; None:\n        \"\"\"Set the x_repeat property value.\"\"\"\n        return self.set_state(self.get_state().set_x_repeat(x_repeat))\n\n    def get_y_repeat(self) -&gt; int:\n        \"\"\"Get y_step property value.\"\"\"\n        return self.get_state().get_y_repeat()\n\n    def set_y_repeat(self, y_repeat: int) -&gt; None:\n        \"\"\"Set the y_repeat property value.\"\"\"\n        return self.set_state(self.get_state().set_y_repeat(y_repeat))\n\n    def get_x_step(self) -&gt; Offset:\n        \"\"\"Get x_step property value.\"\"\"\n        return self.get_state().get_x_step()\n\n    def set_x_step(self, x_step: Offset) -&gt; None:\n        \"\"\"Set the x_step property value.\"\"\"\n        return self.set_state(self.get_state().set_x_step(x_step))\n\n    def get_y_step(self) -&gt; Offset:\n        \"\"\"Get y_step property value.\"\"\"\n        return self.get_state().get_y_step()\n\n    def set_y_step(self, y_step: Offset) -&gt; None:\n        \"\"\"Set the y_step property value.\"\"\"\n        return self.set_state(self.get_state().set_y_step(y_step))\n\n    def get_current_position(self) -&gt; Vector2D:\n        \"\"\"Get current_position property value.\"\"\"\n        return self.get_state().get_current_position()\n\n    def set_current_position(self, current_position: Vector2D) -&gt; None:\n        \"\"\"Set the current_position property value.\"\"\"\n        return self.set_state(\n            self.get_state().set_current_position(current_position),\n        )\n\n    def get_current_aperture_id(self) -&gt; Optional[ApertureID]:\n        \"\"\"Get current_aperture property value.\"\"\"\n        current_aperture_id = self.get_state().get_current_aperture_id()\n        if current_aperture_id is None and self.get_is_region():\n            return REGION_OUTLINE_DEFAULT_APERTURE_ID\n\n        return current_aperture_id\n\n    def set_current_aperture_id(self, current_aperture: Optional[ApertureID]) -&gt; None:\n        \"\"\"Set the current_aperture property value.\"\"\"\n        return self.set_state(\n            self.get_state().set_current_aperture_id(current_aperture),\n        )\n\n    def get_aperture(self, __key: ApertureID) -&gt; Aperture2:\n        \"\"\"Get apertures property value.\"\"\"\n        try:\n            return self.apertures[__key]\n        except KeyError as e:\n            raise ApertureNotDefined2Error(self.current_token) from e\n\n    def set_aperture(self, __key: ApertureID, __value: Aperture2) -&gt; None:\n        \"\"\"Set the apertures property value.\"\"\"\n        self.apertures[__key] = __value\n\n    def get_macro(self, __key: str) -&gt; ApertureMacro2:\n        \"\"\"Get macro property value.\"\"\"\n        try:\n            return self.get_state().get_macro(__key)\n        except KeyError as e:\n            raise MacroNotDefinedError(self.current_token) from e\n\n    def set_macro(self, __key: str, __value: ApertureMacro2) -&gt; None:\n        \"\"\"Set the macro property value.\"\"\"\n        return self.set_state(self.get_state().set_macro(__key, __value))\n\n    def set_reached_program_stop(self) -&gt; None:\n        \"\"\"Set flag indicating that M00 token was reached.\"\"\"\n        self.reached_program_stop = True\n\n    def get_reached_program_stop(self) -&gt; bool:\n        \"\"\"Get flag indicating that M00 token was reached.\"\"\"\n        return self.reached_program_stop\n\n    def set_reached_optional_stop(self) -&gt; None:\n        \"\"\"Set flag indicating that M01 token was reached.\"\"\"\n        self.reached_optional_stop = True\n\n    def get_reached_optional_stop(self) -&gt; bool:\n        \"\"\"Get flag indicating that M01 token was reached.\"\"\"\n        return self.reached_optional_stop\n\n    def set_reached_end_of_file(self) -&gt; None:\n        \"\"\"Set flag indicating that M02 end of file was reached.\"\"\"\n        self.reached_end_of_file = True\n\n    def get_reached_end_of_file(self) -&gt; bool:\n        \"\"\"Get flag indicating that M02 end of file was reached.\"\"\"\n        return self.reached_end_of_file\n\n    def get_file_attribute(self, key: str) -&gt; Optional[str]:\n        \"\"\"Get file attributes property.\"\"\"\n        return self.file_attributes.get(key)\n\n    def delete_file_attribute(self, key: str) -&gt; None:\n        \"\"\"Get file attributes property.\"\"\"\n        self.file_attributes = self.file_attributes.delete(key)\n\n    def set_file_attribute(self, key: str, value: Optional[str]) -&gt; None:\n        \"\"\"Set file attributes property.\"\"\"\n        self.file_attributes = self.file_attributes.update(key, value)\n\n    def get_aperture_attribute(self, key: str) -&gt; Optional[str]:\n        \"\"\"Get aperture attributes property.\"\"\"\n        return self.aperture_attributes.get(key)\n\n    def delete_aperture_attribute(self, key: str) -&gt; None:\n        \"\"\"Delete aperture attributes property.\"\"\"\n        self.aperture_attributes = self.aperture_attributes.delete(key)\n\n    def clear_aperture_attributes(self) -&gt; None:\n        \"\"\"Clear aperture attributes property.\"\"\"\n        self.aperture_attributes = ApertureAttributes()\n\n    def set_aperture_attribute(self, key: str, value: Optional[str]) -&gt; None:\n        \"\"\"Set aperture attributes property.\"\"\"\n        self.aperture_attributes = self.aperture_attributes.update(key, value)\n\n    def get_object_attribute(self, key: str) -&gt; Optional[str]:\n        \"\"\"Get object attributes property.\"\"\"\n        return self.object_attributes.get(key)\n\n    def delete_object_attribute(self, key: str) -&gt; None:\n        \"\"\"Delete object attributes property.\"\"\"\n        self.object_attributes = self.object_attributes.delete(key)\n\n    def set_object_attribute(self, key: str, value: Optional[str]) -&gt; None:\n        \"\"\"Set object attributes property.\"\"\"\n        self.object_attributes = self.object_attributes.update(key, value)\n\n    def clear_object_attributes(self) -&gt; None:\n        \"\"\"Clear object attributes property.\"\"\"\n        self.object_attributes = ObjectAttributes()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.push_block_command_buffer","title":"push_block_command_buffer","text":"<pre><code>push_block_command_buffer() -&gt; None\n</code></pre> <p>Add new command buffer for block aperture draw commands.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def push_block_command_buffer(self) -&gt; None:\n    \"\"\"Add new command buffer for block aperture draw commands.\"\"\"\n    self.block_command_buffer_stack.append(\n        CommandBuffer2()\n        if self.options.initial_block_command_buffer is None\n        else self.options.initial_block_command_buffer.copy(),\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.pop_block_command_buffer","title":"pop_block_command_buffer","text":"<pre><code>pop_block_command_buffer() -&gt; CommandBuffer2\n</code></pre> <p>Return latest block aperture command buffer and delete it from the stack.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def pop_block_command_buffer(self) -&gt; CommandBuffer2:\n    \"\"\"Return latest block aperture command buffer and delete it from the stack.\"\"\"\n    if len(self.block_command_buffer_stack) == 0:\n        raise ReferencedNotInitializedBlockBufferError(self.current_token)\n    return self.block_command_buffer_stack.pop()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.first_block_command_buffer","title":"first_block_command_buffer","text":"<pre><code>first_block_command_buffer() -&gt; CommandBuffer2\n</code></pre> <p>Return first (topmost) block aperture command buffer.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def first_block_command_buffer(self) -&gt; CommandBuffer2:\n    \"\"\"Return first (topmost) block aperture command buffer.\"\"\"\n    if len(self.block_command_buffer_stack) == 0:\n        raise ReferencedNotInitializedBlockBufferError(self.current_token)\n    return self.block_command_buffer_stack[-1]\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.push_block_state","title":"push_block_state","text":"<pre><code>push_block_state() -&gt; None\n</code></pre> <p>Add new command buffer for block aperture draw commands.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def push_block_state(self) -&gt; None:\n    \"\"\"Add new command buffer for block aperture draw commands.\"\"\"\n    self.block_state_stack.append(self.state)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.pop_block_state","title":"pop_block_state","text":"<pre><code>pop_block_state() -&gt; State2\n</code></pre> <p>Return latest block aperture command buffer and delete it from the stack.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def pop_block_state(self) -&gt; State2:\n    \"\"\"Return latest block aperture command buffer and delete it from the stack.\"\"\"\n    if len(self.block_state_stack) == 0:\n        raise ReferencedNotInitializedBlockBufferError(self.current_token)\n    return self.block_state_stack.pop()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.set_region_command_buffer","title":"set_region_command_buffer","text":"<pre><code>set_region_command_buffer() -&gt; None\n</code></pre> <p>Add new command buffer for block aperture draw commands.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def set_region_command_buffer(self) -&gt; None:\n    \"\"\"Add new command buffer for block aperture draw commands.\"\"\"\n    self.region_command_buffer = (\n        CommandBuffer2()\n        if self.options.initial_region_command_buffer is None\n        else self.options.initial_region_command_buffer.copy()\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.unset_region_command_buffer","title":"unset_region_command_buffer","text":"<pre><code>unset_region_command_buffer() -&gt; None\n</code></pre> <p>Add new command buffer for block aperture draw commands.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def unset_region_command_buffer(self) -&gt; None:\n    \"\"\"Add new command buffer for block aperture draw commands.\"\"\"\n    self.region_command_buffer = None\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.get_region_command_buffer","title":"get_region_command_buffer","text":"<pre><code>get_region_command_buffer() -&gt; CommandBuffer2\n</code></pre> <p>Return latest block aperture command buffer and delete it from the stack.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def get_region_command_buffer(self) -&gt; CommandBuffer2:\n    \"\"\"Return latest block aperture command buffer and delete it from the stack.\"\"\"\n    if self.region_command_buffer is None:\n        raise RegionNotInitializedError(self.current_token)\n    return self.region_command_buffer\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.set_step_and_repeat_command_buffer","title":"set_step_and_repeat_command_buffer","text":"<pre><code>set_step_and_repeat_command_buffer() -&gt; None\n</code></pre> <p>Add new command buffer for block aperture draw commands.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def set_step_and_repeat_command_buffer(self) -&gt; None:\n    \"\"\"Add new command buffer for block aperture draw commands.\"\"\"\n    self.step_and_repeat_command_buffer = (\n        CommandBuffer2()\n        if self.options.initial_region_command_buffer is None\n        else self.options.initial_region_command_buffer.copy()\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.unset_step_and_repeat_command_buffer","title":"unset_step_and_repeat_command_buffer","text":"<pre><code>unset_step_and_repeat_command_buffer() -&gt; None\n</code></pre> <p>Unset step and repeat command buffer.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def unset_step_and_repeat_command_buffer(self) -&gt; None:\n    \"\"\"Unset step and repeat command buffer.\"\"\"\n    self.step_and_repeat_command_buffer = None\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.get_step_and_repeat_command_buffer","title":"get_step_and_repeat_command_buffer","text":"<pre><code>get_step_and_repeat_command_buffer() -&gt; CommandBuffer2\n</code></pre> <p>Return step and repeat command buffer.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def get_step_and_repeat_command_buffer(self) -&gt; CommandBuffer2:\n    \"\"\"Return step and repeat command buffer.\"\"\"\n    if self.step_and_repeat_command_buffer is None:\n        raise StepAndRepeatNotInitializedError(self.current_token)\n    return self.step_and_repeat_command_buffer\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.get_state_before_step_and_repeat","title":"get_state_before_step_and_repeat","text":"<pre><code>get_state_before_step_and_repeat() -&gt; State2\n</code></pre> <p>Return step and repeat command buffer.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def get_state_before_step_and_repeat(self) -&gt; State2:\n    \"\"\"Return step and repeat command buffer.\"\"\"\n    if self.state_before_step_and_repeat is None:\n        raise StepAndRepeatNotInitializedError(self.current_token)\n    return self.state_before_step_and_repeat\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.unset_state_before_step_and_repeat","title":"unset_state_before_step_and_repeat","text":"<pre><code>unset_state_before_step_and_repeat() -&gt; None\n</code></pre> <p>Unset step and repeat command buffer.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def unset_state_before_step_and_repeat(self) -&gt; None:\n    \"\"\"Unset step and repeat command buffer.\"\"\"\n    self.state_before_step_and_repeat = None\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.set_state_before_step_and_repeat","title":"set_state_before_step_and_repeat","text":"<pre><code>set_state_before_step_and_repeat() -&gt; None\n</code></pre> <p>Add new command buffer for block aperture draw commands.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def set_state_before_step_and_repeat(self) -&gt; None:\n    \"\"\"Add new command buffer for block aperture draw commands.\"\"\"\n    self.state_before_step_and_repeat = self.state\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.reset_state_to_pre_step_and_repeat","title":"reset_state_to_pre_step_and_repeat","text":"<pre><code>reset_state_to_pre_step_and_repeat() -&gt; None\n</code></pre> <p>Set state to state before step and repeat.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def reset_state_to_pre_step_and_repeat(self) -&gt; None:\n    \"\"\"Set state to state before step and repeat.\"\"\"\n    self.set_state(self.get_state_before_step_and_repeat())\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.get_macro_statement_buffer","title":"get_macro_statement_buffer","text":"<pre><code>get_macro_statement_buffer() -&gt; StatementBuffer2\n</code></pre> <p>Return macro statement buffer.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def get_macro_statement_buffer(self) -&gt; StatementBuffer2:\n    \"\"\"Return macro statement buffer.\"\"\"\n    if self.macro_statement_buffer is None:\n        raise MacroNotInitializedError(self.current_token)\n    return self.macro_statement_buffer\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.set_macro_statement_buffer","title":"set_macro_statement_buffer","text":"<pre><code>set_macro_statement_buffer() -&gt; None\n</code></pre> <p>Add new command buffer for block aperture draw commands.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def set_macro_statement_buffer(self) -&gt; None:\n    \"\"\"Add new command buffer for block aperture draw commands.\"\"\"\n    self.macro_statement_buffer = (\n        StatementBuffer2()\n        if self.options.initial_macro_statement_buffer is None\n        else self.options.initial_macro_statement_buffer\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.unset_macro_statement_buffer","title":"unset_macro_statement_buffer","text":"<pre><code>unset_macro_statement_buffer() -&gt; None\n</code></pre> <p>Unset step and repeat command buffer.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def unset_macro_statement_buffer(self) -&gt; None:\n    \"\"\"Unset step and repeat command buffer.\"\"\"\n    self.macro_statement_buffer = None\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.get_macro_eval_buffer","title":"get_macro_eval_buffer","text":"<pre><code>get_macro_eval_buffer() -&gt; CommandBuffer2\n</code></pre> <p>Return macro evaluation buffer.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def get_macro_eval_buffer(self) -&gt; CommandBuffer2:\n    \"\"\"Return macro evaluation buffer.\"\"\"\n    if self.macro_eval_buffer is None:\n        raise MacroNotInitializedError(self.current_token)\n    return self.macro_eval_buffer\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.set_macro_eval_buffer","title":"set_macro_eval_buffer","text":"<pre><code>set_macro_eval_buffer() -&gt; None\n</code></pre> <p>Add new command buffer for block aperture draw commands.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def set_macro_eval_buffer(self) -&gt; None:\n    \"\"\"Add new command buffer for block aperture draw commands.\"\"\"\n    self.macro_eval_buffer = (\n        CommandBuffer2()\n        if self.options.initial_macro_eval_buffer is None\n        else self.options.initial_macro_eval_buffer\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.unset_macro_eval_buffer","title":"unset_macro_eval_buffer","text":"<pre><code>unset_macro_eval_buffer() -&gt; None\n</code></pre> <p>Unset step and repeat command buffer.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def unset_macro_eval_buffer(self) -&gt; None:\n    \"\"\"Unset step and repeat command buffer.\"\"\"\n    self.macro_eval_buffer = None\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.skip_token","title":"skip_token","text":"<pre><code>skip_token() -&gt; NoReturn\n</code></pre> <p>Skip this token.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def skip_token(self) -&gt; NoReturn:\n    \"\"\"Skip this token.\"\"\"\n    raise SkipTokenInterrupt\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.halt_parser","title":"halt_parser","text":"<pre><code>halt_parser() -&gt; NoReturn\n</code></pre> <p>Halt parsing process.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def halt_parser(self) -&gt; NoReturn:\n    \"\"\"Halt parsing process.\"\"\"\n    raise ExitParsingProcess2Interrupt\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.get_hooks","title":"get_hooks","text":"<pre><code>get_hooks() -&gt; Parser2HooksBase\n</code></pre> <p>Get hooks object.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def get_hooks(self) -&gt; Parser2HooksBase:\n    \"\"\"Get hooks object.\"\"\"\n    return self.hooks\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.get_current_token","title":"get_current_token","text":"<pre><code>get_current_token() -&gt; Optional[Token]\n</code></pre> <p>Get current token object.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def get_current_token(self) -&gt; Optional[Token]:\n    \"\"\"Get current token object.\"\"\"\n    return self.current_token\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.set_current_token","title":"set_current_token","text":"<pre><code>set_current_token(token: Token) -&gt; None\n</code></pre> <p>Get current token object.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def set_current_token(self, token: Token) -&gt; None:\n    \"\"\"Get current token object.\"\"\"\n    self.current_token = token\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.set_state","title":"set_state","text":"<pre><code>set_state(state: State2) -&gt; None\n</code></pre> <p>Set parser state.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def set_state(self, state: State2) -&gt; None:\n    \"\"\"Set parser state.\"\"\"\n    self.state = state\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.add_command","title":"add_command","text":"<pre><code>add_command(__command: Command2) -&gt; None\n</code></pre> <p>Add draw command to command buffer.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def add_command(self, __command: Command2) -&gt; None:\n    \"\"\"Add draw command to command buffer.\"\"\"\n    if self.get_is_region():\n        self.get_region_command_buffer().add_command(__command)\n        return\n\n    if self.get_is_aperture_block():\n        self.first_block_command_buffer().add_command(__command)\n        return\n\n    if self.get_is_step_and_repeat():\n        self.get_step_and_repeat_command_buffer().add_command(__command)\n        return\n\n    self.main_command_buffer.add_command(__command)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.get_state","title":"get_state","text":"<pre><code>get_state() -&gt; State2\n</code></pre> <p>Get parser state.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def get_state(self) -&gt; State2:\n    \"\"\"Get parser state.\"\"\"\n    return self.state\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.get_draw_units","title":"get_draw_units","text":"<pre><code>get_draw_units() -&gt; Unit\n</code></pre> <p>Get draw_units property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def get_draw_units(self) -&gt; Unit:\n    \"\"\"Get draw_units property value.\"\"\"\n    return self.get_state().get_draw_units()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.set_draw_units","title":"set_draw_units","text":"<pre><code>set_draw_units(draw_units: Unit) -&gt; None\n</code></pre> <p>Set the draw_units property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def set_draw_units(self, draw_units: Unit) -&gt; None:\n    \"\"\"Set the draw_units property value.\"\"\"\n    return self.set_state(self.get_state().set_draw_units(draw_units))\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.get_coordinate_parser","title":"get_coordinate_parser","text":"<pre><code>get_coordinate_parser() -&gt; CoordinateParser\n</code></pre> <p>Get coordinate_parser property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def get_coordinate_parser(self) -&gt; CoordinateParser:\n    \"\"\"Get coordinate_parser property value.\"\"\"\n    return self.get_state().get_coordinate_parser()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.set_coordinate_parser","title":"set_coordinate_parser","text":"<pre><code>set_coordinate_parser(\n    coordinate_parser: CoordinateParser,\n) -&gt; None\n</code></pre> <p>Set the coordinate_parser property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def set_coordinate_parser(self, coordinate_parser: CoordinateParser) -&gt; None:\n    \"\"\"Set the coordinate_parser property value.\"\"\"\n    return self.set_state(\n        self.get_state().set_coordinate_parser(coordinate_parser),\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.get_polarity","title":"get_polarity","text":"<pre><code>get_polarity() -&gt; Polarity\n</code></pre> <p>Get polarity property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def get_polarity(self) -&gt; Polarity:\n    \"\"\"Get polarity property value.\"\"\"\n    return self.get_state().get_polarity()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.set_polarity","title":"set_polarity","text":"<pre><code>set_polarity(polarity: Polarity) -&gt; None\n</code></pre> <p>Set the polarity property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def set_polarity(self, polarity: Polarity) -&gt; None:\n    \"\"\"Set the polarity property value.\"\"\"\n    return self.set_state(self.get_state().set_polarity(polarity))\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.get_mirroring","title":"get_mirroring","text":"<pre><code>get_mirroring() -&gt; Mirroring\n</code></pre> <p>Get mirroring property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def get_mirroring(self) -&gt; Mirroring:\n    \"\"\"Get mirroring property value.\"\"\"\n    return self.get_state().get_mirroring()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.set_mirroring","title":"set_mirroring","text":"<pre><code>set_mirroring(mirroring: Mirroring) -&gt; None\n</code></pre> <p>Set the mirroring property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def set_mirroring(self, mirroring: Mirroring) -&gt; None:\n    \"\"\"Set the mirroring property value.\"\"\"\n    return self.set_state(self.get_state().set_mirroring(mirroring))\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.get_rotation","title":"get_rotation","text":"<pre><code>get_rotation() -&gt; Decimal\n</code></pre> <p>Get rotation property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def get_rotation(self) -&gt; Decimal:\n    \"\"\"Get rotation property value.\"\"\"\n    return self.get_state().get_rotation()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.set_rotation","title":"set_rotation","text":"<pre><code>set_rotation(rotation: Decimal) -&gt; None\n</code></pre> <p>Set the rotation property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def set_rotation(self, rotation: Decimal) -&gt; None:\n    \"\"\"Set the rotation property value.\"\"\"\n    return self.set_state(self.get_state().set_rotation(rotation))\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.get_scaling","title":"get_scaling","text":"<pre><code>get_scaling() -&gt; Decimal\n</code></pre> <p>Get scaling property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def get_scaling(self) -&gt; Decimal:\n    \"\"\"Get scaling property value.\"\"\"\n    return self.get_state().get_scaling()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.set_scaling","title":"set_scaling","text":"<pre><code>set_scaling(scaling: Decimal) -&gt; None\n</code></pre> <p>Set the scaling property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def set_scaling(self, scaling: Decimal) -&gt; None:\n    \"\"\"Set the scaling property value.\"\"\"\n    return self.set_state(self.get_state().set_scaling(scaling))\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.get_is_output_image_negation_required","title":"get_is_output_image_negation_required","text":"<pre><code>get_is_output_image_negation_required() -&gt; bool\n</code></pre> <p>Get is_output_image_negation_required property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def get_is_output_image_negation_required(self) -&gt; bool:\n    \"\"\"Get is_output_image_negation_required property value.\"\"\"\n    return self.get_state().get_is_output_image_negation_required()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.set_is_output_image_negation_required","title":"set_is_output_image_negation_required","text":"<pre><code>set_is_output_image_negation_required(\n    *, value: bool\n) -&gt; None\n</code></pre> <p>Set the is_output_image_negation_required property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def set_is_output_image_negation_required(self, *, value: bool) -&gt; None:\n    \"\"\"Set the is_output_image_negation_required property value.\"\"\"\n    return self.set_state(\n        self.get_state().set_is_output_image_negation_required(value),\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.get_image_name","title":"get_image_name","text":"<pre><code>get_image_name() -&gt; Optional[str]\n</code></pre> <p>Get image_name property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def get_image_name(self) -&gt; Optional[str]:\n    \"\"\"Get image_name property value.\"\"\"\n    return self.get_state().get_image_name()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.set_image_name","title":"set_image_name","text":"<pre><code>set_image_name(image_name: Optional[str]) -&gt; None\n</code></pre> <p>Set the image_name property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def set_image_name(self, image_name: Optional[str]) -&gt; None:\n    \"\"\"Set the image_name property value.\"\"\"\n    return self.set_state(self.get_state().set_image_name(image_name))\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.get_file_name","title":"get_file_name","text":"<pre><code>get_file_name() -&gt; Optional[str]\n</code></pre> <p>Get file_name property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def get_file_name(self) -&gt; Optional[str]:\n    \"\"\"Get file_name property value.\"\"\"\n    return self.get_state().get_file_name()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.set_file_name","title":"set_file_name","text":"<pre><code>set_file_name(file_name: Optional[str]) -&gt; None\n</code></pre> <p>Set the file_name property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def set_file_name(self, file_name: Optional[str]) -&gt; None:\n    \"\"\"Set the file_name property value.\"\"\"\n    return self.set_state(self.get_state().set_file_name(file_name))\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.get_axis_correspondence","title":"get_axis_correspondence","text":"<pre><code>get_axis_correspondence() -&gt; AxisCorrespondence\n</code></pre> <p>Get axis_correspondence property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def get_axis_correspondence(self) -&gt; AxisCorrespondence:\n    \"\"\"Get axis_correspondence property value.\"\"\"\n    return self.get_state().get_axis_correspondence()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.set_axis_correspondence","title":"set_axis_correspondence","text":"<pre><code>set_axis_correspondence(\n    axis_correspondence: AxisCorrespondence,\n) -&gt; None\n</code></pre> <p>Set the axis_correspondence property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def set_axis_correspondence(self, axis_correspondence: AxisCorrespondence) -&gt; None:\n    \"\"\"Set the axis_correspondence property value.\"\"\"\n    return self.set_state(\n        self.get_state().set_axis_correspondence(axis_correspondence),\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.get_draw_mode","title":"get_draw_mode","text":"<pre><code>get_draw_mode() -&gt; DrawMode\n</code></pre> <p>Get draw_mode property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def get_draw_mode(self) -&gt; DrawMode:\n    \"\"\"Get draw_mode property value.\"\"\"\n    return self.get_state().get_draw_mode()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.set_draw_mode","title":"set_draw_mode","text":"<pre><code>set_draw_mode(draw_mode: DrawMode) -&gt; None\n</code></pre> <p>Set the draw_mode property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def set_draw_mode(self, draw_mode: DrawMode) -&gt; None:\n    \"\"\"Set the draw_mode property value.\"\"\"\n    return self.set_state(self.get_state().set_draw_mode(draw_mode))\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.get_is_region","title":"get_is_region","text":"<pre><code>get_is_region() -&gt; bool\n</code></pre> <p>Get is_region property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def get_is_region(self) -&gt; bool:\n    \"\"\"Get is_region property value.\"\"\"\n    return self.get_state().get_is_region()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.set_is_region","title":"set_is_region","text":"<pre><code>set_is_region(is_region: bool) -&gt; None\n</code></pre> <p>Set the is_region property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def set_is_region(self, is_region: bool) -&gt; None:  # noqa: FBT001\n    \"\"\"Set the is_region property value.\"\"\"\n    return self.set_state(self.get_state().set_is_region(is_region))\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.get_is_aperture_block","title":"get_is_aperture_block","text":"<pre><code>get_is_aperture_block() -&gt; bool\n</code></pre> <p>Get is_aperture_block property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def get_is_aperture_block(self) -&gt; bool:\n    \"\"\"Get is_aperture_block property value.\"\"\"\n    return self.get_state().get_is_aperture_block()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.set_is_aperture_block","title":"set_is_aperture_block","text":"<pre><code>set_is_aperture_block(is_aperture_block: bool) -&gt; None\n</code></pre> <p>Set the is_aperture_block property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def set_is_aperture_block(self, is_aperture_block: bool) -&gt; None:  # noqa: FBT001\n    \"\"\"Set the is_aperture_block property value.\"\"\"\n    return self.set_state(\n        self.get_state().set_is_aperture_block(is_aperture_block),\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.get_aperture_block_id","title":"get_aperture_block_id","text":"<pre><code>get_aperture_block_id() -&gt; Optional[ApertureID]\n</code></pre> <p>Get is_aperture_block property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def get_aperture_block_id(self) -&gt; Optional[ApertureID]:\n    \"\"\"Get is_aperture_block property value.\"\"\"\n    return self.get_state().get_aperture_block_id()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.set_aperture_block_id","title":"set_aperture_block_id","text":"<pre><code>set_aperture_block_id(\n    aperture_block_id: Optional[ApertureID],\n) -&gt; None\n</code></pre> <p>Set the is_aperture_block property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def set_aperture_block_id(self, aperture_block_id: Optional[ApertureID]) -&gt; None:\n    \"\"\"Set the is_aperture_block property value.\"\"\"\n    return self.set_state(\n        self.get_state().set_aperture_block_id(aperture_block_id),\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.get_is_multi_quadrant","title":"get_is_multi_quadrant","text":"<pre><code>get_is_multi_quadrant() -&gt; bool\n</code></pre> <p>Get is_aperture_block property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def get_is_multi_quadrant(self) -&gt; bool:\n    \"\"\"Get is_aperture_block property value.\"\"\"\n    return self.get_state().get_is_multi_quadrant()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.set_is_multi_quadrant","title":"set_is_multi_quadrant","text":"<pre><code>set_is_multi_quadrant(is_multi_quadrant: bool) -&gt; None\n</code></pre> <p>Set the is_aperture_block property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def set_is_multi_quadrant(self, is_multi_quadrant: bool) -&gt; None:  # noqa: FBT001\n    \"\"\"Set the is_aperture_block property value.\"\"\"\n    return self.set_state(\n        self.get_state().set_is_multi_quadrant(is_multi_quadrant),\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.get_is_step_and_repeat","title":"get_is_step_and_repeat","text":"<pre><code>get_is_step_and_repeat() -&gt; bool\n</code></pre> <p>Get is_step_and_repeat property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def get_is_step_and_repeat(self) -&gt; bool:\n    \"\"\"Get is_step_and_repeat property value.\"\"\"\n    return self.get_state().get_is_step_and_repeat()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.set_is_step_and_repeat","title":"set_is_step_and_repeat","text":"<pre><code>set_is_step_and_repeat(is_step_and_repeat: bool) -&gt; None\n</code></pre> <p>Set the is_step_and_repeat property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def set_is_step_and_repeat(self, is_step_and_repeat: bool) -&gt; None:  # noqa: FBT001\n    \"\"\"Set the is_step_and_repeat property value.\"\"\"\n    return self.set_state(\n        self.get_state().set_is_step_and_repeat(is_step_and_repeat),\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.get_x_repeat","title":"get_x_repeat","text":"<pre><code>get_x_repeat() -&gt; int\n</code></pre> <p>Get x_step property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def get_x_repeat(self) -&gt; int:\n    \"\"\"Get x_step property value.\"\"\"\n    return self.get_state().get_x_repeat()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.set_x_repeat","title":"set_x_repeat","text":"<pre><code>set_x_repeat(x_repeat: int) -&gt; None\n</code></pre> <p>Set the x_repeat property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def set_x_repeat(self, x_repeat: int) -&gt; None:\n    \"\"\"Set the x_repeat property value.\"\"\"\n    return self.set_state(self.get_state().set_x_repeat(x_repeat))\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.get_y_repeat","title":"get_y_repeat","text":"<pre><code>get_y_repeat() -&gt; int\n</code></pre> <p>Get y_step property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def get_y_repeat(self) -&gt; int:\n    \"\"\"Get y_step property value.\"\"\"\n    return self.get_state().get_y_repeat()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.set_y_repeat","title":"set_y_repeat","text":"<pre><code>set_y_repeat(y_repeat: int) -&gt; None\n</code></pre> <p>Set the y_repeat property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def set_y_repeat(self, y_repeat: int) -&gt; None:\n    \"\"\"Set the y_repeat property value.\"\"\"\n    return self.set_state(self.get_state().set_y_repeat(y_repeat))\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.get_x_step","title":"get_x_step","text":"<pre><code>get_x_step() -&gt; Offset\n</code></pre> <p>Get x_step property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def get_x_step(self) -&gt; Offset:\n    \"\"\"Get x_step property value.\"\"\"\n    return self.get_state().get_x_step()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.set_x_step","title":"set_x_step","text":"<pre><code>set_x_step(x_step: Offset) -&gt; None\n</code></pre> <p>Set the x_step property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def set_x_step(self, x_step: Offset) -&gt; None:\n    \"\"\"Set the x_step property value.\"\"\"\n    return self.set_state(self.get_state().set_x_step(x_step))\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.get_y_step","title":"get_y_step","text":"<pre><code>get_y_step() -&gt; Offset\n</code></pre> <p>Get y_step property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def get_y_step(self) -&gt; Offset:\n    \"\"\"Get y_step property value.\"\"\"\n    return self.get_state().get_y_step()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.set_y_step","title":"set_y_step","text":"<pre><code>set_y_step(y_step: Offset) -&gt; None\n</code></pre> <p>Set the y_step property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def set_y_step(self, y_step: Offset) -&gt; None:\n    \"\"\"Set the y_step property value.\"\"\"\n    return self.set_state(self.get_state().set_y_step(y_step))\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.get_current_position","title":"get_current_position","text":"<pre><code>get_current_position() -&gt; Vector2D\n</code></pre> <p>Get current_position property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def get_current_position(self) -&gt; Vector2D:\n    \"\"\"Get current_position property value.\"\"\"\n    return self.get_state().get_current_position()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.set_current_position","title":"set_current_position","text":"<pre><code>set_current_position(current_position: Vector2D) -&gt; None\n</code></pre> <p>Set the current_position property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def set_current_position(self, current_position: Vector2D) -&gt; None:\n    \"\"\"Set the current_position property value.\"\"\"\n    return self.set_state(\n        self.get_state().set_current_position(current_position),\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.get_current_aperture_id","title":"get_current_aperture_id","text":"<pre><code>get_current_aperture_id() -&gt; Optional[ApertureID]\n</code></pre> <p>Get current_aperture property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def get_current_aperture_id(self) -&gt; Optional[ApertureID]:\n    \"\"\"Get current_aperture property value.\"\"\"\n    current_aperture_id = self.get_state().get_current_aperture_id()\n    if current_aperture_id is None and self.get_is_region():\n        return REGION_OUTLINE_DEFAULT_APERTURE_ID\n\n    return current_aperture_id\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.set_current_aperture_id","title":"set_current_aperture_id","text":"<pre><code>set_current_aperture_id(\n    current_aperture: Optional[ApertureID],\n) -&gt; None\n</code></pre> <p>Set the current_aperture property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def set_current_aperture_id(self, current_aperture: Optional[ApertureID]) -&gt; None:\n    \"\"\"Set the current_aperture property value.\"\"\"\n    return self.set_state(\n        self.get_state().set_current_aperture_id(current_aperture),\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.get_aperture","title":"get_aperture","text":"<pre><code>get_aperture(__key: ApertureID) -&gt; Aperture2\n</code></pre> <p>Get apertures property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def get_aperture(self, __key: ApertureID) -&gt; Aperture2:\n    \"\"\"Get apertures property value.\"\"\"\n    try:\n        return self.apertures[__key]\n    except KeyError as e:\n        raise ApertureNotDefined2Error(self.current_token) from e\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.set_aperture","title":"set_aperture","text":"<pre><code>set_aperture(__key: ApertureID, __value: Aperture2) -&gt; None\n</code></pre> <p>Set the apertures property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def set_aperture(self, __key: ApertureID, __value: Aperture2) -&gt; None:\n    \"\"\"Set the apertures property value.\"\"\"\n    self.apertures[__key] = __value\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.get_macro","title":"get_macro","text":"<pre><code>get_macro(__key: str) -&gt; ApertureMacro2\n</code></pre> <p>Get macro property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def get_macro(self, __key: str) -&gt; ApertureMacro2:\n    \"\"\"Get macro property value.\"\"\"\n    try:\n        return self.get_state().get_macro(__key)\n    except KeyError as e:\n        raise MacroNotDefinedError(self.current_token) from e\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.set_macro","title":"set_macro","text":"<pre><code>set_macro(__key: str, __value: ApertureMacro2) -&gt; None\n</code></pre> <p>Set the macro property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def set_macro(self, __key: str, __value: ApertureMacro2) -&gt; None:\n    \"\"\"Set the macro property value.\"\"\"\n    return self.set_state(self.get_state().set_macro(__key, __value))\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.set_reached_program_stop","title":"set_reached_program_stop","text":"<pre><code>set_reached_program_stop() -&gt; None\n</code></pre> <p>Set flag indicating that M00 token was reached.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def set_reached_program_stop(self) -&gt; None:\n    \"\"\"Set flag indicating that M00 token was reached.\"\"\"\n    self.reached_program_stop = True\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.get_reached_program_stop","title":"get_reached_program_stop","text":"<pre><code>get_reached_program_stop() -&gt; bool\n</code></pre> <p>Get flag indicating that M00 token was reached.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def get_reached_program_stop(self) -&gt; bool:\n    \"\"\"Get flag indicating that M00 token was reached.\"\"\"\n    return self.reached_program_stop\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.set_reached_optional_stop","title":"set_reached_optional_stop","text":"<pre><code>set_reached_optional_stop() -&gt; None\n</code></pre> <p>Set flag indicating that M01 token was reached.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def set_reached_optional_stop(self) -&gt; None:\n    \"\"\"Set flag indicating that M01 token was reached.\"\"\"\n    self.reached_optional_stop = True\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.get_reached_optional_stop","title":"get_reached_optional_stop","text":"<pre><code>get_reached_optional_stop() -&gt; bool\n</code></pre> <p>Get flag indicating that M01 token was reached.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def get_reached_optional_stop(self) -&gt; bool:\n    \"\"\"Get flag indicating that M01 token was reached.\"\"\"\n    return self.reached_optional_stop\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.set_reached_end_of_file","title":"set_reached_end_of_file","text":"<pre><code>set_reached_end_of_file() -&gt; None\n</code></pre> <p>Set flag indicating that M02 end of file was reached.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def set_reached_end_of_file(self) -&gt; None:\n    \"\"\"Set flag indicating that M02 end of file was reached.\"\"\"\n    self.reached_end_of_file = True\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.get_reached_end_of_file","title":"get_reached_end_of_file","text":"<pre><code>get_reached_end_of_file() -&gt; bool\n</code></pre> <p>Get flag indicating that M02 end of file was reached.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def get_reached_end_of_file(self) -&gt; bool:\n    \"\"\"Get flag indicating that M02 end of file was reached.\"\"\"\n    return self.reached_end_of_file\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.get_file_attribute","title":"get_file_attribute","text":"<pre><code>get_file_attribute(key: str) -&gt; Optional[str]\n</code></pre> <p>Get file attributes property.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def get_file_attribute(self, key: str) -&gt; Optional[str]:\n    \"\"\"Get file attributes property.\"\"\"\n    return self.file_attributes.get(key)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.delete_file_attribute","title":"delete_file_attribute","text":"<pre><code>delete_file_attribute(key: str) -&gt; None\n</code></pre> <p>Get file attributes property.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def delete_file_attribute(self, key: str) -&gt; None:\n    \"\"\"Get file attributes property.\"\"\"\n    self.file_attributes = self.file_attributes.delete(key)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.set_file_attribute","title":"set_file_attribute","text":"<pre><code>set_file_attribute(key: str, value: Optional[str]) -&gt; None\n</code></pre> <p>Set file attributes property.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def set_file_attribute(self, key: str, value: Optional[str]) -&gt; None:\n    \"\"\"Set file attributes property.\"\"\"\n    self.file_attributes = self.file_attributes.update(key, value)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.get_aperture_attribute","title":"get_aperture_attribute","text":"<pre><code>get_aperture_attribute(key: str) -&gt; Optional[str]\n</code></pre> <p>Get aperture attributes property.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def get_aperture_attribute(self, key: str) -&gt; Optional[str]:\n    \"\"\"Get aperture attributes property.\"\"\"\n    return self.aperture_attributes.get(key)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.delete_aperture_attribute","title":"delete_aperture_attribute","text":"<pre><code>delete_aperture_attribute(key: str) -&gt; None\n</code></pre> <p>Delete aperture attributes property.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def delete_aperture_attribute(self, key: str) -&gt; None:\n    \"\"\"Delete aperture attributes property.\"\"\"\n    self.aperture_attributes = self.aperture_attributes.delete(key)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.clear_aperture_attributes","title":"clear_aperture_attributes","text":"<pre><code>clear_aperture_attributes() -&gt; None\n</code></pre> <p>Clear aperture attributes property.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def clear_aperture_attributes(self) -&gt; None:\n    \"\"\"Clear aperture attributes property.\"\"\"\n    self.aperture_attributes = ApertureAttributes()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.set_aperture_attribute","title":"set_aperture_attribute","text":"<pre><code>set_aperture_attribute(\n    key: str, value: Optional[str]\n) -&gt; None\n</code></pre> <p>Set aperture attributes property.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def set_aperture_attribute(self, key: str, value: Optional[str]) -&gt; None:\n    \"\"\"Set aperture attributes property.\"\"\"\n    self.aperture_attributes = self.aperture_attributes.update(key, value)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.get_object_attribute","title":"get_object_attribute","text":"<pre><code>get_object_attribute(key: str) -&gt; Optional[str]\n</code></pre> <p>Get object attributes property.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def get_object_attribute(self, key: str) -&gt; Optional[str]:\n    \"\"\"Get object attributes property.\"\"\"\n    return self.object_attributes.get(key)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.delete_object_attribute","title":"delete_object_attribute","text":"<pre><code>delete_object_attribute(key: str) -&gt; None\n</code></pre> <p>Delete object attributes property.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def delete_object_attribute(self, key: str) -&gt; None:\n    \"\"\"Delete object attributes property.\"\"\"\n    self.object_attributes = self.object_attributes.delete(key)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.set_object_attribute","title":"set_object_attribute","text":"<pre><code>set_object_attribute(\n    key: str, value: Optional[str]\n) -&gt; None\n</code></pre> <p>Set object attributes property.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def set_object_attribute(self, key: str, value: Optional[str]) -&gt; None:\n    \"\"\"Set object attributes property.\"\"\"\n    self.object_attributes = self.object_attributes.update(key, value)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2Context.clear_object_attributes","title":"clear_object_attributes","text":"<pre><code>clear_object_attributes() -&gt; None\n</code></pre> <p>Clear object attributes property.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>def clear_object_attributes(self) -&gt; None:\n    \"\"\"Clear object attributes property.\"\"\"\n    self.object_attributes = ObjectAttributes()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2ContextMacroExpressionFactories","title":"Parser2ContextMacroExpressionFactories  <code>dataclass</code>","text":"<p>Collection of factories for all macro expressions.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>@dataclass\nclass Parser2ContextMacroExpressionFactories:\n    \"\"\"Collection of factories for all macro expressions.\"\"\"\n\n    constant: Type[Constant2] = Constant2\n    variable_name: Type[VariableName2] = VariableName2\n    addition: Type[Addition2] = Addition2\n    subtraction: Type[Subtraction2] = Subtraction2\n    multiplication: Type[Multiplication2] = Multiplication2\n    division: Type[Division2] = Division2\n    negation: Type[Negation2] = Negation2\n    positive: Type[Positive2] = Positive2\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/context2.html#pygerber.gerberx3.parser2.context2.Parser2ContextOptions","title":"Parser2ContextOptions","text":"<p>             Bases: <code>FrozenGeneralModel</code></p> <p>Options for Parser2Context.</p> Source code in <code>src/pygerber/gerberx3/parser2/context2.py</code> <pre><code>class Parser2ContextOptions(FrozenGeneralModel):\n    \"\"\"Options for Parser2Context.\"\"\"\n\n    initial_state: Optional[State2] = Field(default=None)\n    initial_main_command_buffer: Optional[CommandBuffer2] = Field(default=None)\n    initial_region_command_buffer: Optional[CommandBuffer2] = Field(default=None)\n    initial_block_command_buffer: Optional[CommandBuffer2] = Field(default=None)\n    initial_macro_statement_buffer: Optional[StatementBuffer2] = Field(default=None)\n    initial_macro_eval_buffer: Optional[CommandBuffer2] = Field(default=None)\n    custom_macro_expression_factories: Optional[\n        Parser2ContextMacroExpressionFactories\n    ] = Field(\n        default=None,\n    )\n    hooks: Optional[Parser2HooksBase] = Field(default=None)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/errors2.html","title":"errors2","text":""},{"location":"reference/pygerber/gerberx3/parser2/errors2.html#pygerber.gerberx3.parser2.errors2","title":"errors2","text":"<p>Base error classes used in this module.</p>"},{"location":"reference/pygerber/gerberx3/parser2/errors2.html#pygerber.gerberx3.parser2.errors2.Parser2Error","title":"Parser2Error","text":"<p>             Bases: <code>ValueError</code></p> <p>Base class for parser errors.</p> <p>Exceptions derived from this exception are exclusively raised in PyGerber's Gerber X3 Parser. This exception can be used in <code>try: ... except Parser2Error: ...</code> block to catch all exceptions raised by Parser while allowing other exceptions to interrupt execution.</p> Source code in <code>src/pygerber/gerberx3/parser2/errors2.py</code> <pre><code>class Parser2Error(ValueError):\n    \"\"\"Base class for parser errors.\n\n    Exceptions derived from this exception are exclusively raised in PyGerber's Gerber\n    X3 Parser. This exception can be used in\n    `#!python try: ... except Parser2Error: ...` block to catch all exceptions\n    raised by Parser while allowing other exceptions to interrupt execution.\n    \"\"\"\n\n    def get_message(self) -&gt; str:\n        \"\"\"Get parser error help message.\"\"\"\n        return f\"{self.__class__.__qualname__}: {self.__doc__}\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/errors2.html#pygerber.gerberx3.parser2.errors2.Parser2Error.get_message","title":"get_message","text":"<pre><code>get_message() -&gt; str\n</code></pre> <p>Get parser error help message.</p> Source code in <code>src/pygerber/gerberx3/parser2/errors2.py</code> <pre><code>def get_message(self) -&gt; str:\n    \"\"\"Get parser error help message.\"\"\"\n    return f\"{self.__class__.__qualname__}: {self.__doc__}\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/errors2.html#pygerber.gerberx3.parser2.errors2.ZeroOmissionNotSupported2Error","title":"ZeroOmissionNotSupported2Error","text":"<p>             Bases: <code>Parser2Error</code></p> <p>Raised when incremental coordinates are selected. (Spec. 8.2.1.2).</p> Source code in <code>src/pygerber/gerberx3/parser2/errors2.py</code> <pre><code>class ZeroOmissionNotSupported2Error(Parser2Error):\n    \"\"\"Raised when incremental coordinates are selected. (Spec. 8.2.1.2).\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/errors2.html#pygerber.gerberx3.parser2.errors2.IncrementalCoordinatesNotSupported2Error","title":"IncrementalCoordinatesNotSupported2Error","text":"<p>             Bases: <code>Parser2Error</code></p> <p>Raised when incremental coordinates are selected. (Spec. 8.2.1.2).</p> Source code in <code>src/pygerber/gerberx3/parser2/errors2.py</code> <pre><code>class IncrementalCoordinatesNotSupported2Error(Parser2Error):\n    \"\"\"Raised when incremental coordinates are selected. (Spec. 8.2.1.2).\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/errors2.html#pygerber.gerberx3.parser2.errors2.UnsupportedCoordinateType2Error","title":"UnsupportedCoordinateType2Error","text":"<p>             Bases: <code>Parser2Error</code></p> <p>Raised for unsupported coordinate types.</p> Source code in <code>src/pygerber/gerberx3/parser2/errors2.py</code> <pre><code>class UnsupportedCoordinateType2Error(Parser2Error):\n    \"\"\"Raised for unsupported coordinate types.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/errors2.html#pygerber.gerberx3.parser2.errors2.InvalidCoordinateLength2Error","title":"InvalidCoordinateLength2Error","text":"<p>             Bases: <code>Parser2Error</code></p> <p>Raised when coordinate string is too long.</p> Source code in <code>src/pygerber/gerberx3/parser2/errors2.py</code> <pre><code>class InvalidCoordinateLength2Error(Parser2Error):\n    \"\"\"Raised when coordinate string is too long.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/errors2.html#pygerber.gerberx3.parser2.errors2.ParserFatal2Error","title":"ParserFatal2Error","text":"<p>             Bases: <code>Parser2Error</code></p> <p>Raised when parser encounters fatal failure from non-parser specific exception.</p> Source code in <code>src/pygerber/gerberx3/parser2/errors2.py</code> <pre><code>class ParserFatal2Error(Parser2Error):\n    \"\"\"Raised when parser encounters fatal failure from non-parser specific\n    exception.\n    \"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/errors2.html#pygerber.gerberx3.parser2.errors2.OnUpdateDrawingState2Error","title":"OnUpdateDrawingState2Error","text":"<p>             Bases: <code>Parser2Error</code></p> <p>Raised when parser encounters fatal failure from non-parser specific exception during call to .update_drawing_state() call.</p> Source code in <code>src/pygerber/gerberx3/parser2/errors2.py</code> <pre><code>class OnUpdateDrawingState2Error(Parser2Error):\n    \"\"\"Raised when parser encounters fatal failure from non-parser specific\n    exception during call to .update_drawing_state() call.\n    \"\"\"\n\n    def __init__(self, token: Token, *args: object) -&gt; None:\n        super().__init__(*args)\n        self.token = token\n\n    def __str__(self) -&gt; str:\n        return f\"{self.token} {self.token.get_token_position()}\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/errors2.html#pygerber.gerberx3.parser2.errors2.UnitNotSet2Error","title":"UnitNotSet2Error","text":"<p>             Bases: <code>Parser2Error</code></p> <p>Raised when operation which requires units to be set is executed before units are set.</p> Source code in <code>src/pygerber/gerberx3/parser2/errors2.py</code> <pre><code>class UnitNotSet2Error(Parser2Error):\n    \"\"\"Raised when operation which requires units to be set is executed before units\n    are set.\n    \"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/errors2.html#pygerber.gerberx3.parser2.errors2.ReferencedNotInitializedBlockBufferError","title":"ReferencedNotInitializedBlockBufferError","text":"<p>             Bases: <code>Parser2Error</code></p> <p>Raised when Gerber file references block buffer which has not been initialized, ie. when block aperture was not correctly started.</p> Source code in <code>src/pygerber/gerberx3/parser2/errors2.py</code> <pre><code>class ReferencedNotInitializedBlockBufferError(Parser2Error):\n    \"\"\"Raised when Gerber file references block buffer which has not been\n    initialized, ie. when block aperture was not correctly started.\n    \"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/errors2.html#pygerber.gerberx3.parser2.errors2.UnnamedBlockApertureNotAllowedError","title":"UnnamedBlockApertureNotAllowedError","text":"<p>             Bases: <code>Parser2Error</code></p> <p>Raised when aperture block with no ID is encountered.</p> Source code in <code>src/pygerber/gerberx3/parser2/errors2.py</code> <pre><code>class UnnamedBlockApertureNotAllowedError(Parser2Error):\n    \"\"\"Raised when aperture block with no ID is encountered.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/errors2.html#pygerber.gerberx3.parser2.errors2.RegionNotInitializedError","title":"RegionNotInitializedError","text":"<p>             Bases: <code>Parser2Error</code></p> <p>Raised when region is modified without being accessed without initialization.</p> Source code in <code>src/pygerber/gerberx3/parser2/errors2.py</code> <pre><code>class RegionNotInitializedError(Parser2Error):\n    \"\"\"Raised when region is modified without being accessed without initialization.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/errors2.html#pygerber.gerberx3.parser2.errors2.ApertureNotDefined2Error","title":"ApertureNotDefined2Error","text":"<p>             Bases: <code>Parser2Error</code></p> <p>Raised when undefined aperture is selected.</p> Source code in <code>src/pygerber/gerberx3/parser2/errors2.py</code> <pre><code>class ApertureNotDefined2Error(Parser2Error):\n    \"\"\"Raised when undefined aperture is selected.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/errors2.html#pygerber.gerberx3.parser2.errors2.MacroNotDefinedError","title":"MacroNotDefinedError","text":"<p>             Bases: <code>Parser2Error</code></p> <p>Raised when undefined macro is referenced.</p> Source code in <code>src/pygerber/gerberx3/parser2/errors2.py</code> <pre><code>class MacroNotDefinedError(Parser2Error):\n    \"\"\"Raised when undefined macro is referenced.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/errors2.html#pygerber.gerberx3.parser2.errors2.NoValidArcCenterFoundError","title":"NoValidArcCenterFoundError","text":"<p>             Bases: <code>Parser2Error</code></p> <p>Raised when no valid arc center point can not be deduced from IJ offset in single quadrant mode (G74).</p> Source code in <code>src/pygerber/gerberx3/parser2/errors2.py</code> <pre><code>class NoValidArcCenterFoundError(Parser2Error):\n    \"\"\"Raised when no valid arc center point can not be deduced from IJ offset in\n    single quadrant mode (G74).\n    \"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/errors2.html#pygerber.gerberx3.parser2.errors2.CoordinateFormatNotSet2Error","title":"CoordinateFormatNotSet2Error","text":"<p>             Bases: <code>Parser2Error</code></p> <p>Raised when coordinate parser is requested before coordinate format was set.</p> Source code in <code>src/pygerber/gerberx3/parser2/errors2.py</code> <pre><code>class CoordinateFormatNotSet2Error(Parser2Error):\n    \"\"\"Raised when coordinate parser is requested before coordinate format was set.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/errors2.html#pygerber.gerberx3.parser2.errors2.ApertureNotSelected2Error","title":"ApertureNotSelected2Error","text":"<p>             Bases: <code>Parser2Error</code></p> <p>Raised when attempting to use aperture without selecting it first.</p> Source code in <code>src/pygerber/gerberx3/parser2/errors2.py</code> <pre><code>class ApertureNotSelected2Error(Parser2Error):\n    \"\"\"Raised when attempting to use aperture without selecting it first.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/errors2.html#pygerber.gerberx3.parser2.errors2.StepAndRepeatNotInitializedError","title":"StepAndRepeatNotInitializedError","text":"<p>             Bases: <code>Parser2Error</code></p> <p>Raised when step and repeat block is closed without being correctly opened.</p> Source code in <code>src/pygerber/gerberx3/parser2/errors2.py</code> <pre><code>class StepAndRepeatNotInitializedError(Parser2Error):\n    \"\"\"Raised when step and repeat block is closed without being correctly opened.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/errors2.html#pygerber.gerberx3.parser2.errors2.MacroNotInitializedError","title":"MacroNotInitializedError","text":"<p>             Bases: <code>Parser2Error</code></p> <p>Raised when macro statement buffer is requested without being correctly initialized.</p> Source code in <code>src/pygerber/gerberx3/parser2/errors2.py</code> <pre><code>class MacroNotInitializedError(Parser2Error):\n    \"\"\"Raised when macro statement buffer is requested without being correctly\n    initialized.\n    \"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/errors2.html#pygerber.gerberx3.parser2.errors2.StandardAttributeError","title":"StandardAttributeError","text":"<p>             Bases: <code>Parser2Error</code></p> <p>Raised when parser encounters an error while processing a standard attribute.</p> Source code in <code>src/pygerber/gerberx3/parser2/errors2.py</code> <pre><code>class StandardAttributeError(Parser2Error):\n    \"\"\"Raised when parser encounters an error while processing a standard attribute.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/errors2.html#pygerber.gerberx3.parser2.errors2.MissingNameFieldError","title":"MissingNameFieldError","text":"<p>             Bases: <code>StandardAttributeError</code></p> <p>Raised when a missing name field is detected.</p> Source code in <code>src/pygerber/gerberx3/parser2/errors2.py</code> <pre><code>class MissingNameFieldError(StandardAttributeError):\n    \"\"\"Raised when a missing name field is detected.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/errors2.html#pygerber.gerberx3.parser2.errors2.MissingGuidFieldError","title":"MissingGuidFieldError","text":"<p>             Bases: <code>StandardAttributeError</code></p> <p>Raised when a missing name field is detected.</p> Source code in <code>src/pygerber/gerberx3/parser2/errors2.py</code> <pre><code>class MissingGuidFieldError(StandardAttributeError):\n    \"\"\"Raised when a missing name field is detected.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/errors2.html#pygerber.gerberx3.parser2.errors2.MissingRevisionFieldError","title":"MissingRevisionFieldError","text":"<p>             Bases: <code>StandardAttributeError</code></p> <p>Raised when a missing name field is detected.</p> Source code in <code>src/pygerber/gerberx3/parser2/errors2.py</code> <pre><code>class MissingRevisionFieldError(StandardAttributeError):\n    \"\"\"Raised when a missing name field is detected.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/errors2.html#pygerber.gerberx3.parser2.errors2.Parser2Interrupt","title":"Parser2Interrupt","text":"<p>             Bases: <code>Exception</code></p> <p>Base class for implementing interrupts.</p> Source code in <code>src/pygerber/gerberx3/parser2/errors2.py</code> <pre><code>class Parser2Interrupt(Exception):  # noqa: N818\n    \"\"\"Base class for implementing interrupts.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/errors2.html#pygerber.gerberx3.parser2.errors2.ExitParsingProcess2Interrupt","title":"ExitParsingProcess2Interrupt","text":"<p>             Bases: <code>Exception</code></p> <p>Raised to stop parsing.</p> Source code in <code>src/pygerber/gerberx3/parser2/errors2.py</code> <pre><code>class ExitParsingProcess2Interrupt(Exception):  # noqa: N818\n    \"\"\"Raised to stop parsing.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/errors2.html#pygerber.gerberx3.parser2.errors2.SkipTokenInterrupt","title":"SkipTokenInterrupt","text":"<p>             Bases: <code>Exception</code></p> <p>Raised to skip all other actions that would be performed on current token.</p> Source code in <code>src/pygerber/gerberx3/parser2/errors2.py</code> <pre><code>class SkipTokenInterrupt(Exception):  # noqa: N818\n    \"\"\"Raised to skip all other actions that would be performed on current token.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2.html","title":"parser2","text":""},{"location":"reference/pygerber/gerberx3/parser2/parser2.html#pygerber.gerberx3.parser2.parser2","title":"parser2","text":"<p>Implementation of Gerber AST parser, version 2.</p>"},{"location":"reference/pygerber/gerberx3/parser2/parser2.html#pygerber.gerberx3.parser2.parser2.Parser2","title":"Parser2","text":"<p>Gerber AST parser, version 2.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2.py</code> <pre><code>class Parser2:\n    \"\"\"Gerber AST parser, version 2.\"\"\"\n\n    def __init__(\n        self,\n        options: Optional[Parser2Options] = None,\n    ) -&gt; None:\n        \"\"\"Initialize parser.\n\n        Parameters\n        ----------\n        options : ParserOptions | None\n            Additional options for modifying parser behavior.\n        \"\"\"\n        self.options = Parser2Options() if options is None else options\n        self.is_used = False\n        self.context = (\n            Parser2Context(self.options.context_options)\n            if self.options.initial_context is None\n            else self.options.initial_context\n        )\n        self.get_hooks().on_parser_init(self)\n\n    def parse(self, ast: AST) -&gt; ReadonlyCommandBuffer2:\n        \"\"\"Parse token stack.\"\"\"\n        for _ in self.parse_iter(ast):\n            pass\n\n        return self.context.main_command_buffer.get_readonly()\n\n    def parse_iter(\n        self,\n        ast: AST,\n    ) -&gt; Generator[tuple[Token, Parser2Context], None, None]:\n        \"\"\"Iterate over tokens in stack and parse them.\"\"\"\n        self.get_hooks().pre_parse(self.context)\n        self.is_used = True\n\n        try:\n            for token in ast:\n                self.context.set_current_token(token)\n                self._token_try_visit_except(token)\n\n                yield token, self.context\n\n        except ExitParsingProcess2Interrupt:\n            pass\n\n        self.get_hooks().post_parse(self.context)\n\n    def _token_try_visit_except(self, token: Token) -&gt; None:\n        try:\n            self.get_hooks().pre_parser_visit_any_token(self.context)\n            token.parser2_visit_token(self.context)\n            self.get_hooks().post_parser_visit_any_token(self.context)\n\n        except SkipTokenInterrupt:\n            return\n\n        except ExitParsingProcess2Interrupt:\n            raise\n\n        except Exception as e:  # noqa: BLE001\n            if (\n                self.options.on_update_drawing_state_error\n                == Parser2OnErrorAction.Ignore\n            ):\n                pass\n\n            elif (\n                self.options.on_update_drawing_state_error == Parser2OnErrorAction.Raise\n            ):\n                if not isinstance(e, Parser2Error):\n                    raise OnUpdateDrawingState2Error(token) from e\n\n                raise\n\n            elif (\n                self.options.on_update_drawing_state_error == Parser2OnErrorAction.Warn\n            ):\n                logging.warning(\n                    \"Encountered fatal error during call to update_drawing_state() \"\n                    \"of '%s' token %s. Parser will skip this token and continue.\",\n                    token,\n                    token.get_token_position(),\n                )\n\n            elif (\n                self.options.on_update_drawing_state_error\n                == Parser2OnErrorAction.UseHook\n            ):\n                if isinstance(e, Parser2Error):\n                    self.get_hooks().on_parser_error(self.context, e)\n                else:\n                    self.get_hooks().on_other_error(self.context, e)\n\n    def get_hooks(self) -&gt; Parser2HooksBase:\n        \"\"\"Get hooks object.\"\"\"\n        return self.context.get_hooks()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2.html#pygerber.gerberx3.parser2.parser2.Parser2.__init__","title":"__init__","text":"<pre><code>__init__(options: Optional[Parser2Options] = None) -&gt; None\n</code></pre> <p>Initialize parser.</p> <p>Parameters:</p> Name Type Description Default <code>options</code> <code>ParserOptions | None</code> <p>Additional options for modifying parser behavior.</p> <code>None</code> Source code in <code>src/pygerber/gerberx3/parser2/parser2.py</code> <pre><code>def __init__(\n    self,\n    options: Optional[Parser2Options] = None,\n) -&gt; None:\n    \"\"\"Initialize parser.\n\n    Parameters\n    ----------\n    options : ParserOptions | None\n        Additional options for modifying parser behavior.\n    \"\"\"\n    self.options = Parser2Options() if options is None else options\n    self.is_used = False\n    self.context = (\n        Parser2Context(self.options.context_options)\n        if self.options.initial_context is None\n        else self.options.initial_context\n    )\n    self.get_hooks().on_parser_init(self)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2.html#pygerber.gerberx3.parser2.parser2.Parser2.parse","title":"parse","text":"<pre><code>parse(ast: AST) -&gt; ReadonlyCommandBuffer2\n</code></pre> <p>Parse token stack.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2.py</code> <pre><code>def parse(self, ast: AST) -&gt; ReadonlyCommandBuffer2:\n    \"\"\"Parse token stack.\"\"\"\n    for _ in self.parse_iter(ast):\n        pass\n\n    return self.context.main_command_buffer.get_readonly()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2.html#pygerber.gerberx3.parser2.parser2.Parser2.parse_iter","title":"parse_iter","text":"<pre><code>parse_iter(\n    ast: AST,\n) -&gt; Generator[tuple[Token, Parser2Context], None, None]\n</code></pre> <p>Iterate over tokens in stack and parse them.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2.py</code> <pre><code>def parse_iter(\n    self,\n    ast: AST,\n) -&gt; Generator[tuple[Token, Parser2Context], None, None]:\n    \"\"\"Iterate over tokens in stack and parse them.\"\"\"\n    self.get_hooks().pre_parse(self.context)\n    self.is_used = True\n\n    try:\n        for token in ast:\n            self.context.set_current_token(token)\n            self._token_try_visit_except(token)\n\n            yield token, self.context\n\n    except ExitParsingProcess2Interrupt:\n        pass\n\n    self.get_hooks().post_parse(self.context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2.html#pygerber.gerberx3.parser2.parser2.Parser2.get_hooks","title":"get_hooks","text":"<pre><code>get_hooks() -&gt; Parser2HooksBase\n</code></pre> <p>Get hooks object.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2.py</code> <pre><code>def get_hooks(self) -&gt; Parser2HooksBase:\n    \"\"\"Get hooks object.\"\"\"\n    return self.context.get_hooks()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2.html#pygerber.gerberx3.parser2.parser2.Parser2OnErrorAction","title":"Parser2OnErrorAction","text":"<p>             Bases: <code>Enum</code></p> <p>Possible error actions.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2.py</code> <pre><code>class Parser2OnErrorAction(Enum):\n    \"\"\"Possible error actions.\"\"\"\n\n    Ignore = \"ignore\"\n    \"\"\"Ignore parser errors. Errors which occurred will not be signaled. May yield\n    unexpected results for broken files, with missing draw commands or even more\n    significant errors.\"\"\"\n\n    Warn = \"warn\"\n    \"\"\"Warn on parser error. Parser will log warning message about what went wrong.\n    Best for supporting wide range of files without silently ignoring errors in code.\"\"\"\n\n    Raise = \"raise\"\n    \"\"\"Raise exception whenever parser encounters error. Will completely break out of\n    parsing process, making it impossible to render slightly malformed files.\"\"\"\n\n    UseHook = \"use_hook\"\n    \"\"\"Use appropriate hooks to dispatch exception.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2.html#pygerber.gerberx3.parser2.parser2.Parser2OnErrorAction.Ignore","title":"Ignore  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Ignore = 'ignore'\n</code></pre> <p>Ignore parser errors. Errors which occurred will not be signaled. May yield unexpected results for broken files, with missing draw commands or even more significant errors.</p>"},{"location":"reference/pygerber/gerberx3/parser2/parser2.html#pygerber.gerberx3.parser2.parser2.Parser2OnErrorAction.Warn","title":"Warn  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Warn = 'warn'\n</code></pre> <p>Warn on parser error. Parser will log warning message about what went wrong. Best for supporting wide range of files without silently ignoring errors in code.</p>"},{"location":"reference/pygerber/gerberx3/parser2/parser2.html#pygerber.gerberx3.parser2.parser2.Parser2OnErrorAction.Raise","title":"Raise  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Raise = 'raise'\n</code></pre> <p>Raise exception whenever parser encounters error. Will completely break out of parsing process, making it impossible to render slightly malformed files.</p>"},{"location":"reference/pygerber/gerberx3/parser2/parser2.html#pygerber.gerberx3.parser2.parser2.Parser2OnErrorAction.UseHook","title":"UseHook  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UseHook = 'use_hook'\n</code></pre> <p>Use appropriate hooks to dispatch exception.</p>"},{"location":"reference/pygerber/gerberx3/parser2/parser2.html#pygerber.gerberx3.parser2.parser2.Parser2Options","title":"Parser2Options","text":"<p>             Bases: <code>FrozenGeneralModel</code></p> <p>Container class for Gerber parser options.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2.py</code> <pre><code>class Parser2Options(FrozenGeneralModel):\n    \"\"\"Container class for Gerber parser options.\"\"\"\n\n    initial_context: Optional[Parser2Context] = Field(default=None)\n    context_options: Optional[Parser2ContextOptions] = Field(default=None)\n    on_update_drawing_state_error: Parser2OnErrorAction = Parser2OnErrorAction.Raise\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html","title":"parser2hooks","text":""},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks","title":"parser2hooks","text":"<p>Implementation of hooks for Gerber AST Parser, version 2.</p>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks","title":"Parser2Hooks","text":"<p>             Bases: <code>Parser2HooksBase</code></p> <p>Implementation of hooks for Gerber AST Parser, version 2.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>class Parser2Hooks(Parser2HooksBase):\n    \"\"\"Implementation of hooks for Gerber AST Parser, version 2.\"\"\"\n\n    class MacroBeginTokenHooks(Parser2HooksBase.MacroBeginTokenHooks):\n        \"\"\"Hooks for visiting macro begin token (AM).\"\"\"\n\n        def on_parser_visit_token(\n            self,\n            token: MacroBegin,\n            context: Parser2Context,\n        ) -&gt; None:\n            \"\"\"Called when parser visits a token.\n\n            This hook should perform all changes on context implicated by token type.\n\n            Parameters\n            ----------\n            token: TokenT\n                The token that is being visited.\n            context : Parser2Context\n                The context object containing information about the parser state.\n            \"\"\"\n            context.set_macro_statement_buffer()\n            return super().on_parser_visit_token(token, context)\n\n    class MacroCode1CircleTokenHooks(Parser2HooksBase.MacroCode1CircleTokenHooks):\n        \"\"\"Hooks for visiting macro primitive code 0 circle.\"\"\"\n\n        def on_parser_visit_token(\n            self,\n            token: Code1CircleToken,\n            context: Parser2Context,\n        ) -&gt; None:\n            \"\"\"Adds the primitive to the statement buffer.\n\n            Parameters\n            ----------\n            token: TokenT\n                The token that is being visited.\n            context : Parser2Context\n                The context object containing information about the parser state.\n\n            \"\"\"\n            context.get_macro_statement_buffer().add_statement(\n                Code1Circle2(\n                    exposure=token.exposure.to_parser2_expression(context),\n                    diameter=token.diameter.to_parser2_expression(context),\n                    center_x=token.center_x.to_parser2_expression(context),\n                    center_y=token.center_y.to_parser2_expression(context),\n                    rotation=token.rotation.to_parser2_expression(context),\n                ),\n            )\n            return super().on_parser_visit_token(token, context)\n\n    class MacroCode2VectorLineTokenHooks(\n        Parser2HooksBase.MacroCode2VectorLineTokenHooks,\n    ):\n        \"\"\"Hooks for visiting macro primitive code 2 vector line.\"\"\"\n\n        def on_parser_visit_token(\n            self,\n            token: Code2VectorLineToken,\n            context: Parser2Context,\n        ) -&gt; None:\n            \"\"\"Adds the primitive to the statement buffer.\n\n            Parameters\n            ----------\n            token: Code2VectorLine\n                The token that is being visited.\n            context : Parser2Context\n                The context object containing information about the parser state.\n\n            \"\"\"\n            context.get_macro_statement_buffer().add_statement(\n                Code2VectorLine2(),\n            )\n            return super().on_parser_visit_token(token, context)\n\n    class MacroCode4OutlineTokenHooks(Parser2HooksBase.MacroCode4OutlineTokenHooks):\n        \"\"\"Hooks for visiting macro primitive code 4 outline.\"\"\"\n\n        def on_parser_visit_token(\n            self,\n            token: Code4OutlineToken,\n            context: Parser2Context,\n        ) -&gt; None:\n            \"\"\"Adds the primitive to the statement buffer.\n\n            Parameters\n            ----------\n            token: TokenT\n                The token that is being visited.\n            context : Parser2Context\n                The context object containing information about the parser state.\n\n            \"\"\"\n            context.get_macro_statement_buffer().add_statement(\n                Code4Outline2(\n                    exposure=token.exposure.to_parser2_expression(context),\n                    vertex_count=token.number_of_vertices.to_parser2_expression(\n                        context,\n                    ),\n                    start_x=token.start_x.to_parser2_expression(context),\n                    start_y=token.start_y.to_parser2_expression(context),\n                    points=[point.to_parser2_point2(context) for point in token.point],\n                    rotation=token.rotation.to_parser2_expression(context),\n                ),\n            )\n            return super().on_parser_visit_token(token, context)\n\n    class MacroCode5PolygonTokenHooks(Parser2HooksBase.MacroCode5PolygonTokenHooks):\n        \"\"\"Hooks for visiting macro primitive code 5 polygon.\"\"\"\n\n        def on_parser_visit_token(\n            self,\n            token: Code5PolygonToken,\n            context: Parser2Context,\n        ) -&gt; None:\n            \"\"\"Adds the primitive to the statement buffer.\n\n            Parameters\n            ----------\n            token: TokenT\n                The token that is being visited.\n            context : Parser2Context\n                The context object containing information about the parser state.\n\n            \"\"\"\n            context.get_macro_statement_buffer().add_statement(\n                Code5Polygon2(\n                    exposure=token.exposure.to_parser2_expression(context),\n                    number_of_vertices=token.number_of_vertices.to_parser2_expression(\n                        context,\n                    ),\n                    center_x=token.center_x.to_parser2_expression(context),\n                    center_y=token.center_y.to_parser2_expression(context),\n                    diameter=token.diameter.to_parser2_expression(context),\n                    rotation=token.rotation.to_parser2_expression(context),\n                ),\n            )\n            return super().on_parser_visit_token(token, context)\n\n    class MacroCode6MoireTokenHooks(Parser2HooksBase.MacroCode6MoireTokenHooks):\n        \"\"\"Hooks for visiting macro primitive code 6 moire.\"\"\"\n\n        def on_parser_visit_token(\n            self,\n            token: Code6MoireToken,\n            context: Parser2Context,\n        ) -&gt; None:\n            \"\"\"Adds the primitive to the statement buffer.\n\n            Parameters\n            ----------\n            token: TokenT\n                The token that is being visited.\n            context : Parser2Context\n                The context object containing information about the parser state.\n\n            \"\"\"\n            context.get_macro_statement_buffer().add_statement(\n                Code6Moire2(),\n            )\n            return super().on_parser_visit_token(token, context)\n\n    class MacroCode7ThermalTokenHooks(Parser2HooksBase.MacroCode7ThermalTokenHooks):\n        \"\"\"Hooks for visiting macro primitive code 7 thermal.\"\"\"\n\n        def on_parser_visit_token(\n            self,\n            token: Code7ThermalToken,\n            context: Parser2Context,\n        ) -&gt; None:\n            \"\"\"Adds the primitive to the statement buffer.\n\n            Parameters\n            ----------\n            token: TokenT\n                The token that is being visited.\n            context : Parser2Context\n                The context object containing information about the parser state.\n\n            \"\"\"\n            context.get_macro_statement_buffer().add_statement(\n                Code7Thermal2(\n                    center_x=token.center_x.to_parser2_expression(context),\n                    center_y=token.center_y.to_parser2_expression(context),\n                    outer_diameter=token.outer_diameter.to_parser2_expression(context),\n                    inner_diameter=token.inner_diameter.to_parser2_expression(context),\n                    gap=token.gap.to_parser2_expression(context),\n                    rotation=token.rotation.to_parser2_expression(context),\n                ),\n            )\n            return super().on_parser_visit_token(token, context)\n\n    class MacroCode20VectorLineTokenHooks(\n        Parser2HooksBase.MacroCode20VectorLineTokenHooks,\n    ):\n        \"\"\"Hooks for visiting macro primitive code 20 vector line.\"\"\"\n\n        def on_parser_visit_token(\n            self,\n            token: Code20VectorLineToken,\n            context: Parser2Context,\n        ) -&gt; None:\n            \"\"\"Adds the primitive to the statement buffer.\n\n            Parameters\n            ----------\n            token: TokenT\n                The token that is being visited.\n            context : Parser2Context\n                The context object containing information about the parser state.\n\n            \"\"\"\n            context.get_macro_statement_buffer().add_statement(\n                Code20VectorLine2(\n                    exposure=token.exposure.to_parser2_expression(context),\n                    width=token.width.to_parser2_expression(context),\n                    start_x=token.start_x.to_parser2_expression(context),\n                    start_y=token.start_y.to_parser2_expression(context),\n                    end_x=token.end_x.to_parser2_expression(context),\n                    end_y=token.end_y.to_parser2_expression(context),\n                    rotation=token.rotation.to_parser2_expression(context),\n                ),\n            )\n            return super().on_parser_visit_token(token, context)\n\n    class MacroCode21CenterLineTokenHooks(\n        Parser2HooksBase.MacroCode21CenterLineTokenHooks,\n    ):\n        \"\"\"Hooks for visiting macro primitive code 21 center line.\"\"\"\n\n        def on_parser_visit_token(\n            self,\n            token: Code21CenterLineToken,\n            context: Parser2Context,\n        ) -&gt; None:\n            \"\"\"Adds the primitive to the statement buffer.\n\n            Parameters\n            ----------\n            token: TokenT\n                The token that is being visited.\n            context : Parser2Context\n                The context object containing information about the parser state.\n\n            \"\"\"\n            context.get_macro_statement_buffer().add_statement(\n                Code21CenterLine2(\n                    exposure=token.exposure.to_parser2_expression(context),\n                    width=token.width.to_parser2_expression(context),\n                    height=token.height.to_parser2_expression(context),\n                    center_x=token.center_x.to_parser2_expression(context),\n                    center_y=token.center_y.to_parser2_expression(context),\n                    rotation=token.rotation.to_parser2_expression(context),\n                ),\n            )\n            return super().on_parser_visit_token(token, context)\n\n    class MacroCode22LowerLeftLineTokenHooks(\n        Parser2HooksBase.MacroCode22LowerLeftLineTokenHooks,\n    ):\n        \"\"\"Hooks for visiting macro primitive code 22 lower left line.\"\"\"\n\n        def on_parser_visit_token(\n            self,\n            token: Code22LowerLeftLineToken,\n            context: Parser2Context,\n        ) -&gt; None:\n            \"\"\"Adds the primitive to the statement buffer.\n\n            Parameters\n            ----------\n            token: TokenT\n                The token that is being visited.\n            context : Parser2Context\n                The context object containing information about the parser state.\n\n            \"\"\"\n            context.get_macro_statement_buffer().add_statement(Code22LowerLeftLine2())\n            return super().on_parser_visit_token(token, context)\n\n    class MacroVariableAssignment(Parser2HooksBase.MacroVariableAssignment):\n        \"\"\"Hooks for visiting macro variable assignment token.\"\"\"\n\n        def on_parser_visit_token(\n            self,\n            token: MacroVariableAssignment,\n            context: Parser2Context,\n        ) -&gt; None:\n            \"\"\"Adds the primitive to the statement buffer.\n\n            Parameters\n            ----------\n            token: TokenT\n                The token that is being visited.\n            context : Parser2Context\n                The context object containing information about the parser state.\n\n            \"\"\"\n            context.get_macro_statement_buffer().add_statement(\n                Assignment2(\n                    variable_name=token.variable.name,\n                    value=token.value.to_parser2_expression(context),\n                ),\n            )\n            return super().on_parser_visit_token(token, context)\n\n    class MacroDefinitionTokenHooks(Parser2HooksBase.MacroDefinitionTokenHooks):\n        \"\"\"Hooks for visiting macro definition token (AM).\"\"\"\n\n        def on_parser_visit_token(\n            self,\n            token: MacroDefinition,\n            context: Parser2Context,\n        ) -&gt; None:\n            \"\"\"Called when parser visits a token.\n\n            This hook should perform all changes on context implicated by token type.\n\n            Parameters\n            ----------\n            token: TokenT\n                The token that is being visited.\n            context : Parser2Context\n                The context object containing information about the parser state.\n            \"\"\"\n            stmt_buff = context.get_macro_statement_buffer()\n            macro_name = token.macro_name\n\n            context.set_macro(\n                macro_name,\n                ApertureMacro2(name=macro_name, statements=stmt_buff.get_readonly()),\n            )\n            context.unset_macro_statement_buffer()\n            return super().on_parser_visit_token(token, context)\n\n    class BeginBlockApertureTokenHooks(Parser2HooksBase.BeginBlockApertureTokenHooks):\n        \"\"\"Hooks for visiting begin block aperture token (AB).\"\"\"\n\n        def on_parser_visit_token(\n            self,\n            token: BlockApertureBegin,\n            context: Parser2Context,\n        ) -&gt; None:\n            \"\"\"Called when parser visits a token.\n\n            This hook should perform all changes on context implicated by token type.\n\n            Parameters\n            ----------\n            token: TokenT\n                The token that is being visited.\n            context : Parser2Context\n                The context object containing information about the parser state.\n            \"\"\"\n            context.push_block_command_buffer()\n            # Save state from before block definition started.\n            context.push_block_state()\n\n            context.set_current_position(Vector2D.NULL)\n            context.set_is_aperture_block(is_aperture_block=True)\n            context.set_aperture_block_id(token.identifier)\n\n            return super().on_parser_visit_token(token, context)\n\n    class EndBlockApertureTokenHooks(Parser2HooksBase.EndBlockApertureTokenHooks):\n        \"\"\"Hooks for visiting end block aperture token (AB).\"\"\"\n\n        def on_parser_visit_token(\n            self,\n            token: BlockApertureEnd,\n            context: Parser2Context,\n        ) -&gt; None:\n            \"\"\"Called when parser visits a token.\n\n            This hook should perform all changes on context implicated by token type.\n\n            Parameters\n            ----------\n            token: TokenT\n                The token that is being visited.\n            context : Parser2Context\n                The context object containing information about the parser state.\n            \"\"\"\n            command_buffer = context.pop_block_command_buffer()\n            identifier = context.get_aperture_block_id()\n            if identifier is None:\n                raise UnnamedBlockApertureNotAllowedError(token)\n\n            context.set_aperture(\n                identifier,\n                Block2(\n                    attributes=context.aperture_attributes,\n                    command_buffer=command_buffer.get_readonly(),\n                ),\n            )\n            # Restore context state from before the block definition.\n            context.set_state(context.pop_block_state())\n            return super().on_parser_visit_token(token, context)\n\n    class DefineApertureCircleTokenHooks(\n        Parser2HooksBase.DefineApertureCircleTokenHooks,\n    ):\n        \"\"\"Hooks for visiting circle aperture definition token (ADD).\"\"\"\n\n        def on_parser_visit_token(\n            self,\n            token: DefineCircle,\n            context: Parser2Context,\n        ) -&gt; None:\n            \"\"\"Called when parser visits a token.\n\n            This hook should perform all changes on context implicated by token type.\n\n            Parameters\n            ----------\n            token: TokenT\n                The token that is being visited.\n            context : Parser2Context\n                The context object containing information about the parser state.\n            \"\"\"\n            hole_diameter = (\n                None\n                if token.hole_diameter is None\n                else Offset.new(token.hole_diameter, context.get_draw_units())\n            )\n\n            context.set_aperture(\n                token.aperture_id,\n                Circle2(\n                    attributes=context.aperture_attributes,\n                    diameter=Offset.new(token.diameter, context.get_draw_units()),\n                    hole_diameter=hole_diameter,\n                ),\n            )\n            return super().on_parser_visit_token(token, context)\n\n    class DefineApertureRectangleTokenHooks(\n        Parser2HooksBase.DefineApertureRectangleTokenHooks,\n    ):\n        \"\"\"Hooks for visiting rectangle aperture definition token (ADD).\"\"\"\n\n        def on_parser_visit_token(\n            self,\n            token: DefineRectangle,\n            context: Parser2Context,\n        ) -&gt; None:\n            \"\"\"Called when parser visits a token.\n\n            This hook should perform all changes on context implicated by token type.\n\n            Parameters\n            ----------\n            token: TokenT\n                The token that is being visited.\n            context : Parser2Context\n                The context object containing information about the parser state.\n            \"\"\"\n            hole_diameter = (\n                None\n                if token.hole_diameter is None\n                else Offset.new(token.hole_diameter, context.get_draw_units())\n            )\n\n            context.set_aperture(\n                token.aperture_id,\n                Rectangle2(\n                    attributes=context.aperture_attributes,\n                    x_size=Offset.new(token.x_size, context.get_draw_units()),\n                    y_size=Offset.new(token.y_size, context.get_draw_units()),\n                    hole_diameter=hole_diameter,\n                ),\n            )\n            return super().on_parser_visit_token(token, context)\n\n    class DefineApertureObroundTokenHooks(\n        Parser2HooksBase.DefineApertureObroundTokenHooks,\n    ):\n        \"\"\"Hooks for visiting obround aperture definition token (ADD).\"\"\"\n\n        def on_parser_visit_token(\n            self,\n            token: DefineObround,\n            context: Parser2Context,\n        ) -&gt; None:\n            \"\"\"Called when parser visits a token.\n\n            This hook should perform all changes on context implicated by token type.\n\n            Parameters\n            ----------\n            token: TokenT\n                The token that is being visited.\n            context : Parser2Context\n                The context object containing information about the parser state.\n            \"\"\"\n            hole_diameter = (\n                None\n                if token.hole_diameter is None\n                else Offset.new(token.hole_diameter, context.get_draw_units())\n            )\n\n            context.set_aperture(\n                token.aperture_id,\n                Obround2(\n                    attributes=context.aperture_attributes,\n                    x_size=Offset.new(token.x_size, context.get_draw_units()),\n                    y_size=Offset.new(token.y_size, context.get_draw_units()),\n                    hole_diameter=hole_diameter,\n                ),\n            )\n            return super().on_parser_visit_token(token, context)\n\n    class DefineAperturePolygonTokenHooks(\n        Parser2HooksBase.DefineAperturePolygonTokenHooks,\n    ):\n        \"\"\"Hooks for visiting polygon aperture definition token (ADD).\"\"\"\n\n        def on_parser_visit_token(\n            self,\n            token: DefinePolygon,\n            context: Parser2Context,\n        ) -&gt; None:\n            \"\"\"Called when parser visits a token.\n\n            This hook should perform all changes on context implicated by token type.\n\n            Parameters\n            ----------\n            token: TokenT\n                The token that is being visited.\n            context : Parser2Context\n                The context object containing information about the parser state.\n            \"\"\"\n            hole_diameter = (\n                None\n                if token.hole_diameter is None\n                else Offset.new(token.hole_diameter, context.get_draw_units())\n            )\n            rotation = Decimal(\"0.0\") if token.rotation is None else token.rotation\n\n            context.set_aperture(\n                token.aperture_id,\n                Polygon2(\n                    attributes=context.aperture_attributes,\n                    outer_diameter=Offset.new(\n                        token.outer_diameter,\n                        context.get_draw_units(),\n                    ),\n                    number_vertices=token.number_of_vertices,\n                    rotation=rotation,\n                    hole_diameter=hole_diameter,\n                ),\n            )\n            return super().on_parser_visit_token(token, context)\n\n    class DefineApertureMacroTokenHooks(Parser2HooksBase.DefineApertureMacroTokenHooks):\n        \"\"\"Hooks for visiting macro aperture definition token (ADD).\"\"\"\n\n        def on_parser_visit_token(\n            self,\n            token: DefineMacro,\n            context: Parser2Context,\n        ) -&gt; None:\n            \"\"\"Called when parser visits a token.\n\n            This hook should perform all changes on context implicated by token type.\n\n            Parameters\n            ----------\n            token: TokenT\n                The token that is being visited.\n            context : Parser2Context\n                The context object containing information about the parser state.\n            \"\"\"\n            macro = context.get_macro(token.aperture_type)\n            context.set_macro_eval_buffer()\n            context.macro_variable_buffer = {\n                f\"${i}\": Decimal(param) for i, param in enumerate(token.am_param, 1)\n            }\n            macro.on_parser2_eval_statement(context)\n\n            context.set_aperture(\n                token.aperture_id,\n                Macro2(\n                    attributes=context.aperture_attributes,\n                    command_buffer=context.get_macro_eval_buffer().get_readonly(),\n                ),\n            )\n\n            context.unset_macro_eval_buffer()\n            context.macro_variable_buffer = {}\n\n            return super().on_parser_visit_token(token, context)\n\n    class MacroEvalHooks:\n        \"\"\"Hooks called when evaluating macro aperture.\"\"\"\n\n        def on_code_1_circle(\n            self,\n            context: Parser2Context,\n            primitive: Code1Circle2,\n        ) -&gt; None:\n            \"\"\"Evaluate code 1 circle primitive.\"\"\"\n            exposure = primitive.exposure.on_parser2_eval_expression(context)\n            polarity = (\n                Polarity.Clear\n                if math.isclose(exposure, Decimal(\"0.0\"))\n                else Polarity.Dark\n            )\n            context.get_macro_eval_buffer().add_command(\n                Flash2(\n                    transform=ApertureTransform(\n                        polarity=polarity,\n                        mirroring=Mirroring.NoMirroring,\n                        rotation=Decimal(\"0.0\"),\n                        scaling=Decimal(\"1.0\"),\n                    ),\n                    aperture=Circle2(\n                        diameter=Offset.new(\n                            primitive.diameter.on_parser2_eval_expression(context),\n                            context.get_draw_units(),\n                        ),\n                        hole_diameter=None,\n                    ),\n                    flash_point=Vector2D(\n                        x=Offset.new(\n                            primitive.center_x.on_parser2_eval_expression(context),\n                            context.get_draw_units(),\n                        ),\n                        y=Offset.new(\n                            primitive.center_y.on_parser2_eval_expression(context),\n                            context.get_draw_units(),\n                        ),\n                    ),\n                ),\n            )\n\n        def on_code_2_vector_line(\n            self,\n            context: Parser2Context,\n            primitive: Code2VectorLine2,\n        ) -&gt; None:\n            \"\"\"Evaluate code 2 vector line primitive.\"\"\"\n\n        def on_code_4_outline(\n            self,\n            context: Parser2Context,\n            primitive: Code4Outline2,\n        ) -&gt; None:\n            \"\"\"Evaluate code 4 outline primitive.\"\"\"\n            exposure = primitive.exposure.on_parser2_eval_expression(context)\n            polarity = (\n                Polarity.Clear\n                if math.isclose(exposure, Decimal(\"0.0\"))\n                else Polarity.Dark\n            )\n            transform = ApertureTransform(\n                polarity=polarity,\n                mirroring=Mirroring.NoMirroring,\n                rotation=Decimal(\"0.0\"),\n                scaling=Decimal(\"1.0\"),\n            )\n            aperture = Circle2(\n                diameter=Offset.NULL,\n                hole_diameter=None,\n            )\n            context.get_macro_eval_buffer().add_command(\n                Region2(\n                    transform=ApertureTransform(\n                        polarity=polarity,\n                        mirroring=Mirroring.NoMirroring,\n                        rotation=Decimal(\"0.0\"),\n                        scaling=Decimal(\"1.0\"),\n                    ),\n                    command_buffer=CommandBuffer2(\n                        [\n                            Line2(\n                                transform=transform,\n                                aperture=aperture,\n                                start_point=Vector2D(\n                                    x=Offset.new(\n                                        start_point.x.on_parser2_eval_expression(\n                                            context,\n                                        ),\n                                        context.get_draw_units(),\n                                    ),\n                                    y=Offset.new(\n                                        start_point.y.on_parser2_eval_expression(\n                                            context,\n                                        ),\n                                        context.get_draw_units(),\n                                    ),\n                                ),\n                                end_point=Vector2D(\n                                    x=Offset.new(\n                                        end_point.x.on_parser2_eval_expression(\n                                            context,\n                                        ),\n                                        context.get_draw_units(),\n                                    ),\n                                    y=Offset.new(\n                                        end_point.y.on_parser2_eval_expression(\n                                            context,\n                                        ),\n                                        context.get_draw_units(),\n                                    ),\n                                ),\n                            )\n                            for start_point, end_point in zip(\n                                [\n                                    Point2(x=primitive.start_x, y=primitive.start_y),\n                                    *primitive.points,\n                                ],\n                                [\n                                    *primitive.points,\n                                    Point2(x=primitive.start_x, y=primitive.start_y),\n                                ],\n                            )\n                        ],\n                    ).get_readonly(),\n                ),\n            )\n\n        def on_code_5_polygon(\n            self,\n            context: Parser2Context,\n            primitive: Code5Polygon2,\n        ) -&gt; None:\n            \"\"\"Evaluate code 5 polygon primitive.\"\"\"\n            exposure = primitive.exposure.on_parser2_eval_expression(context)\n            polarity = (\n                Polarity.Clear\n                if math.isclose(exposure, Decimal(\"0.0\"))\n                else Polarity.Dark\n            )\n            context.get_macro_eval_buffer().add_command(\n                Flash2(\n                    transform=ApertureTransform(\n                        polarity=polarity,\n                        mirroring=Mirroring.NoMirroring,\n                        rotation=Decimal(\"0.0\"),\n                        scaling=Decimal(\"1.0\"),\n                    ),\n                    aperture=Polygon2(\n                        outer_diameter=Offset.new(\n                            primitive.diameter.on_parser2_eval_expression(\n                                context,\n                            ),\n                        ),\n                        number_vertices=round(\n                            primitive.number_of_vertices.on_parser2_eval_expression(\n                                context,\n                            ),\n                        ),\n                        rotation=Decimal(\"0.0\"),\n                        hole_diameter=None,\n                    ),\n                    flash_point=Vector2D(\n                        x=Offset.new(\n                            primitive.center_x.on_parser2_eval_expression(context),\n                            context.get_draw_units(),\n                        ),\n                        y=Offset.new(\n                            primitive.center_y.on_parser2_eval_expression(context),\n                            context.get_draw_units(),\n                        ),\n                    ),\n                ),\n            )\n\n        def on_code_6_moire(\n            self,\n            context: Parser2Context,\n            primitive: Code6Moire2,\n        ) -&gt; None:\n            \"\"\"Evaluate code 6 moire primitive.\"\"\"\n\n        def on_code_7_thermal(\n            self,\n            context: Parser2Context,\n            primitive: Code7Thermal2,\n        ) -&gt; None:\n            \"\"\"Evaluate code 7 thermal primitive.\"\"\"\n\n        def on_code_20_vector_line(\n            self,\n            context: Parser2Context,\n            primitive: Code20VectorLine2,\n        ) -&gt; None:\n            \"\"\"Evaluate code 20 vector line primitive.\"\"\"\n            exposure = primitive.exposure.on_parser2_eval_expression(context)\n            polarity = (\n                Polarity.Clear\n                if math.isclose(exposure, Decimal(\"0.0\"))\n                else Polarity.Dark\n            )\n            context.get_macro_eval_buffer().add_command(\n                Line2(\n                    transform=ApertureTransform(\n                        polarity=polarity,\n                        mirroring=Mirroring.NoMirroring,\n                        rotation=Decimal(\"0.0\"),\n                        scaling=Decimal(\"1.0\"),\n                    ),\n                    aperture=NoCircle2(\n                        diameter=Offset.new(\n                            primitive.width.on_parser2_eval_expression(context),\n                            context.get_draw_units(),\n                        ),\n                        hole_diameter=None,\n                    ),\n                    start_point=Vector2D(\n                        x=Offset.new(\n                            primitive.start_x.on_parser2_eval_expression(context),\n                            context.get_draw_units(),\n                        ),\n                        y=Offset.new(\n                            primitive.start_y.on_parser2_eval_expression(context),\n                            context.get_draw_units(),\n                        ),\n                    ),\n                    end_point=Vector2D(\n                        x=Offset.new(\n                            primitive.end_x.on_parser2_eval_expression(context),\n                            context.get_draw_units(),\n                        ),\n                        y=Offset.new(\n                            primitive.end_y.on_parser2_eval_expression(context),\n                            context.get_draw_units(),\n                        ),\n                    ),\n                ),\n            )\n\n        def on_code_21_center_line(\n            self,\n            context: Parser2Context,\n            primitive: Code21CenterLine2,\n        ) -&gt; None:\n            \"\"\"Evaluate code 21 center line primitive.\"\"\"\n            exposure = primitive.exposure.on_parser2_eval_expression(context)\n            polarity = (\n                Polarity.Clear\n                if math.isclose(exposure, Decimal(\"0.0\"))\n                else Polarity.Dark\n            )\n            context.get_macro_eval_buffer().add_command(\n                Flash2(\n                    transform=ApertureTransform(\n                        polarity=polarity,\n                        mirroring=Mirroring.NoMirroring,\n                        rotation=Decimal(\"0.0\"),\n                        scaling=Decimal(\"1.0\"),\n                    ),\n                    aperture=Rectangle2(\n                        x_size=Offset.new(\n                            primitive.width.on_parser2_eval_expression(context),\n                            context.get_draw_units(),\n                        ),\n                        y_size=Offset.new(\n                            primitive.height.on_parser2_eval_expression(context),\n                            context.get_draw_units(),\n                        ),\n                        hole_diameter=None,\n                    ),\n                    flash_point=Vector2D(\n                        x=Offset.new(\n                            primitive.center_x.on_parser2_eval_expression(context),\n                            context.get_draw_units(),\n                        ),\n                        y=Offset.new(\n                            primitive.center_y.on_parser2_eval_expression(context),\n                            context.get_draw_units(),\n                        ),\n                    ),\n                ),\n            )\n\n        def on_code_22_lower_left_line(\n            self,\n            context: Parser2Context,\n            primitive: Code22LowerLeftLine2,\n        ) -&gt; None:\n            \"\"\"Evaluate code 22 lower left line primitive.\"\"\"\n\n        def on_assignment(\n            self,\n            context: Parser2Context,\n            assignment: Assignment2,\n        ) -&gt; None:\n            \"\"\"Evaluate macro variable assignment statement.\"\"\"\n            context.macro_variable_buffer[\n                assignment.variable_name\n            ] = assignment.value.on_parser2_eval_expression(context)\n\n    class AxisSelectTokenHooksTokenHooks(\n        Parser2HooksBase.AxisSelectTokenHooksTokenHooks,\n    ):\n        \"\"\"Hooks for visiting axis select token (AS).\"\"\"\n\n        def on_parser_visit_token(\n            self,\n            token: AxisSelect,\n            context: Parser2Context,\n        ) -&gt; None:\n            \"\"\"Perform actions on the context implicated by this token.\n\n            Parameters\n            ----------\n            token: TokenT\n                The token that is being visited.\n            context : Parser2Context\n                The context on which to perform the actions.\n            \"\"\"\n            context.set_axis_correspondence(token.correspondence)\n            return super().on_parser_visit_token(token, context)\n\n    class CommandDrawTokenHooks(Parser2HooksBase.CommandDrawTokenHooks):\n        \"\"\"Hooks for visiting draw token (D01).\"\"\"\n\n        def on_parser_visit_token(\n            self,\n            token: D01Draw,\n            context: Parser2Context,\n        ) -&gt; None:\n            \"\"\"Called when parser visits a token.\n\n            This hook should perform all changes on context implicated by token type.\n\n            Parameters\n            ----------\n            token: TokenT\n                The token that is being visited.\n            context : Parser2Context\n                The context object containing information about the parser state.\n            \"\"\"\n            self.DRAW_MODE_DISPATCH_TABLE[context.get_draw_mode()](self, token, context)\n            return super().on_parser_visit_token(token, context)\n\n        def on_parser_visit_token_line(\n            self,\n            token: D01Draw,\n            context: Parser2Context,\n        ) -&gt; None:\n            \"\"\"Called when parser visits a token.\n\n            This hook should perform all changes on context implicated by token type.\n\n            Parameters\n            ----------\n            token: TokenT\n                The token that is being visited.\n            context : Parser2Context\n                The context object containing information about the parser state.\n            \"\"\"\n            state = context.get_state()\n\n            x = state.parse_coordinate(token.x)\n            y = state.parse_coordinate(token.y)\n\n            start_point = context.get_current_position()\n            end_point = Vector2D(x=x, y=y)\n\n            aperture_id = context.get_current_aperture_id() or throw(\n                ApertureNotSelected2Error(token),\n            )\n            aperture = context.get_aperture(aperture_id)\n\n            context.add_command(\n                Line2(\n                    attributes=context.object_attributes,\n                    aperture=aperture,\n                    start_point=start_point,\n                    end_point=end_point,\n                    transform=context.get_state().get_aperture_transform(),\n                ),\n            )\n            context.set_current_position(end_point)\n\n        def on_parser_visit_token_arc(\n            self,\n            token: D01Draw,\n            context: Parser2Context,\n        ) -&gt; None:\n            \"\"\"Called when parser visits a token.\n\n            This hook should perform all changes on context implicated by token type.\n\n            Parameters\n            ----------\n            token: TokenT\n                The token that is being visited.\n            context : Parser2Context\n                The context object containing information about the parser state.\n            \"\"\"\n            state = context.get_state()\n\n            x = state.parse_coordinate(token.x)\n            y = state.parse_coordinate(token.y)\n            i = state.parse_coordinate(token.i)\n            j = state.parse_coordinate(token.j)\n\n            start_point = context.get_current_position()\n            end_point = Vector2D(x=x, y=y)\n            final_center_point = Vector2D.NULL\n\n            if context.get_is_multi_quadrant() is False:\n                # In single quadrant mode I and J offsets are unsigned, therefore we\n                # need to check all 4 possible center points. We will choose first\n                # valid, if anyone needs behavior strictly matching this from spec,\n                # they can always create issue.\n                for center_offset in (\n                    Vector2D(x=i, y=j),\n                    Vector2D(x=-i, y=j),\n                    Vector2D(x=i, y=-j),\n                    Vector2D(x=-i, y=-j),\n                ):\n                    center_point = start_point + center_offset\n                    relative_start_point = start_point - center_point\n                    relative_end_point = end_point - center_point\n                    # Calculate radius of arc from center to start point and end point,\n                    # If they aren't equal, this center candidate is not valid and we\n                    # can skip it.\n                    if not math.isclose(\n                        relative_start_point.length().value,\n                        relative_end_point.length().value,\n                        rel_tol=1e-3,\n                    ):\n                        continue\n\n                    # Calculate angle between vector pointing from center of arc to\n                    # start, and vector pointing from center of arc to end point. If\n                    # this angle is above 90 degrees, we exceeded allowed angle size in\n                    # single quadrant mode and need to try other possible center points.\n                    clockwise_angle = relative_start_point.angle_between(\n                        relative_end_point,\n                    )\n                    if clockwise_angle &gt; MAX_SINGLE_QUADRANT_ANGLE:\n                        continue\n\n                    final_center_point = center_point\n                    break\n                else:\n                    raise NoValidArcCenterFoundError(token)\n\n            else:\n                # In multi quadrant mode I and J offsets are signed, so we can simply\n                # use them to calculate center point relative to start point.\n                center_offset = Vector2D(x=i, y=j)\n                final_center_point = start_point + center_offset\n\n            aperture_id = context.get_current_aperture_id() or throw(\n                ApertureNotSelected2Error(token),\n            )\n            aperture = context.get_aperture(aperture_id)\n\n            context.add_command(\n                Arc2(\n                    attributes=context.object_attributes,\n                    aperture=aperture,\n                    start_point=start_point,\n                    end_point=end_point,\n                    center_point=final_center_point,\n                    transform=context.get_state().get_aperture_transform(),\n                ),\n            )\n            context.set_current_position(end_point)\n\n        def on_parser_visit_token_cc_arc(\n            self,\n            token: D01Draw,\n            context: Parser2Context,\n        ) -&gt; None:\n            \"\"\"Called when parser visits a token.\n\n            This hook should perform all changes on context implicated by token type.\n\n            Parameters\n            ----------\n            token: TokenT\n                The token that is being visited.\n            context : Parser2Context\n                The context object containing information about the parser state.\n            \"\"\"\n            state = context.get_state()\n\n            x = state.parse_coordinate(token.x)\n            y = state.parse_coordinate(token.y)\n            i = state.parse_coordinate(token.i)\n            j = state.parse_coordinate(token.j)\n\n            start_point = context.get_current_position()\n            end_point = Vector2D(x=x, y=y)\n            final_center_point = Vector2D.NULL\n\n            if context.get_is_multi_quadrant() is False:\n                for center_offset in (\n                    Vector2D(x=i, y=j),\n                    Vector2D(x=-i, y=j),\n                    Vector2D(x=i, y=-j),\n                    Vector2D(x=-i, y=-j),\n                ):\n                    center_point = start_point + center_offset\n                    relative_start_point = start_point - center_point\n                    relative_end_point = end_point - center_point\n\n                    if not math.isclose(\n                        relative_start_point.length().value,\n                        relative_end_point.length().value,\n                        rel_tol=1e-6,\n                    ):\n                        continue\n\n                    # Calculate angle between vector pointing from center of arc to\n                    # start, and vector pointing from center of arc to end point. If\n                    # this angle is above 90 degrees, we exceeded allowed angle size in\n                    # single quadrant mode and need to try other possible center points.\n                    clockwise_angle = relative_start_point.angle_between_cc(\n                        relative_end_point,\n                    )\n                    if clockwise_angle &gt; MAX_SINGLE_QUADRANT_ANGLE:\n                        continue\n\n                    final_center_point = center_point\n                    break\n                else:\n                    raise NoValidArcCenterFoundError(token)\n\n            else:\n                center_offset = Vector2D(x=i, y=j)\n                final_center_point = start_point + center_offset\n\n            aperture_id = context.get_current_aperture_id() or throw(\n                ApertureNotSelected2Error(token),\n            )\n            aperture = context.get_aperture(aperture_id)\n\n            context.add_command(\n                CCArc2(\n                    attributes=context.object_attributes,\n                    aperture=aperture,\n                    start_point=start_point,\n                    end_point=end_point,\n                    center_point=final_center_point,\n                    transform=context.get_state().get_aperture_transform(),\n                ),\n            )\n\n            context.set_current_position(end_point)\n\n        DRAW_MODE_DISPATCH_TABLE = MappingProxyType(\n            {\n                DrawMode.Linear: on_parser_visit_token_line,\n                DrawMode.ClockwiseCircular: on_parser_visit_token_arc,\n                DrawMode.CounterclockwiseCircular: on_parser_visit_token_cc_arc,\n            },\n        )\n\n    class CommandMoveTokenHooks(Parser2HooksBase.CommandMoveTokenHooks):\n        \"\"\"Hooks for visiting move token (D02).\"\"\"\n\n        def on_parser_visit_token(\n            self,\n            token: D02Move,\n            context: Parser2Context,\n        ) -&gt; None:\n            \"\"\"Called when parser visits a token.\n\n            This hook should perform all changes on context implicated by token type.\n\n            Parameters\n            ----------\n            token: TokenT\n                The token that is being visited.\n            context : Parser2Context\n                The context object containing information about the parser state.\n            \"\"\"\n            state = context.get_state()\n\n            x = state.parse_coordinate(token.x)\n            y = state.parse_coordinate(token.y)\n\n            destination_point = Vector2D(x=x, y=y)\n\n            context.set_current_position(destination_point)\n            return super().on_parser_visit_token(token, context)\n\n    class CommandFlashTokenHooks(Parser2HooksBase.CommandFlashTokenHooks):\n        \"\"\"Hooks for visiting flash token (D03).\"\"\"\n\n        def on_parser_visit_token(\n            self,\n            token: D03Flash,\n            context: Parser2Context,\n        ) -&gt; None:\n            \"\"\"Called when parser visits a token.\n\n            This hook should perform all changes on context implicated by token type.\n\n            Parameters\n            ----------\n            token: TokenT\n                The token that is being visited.\n            context : Parser2Context\n                The context object containing information about the parser state.\n            \"\"\"\n            state = context.get_state()\n\n            x = state.parse_coordinate(token.x)\n            y = state.parse_coordinate(token.y)\n\n            flash_point = Vector2D(x=x, y=y)\n\n            aperture_id = context.get_current_aperture_id() or throw(\n                ApertureNotSelected2Error(token),\n            )\n            aperture = context.get_aperture(aperture_id)\n\n            if isinstance(aperture, Block2):\n                context.add_command(\n                    BufferCommand2(\n                        transform=context.get_state().get_aperture_transform(),\n                        command_buffer=aperture.command_buffer.get_transposed(\n                            flash_point,\n                        ),\n                    ),\n                )\n\n            else:\n                context.add_command(\n                    Flash2(\n                        attributes=context.object_attributes,\n                        aperture=aperture,\n                        flash_point=flash_point,\n                        transform=context.get_state().get_aperture_transform(),\n                    ),\n                )\n\n            context.set_current_position(flash_point)\n            return super().on_parser_visit_token(token, context)\n\n    class SelectApertureTokenHooks(Parser2HooksBase.SelectApertureTokenHooks):\n        \"\"\"Hooks for visiting select aperture token (DNN).\"\"\"\n\n        def on_parser_visit_token(\n            self,\n            token: DNNSelectAperture,\n            context: Parser2Context,\n        ) -&gt; None:\n            \"\"\"Called when parser visits a token.\n\n            This hook should perform all changes on context implicated by token type.\n\n            Parameters\n            ----------\n            token: TokenT\n                The token that is being visited.\n            context : Parser2Context\n                The context object containing information about the parser state.\n            \"\"\"\n            context.get_aperture(\n                token.aperture_id,\n            )  # Make sure aperture exists.\n            context.set_current_aperture_id(token.aperture_id)\n            return super().on_parser_visit_token(token, context)\n\n    class CoordinateFormatTokenHooks(Parser2HooksBase.CoordinateFormatTokenHooks):\n        \"\"\"Hooks for visiting coordinate format token (FS).\"\"\"\n\n        def on_parser_visit_token(\n            self,\n            token: CoordinateFormat,\n            context: Parser2Context,\n        ) -&gt; None:\n            \"\"\"Called when parser visits a token.\n\n            This hook should perform all changes on context implicated by token type.\n\n            Parameters\n            ----------\n            token: TokenT\n                The token that is being visited.\n            context : Parser2Context\n                The context object containing information about the parser state.\n            \"\"\"\n            context.set_coordinate_parser(\n                CoordinateParser.new(\n                    x_format=token.x_format,\n                    y_format=token.y_format,\n                    coordinate_mode=token.coordinate_mode,\n                    zeros_mode=token.zeros_mode,\n                ),\n            )\n\n    class SetLinearTokenHooks(Parser2HooksBase.SetLinearTokenHooks):\n        \"\"\"Hooks for visiting set linear token (G01).\"\"\"\n\n        def on_parser_visit_token(\n            self,\n            token: SetLinear,\n            context: Parser2Context,\n        ) -&gt; None:\n            \"\"\"Called when parser visits a token.\n\n            This hook should perform all changes on context implicated by token type.\n\n            Parameters\n            ----------\n            token: TokenT\n                The token that is being visited.\n            context : Parser2Context\n                The context object containing information about the parser state.\n            \"\"\"\n            context.set_draw_mode(DrawMode.Linear)\n            return super().on_parser_visit_token(token, context)\n\n    class SetClockwiseCircularTokenHooks(\n        Parser2HooksBase.SetClockwiseCircularTokenHooks,\n    ):\n        \"\"\"Hooks for visiting set clockwise circular token (G02).\"\"\"\n\n        def on_parser_visit_token(\n            self,\n            token: SetClockwiseCircular,\n            context: Parser2Context,\n        ) -&gt; None:\n            \"\"\"Called when parser visits a token.\n\n            This hook should perform all changes on context implicated by token type.\n\n            Parameters\n            ----------\n            token: TokenT\n                The token that is being visited.\n            context : Parser2Context\n                The context object containing information about the parser state.\n            \"\"\"\n            context.set_draw_mode(DrawMode.ClockwiseCircular)\n            return super().on_parser_visit_token(token, context)\n\n    class SetCounterClockwiseCircularTokenHooks(\n        Parser2HooksBase.SetCounterClockwiseCircularTokenHooks,\n    ):\n        \"\"\"Hooks for visiting set counter clockwise circular token (G03).\"\"\"\n\n        def on_parser_visit_token(\n            self,\n            token: SetCounterclockwiseCircular,\n            context: Parser2Context,\n        ) -&gt; None:\n            \"\"\"Called when parser visits a token.\n\n            This hook should perform all changes on context implicated by token type.\n\n            Parameters\n            ----------\n            token: TokenT\n                The token that is being visited.\n            context : Parser2Context\n                The context object containing information about the parser state.\n            \"\"\"\n            context.set_draw_mode(DrawMode.CounterclockwiseCircular)\n            return super().on_parser_visit_token(token, context)\n\n    class CommentTokenHooks(Parser2HooksBase.CommentTokenHooks):\n        \"\"\"Hooks for visiting comment token (G04).\"\"\"\n\n    class BeginRegionTokenHooks(Parser2HooksBase.BeginRegionTokenHooks):\n        \"\"\"Hooks for visiting begin region token (G36).\"\"\"\n\n        def on_parser_visit_token(\n            self,\n            token: BeginRegion,\n            context: Parser2Context,\n        ) -&gt; None:\n            \"\"\"Called when parser visits a token.\n\n            This hook should perform all changes on context implicated by token type.\n\n            Parameters\n            ----------\n            token: TokenT\n                The token that is being visited.\n            context : Parser2Context\n                The context object containing information about the parser state.\n            \"\"\"\n            context.set_is_region(is_region=True)\n            context.set_region_command_buffer()\n\n            return super().on_parser_visit_token(token, context)\n\n    class EndRegionTokenHooks(Parser2HooksBase.EndRegionTokenHooks):\n        \"\"\"Hooks for visiting end region token (G37).\"\"\"\n\n        def on_parser_visit_token(\n            self,\n            token: EndRegion,\n            context: Parser2Context,\n        ) -&gt; None:\n            \"\"\"Called when parser visits a token.\n\n            This hook should perform all changes on context implicated by token type.\n\n            Parameters\n            ----------\n            token: TokenT\n                The token that is being visited.\n            context : Parser2Context\n                The context object containing information about the parser state.\n            \"\"\"\n            context.set_is_region(is_region=False)\n            command_buffer = context.get_region_command_buffer()\n\n            context.add_command(\n                Region2(\n                    aperture_attributes=context.aperture_attributes,\n                    object_attributes=context.object_attributes,\n                    command_buffer=command_buffer.get_readonly(),\n                    transform=context.get_state().get_aperture_transform(),\n                ),\n            )\n\n            context.unset_region_command_buffer()\n            return super().on_parser_visit_token(token, context)\n\n    class PrepareSelectApertureTokenHooks(\n        Parser2HooksBase.PrepareSelectApertureTokenHooks,\n    ):\n        \"\"\"Hooks for visiting prepare select aperture token (G54).\"\"\"\n\n        def on_parser_visit_token(\n            self,\n            token: G54SelectAperture,\n            context: Parser2Context,\n        ) -&gt; None:\n            \"\"\"Called when parser visits a token.\n\n            This hook should perform all changes on context implicated by token type.\n\n            Parameters\n            ----------\n            token: TokenT\n                The token that is being visited.\n            context : Parser2Context\n                The context object containing information about the parser state.\n            \"\"\"\n            self.hooks.select_aperture.on_parser_visit_token(token, context)\n            return super().on_parser_visit_token(token, context)\n\n    class SetUnitInchTokenHooks(Parser2HooksBase.SetUnitInchTokenHooks):\n        \"\"\"Hooks for visiting set unit inch token (G70).\"\"\"\n\n        def on_parser_visit_token(\n            self,\n            token: SetUnitInch,\n            context: Parser2Context,\n        ) -&gt; None:\n            \"\"\"Called when parser visits a token.\n\n            This hook should perform all changes on context implicated by token type.\n\n            Parameters\n            ----------\n            token: TokenT\n                The token that is being visited.\n            context : Parser2Context\n                The context object containing information about the parser state.\n            \"\"\"\n            context.set_draw_units(Unit.Inches)\n            return super().on_parser_visit_token(token, context)\n\n    class SetUnitMillimetersTokenHooks(Parser2HooksBase.SetUnitMillimetersTokenHooks):\n        \"\"\"Hooks for visiting set unit millimeters token (G71).\"\"\"\n\n        def on_parser_visit_token(\n            self,\n            token: SetUnitMillimeters,\n            context: Parser2Context,\n        ) -&gt; None:\n            \"\"\"Called when parser visits a token.\n\n            This hook should perform all changes on context implicated by token type.\n\n            Parameters\n            ----------\n            token: TokenT\n                The token that is being visited.\n            context : Parser2Context\n                The context object containing information about the parser state.\n            \"\"\"\n            context.set_draw_units(Unit.Millimeters)\n            return super().on_parser_visit_token(token, context)\n\n    class SetSingleQuadrantModeTokenHooks(\n        Parser2HooksBase.SetSingleQuadrantModeTokenHooks,\n    ):\n        \"\"\"Hooks for visiting set single-quadrant mode token (G74).\"\"\"\n\n        def on_parser_visit_token(\n            self,\n            token: SetSingleQuadrantMode,\n            context: Parser2Context,\n        ) -&gt; None:\n            \"\"\"Called when parser visits a token.\n\n            This hook should perform all changes on context implicated by token type.\n\n            Parameters\n            ----------\n            token: TokenT\n                The token that is being visited.\n            context : Parser2Context\n                The context object containing information about the parser state.\n            \"\"\"\n            context.set_is_multi_quadrant(is_multi_quadrant=False)\n            return super().on_parser_visit_token(token, context)\n\n    class SetMultiQuadrantModeTokenHooks(\n        Parser2HooksBase.SetMultiQuadrantModeTokenHooks,\n    ):\n        \"\"\"Hooks for visiting set multi-quadrant mode token (G75).\"\"\"\n\n        def on_parser_visit_token(\n            self,\n            token: SetMultiQuadrantMode,\n            context: Parser2Context,\n        ) -&gt; None:\n            \"\"\"Called when parser visits a token.\n\n            This hook should perform all changes on context implicated by token type.\n\n            Parameters\n            ----------\n            token: TokenT\n                The token that is being visited.\n            context : Parser2Context\n                The context object containing information about the parser state.\n            \"\"\"\n            context.set_is_multi_quadrant(is_multi_quadrant=True)\n            return super().on_parser_visit_token(token, context)\n\n    class SetCoordinateAbsoluteTokenHooks(\n        Parser2HooksBase.SetCoordinateAbsoluteTokenHooks,\n    ):\n        \"\"\"Hooks for visiting set coordinate absolute token (G90).\"\"\"\n\n        def on_parser_visit_token(\n            self,\n            token: SetAbsoluteNotation,\n            context: Parser2Context,\n        ) -&gt; None:\n            \"\"\"Called when parser visits a token.\n\n            This hook should perform all changes on context implicated by token type.\n\n            Parameters\n            ----------\n            token: TokenT\n                The token that is being visited.\n            context : Parser2Context\n                The context object containing information about the parser state.\n            \"\"\"\n            # NOOP - only absolute format supported.\n            return super().on_parser_visit_token(token, context)\n\n    class SetCoordinateIncrementalTokenHooks(\n        Parser2HooksBase.SetCoordinateIncrementalTokenHooks,\n    ):\n        \"\"\"Hooks for visiting set coordinate incremental token (G91).\"\"\"\n\n        def on_parser_visit_token(\n            self,\n            token: SetIncrementalNotation,  # noqa: ARG002\n            context: Parser2Context,  # noqa: ARG002\n        ) -&gt; None:\n            \"\"\"Called when parser visits a token.\n\n            This hook should perform all changes on context implicated by token type.\n\n            Parameters\n            ----------\n            token: TokenT\n                The token that is being visited.\n            context : Parser2Context\n                The context object containing information about the parser state.\n            \"\"\"\n            raise IncrementalCoordinatesNotSupported2Error\n\n    class ImageNameTokenHooks(Parser2HooksBase.ImageNameTokenHooks):\n        \"\"\"Hooks for visiting image name token (IN).\"\"\"\n\n        def on_parser_visit_token(\n            self,\n            token: ImageName,\n            context: Parser2Context,\n        ) -&gt; None:\n            \"\"\"Called when parser visits a token.\n\n            This hook should perform all changes on context implicated by token type.\n\n            Parameters\n            ----------\n            token: TokenT\n                The token that is being visited.\n            context : Parser2Context\n                The context object containing information about the parser state.\n            \"\"\"\n            context.set_image_name(token.content)\n            return super().on_parser_visit_token(token, context)\n\n    class InvalidTokenHooks(Parser2HooksBase.InvalidTokenHooks):\n        \"\"\"Hooks for visiting invalid token.\"\"\"\n\n    class ImagePolarityTokenHooks(Parser2HooksBase.ImagePolarityTokenHooks):\n        \"\"\"Hooks for visiting image polarity token (IP).\"\"\"\n\n        def on_parser_visit_token(\n            self,\n            token: ImagePolarity,\n            context: Parser2Context,\n        ) -&gt; None:\n            \"\"\"Called when parser visits a token.\n\n            This hook should perform all changes on context implicated by token type.\n\n            Parameters\n            ----------\n            token: TokenT\n                The token that is being visited.\n            context : Parser2Context\n                The context object containing information about the parser state.\n            \"\"\"\n            context.set_is_output_image_negation_required(\n                value=(token.image_polarity == ImagePolarityEnum.NEGATIVE),\n            )\n            return super().on_parser_visit_token(token, context)\n\n    class LoadMirroringTokenHooks(Parser2HooksBase.LoadMirroringTokenHooks):\n        \"\"\"Hooks for visiting load mirroring token (LM).\"\"\"\n\n        def on_parser_visit_token(\n            self,\n            token: LoadMirroring,\n            context: Parser2Context,\n        ) -&gt; None:\n            \"\"\"Called when parser visits a token.\n\n            This hook should perform all changes on context implicated by token type.\n\n            Parameters\n            ----------\n            token: TokenT\n                The token that is being visited.\n            context : Parser2Context\n                The context object containing information about the parser state.\n            \"\"\"\n            context.set_mirroring(token.mirroring)\n            return super().on_parser_visit_token(token, context)\n\n    class LoadNameTokenHooks(Parser2HooksBase.LoadNameTokenHooks):\n        \"\"\"Hooks for visiting load name token (LN).\"\"\"\n\n        def on_parser_visit_token(\n            self,\n            token: LoadName,\n            context: Parser2Context,\n        ) -&gt; None:\n            \"\"\"Called when parser visits a token.\n\n            This hook should perform all changes on context implicated by token type.\n\n            Parameters\n            ----------\n            token: TokenT\n                The token that is being visited.\n            context : Parser2Context\n                The context object containing information about the parser state.\n            \"\"\"\n            context.set_file_name(token.content)\n            return super().on_parser_visit_token(token, context)\n\n    class LoadPolarityTokenHooks(Parser2HooksBase.LoadPolarityTokenHooks):\n        \"\"\"Hooks for visiting load polarity token (LP).\"\"\"\n\n        def on_parser_visit_token(\n            self,\n            token: LoadPolarity,\n            context: Parser2Context,\n        ) -&gt; None:\n            \"\"\"Called when parser visits a token.\n\n            This hook should perform all changes on context implicated by token type.\n\n            Parameters\n            ----------\n            token: TokenT\n                The token that is being visited.\n            context : Parser2Context\n                The context object containing information about the parser state.\n            \"\"\"\n            context.set_polarity(token.polarity)\n            return super().on_parser_visit_token(token, context)\n\n    class LoadRotationTokenHooks(Parser2HooksBase.LoadRotationTokenHooks):\n        \"\"\"Hooks for visiting load rotation token (LR).\"\"\"\n\n        def on_parser_visit_token(\n            self,\n            token: LoadRotation,\n            context: Parser2Context,\n        ) -&gt; None:\n            \"\"\"Called when parser visits a token.\n\n            This hook should perform all changes on context implicated by token type.\n\n            Parameters\n            ----------\n            token: TokenT\n                The token that is being visited.\n            context : Parser2Context\n                The context object containing information about the parser state.\n            \"\"\"\n            context.set_rotation(token.rotation)\n            return super().on_parser_visit_token(token, context)\n\n    class LoadScalingTokenHooks(Parser2HooksBase.LoadScalingTokenHooks):\n        \"\"\"Hooks for visiting load scaling token (LS).\"\"\"\n\n        def on_parser_visit_token(\n            self,\n            token: LoadScaling,\n            context: Parser2Context,\n        ) -&gt; None:\n            \"\"\"Called when parser visits a token.\n\n            This hook should perform all changes on context implicated by token type.\n\n            Parameters\n            ----------\n            token: TokenT\n                The token that is being visited.\n            context : Parser2Context\n                The context object containing information about the parser state.\n            \"\"\"\n            context.set_scaling(token.scaling)\n            return super().on_parser_visit_token(token, context)\n\n    class ProgramStopTokenHooks(Parser2HooksBase.ProgramStopTokenHooks):\n        \"\"\"Hooks for visiting program stop token (M00).\"\"\"\n\n        def on_parser_visit_token(\n            self,\n            token: M00ProgramStop,  # noqa: ARG002\n            context: Parser2Context,\n        ) -&gt; None:\n            \"\"\"Called when parser visits a token.\n\n            This hook should perform all changes on context implicated by token type.\n\n            Parameters\n            ----------\n            token: TokenT\n                The token that is being visited.\n            context : Parser2Context\n                The context object containing information about the parser state.\n            \"\"\"\n            context.set_reached_program_stop()\n            context.halt_parser()\n\n    class OptionalStopTokenHooks(Parser2HooksBase.OptionalStopTokenHooks):\n        \"\"\"Hooks for visiting optional stop token (M01).\"\"\"\n\n        def on_parser_visit_token(\n            self,\n            token: M01OptionalStop,  # noqa: ARG002\n            context: Parser2Context,\n        ) -&gt; None:\n            \"\"\"Handle child parsing being completed.\"\"\"\n            context.set_reached_optional_stop()\n\n    class EndOfFileTokenHooks(Parser2HooksBase.EndOfFileTokenHooks):\n        \"\"\"Hooks for visiting end of file token (M02).\"\"\"\n\n        def on_parser_visit_token(\n            self,\n            token: M02EndOfFile,  # noqa: ARG002\n            context: Parser2Context,\n        ) -&gt; None:\n            \"\"\"Called when parser visits a token.\n\n            This hook should perform all changes on context implicated by token type.\n\n            Parameters\n            ----------\n            token: TokenT\n                The token that is being visited.\n            context : Parser2Context\n                The context object containing information about the parser state.\n            \"\"\"\n            context.set_reached_end_of_file()\n            context.halt_parser()\n\n    class UnitModeTokenHooks(Parser2HooksBase.UnitModeTokenHooks):\n        \"\"\"Hooks for visiting unit mode token (MO).\"\"\"\n\n        def on_parser_visit_token(\n            self,\n            token: UnitMode,\n            context: Parser2Context,\n        ) -&gt; None:\n            \"\"\"Called when parser visits a token.\n\n            This hook should perform all changes on context implicated by token type.\n\n            Parameters\n            ----------\n            token: TokenT\n                The token that is being visited.\n            context : Parser2Context\n                The context object containing information about the parser state.\n            \"\"\"\n            context.set_draw_units(token.unit)\n            return super().on_parser_visit_token(token, context)\n\n    class ImageOffsetTokenHooks(Parser2HooksBase.ImageOffsetTokenHooks):\n        \"\"\"Hooks for visiting image offset token (OF).\"\"\"\n\n    class StepRepeatBeginTokenHooks(Parser2HooksBase.StepRepeatBeginTokenHooks):\n        \"\"\"Hooks for visiting step and repeat begin token (SR).\"\"\"\n\n        def on_parser_visit_token(\n            self,\n            token: StepRepeatBegin,\n            context: Parser2Context,\n        ) -&gt; None:\n            \"\"\"Called when parser visits a token.\n\n            This hook should perform all changes on context implicated by token type.\n\n            Parameters\n            ----------\n            token: TokenT\n                The token that is being visited.\n            context : Parser2Context\n                The context object containing information about the parser state.\n            \"\"\"\n            context.set_state_before_step_and_repeat()\n\n            context.set_is_step_and_repeat(is_step_and_repeat=True)\n            context.set_x_repeat(token.x_repeat)\n            context.set_y_repeat(token.y_repeat)\n            context.set_x_step(Offset.new(token.x_step, unit=context.get_draw_units()))\n            context.set_y_step(Offset.new(token.y_step, unit=context.get_draw_units()))\n            context.set_step_and_repeat_command_buffer()\n\n            return super().on_parser_visit_token(token, context)\n\n    class StepRepeatEndTokenHooks(Parser2HooksBase.StepRepeatEndTokenHooks):\n        \"\"\"Hooks for visiting step and repeat end token (SR).\"\"\"\n\n        def on_parser_visit_token(\n            self,\n            token: StepRepeatEnd,\n            context: Parser2Context,\n        ) -&gt; None:\n            \"\"\"Called when parser visits a token.\n\n            This hook should perform all changes on context implicated by token type.\n\n            Parameters\n            ----------\n            token: TokenT\n                The token that is being visited.\n            context : Parser2Context\n                The context object containing information about the parser state.\n            \"\"\"\n            if context.get_is_step_and_repeat() is False:\n                raise StepAndRepeatNotInitializedError(token)\n\n            command_buffer = context.get_step_and_repeat_command_buffer().get_readonly()\n            commands: list[Command2] = []\n\n            for x_index in range(context.get_x_repeat()):\n                for y_index in range(context.get_y_repeat()):\n                    buffer_command = BufferCommand2(\n                        transform=context.get_state().get_aperture_transform(),\n                        command_buffer=command_buffer,\n                    ).get_transposed(\n                        Vector2D(\n                            x=(context.get_x_step() * x_index),\n                            y=(context.get_y_step() * y_index),\n                        ),\n                    )\n                    commands.append(buffer_command)\n\n            # Resets all variables, including is_step_and_repeat and possibly other\n            # set during recording of SR command block. Must be done before\n            # add_command() to push SR command buffers to main command buffers.\n            context.reset_state_to_pre_step_and_repeat()\n            context.unset_state_before_step_and_repeat()\n            context.unset_step_and_repeat_command_buffer()\n\n            for command in commands:\n                context.add_command(command)\n\n            return super().on_parser_visit_token(token, context)\n\n    class ApertureAttributeHooks(Parser2HooksBase.ApertureAttributeHooks):\n        \"\"\"Hooks for visiting aperture attribute token (TA).\"\"\"\n\n        def on_parser_visit_token(\n            self,\n            token: ApertureAttribute,\n            context: Parser2Context,\n        ) -&gt; None:\n            \"\"\"Called when parser visits a token.\n\n            This hook should perform all changes on context implicated by token type.\n\n            Parameters\n            ----------\n            token: TokenT\n                The token that is being visited.\n            context : Parser2Context\n                The context object containing information about the parser state.\n            \"\"\"\n            context.set_aperture_attribute(token.name, token.value)\n            return super().on_parser_visit_token(token, context)\n\n    class DeleteAttributeHooks(Parser2HooksBase.DeleteAttributeHooks):\n        \"\"\"Hooks for visiting delete attribute token (TD).\"\"\"\n\n        def on_parser_visit_token(\n            self,\n            token: DeleteAttribute,\n            context: Parser2Context,\n        ) -&gt; None:\n            \"\"\"Called when parser visits a token.\n\n            This hook should perform all changes on context implicated by token type.\n\n            Parameters\n            ----------\n            token: TokenT\n                The token that is being visited.\n            context : Parser2Context\n                The context object containing information about the parser state.\n            \"\"\"\n            if token.name is not None:\n                context.delete_aperture_attribute(token.name)\n                context.delete_object_attribute(token.name)\n            else:\n                context.clear_aperture_attributes()\n                context.clear_object_attributes()\n            return super().on_parser_visit_token(token, context)\n\n    class FileAttributeHooks(Parser2HooksBase.FileAttributeHooks):\n        \"\"\"Hooks for visiting file attribute token (TF).\"\"\"\n\n        def on_parser_visit_token(\n            self,\n            token: FileAttribute,\n            context: Parser2Context,\n        ) -&gt; None:\n            \"\"\"Called when parser visits a token.\n\n            This hook should perform all changes on context implicated by token type.\n\n            Parameters\n            ----------\n            token: TokenT\n                The token that is being visited.\n            context : Parser2Context\n                The context object containing information about the parser state.\n            \"\"\"\n            context.set_file_attribute(token.name, token.value)\n            return super().on_parser_visit_token(token, context)\n\n    class ObjectAttributeHooks(Parser2HooksBase.ObjectAttributeHooks):\n        \"\"\"Hooks for visiting object attribute token (TO).\"\"\"\n\n        def on_parser_visit_token(\n            self,\n            token: ObjectAttribute,\n            context: Parser2Context,\n        ) -&gt; None:\n            \"\"\"Called when parser visits a token.\n\n            This hook should perform all changes on context implicated by token type.\n\n            Parameters\n            ----------\n            token: TokenT\n                The token that is being visited.\n            context : Parser2Context\n                The context object containing information about the parser state.\n            \"\"\"\n            context.set_object_attribute(token.name, token.value)\n            return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.MacroBeginTokenHooks","title":"MacroBeginTokenHooks","text":"<p>             Bases: <code>MacroBeginTokenHooks</code></p> <p>Hooks for visiting macro begin token (AM).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>class MacroBeginTokenHooks(Parser2HooksBase.MacroBeginTokenHooks):\n    \"\"\"Hooks for visiting macro begin token (AM).\"\"\"\n\n    def on_parser_visit_token(\n        self,\n        token: MacroBegin,\n        context: Parser2Context,\n    ) -&gt; None:\n        \"\"\"Called when parser visits a token.\n\n        This hook should perform all changes on context implicated by token type.\n\n        Parameters\n        ----------\n        token: TokenT\n            The token that is being visited.\n        context : Parser2Context\n            The context object containing information about the parser state.\n        \"\"\"\n        context.set_macro_statement_buffer()\n        return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.MacroBeginTokenHooks.on_parser_visit_token","title":"on_parser_visit_token","text":"<pre><code>on_parser_visit_token(\n    token: MacroBegin, context: Parser2Context\n) -&gt; None\n</code></pre> <p>Called when parser visits a token.</p> <p>This hook should perform all changes on context implicated by token type.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>MacroBegin</code> <p>The token that is being visited.</p> required <code>context</code> <code>Parser2Context</code> <p>The context object containing information about the parser state.</p> required Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>def on_parser_visit_token(\n    self,\n    token: MacroBegin,\n    context: Parser2Context,\n) -&gt; None:\n    \"\"\"Called when parser visits a token.\n\n    This hook should perform all changes on context implicated by token type.\n\n    Parameters\n    ----------\n    token: TokenT\n        The token that is being visited.\n    context : Parser2Context\n        The context object containing information about the parser state.\n    \"\"\"\n    context.set_macro_statement_buffer()\n    return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.MacroCode1CircleTokenHooks","title":"MacroCode1CircleTokenHooks","text":"<p>             Bases: <code>MacroCode1CircleTokenHooks</code></p> <p>Hooks for visiting macro primitive code 0 circle.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>class MacroCode1CircleTokenHooks(Parser2HooksBase.MacroCode1CircleTokenHooks):\n    \"\"\"Hooks for visiting macro primitive code 0 circle.\"\"\"\n\n    def on_parser_visit_token(\n        self,\n        token: Code1CircleToken,\n        context: Parser2Context,\n    ) -&gt; None:\n        \"\"\"Adds the primitive to the statement buffer.\n\n        Parameters\n        ----------\n        token: TokenT\n            The token that is being visited.\n        context : Parser2Context\n            The context object containing information about the parser state.\n\n        \"\"\"\n        context.get_macro_statement_buffer().add_statement(\n            Code1Circle2(\n                exposure=token.exposure.to_parser2_expression(context),\n                diameter=token.diameter.to_parser2_expression(context),\n                center_x=token.center_x.to_parser2_expression(context),\n                center_y=token.center_y.to_parser2_expression(context),\n                rotation=token.rotation.to_parser2_expression(context),\n            ),\n        )\n        return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.MacroCode1CircleTokenHooks.on_parser_visit_token","title":"on_parser_visit_token","text":"<pre><code>on_parser_visit_token(\n    token: Code1CircleToken, context: Parser2Context\n) -&gt; None\n</code></pre> <p>Adds the primitive to the statement buffer.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>Code1CircleToken</code> <p>The token that is being visited.</p> required <code>context</code> <code>Parser2Context</code> <p>The context object containing information about the parser state.</p> required Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>def on_parser_visit_token(\n    self,\n    token: Code1CircleToken,\n    context: Parser2Context,\n) -&gt; None:\n    \"\"\"Adds the primitive to the statement buffer.\n\n    Parameters\n    ----------\n    token: TokenT\n        The token that is being visited.\n    context : Parser2Context\n        The context object containing information about the parser state.\n\n    \"\"\"\n    context.get_macro_statement_buffer().add_statement(\n        Code1Circle2(\n            exposure=token.exposure.to_parser2_expression(context),\n            diameter=token.diameter.to_parser2_expression(context),\n            center_x=token.center_x.to_parser2_expression(context),\n            center_y=token.center_y.to_parser2_expression(context),\n            rotation=token.rotation.to_parser2_expression(context),\n        ),\n    )\n    return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.MacroCode2VectorLineTokenHooks","title":"MacroCode2VectorLineTokenHooks","text":"<p>             Bases: <code>MacroCode2VectorLineTokenHooks</code></p> <p>Hooks for visiting macro primitive code 2 vector line.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>class MacroCode2VectorLineTokenHooks(\n    Parser2HooksBase.MacroCode2VectorLineTokenHooks,\n):\n    \"\"\"Hooks for visiting macro primitive code 2 vector line.\"\"\"\n\n    def on_parser_visit_token(\n        self,\n        token: Code2VectorLineToken,\n        context: Parser2Context,\n    ) -&gt; None:\n        \"\"\"Adds the primitive to the statement buffer.\n\n        Parameters\n        ----------\n        token: Code2VectorLine\n            The token that is being visited.\n        context : Parser2Context\n            The context object containing information about the parser state.\n\n        \"\"\"\n        context.get_macro_statement_buffer().add_statement(\n            Code2VectorLine2(),\n        )\n        return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.MacroCode2VectorLineTokenHooks.on_parser_visit_token","title":"on_parser_visit_token","text":"<pre><code>on_parser_visit_token(\n    token: Code2VectorLineToken, context: Parser2Context\n) -&gt; None\n</code></pre> <p>Adds the primitive to the statement buffer.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>Code2VectorLineToken</code> <p>The token that is being visited.</p> required <code>context</code> <code>Parser2Context</code> <p>The context object containing information about the parser state.</p> required Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>def on_parser_visit_token(\n    self,\n    token: Code2VectorLineToken,\n    context: Parser2Context,\n) -&gt; None:\n    \"\"\"Adds the primitive to the statement buffer.\n\n    Parameters\n    ----------\n    token: Code2VectorLine\n        The token that is being visited.\n    context : Parser2Context\n        The context object containing information about the parser state.\n\n    \"\"\"\n    context.get_macro_statement_buffer().add_statement(\n        Code2VectorLine2(),\n    )\n    return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.MacroCode4OutlineTokenHooks","title":"MacroCode4OutlineTokenHooks","text":"<p>             Bases: <code>MacroCode4OutlineTokenHooks</code></p> <p>Hooks for visiting macro primitive code 4 outline.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>class MacroCode4OutlineTokenHooks(Parser2HooksBase.MacroCode4OutlineTokenHooks):\n    \"\"\"Hooks for visiting macro primitive code 4 outline.\"\"\"\n\n    def on_parser_visit_token(\n        self,\n        token: Code4OutlineToken,\n        context: Parser2Context,\n    ) -&gt; None:\n        \"\"\"Adds the primitive to the statement buffer.\n\n        Parameters\n        ----------\n        token: TokenT\n            The token that is being visited.\n        context : Parser2Context\n            The context object containing information about the parser state.\n\n        \"\"\"\n        context.get_macro_statement_buffer().add_statement(\n            Code4Outline2(\n                exposure=token.exposure.to_parser2_expression(context),\n                vertex_count=token.number_of_vertices.to_parser2_expression(\n                    context,\n                ),\n                start_x=token.start_x.to_parser2_expression(context),\n                start_y=token.start_y.to_parser2_expression(context),\n                points=[point.to_parser2_point2(context) for point in token.point],\n                rotation=token.rotation.to_parser2_expression(context),\n            ),\n        )\n        return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.MacroCode4OutlineTokenHooks.on_parser_visit_token","title":"on_parser_visit_token","text":"<pre><code>on_parser_visit_token(\n    token: Code4OutlineToken, context: Parser2Context\n) -&gt; None\n</code></pre> <p>Adds the primitive to the statement buffer.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>Code4OutlineToken</code> <p>The token that is being visited.</p> required <code>context</code> <code>Parser2Context</code> <p>The context object containing information about the parser state.</p> required Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>def on_parser_visit_token(\n    self,\n    token: Code4OutlineToken,\n    context: Parser2Context,\n) -&gt; None:\n    \"\"\"Adds the primitive to the statement buffer.\n\n    Parameters\n    ----------\n    token: TokenT\n        The token that is being visited.\n    context : Parser2Context\n        The context object containing information about the parser state.\n\n    \"\"\"\n    context.get_macro_statement_buffer().add_statement(\n        Code4Outline2(\n            exposure=token.exposure.to_parser2_expression(context),\n            vertex_count=token.number_of_vertices.to_parser2_expression(\n                context,\n            ),\n            start_x=token.start_x.to_parser2_expression(context),\n            start_y=token.start_y.to_parser2_expression(context),\n            points=[point.to_parser2_point2(context) for point in token.point],\n            rotation=token.rotation.to_parser2_expression(context),\n        ),\n    )\n    return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.MacroCode5PolygonTokenHooks","title":"MacroCode5PolygonTokenHooks","text":"<p>             Bases: <code>MacroCode5PolygonTokenHooks</code></p> <p>Hooks for visiting macro primitive code 5 polygon.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>class MacroCode5PolygonTokenHooks(Parser2HooksBase.MacroCode5PolygonTokenHooks):\n    \"\"\"Hooks for visiting macro primitive code 5 polygon.\"\"\"\n\n    def on_parser_visit_token(\n        self,\n        token: Code5PolygonToken,\n        context: Parser2Context,\n    ) -&gt; None:\n        \"\"\"Adds the primitive to the statement buffer.\n\n        Parameters\n        ----------\n        token: TokenT\n            The token that is being visited.\n        context : Parser2Context\n            The context object containing information about the parser state.\n\n        \"\"\"\n        context.get_macro_statement_buffer().add_statement(\n            Code5Polygon2(\n                exposure=token.exposure.to_parser2_expression(context),\n                number_of_vertices=token.number_of_vertices.to_parser2_expression(\n                    context,\n                ),\n                center_x=token.center_x.to_parser2_expression(context),\n                center_y=token.center_y.to_parser2_expression(context),\n                diameter=token.diameter.to_parser2_expression(context),\n                rotation=token.rotation.to_parser2_expression(context),\n            ),\n        )\n        return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.MacroCode5PolygonTokenHooks.on_parser_visit_token","title":"on_parser_visit_token","text":"<pre><code>on_parser_visit_token(\n    token: Code5PolygonToken, context: Parser2Context\n) -&gt; None\n</code></pre> <p>Adds the primitive to the statement buffer.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>Code5PolygonToken</code> <p>The token that is being visited.</p> required <code>context</code> <code>Parser2Context</code> <p>The context object containing information about the parser state.</p> required Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>def on_parser_visit_token(\n    self,\n    token: Code5PolygonToken,\n    context: Parser2Context,\n) -&gt; None:\n    \"\"\"Adds the primitive to the statement buffer.\n\n    Parameters\n    ----------\n    token: TokenT\n        The token that is being visited.\n    context : Parser2Context\n        The context object containing information about the parser state.\n\n    \"\"\"\n    context.get_macro_statement_buffer().add_statement(\n        Code5Polygon2(\n            exposure=token.exposure.to_parser2_expression(context),\n            number_of_vertices=token.number_of_vertices.to_parser2_expression(\n                context,\n            ),\n            center_x=token.center_x.to_parser2_expression(context),\n            center_y=token.center_y.to_parser2_expression(context),\n            diameter=token.diameter.to_parser2_expression(context),\n            rotation=token.rotation.to_parser2_expression(context),\n        ),\n    )\n    return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.MacroCode6MoireTokenHooks","title":"MacroCode6MoireTokenHooks","text":"<p>             Bases: <code>MacroCode6MoireTokenHooks</code></p> <p>Hooks for visiting macro primitive code 6 moire.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>class MacroCode6MoireTokenHooks(Parser2HooksBase.MacroCode6MoireTokenHooks):\n    \"\"\"Hooks for visiting macro primitive code 6 moire.\"\"\"\n\n    def on_parser_visit_token(\n        self,\n        token: Code6MoireToken,\n        context: Parser2Context,\n    ) -&gt; None:\n        \"\"\"Adds the primitive to the statement buffer.\n\n        Parameters\n        ----------\n        token: TokenT\n            The token that is being visited.\n        context : Parser2Context\n            The context object containing information about the parser state.\n\n        \"\"\"\n        context.get_macro_statement_buffer().add_statement(\n            Code6Moire2(),\n        )\n        return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.MacroCode6MoireTokenHooks.on_parser_visit_token","title":"on_parser_visit_token","text":"<pre><code>on_parser_visit_token(\n    token: Code6MoireToken, context: Parser2Context\n) -&gt; None\n</code></pre> <p>Adds the primitive to the statement buffer.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>Code6MoireToken</code> <p>The token that is being visited.</p> required <code>context</code> <code>Parser2Context</code> <p>The context object containing information about the parser state.</p> required Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>def on_parser_visit_token(\n    self,\n    token: Code6MoireToken,\n    context: Parser2Context,\n) -&gt; None:\n    \"\"\"Adds the primitive to the statement buffer.\n\n    Parameters\n    ----------\n    token: TokenT\n        The token that is being visited.\n    context : Parser2Context\n        The context object containing information about the parser state.\n\n    \"\"\"\n    context.get_macro_statement_buffer().add_statement(\n        Code6Moire2(),\n    )\n    return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.MacroCode7ThermalTokenHooks","title":"MacroCode7ThermalTokenHooks","text":"<p>             Bases: <code>MacroCode7ThermalTokenHooks</code></p> <p>Hooks for visiting macro primitive code 7 thermal.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>class MacroCode7ThermalTokenHooks(Parser2HooksBase.MacroCode7ThermalTokenHooks):\n    \"\"\"Hooks for visiting macro primitive code 7 thermal.\"\"\"\n\n    def on_parser_visit_token(\n        self,\n        token: Code7ThermalToken,\n        context: Parser2Context,\n    ) -&gt; None:\n        \"\"\"Adds the primitive to the statement buffer.\n\n        Parameters\n        ----------\n        token: TokenT\n            The token that is being visited.\n        context : Parser2Context\n            The context object containing information about the parser state.\n\n        \"\"\"\n        context.get_macro_statement_buffer().add_statement(\n            Code7Thermal2(\n                center_x=token.center_x.to_parser2_expression(context),\n                center_y=token.center_y.to_parser2_expression(context),\n                outer_diameter=token.outer_diameter.to_parser2_expression(context),\n                inner_diameter=token.inner_diameter.to_parser2_expression(context),\n                gap=token.gap.to_parser2_expression(context),\n                rotation=token.rotation.to_parser2_expression(context),\n            ),\n        )\n        return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.MacroCode7ThermalTokenHooks.on_parser_visit_token","title":"on_parser_visit_token","text":"<pre><code>on_parser_visit_token(\n    token: Code7ThermalToken, context: Parser2Context\n) -&gt; None\n</code></pre> <p>Adds the primitive to the statement buffer.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>Code7ThermalToken</code> <p>The token that is being visited.</p> required <code>context</code> <code>Parser2Context</code> <p>The context object containing information about the parser state.</p> required Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>def on_parser_visit_token(\n    self,\n    token: Code7ThermalToken,\n    context: Parser2Context,\n) -&gt; None:\n    \"\"\"Adds the primitive to the statement buffer.\n\n    Parameters\n    ----------\n    token: TokenT\n        The token that is being visited.\n    context : Parser2Context\n        The context object containing information about the parser state.\n\n    \"\"\"\n    context.get_macro_statement_buffer().add_statement(\n        Code7Thermal2(\n            center_x=token.center_x.to_parser2_expression(context),\n            center_y=token.center_y.to_parser2_expression(context),\n            outer_diameter=token.outer_diameter.to_parser2_expression(context),\n            inner_diameter=token.inner_diameter.to_parser2_expression(context),\n            gap=token.gap.to_parser2_expression(context),\n            rotation=token.rotation.to_parser2_expression(context),\n        ),\n    )\n    return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.MacroCode20VectorLineTokenHooks","title":"MacroCode20VectorLineTokenHooks","text":"<p>             Bases: <code>MacroCode20VectorLineTokenHooks</code></p> <p>Hooks for visiting macro primitive code 20 vector line.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>class MacroCode20VectorLineTokenHooks(\n    Parser2HooksBase.MacroCode20VectorLineTokenHooks,\n):\n    \"\"\"Hooks for visiting macro primitive code 20 vector line.\"\"\"\n\n    def on_parser_visit_token(\n        self,\n        token: Code20VectorLineToken,\n        context: Parser2Context,\n    ) -&gt; None:\n        \"\"\"Adds the primitive to the statement buffer.\n\n        Parameters\n        ----------\n        token: TokenT\n            The token that is being visited.\n        context : Parser2Context\n            The context object containing information about the parser state.\n\n        \"\"\"\n        context.get_macro_statement_buffer().add_statement(\n            Code20VectorLine2(\n                exposure=token.exposure.to_parser2_expression(context),\n                width=token.width.to_parser2_expression(context),\n                start_x=token.start_x.to_parser2_expression(context),\n                start_y=token.start_y.to_parser2_expression(context),\n                end_x=token.end_x.to_parser2_expression(context),\n                end_y=token.end_y.to_parser2_expression(context),\n                rotation=token.rotation.to_parser2_expression(context),\n            ),\n        )\n        return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.MacroCode20VectorLineTokenHooks.on_parser_visit_token","title":"on_parser_visit_token","text":"<pre><code>on_parser_visit_token(\n    token: Code20VectorLineToken, context: Parser2Context\n) -&gt; None\n</code></pre> <p>Adds the primitive to the statement buffer.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>Code20VectorLineToken</code> <p>The token that is being visited.</p> required <code>context</code> <code>Parser2Context</code> <p>The context object containing information about the parser state.</p> required Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>def on_parser_visit_token(\n    self,\n    token: Code20VectorLineToken,\n    context: Parser2Context,\n) -&gt; None:\n    \"\"\"Adds the primitive to the statement buffer.\n\n    Parameters\n    ----------\n    token: TokenT\n        The token that is being visited.\n    context : Parser2Context\n        The context object containing information about the parser state.\n\n    \"\"\"\n    context.get_macro_statement_buffer().add_statement(\n        Code20VectorLine2(\n            exposure=token.exposure.to_parser2_expression(context),\n            width=token.width.to_parser2_expression(context),\n            start_x=token.start_x.to_parser2_expression(context),\n            start_y=token.start_y.to_parser2_expression(context),\n            end_x=token.end_x.to_parser2_expression(context),\n            end_y=token.end_y.to_parser2_expression(context),\n            rotation=token.rotation.to_parser2_expression(context),\n        ),\n    )\n    return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.MacroCode21CenterLineTokenHooks","title":"MacroCode21CenterLineTokenHooks","text":"<p>             Bases: <code>MacroCode21CenterLineTokenHooks</code></p> <p>Hooks for visiting macro primitive code 21 center line.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>class MacroCode21CenterLineTokenHooks(\n    Parser2HooksBase.MacroCode21CenterLineTokenHooks,\n):\n    \"\"\"Hooks for visiting macro primitive code 21 center line.\"\"\"\n\n    def on_parser_visit_token(\n        self,\n        token: Code21CenterLineToken,\n        context: Parser2Context,\n    ) -&gt; None:\n        \"\"\"Adds the primitive to the statement buffer.\n\n        Parameters\n        ----------\n        token: TokenT\n            The token that is being visited.\n        context : Parser2Context\n            The context object containing information about the parser state.\n\n        \"\"\"\n        context.get_macro_statement_buffer().add_statement(\n            Code21CenterLine2(\n                exposure=token.exposure.to_parser2_expression(context),\n                width=token.width.to_parser2_expression(context),\n                height=token.height.to_parser2_expression(context),\n                center_x=token.center_x.to_parser2_expression(context),\n                center_y=token.center_y.to_parser2_expression(context),\n                rotation=token.rotation.to_parser2_expression(context),\n            ),\n        )\n        return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.MacroCode21CenterLineTokenHooks.on_parser_visit_token","title":"on_parser_visit_token","text":"<pre><code>on_parser_visit_token(\n    token: Code21CenterLineToken, context: Parser2Context\n) -&gt; None\n</code></pre> <p>Adds the primitive to the statement buffer.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>Code21CenterLineToken</code> <p>The token that is being visited.</p> required <code>context</code> <code>Parser2Context</code> <p>The context object containing information about the parser state.</p> required Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>def on_parser_visit_token(\n    self,\n    token: Code21CenterLineToken,\n    context: Parser2Context,\n) -&gt; None:\n    \"\"\"Adds the primitive to the statement buffer.\n\n    Parameters\n    ----------\n    token: TokenT\n        The token that is being visited.\n    context : Parser2Context\n        The context object containing information about the parser state.\n\n    \"\"\"\n    context.get_macro_statement_buffer().add_statement(\n        Code21CenterLine2(\n            exposure=token.exposure.to_parser2_expression(context),\n            width=token.width.to_parser2_expression(context),\n            height=token.height.to_parser2_expression(context),\n            center_x=token.center_x.to_parser2_expression(context),\n            center_y=token.center_y.to_parser2_expression(context),\n            rotation=token.rotation.to_parser2_expression(context),\n        ),\n    )\n    return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.MacroCode22LowerLeftLineTokenHooks","title":"MacroCode22LowerLeftLineTokenHooks","text":"<p>             Bases: <code>MacroCode22LowerLeftLineTokenHooks</code></p> <p>Hooks for visiting macro primitive code 22 lower left line.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>class MacroCode22LowerLeftLineTokenHooks(\n    Parser2HooksBase.MacroCode22LowerLeftLineTokenHooks,\n):\n    \"\"\"Hooks for visiting macro primitive code 22 lower left line.\"\"\"\n\n    def on_parser_visit_token(\n        self,\n        token: Code22LowerLeftLineToken,\n        context: Parser2Context,\n    ) -&gt; None:\n        \"\"\"Adds the primitive to the statement buffer.\n\n        Parameters\n        ----------\n        token: TokenT\n            The token that is being visited.\n        context : Parser2Context\n            The context object containing information about the parser state.\n\n        \"\"\"\n        context.get_macro_statement_buffer().add_statement(Code22LowerLeftLine2())\n        return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.MacroCode22LowerLeftLineTokenHooks.on_parser_visit_token","title":"on_parser_visit_token","text":"<pre><code>on_parser_visit_token(\n    token: Code22LowerLeftLineToken, context: Parser2Context\n) -&gt; None\n</code></pre> <p>Adds the primitive to the statement buffer.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>Code22LowerLeftLineToken</code> <p>The token that is being visited.</p> required <code>context</code> <code>Parser2Context</code> <p>The context object containing information about the parser state.</p> required Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>def on_parser_visit_token(\n    self,\n    token: Code22LowerLeftLineToken,\n    context: Parser2Context,\n) -&gt; None:\n    \"\"\"Adds the primitive to the statement buffer.\n\n    Parameters\n    ----------\n    token: TokenT\n        The token that is being visited.\n    context : Parser2Context\n        The context object containing information about the parser state.\n\n    \"\"\"\n    context.get_macro_statement_buffer().add_statement(Code22LowerLeftLine2())\n    return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.MacroVariableAssignment","title":"MacroVariableAssignment","text":"<p>             Bases: <code>MacroVariableAssignment</code></p> <p>Hooks for visiting macro variable assignment token.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>class MacroVariableAssignment(Parser2HooksBase.MacroVariableAssignment):\n    \"\"\"Hooks for visiting macro variable assignment token.\"\"\"\n\n    def on_parser_visit_token(\n        self,\n        token: MacroVariableAssignment,\n        context: Parser2Context,\n    ) -&gt; None:\n        \"\"\"Adds the primitive to the statement buffer.\n\n        Parameters\n        ----------\n        token: TokenT\n            The token that is being visited.\n        context : Parser2Context\n            The context object containing information about the parser state.\n\n        \"\"\"\n        context.get_macro_statement_buffer().add_statement(\n            Assignment2(\n                variable_name=token.variable.name,\n                value=token.value.to_parser2_expression(context),\n            ),\n        )\n        return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.MacroVariableAssignment.on_parser_visit_token","title":"on_parser_visit_token","text":"<pre><code>on_parser_visit_token(\n    token: MacroVariableAssignment, context: Parser2Context\n) -&gt; None\n</code></pre> <p>Adds the primitive to the statement buffer.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>MacroVariableAssignment</code> <p>The token that is being visited.</p> required <code>context</code> <code>Parser2Context</code> <p>The context object containing information about the parser state.</p> required Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>def on_parser_visit_token(\n    self,\n    token: MacroVariableAssignment,\n    context: Parser2Context,\n) -&gt; None:\n    \"\"\"Adds the primitive to the statement buffer.\n\n    Parameters\n    ----------\n    token: TokenT\n        The token that is being visited.\n    context : Parser2Context\n        The context object containing information about the parser state.\n\n    \"\"\"\n    context.get_macro_statement_buffer().add_statement(\n        Assignment2(\n            variable_name=token.variable.name,\n            value=token.value.to_parser2_expression(context),\n        ),\n    )\n    return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.MacroDefinitionTokenHooks","title":"MacroDefinitionTokenHooks","text":"<p>             Bases: <code>MacroDefinitionTokenHooks</code></p> <p>Hooks for visiting macro definition token (AM).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>class MacroDefinitionTokenHooks(Parser2HooksBase.MacroDefinitionTokenHooks):\n    \"\"\"Hooks for visiting macro definition token (AM).\"\"\"\n\n    def on_parser_visit_token(\n        self,\n        token: MacroDefinition,\n        context: Parser2Context,\n    ) -&gt; None:\n        \"\"\"Called when parser visits a token.\n\n        This hook should perform all changes on context implicated by token type.\n\n        Parameters\n        ----------\n        token: TokenT\n            The token that is being visited.\n        context : Parser2Context\n            The context object containing information about the parser state.\n        \"\"\"\n        stmt_buff = context.get_macro_statement_buffer()\n        macro_name = token.macro_name\n\n        context.set_macro(\n            macro_name,\n            ApertureMacro2(name=macro_name, statements=stmt_buff.get_readonly()),\n        )\n        context.unset_macro_statement_buffer()\n        return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.MacroDefinitionTokenHooks.on_parser_visit_token","title":"on_parser_visit_token","text":"<pre><code>on_parser_visit_token(\n    token: MacroDefinition, context: Parser2Context\n) -&gt; None\n</code></pre> <p>Called when parser visits a token.</p> <p>This hook should perform all changes on context implicated by token type.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>MacroDefinition</code> <p>The token that is being visited.</p> required <code>context</code> <code>Parser2Context</code> <p>The context object containing information about the parser state.</p> required Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>def on_parser_visit_token(\n    self,\n    token: MacroDefinition,\n    context: Parser2Context,\n) -&gt; None:\n    \"\"\"Called when parser visits a token.\n\n    This hook should perform all changes on context implicated by token type.\n\n    Parameters\n    ----------\n    token: TokenT\n        The token that is being visited.\n    context : Parser2Context\n        The context object containing information about the parser state.\n    \"\"\"\n    stmt_buff = context.get_macro_statement_buffer()\n    macro_name = token.macro_name\n\n    context.set_macro(\n        macro_name,\n        ApertureMacro2(name=macro_name, statements=stmt_buff.get_readonly()),\n    )\n    context.unset_macro_statement_buffer()\n    return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.BeginBlockApertureTokenHooks","title":"BeginBlockApertureTokenHooks","text":"<p>             Bases: <code>BeginBlockApertureTokenHooks</code></p> <p>Hooks for visiting begin block aperture token (AB).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>class BeginBlockApertureTokenHooks(Parser2HooksBase.BeginBlockApertureTokenHooks):\n    \"\"\"Hooks for visiting begin block aperture token (AB).\"\"\"\n\n    def on_parser_visit_token(\n        self,\n        token: BlockApertureBegin,\n        context: Parser2Context,\n    ) -&gt; None:\n        \"\"\"Called when parser visits a token.\n\n        This hook should perform all changes on context implicated by token type.\n\n        Parameters\n        ----------\n        token: TokenT\n            The token that is being visited.\n        context : Parser2Context\n            The context object containing information about the parser state.\n        \"\"\"\n        context.push_block_command_buffer()\n        # Save state from before block definition started.\n        context.push_block_state()\n\n        context.set_current_position(Vector2D.NULL)\n        context.set_is_aperture_block(is_aperture_block=True)\n        context.set_aperture_block_id(token.identifier)\n\n        return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.BeginBlockApertureTokenHooks.on_parser_visit_token","title":"on_parser_visit_token","text":"<pre><code>on_parser_visit_token(\n    token: BlockApertureBegin, context: Parser2Context\n) -&gt; None\n</code></pre> <p>Called when parser visits a token.</p> <p>This hook should perform all changes on context implicated by token type.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>BlockApertureBegin</code> <p>The token that is being visited.</p> required <code>context</code> <code>Parser2Context</code> <p>The context object containing information about the parser state.</p> required Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>def on_parser_visit_token(\n    self,\n    token: BlockApertureBegin,\n    context: Parser2Context,\n) -&gt; None:\n    \"\"\"Called when parser visits a token.\n\n    This hook should perform all changes on context implicated by token type.\n\n    Parameters\n    ----------\n    token: TokenT\n        The token that is being visited.\n    context : Parser2Context\n        The context object containing information about the parser state.\n    \"\"\"\n    context.push_block_command_buffer()\n    # Save state from before block definition started.\n    context.push_block_state()\n\n    context.set_current_position(Vector2D.NULL)\n    context.set_is_aperture_block(is_aperture_block=True)\n    context.set_aperture_block_id(token.identifier)\n\n    return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.EndBlockApertureTokenHooks","title":"EndBlockApertureTokenHooks","text":"<p>             Bases: <code>EndBlockApertureTokenHooks</code></p> <p>Hooks for visiting end block aperture token (AB).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>class EndBlockApertureTokenHooks(Parser2HooksBase.EndBlockApertureTokenHooks):\n    \"\"\"Hooks for visiting end block aperture token (AB).\"\"\"\n\n    def on_parser_visit_token(\n        self,\n        token: BlockApertureEnd,\n        context: Parser2Context,\n    ) -&gt; None:\n        \"\"\"Called when parser visits a token.\n\n        This hook should perform all changes on context implicated by token type.\n\n        Parameters\n        ----------\n        token: TokenT\n            The token that is being visited.\n        context : Parser2Context\n            The context object containing information about the parser state.\n        \"\"\"\n        command_buffer = context.pop_block_command_buffer()\n        identifier = context.get_aperture_block_id()\n        if identifier is None:\n            raise UnnamedBlockApertureNotAllowedError(token)\n\n        context.set_aperture(\n            identifier,\n            Block2(\n                attributes=context.aperture_attributes,\n                command_buffer=command_buffer.get_readonly(),\n            ),\n        )\n        # Restore context state from before the block definition.\n        context.set_state(context.pop_block_state())\n        return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.EndBlockApertureTokenHooks.on_parser_visit_token","title":"on_parser_visit_token","text":"<pre><code>on_parser_visit_token(\n    token: BlockApertureEnd, context: Parser2Context\n) -&gt; None\n</code></pre> <p>Called when parser visits a token.</p> <p>This hook should perform all changes on context implicated by token type.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>BlockApertureEnd</code> <p>The token that is being visited.</p> required <code>context</code> <code>Parser2Context</code> <p>The context object containing information about the parser state.</p> required Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>def on_parser_visit_token(\n    self,\n    token: BlockApertureEnd,\n    context: Parser2Context,\n) -&gt; None:\n    \"\"\"Called when parser visits a token.\n\n    This hook should perform all changes on context implicated by token type.\n\n    Parameters\n    ----------\n    token: TokenT\n        The token that is being visited.\n    context : Parser2Context\n        The context object containing information about the parser state.\n    \"\"\"\n    command_buffer = context.pop_block_command_buffer()\n    identifier = context.get_aperture_block_id()\n    if identifier is None:\n        raise UnnamedBlockApertureNotAllowedError(token)\n\n    context.set_aperture(\n        identifier,\n        Block2(\n            attributes=context.aperture_attributes,\n            command_buffer=command_buffer.get_readonly(),\n        ),\n    )\n    # Restore context state from before the block definition.\n    context.set_state(context.pop_block_state())\n    return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.DefineApertureCircleTokenHooks","title":"DefineApertureCircleTokenHooks","text":"<p>             Bases: <code>DefineApertureCircleTokenHooks</code></p> <p>Hooks for visiting circle aperture definition token (ADD).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>class DefineApertureCircleTokenHooks(\n    Parser2HooksBase.DefineApertureCircleTokenHooks,\n):\n    \"\"\"Hooks for visiting circle aperture definition token (ADD).\"\"\"\n\n    def on_parser_visit_token(\n        self,\n        token: DefineCircle,\n        context: Parser2Context,\n    ) -&gt; None:\n        \"\"\"Called when parser visits a token.\n\n        This hook should perform all changes on context implicated by token type.\n\n        Parameters\n        ----------\n        token: TokenT\n            The token that is being visited.\n        context : Parser2Context\n            The context object containing information about the parser state.\n        \"\"\"\n        hole_diameter = (\n            None\n            if token.hole_diameter is None\n            else Offset.new(token.hole_diameter, context.get_draw_units())\n        )\n\n        context.set_aperture(\n            token.aperture_id,\n            Circle2(\n                attributes=context.aperture_attributes,\n                diameter=Offset.new(token.diameter, context.get_draw_units()),\n                hole_diameter=hole_diameter,\n            ),\n        )\n        return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.DefineApertureCircleTokenHooks.on_parser_visit_token","title":"on_parser_visit_token","text":"<pre><code>on_parser_visit_token(\n    token: DefineCircle, context: Parser2Context\n) -&gt; None\n</code></pre> <p>Called when parser visits a token.</p> <p>This hook should perform all changes on context implicated by token type.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>DefineCircle</code> <p>The token that is being visited.</p> required <code>context</code> <code>Parser2Context</code> <p>The context object containing information about the parser state.</p> required Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>def on_parser_visit_token(\n    self,\n    token: DefineCircle,\n    context: Parser2Context,\n) -&gt; None:\n    \"\"\"Called when parser visits a token.\n\n    This hook should perform all changes on context implicated by token type.\n\n    Parameters\n    ----------\n    token: TokenT\n        The token that is being visited.\n    context : Parser2Context\n        The context object containing information about the parser state.\n    \"\"\"\n    hole_diameter = (\n        None\n        if token.hole_diameter is None\n        else Offset.new(token.hole_diameter, context.get_draw_units())\n    )\n\n    context.set_aperture(\n        token.aperture_id,\n        Circle2(\n            attributes=context.aperture_attributes,\n            diameter=Offset.new(token.diameter, context.get_draw_units()),\n            hole_diameter=hole_diameter,\n        ),\n    )\n    return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.DefineApertureRectangleTokenHooks","title":"DefineApertureRectangleTokenHooks","text":"<p>             Bases: <code>DefineApertureRectangleTokenHooks</code></p> <p>Hooks for visiting rectangle aperture definition token (ADD).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>class DefineApertureRectangleTokenHooks(\n    Parser2HooksBase.DefineApertureRectangleTokenHooks,\n):\n    \"\"\"Hooks for visiting rectangle aperture definition token (ADD).\"\"\"\n\n    def on_parser_visit_token(\n        self,\n        token: DefineRectangle,\n        context: Parser2Context,\n    ) -&gt; None:\n        \"\"\"Called when parser visits a token.\n\n        This hook should perform all changes on context implicated by token type.\n\n        Parameters\n        ----------\n        token: TokenT\n            The token that is being visited.\n        context : Parser2Context\n            The context object containing information about the parser state.\n        \"\"\"\n        hole_diameter = (\n            None\n            if token.hole_diameter is None\n            else Offset.new(token.hole_diameter, context.get_draw_units())\n        )\n\n        context.set_aperture(\n            token.aperture_id,\n            Rectangle2(\n                attributes=context.aperture_attributes,\n                x_size=Offset.new(token.x_size, context.get_draw_units()),\n                y_size=Offset.new(token.y_size, context.get_draw_units()),\n                hole_diameter=hole_diameter,\n            ),\n        )\n        return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.DefineApertureRectangleTokenHooks.on_parser_visit_token","title":"on_parser_visit_token","text":"<pre><code>on_parser_visit_token(\n    token: DefineRectangle, context: Parser2Context\n) -&gt; None\n</code></pre> <p>Called when parser visits a token.</p> <p>This hook should perform all changes on context implicated by token type.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>DefineRectangle</code> <p>The token that is being visited.</p> required <code>context</code> <code>Parser2Context</code> <p>The context object containing information about the parser state.</p> required Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>def on_parser_visit_token(\n    self,\n    token: DefineRectangle,\n    context: Parser2Context,\n) -&gt; None:\n    \"\"\"Called when parser visits a token.\n\n    This hook should perform all changes on context implicated by token type.\n\n    Parameters\n    ----------\n    token: TokenT\n        The token that is being visited.\n    context : Parser2Context\n        The context object containing information about the parser state.\n    \"\"\"\n    hole_diameter = (\n        None\n        if token.hole_diameter is None\n        else Offset.new(token.hole_diameter, context.get_draw_units())\n    )\n\n    context.set_aperture(\n        token.aperture_id,\n        Rectangle2(\n            attributes=context.aperture_attributes,\n            x_size=Offset.new(token.x_size, context.get_draw_units()),\n            y_size=Offset.new(token.y_size, context.get_draw_units()),\n            hole_diameter=hole_diameter,\n        ),\n    )\n    return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.DefineApertureObroundTokenHooks","title":"DefineApertureObroundTokenHooks","text":"<p>             Bases: <code>DefineApertureObroundTokenHooks</code></p> <p>Hooks for visiting obround aperture definition token (ADD).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>class DefineApertureObroundTokenHooks(\n    Parser2HooksBase.DefineApertureObroundTokenHooks,\n):\n    \"\"\"Hooks for visiting obround aperture definition token (ADD).\"\"\"\n\n    def on_parser_visit_token(\n        self,\n        token: DefineObround,\n        context: Parser2Context,\n    ) -&gt; None:\n        \"\"\"Called when parser visits a token.\n\n        This hook should perform all changes on context implicated by token type.\n\n        Parameters\n        ----------\n        token: TokenT\n            The token that is being visited.\n        context : Parser2Context\n            The context object containing information about the parser state.\n        \"\"\"\n        hole_diameter = (\n            None\n            if token.hole_diameter is None\n            else Offset.new(token.hole_diameter, context.get_draw_units())\n        )\n\n        context.set_aperture(\n            token.aperture_id,\n            Obround2(\n                attributes=context.aperture_attributes,\n                x_size=Offset.new(token.x_size, context.get_draw_units()),\n                y_size=Offset.new(token.y_size, context.get_draw_units()),\n                hole_diameter=hole_diameter,\n            ),\n        )\n        return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.DefineApertureObroundTokenHooks.on_parser_visit_token","title":"on_parser_visit_token","text":"<pre><code>on_parser_visit_token(\n    token: DefineObround, context: Parser2Context\n) -&gt; None\n</code></pre> <p>Called when parser visits a token.</p> <p>This hook should perform all changes on context implicated by token type.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>DefineObround</code> <p>The token that is being visited.</p> required <code>context</code> <code>Parser2Context</code> <p>The context object containing information about the parser state.</p> required Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>def on_parser_visit_token(\n    self,\n    token: DefineObround,\n    context: Parser2Context,\n) -&gt; None:\n    \"\"\"Called when parser visits a token.\n\n    This hook should perform all changes on context implicated by token type.\n\n    Parameters\n    ----------\n    token: TokenT\n        The token that is being visited.\n    context : Parser2Context\n        The context object containing information about the parser state.\n    \"\"\"\n    hole_diameter = (\n        None\n        if token.hole_diameter is None\n        else Offset.new(token.hole_diameter, context.get_draw_units())\n    )\n\n    context.set_aperture(\n        token.aperture_id,\n        Obround2(\n            attributes=context.aperture_attributes,\n            x_size=Offset.new(token.x_size, context.get_draw_units()),\n            y_size=Offset.new(token.y_size, context.get_draw_units()),\n            hole_diameter=hole_diameter,\n        ),\n    )\n    return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.DefineAperturePolygonTokenHooks","title":"DefineAperturePolygonTokenHooks","text":"<p>             Bases: <code>DefineAperturePolygonTokenHooks</code></p> <p>Hooks for visiting polygon aperture definition token (ADD).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>class DefineAperturePolygonTokenHooks(\n    Parser2HooksBase.DefineAperturePolygonTokenHooks,\n):\n    \"\"\"Hooks for visiting polygon aperture definition token (ADD).\"\"\"\n\n    def on_parser_visit_token(\n        self,\n        token: DefinePolygon,\n        context: Parser2Context,\n    ) -&gt; None:\n        \"\"\"Called when parser visits a token.\n\n        This hook should perform all changes on context implicated by token type.\n\n        Parameters\n        ----------\n        token: TokenT\n            The token that is being visited.\n        context : Parser2Context\n            The context object containing information about the parser state.\n        \"\"\"\n        hole_diameter = (\n            None\n            if token.hole_diameter is None\n            else Offset.new(token.hole_diameter, context.get_draw_units())\n        )\n        rotation = Decimal(\"0.0\") if token.rotation is None else token.rotation\n\n        context.set_aperture(\n            token.aperture_id,\n            Polygon2(\n                attributes=context.aperture_attributes,\n                outer_diameter=Offset.new(\n                    token.outer_diameter,\n                    context.get_draw_units(),\n                ),\n                number_vertices=token.number_of_vertices,\n                rotation=rotation,\n                hole_diameter=hole_diameter,\n            ),\n        )\n        return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.DefineAperturePolygonTokenHooks.on_parser_visit_token","title":"on_parser_visit_token","text":"<pre><code>on_parser_visit_token(\n    token: DefinePolygon, context: Parser2Context\n) -&gt; None\n</code></pre> <p>Called when parser visits a token.</p> <p>This hook should perform all changes on context implicated by token type.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>DefinePolygon</code> <p>The token that is being visited.</p> required <code>context</code> <code>Parser2Context</code> <p>The context object containing information about the parser state.</p> required Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>def on_parser_visit_token(\n    self,\n    token: DefinePolygon,\n    context: Parser2Context,\n) -&gt; None:\n    \"\"\"Called when parser visits a token.\n\n    This hook should perform all changes on context implicated by token type.\n\n    Parameters\n    ----------\n    token: TokenT\n        The token that is being visited.\n    context : Parser2Context\n        The context object containing information about the parser state.\n    \"\"\"\n    hole_diameter = (\n        None\n        if token.hole_diameter is None\n        else Offset.new(token.hole_diameter, context.get_draw_units())\n    )\n    rotation = Decimal(\"0.0\") if token.rotation is None else token.rotation\n\n    context.set_aperture(\n        token.aperture_id,\n        Polygon2(\n            attributes=context.aperture_attributes,\n            outer_diameter=Offset.new(\n                token.outer_diameter,\n                context.get_draw_units(),\n            ),\n            number_vertices=token.number_of_vertices,\n            rotation=rotation,\n            hole_diameter=hole_diameter,\n        ),\n    )\n    return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.DefineApertureMacroTokenHooks","title":"DefineApertureMacroTokenHooks","text":"<p>             Bases: <code>DefineApertureMacroTokenHooks</code></p> <p>Hooks for visiting macro aperture definition token (ADD).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>class DefineApertureMacroTokenHooks(Parser2HooksBase.DefineApertureMacroTokenHooks):\n    \"\"\"Hooks for visiting macro aperture definition token (ADD).\"\"\"\n\n    def on_parser_visit_token(\n        self,\n        token: DefineMacro,\n        context: Parser2Context,\n    ) -&gt; None:\n        \"\"\"Called when parser visits a token.\n\n        This hook should perform all changes on context implicated by token type.\n\n        Parameters\n        ----------\n        token: TokenT\n            The token that is being visited.\n        context : Parser2Context\n            The context object containing information about the parser state.\n        \"\"\"\n        macro = context.get_macro(token.aperture_type)\n        context.set_macro_eval_buffer()\n        context.macro_variable_buffer = {\n            f\"${i}\": Decimal(param) for i, param in enumerate(token.am_param, 1)\n        }\n        macro.on_parser2_eval_statement(context)\n\n        context.set_aperture(\n            token.aperture_id,\n            Macro2(\n                attributes=context.aperture_attributes,\n                command_buffer=context.get_macro_eval_buffer().get_readonly(),\n            ),\n        )\n\n        context.unset_macro_eval_buffer()\n        context.macro_variable_buffer = {}\n\n        return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.DefineApertureMacroTokenHooks.on_parser_visit_token","title":"on_parser_visit_token","text":"<pre><code>on_parser_visit_token(\n    token: DefineMacro, context: Parser2Context\n) -&gt; None\n</code></pre> <p>Called when parser visits a token.</p> <p>This hook should perform all changes on context implicated by token type.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>DefineMacro</code> <p>The token that is being visited.</p> required <code>context</code> <code>Parser2Context</code> <p>The context object containing information about the parser state.</p> required Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>def on_parser_visit_token(\n    self,\n    token: DefineMacro,\n    context: Parser2Context,\n) -&gt; None:\n    \"\"\"Called when parser visits a token.\n\n    This hook should perform all changes on context implicated by token type.\n\n    Parameters\n    ----------\n    token: TokenT\n        The token that is being visited.\n    context : Parser2Context\n        The context object containing information about the parser state.\n    \"\"\"\n    macro = context.get_macro(token.aperture_type)\n    context.set_macro_eval_buffer()\n    context.macro_variable_buffer = {\n        f\"${i}\": Decimal(param) for i, param in enumerate(token.am_param, 1)\n    }\n    macro.on_parser2_eval_statement(context)\n\n    context.set_aperture(\n        token.aperture_id,\n        Macro2(\n            attributes=context.aperture_attributes,\n            command_buffer=context.get_macro_eval_buffer().get_readonly(),\n        ),\n    )\n\n    context.unset_macro_eval_buffer()\n    context.macro_variable_buffer = {}\n\n    return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.MacroEvalHooks","title":"MacroEvalHooks","text":"<p>Hooks called when evaluating macro aperture.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>class MacroEvalHooks:\n    \"\"\"Hooks called when evaluating macro aperture.\"\"\"\n\n    def on_code_1_circle(\n        self,\n        context: Parser2Context,\n        primitive: Code1Circle2,\n    ) -&gt; None:\n        \"\"\"Evaluate code 1 circle primitive.\"\"\"\n        exposure = primitive.exposure.on_parser2_eval_expression(context)\n        polarity = (\n            Polarity.Clear\n            if math.isclose(exposure, Decimal(\"0.0\"))\n            else Polarity.Dark\n        )\n        context.get_macro_eval_buffer().add_command(\n            Flash2(\n                transform=ApertureTransform(\n                    polarity=polarity,\n                    mirroring=Mirroring.NoMirroring,\n                    rotation=Decimal(\"0.0\"),\n                    scaling=Decimal(\"1.0\"),\n                ),\n                aperture=Circle2(\n                    diameter=Offset.new(\n                        primitive.diameter.on_parser2_eval_expression(context),\n                        context.get_draw_units(),\n                    ),\n                    hole_diameter=None,\n                ),\n                flash_point=Vector2D(\n                    x=Offset.new(\n                        primitive.center_x.on_parser2_eval_expression(context),\n                        context.get_draw_units(),\n                    ),\n                    y=Offset.new(\n                        primitive.center_y.on_parser2_eval_expression(context),\n                        context.get_draw_units(),\n                    ),\n                ),\n            ),\n        )\n\n    def on_code_2_vector_line(\n        self,\n        context: Parser2Context,\n        primitive: Code2VectorLine2,\n    ) -&gt; None:\n        \"\"\"Evaluate code 2 vector line primitive.\"\"\"\n\n    def on_code_4_outline(\n        self,\n        context: Parser2Context,\n        primitive: Code4Outline2,\n    ) -&gt; None:\n        \"\"\"Evaluate code 4 outline primitive.\"\"\"\n        exposure = primitive.exposure.on_parser2_eval_expression(context)\n        polarity = (\n            Polarity.Clear\n            if math.isclose(exposure, Decimal(\"0.0\"))\n            else Polarity.Dark\n        )\n        transform = ApertureTransform(\n            polarity=polarity,\n            mirroring=Mirroring.NoMirroring,\n            rotation=Decimal(\"0.0\"),\n            scaling=Decimal(\"1.0\"),\n        )\n        aperture = Circle2(\n            diameter=Offset.NULL,\n            hole_diameter=None,\n        )\n        context.get_macro_eval_buffer().add_command(\n            Region2(\n                transform=ApertureTransform(\n                    polarity=polarity,\n                    mirroring=Mirroring.NoMirroring,\n                    rotation=Decimal(\"0.0\"),\n                    scaling=Decimal(\"1.0\"),\n                ),\n                command_buffer=CommandBuffer2(\n                    [\n                        Line2(\n                            transform=transform,\n                            aperture=aperture,\n                            start_point=Vector2D(\n                                x=Offset.new(\n                                    start_point.x.on_parser2_eval_expression(\n                                        context,\n                                    ),\n                                    context.get_draw_units(),\n                                ),\n                                y=Offset.new(\n                                    start_point.y.on_parser2_eval_expression(\n                                        context,\n                                    ),\n                                    context.get_draw_units(),\n                                ),\n                            ),\n                            end_point=Vector2D(\n                                x=Offset.new(\n                                    end_point.x.on_parser2_eval_expression(\n                                        context,\n                                    ),\n                                    context.get_draw_units(),\n                                ),\n                                y=Offset.new(\n                                    end_point.y.on_parser2_eval_expression(\n                                        context,\n                                    ),\n                                    context.get_draw_units(),\n                                ),\n                            ),\n                        )\n                        for start_point, end_point in zip(\n                            [\n                                Point2(x=primitive.start_x, y=primitive.start_y),\n                                *primitive.points,\n                            ],\n                            [\n                                *primitive.points,\n                                Point2(x=primitive.start_x, y=primitive.start_y),\n                            ],\n                        )\n                    ],\n                ).get_readonly(),\n            ),\n        )\n\n    def on_code_5_polygon(\n        self,\n        context: Parser2Context,\n        primitive: Code5Polygon2,\n    ) -&gt; None:\n        \"\"\"Evaluate code 5 polygon primitive.\"\"\"\n        exposure = primitive.exposure.on_parser2_eval_expression(context)\n        polarity = (\n            Polarity.Clear\n            if math.isclose(exposure, Decimal(\"0.0\"))\n            else Polarity.Dark\n        )\n        context.get_macro_eval_buffer().add_command(\n            Flash2(\n                transform=ApertureTransform(\n                    polarity=polarity,\n                    mirroring=Mirroring.NoMirroring,\n                    rotation=Decimal(\"0.0\"),\n                    scaling=Decimal(\"1.0\"),\n                ),\n                aperture=Polygon2(\n                    outer_diameter=Offset.new(\n                        primitive.diameter.on_parser2_eval_expression(\n                            context,\n                        ),\n                    ),\n                    number_vertices=round(\n                        primitive.number_of_vertices.on_parser2_eval_expression(\n                            context,\n                        ),\n                    ),\n                    rotation=Decimal(\"0.0\"),\n                    hole_diameter=None,\n                ),\n                flash_point=Vector2D(\n                    x=Offset.new(\n                        primitive.center_x.on_parser2_eval_expression(context),\n                        context.get_draw_units(),\n                    ),\n                    y=Offset.new(\n                        primitive.center_y.on_parser2_eval_expression(context),\n                        context.get_draw_units(),\n                    ),\n                ),\n            ),\n        )\n\n    def on_code_6_moire(\n        self,\n        context: Parser2Context,\n        primitive: Code6Moire2,\n    ) -&gt; None:\n        \"\"\"Evaluate code 6 moire primitive.\"\"\"\n\n    def on_code_7_thermal(\n        self,\n        context: Parser2Context,\n        primitive: Code7Thermal2,\n    ) -&gt; None:\n        \"\"\"Evaluate code 7 thermal primitive.\"\"\"\n\n    def on_code_20_vector_line(\n        self,\n        context: Parser2Context,\n        primitive: Code20VectorLine2,\n    ) -&gt; None:\n        \"\"\"Evaluate code 20 vector line primitive.\"\"\"\n        exposure = primitive.exposure.on_parser2_eval_expression(context)\n        polarity = (\n            Polarity.Clear\n            if math.isclose(exposure, Decimal(\"0.0\"))\n            else Polarity.Dark\n        )\n        context.get_macro_eval_buffer().add_command(\n            Line2(\n                transform=ApertureTransform(\n                    polarity=polarity,\n                    mirroring=Mirroring.NoMirroring,\n                    rotation=Decimal(\"0.0\"),\n                    scaling=Decimal(\"1.0\"),\n                ),\n                aperture=NoCircle2(\n                    diameter=Offset.new(\n                        primitive.width.on_parser2_eval_expression(context),\n                        context.get_draw_units(),\n                    ),\n                    hole_diameter=None,\n                ),\n                start_point=Vector2D(\n                    x=Offset.new(\n                        primitive.start_x.on_parser2_eval_expression(context),\n                        context.get_draw_units(),\n                    ),\n                    y=Offset.new(\n                        primitive.start_y.on_parser2_eval_expression(context),\n                        context.get_draw_units(),\n                    ),\n                ),\n                end_point=Vector2D(\n                    x=Offset.new(\n                        primitive.end_x.on_parser2_eval_expression(context),\n                        context.get_draw_units(),\n                    ),\n                    y=Offset.new(\n                        primitive.end_y.on_parser2_eval_expression(context),\n                        context.get_draw_units(),\n                    ),\n                ),\n            ),\n        )\n\n    def on_code_21_center_line(\n        self,\n        context: Parser2Context,\n        primitive: Code21CenterLine2,\n    ) -&gt; None:\n        \"\"\"Evaluate code 21 center line primitive.\"\"\"\n        exposure = primitive.exposure.on_parser2_eval_expression(context)\n        polarity = (\n            Polarity.Clear\n            if math.isclose(exposure, Decimal(\"0.0\"))\n            else Polarity.Dark\n        )\n        context.get_macro_eval_buffer().add_command(\n            Flash2(\n                transform=ApertureTransform(\n                    polarity=polarity,\n                    mirroring=Mirroring.NoMirroring,\n                    rotation=Decimal(\"0.0\"),\n                    scaling=Decimal(\"1.0\"),\n                ),\n                aperture=Rectangle2(\n                    x_size=Offset.new(\n                        primitive.width.on_parser2_eval_expression(context),\n                        context.get_draw_units(),\n                    ),\n                    y_size=Offset.new(\n                        primitive.height.on_parser2_eval_expression(context),\n                        context.get_draw_units(),\n                    ),\n                    hole_diameter=None,\n                ),\n                flash_point=Vector2D(\n                    x=Offset.new(\n                        primitive.center_x.on_parser2_eval_expression(context),\n                        context.get_draw_units(),\n                    ),\n                    y=Offset.new(\n                        primitive.center_y.on_parser2_eval_expression(context),\n                        context.get_draw_units(),\n                    ),\n                ),\n            ),\n        )\n\n    def on_code_22_lower_left_line(\n        self,\n        context: Parser2Context,\n        primitive: Code22LowerLeftLine2,\n    ) -&gt; None:\n        \"\"\"Evaluate code 22 lower left line primitive.\"\"\"\n\n    def on_assignment(\n        self,\n        context: Parser2Context,\n        assignment: Assignment2,\n    ) -&gt; None:\n        \"\"\"Evaluate macro variable assignment statement.\"\"\"\n        context.macro_variable_buffer[\n            assignment.variable_name\n        ] = assignment.value.on_parser2_eval_expression(context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.MacroEvalHooks.on_code_1_circle","title":"on_code_1_circle","text":"<pre><code>on_code_1_circle(\n    context: Parser2Context, primitive: Code1Circle2\n) -&gt; None\n</code></pre> <p>Evaluate code 1 circle primitive.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>def on_code_1_circle(\n    self,\n    context: Parser2Context,\n    primitive: Code1Circle2,\n) -&gt; None:\n    \"\"\"Evaluate code 1 circle primitive.\"\"\"\n    exposure = primitive.exposure.on_parser2_eval_expression(context)\n    polarity = (\n        Polarity.Clear\n        if math.isclose(exposure, Decimal(\"0.0\"))\n        else Polarity.Dark\n    )\n    context.get_macro_eval_buffer().add_command(\n        Flash2(\n            transform=ApertureTransform(\n                polarity=polarity,\n                mirroring=Mirroring.NoMirroring,\n                rotation=Decimal(\"0.0\"),\n                scaling=Decimal(\"1.0\"),\n            ),\n            aperture=Circle2(\n                diameter=Offset.new(\n                    primitive.diameter.on_parser2_eval_expression(context),\n                    context.get_draw_units(),\n                ),\n                hole_diameter=None,\n            ),\n            flash_point=Vector2D(\n                x=Offset.new(\n                    primitive.center_x.on_parser2_eval_expression(context),\n                    context.get_draw_units(),\n                ),\n                y=Offset.new(\n                    primitive.center_y.on_parser2_eval_expression(context),\n                    context.get_draw_units(),\n                ),\n            ),\n        ),\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.MacroEvalHooks.on_code_2_vector_line","title":"on_code_2_vector_line","text":"<pre><code>on_code_2_vector_line(\n    context: Parser2Context, primitive: Code2VectorLine2\n) -&gt; None\n</code></pre> <p>Evaluate code 2 vector line primitive.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>def on_code_2_vector_line(\n    self,\n    context: Parser2Context,\n    primitive: Code2VectorLine2,\n) -&gt; None:\n    \"\"\"Evaluate code 2 vector line primitive.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.MacroEvalHooks.on_code_4_outline","title":"on_code_4_outline","text":"<pre><code>on_code_4_outline(\n    context: Parser2Context, primitive: Code4Outline2\n) -&gt; None\n</code></pre> <p>Evaluate code 4 outline primitive.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>def on_code_4_outline(\n    self,\n    context: Parser2Context,\n    primitive: Code4Outline2,\n) -&gt; None:\n    \"\"\"Evaluate code 4 outline primitive.\"\"\"\n    exposure = primitive.exposure.on_parser2_eval_expression(context)\n    polarity = (\n        Polarity.Clear\n        if math.isclose(exposure, Decimal(\"0.0\"))\n        else Polarity.Dark\n    )\n    transform = ApertureTransform(\n        polarity=polarity,\n        mirroring=Mirroring.NoMirroring,\n        rotation=Decimal(\"0.0\"),\n        scaling=Decimal(\"1.0\"),\n    )\n    aperture = Circle2(\n        diameter=Offset.NULL,\n        hole_diameter=None,\n    )\n    context.get_macro_eval_buffer().add_command(\n        Region2(\n            transform=ApertureTransform(\n                polarity=polarity,\n                mirroring=Mirroring.NoMirroring,\n                rotation=Decimal(\"0.0\"),\n                scaling=Decimal(\"1.0\"),\n            ),\n            command_buffer=CommandBuffer2(\n                [\n                    Line2(\n                        transform=transform,\n                        aperture=aperture,\n                        start_point=Vector2D(\n                            x=Offset.new(\n                                start_point.x.on_parser2_eval_expression(\n                                    context,\n                                ),\n                                context.get_draw_units(),\n                            ),\n                            y=Offset.new(\n                                start_point.y.on_parser2_eval_expression(\n                                    context,\n                                ),\n                                context.get_draw_units(),\n                            ),\n                        ),\n                        end_point=Vector2D(\n                            x=Offset.new(\n                                end_point.x.on_parser2_eval_expression(\n                                    context,\n                                ),\n                                context.get_draw_units(),\n                            ),\n                            y=Offset.new(\n                                end_point.y.on_parser2_eval_expression(\n                                    context,\n                                ),\n                                context.get_draw_units(),\n                            ),\n                        ),\n                    )\n                    for start_point, end_point in zip(\n                        [\n                            Point2(x=primitive.start_x, y=primitive.start_y),\n                            *primitive.points,\n                        ],\n                        [\n                            *primitive.points,\n                            Point2(x=primitive.start_x, y=primitive.start_y),\n                        ],\n                    )\n                ],\n            ).get_readonly(),\n        ),\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.MacroEvalHooks.on_code_5_polygon","title":"on_code_5_polygon","text":"<pre><code>on_code_5_polygon(\n    context: Parser2Context, primitive: Code5Polygon2\n) -&gt; None\n</code></pre> <p>Evaluate code 5 polygon primitive.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>def on_code_5_polygon(\n    self,\n    context: Parser2Context,\n    primitive: Code5Polygon2,\n) -&gt; None:\n    \"\"\"Evaluate code 5 polygon primitive.\"\"\"\n    exposure = primitive.exposure.on_parser2_eval_expression(context)\n    polarity = (\n        Polarity.Clear\n        if math.isclose(exposure, Decimal(\"0.0\"))\n        else Polarity.Dark\n    )\n    context.get_macro_eval_buffer().add_command(\n        Flash2(\n            transform=ApertureTransform(\n                polarity=polarity,\n                mirroring=Mirroring.NoMirroring,\n                rotation=Decimal(\"0.0\"),\n                scaling=Decimal(\"1.0\"),\n            ),\n            aperture=Polygon2(\n                outer_diameter=Offset.new(\n                    primitive.diameter.on_parser2_eval_expression(\n                        context,\n                    ),\n                ),\n                number_vertices=round(\n                    primitive.number_of_vertices.on_parser2_eval_expression(\n                        context,\n                    ),\n                ),\n                rotation=Decimal(\"0.0\"),\n                hole_diameter=None,\n            ),\n            flash_point=Vector2D(\n                x=Offset.new(\n                    primitive.center_x.on_parser2_eval_expression(context),\n                    context.get_draw_units(),\n                ),\n                y=Offset.new(\n                    primitive.center_y.on_parser2_eval_expression(context),\n                    context.get_draw_units(),\n                ),\n            ),\n        ),\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.MacroEvalHooks.on_code_6_moire","title":"on_code_6_moire","text":"<pre><code>on_code_6_moire(\n    context: Parser2Context, primitive: Code6Moire2\n) -&gt; None\n</code></pre> <p>Evaluate code 6 moire primitive.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>def on_code_6_moire(\n    self,\n    context: Parser2Context,\n    primitive: Code6Moire2,\n) -&gt; None:\n    \"\"\"Evaluate code 6 moire primitive.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.MacroEvalHooks.on_code_7_thermal","title":"on_code_7_thermal","text":"<pre><code>on_code_7_thermal(\n    context: Parser2Context, primitive: Code7Thermal2\n) -&gt; None\n</code></pre> <p>Evaluate code 7 thermal primitive.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>def on_code_7_thermal(\n    self,\n    context: Parser2Context,\n    primitive: Code7Thermal2,\n) -&gt; None:\n    \"\"\"Evaluate code 7 thermal primitive.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.MacroEvalHooks.on_code_20_vector_line","title":"on_code_20_vector_line","text":"<pre><code>on_code_20_vector_line(\n    context: Parser2Context, primitive: Code20VectorLine2\n) -&gt; None\n</code></pre> <p>Evaluate code 20 vector line primitive.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>def on_code_20_vector_line(\n    self,\n    context: Parser2Context,\n    primitive: Code20VectorLine2,\n) -&gt; None:\n    \"\"\"Evaluate code 20 vector line primitive.\"\"\"\n    exposure = primitive.exposure.on_parser2_eval_expression(context)\n    polarity = (\n        Polarity.Clear\n        if math.isclose(exposure, Decimal(\"0.0\"))\n        else Polarity.Dark\n    )\n    context.get_macro_eval_buffer().add_command(\n        Line2(\n            transform=ApertureTransform(\n                polarity=polarity,\n                mirroring=Mirroring.NoMirroring,\n                rotation=Decimal(\"0.0\"),\n                scaling=Decimal(\"1.0\"),\n            ),\n            aperture=NoCircle2(\n                diameter=Offset.new(\n                    primitive.width.on_parser2_eval_expression(context),\n                    context.get_draw_units(),\n                ),\n                hole_diameter=None,\n            ),\n            start_point=Vector2D(\n                x=Offset.new(\n                    primitive.start_x.on_parser2_eval_expression(context),\n                    context.get_draw_units(),\n                ),\n                y=Offset.new(\n                    primitive.start_y.on_parser2_eval_expression(context),\n                    context.get_draw_units(),\n                ),\n            ),\n            end_point=Vector2D(\n                x=Offset.new(\n                    primitive.end_x.on_parser2_eval_expression(context),\n                    context.get_draw_units(),\n                ),\n                y=Offset.new(\n                    primitive.end_y.on_parser2_eval_expression(context),\n                    context.get_draw_units(),\n                ),\n            ),\n        ),\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.MacroEvalHooks.on_code_21_center_line","title":"on_code_21_center_line","text":"<pre><code>on_code_21_center_line(\n    context: Parser2Context, primitive: Code21CenterLine2\n) -&gt; None\n</code></pre> <p>Evaluate code 21 center line primitive.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>def on_code_21_center_line(\n    self,\n    context: Parser2Context,\n    primitive: Code21CenterLine2,\n) -&gt; None:\n    \"\"\"Evaluate code 21 center line primitive.\"\"\"\n    exposure = primitive.exposure.on_parser2_eval_expression(context)\n    polarity = (\n        Polarity.Clear\n        if math.isclose(exposure, Decimal(\"0.0\"))\n        else Polarity.Dark\n    )\n    context.get_macro_eval_buffer().add_command(\n        Flash2(\n            transform=ApertureTransform(\n                polarity=polarity,\n                mirroring=Mirroring.NoMirroring,\n                rotation=Decimal(\"0.0\"),\n                scaling=Decimal(\"1.0\"),\n            ),\n            aperture=Rectangle2(\n                x_size=Offset.new(\n                    primitive.width.on_parser2_eval_expression(context),\n                    context.get_draw_units(),\n                ),\n                y_size=Offset.new(\n                    primitive.height.on_parser2_eval_expression(context),\n                    context.get_draw_units(),\n                ),\n                hole_diameter=None,\n            ),\n            flash_point=Vector2D(\n                x=Offset.new(\n                    primitive.center_x.on_parser2_eval_expression(context),\n                    context.get_draw_units(),\n                ),\n                y=Offset.new(\n                    primitive.center_y.on_parser2_eval_expression(context),\n                    context.get_draw_units(),\n                ),\n            ),\n        ),\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.MacroEvalHooks.on_code_22_lower_left_line","title":"on_code_22_lower_left_line","text":"<pre><code>on_code_22_lower_left_line(\n    context: Parser2Context, primitive: Code22LowerLeftLine2\n) -&gt; None\n</code></pre> <p>Evaluate code 22 lower left line primitive.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>def on_code_22_lower_left_line(\n    self,\n    context: Parser2Context,\n    primitive: Code22LowerLeftLine2,\n) -&gt; None:\n    \"\"\"Evaluate code 22 lower left line primitive.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.MacroEvalHooks.on_assignment","title":"on_assignment","text":"<pre><code>on_assignment(\n    context: Parser2Context, assignment: Assignment2\n) -&gt; None\n</code></pre> <p>Evaluate macro variable assignment statement.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>def on_assignment(\n    self,\n    context: Parser2Context,\n    assignment: Assignment2,\n) -&gt; None:\n    \"\"\"Evaluate macro variable assignment statement.\"\"\"\n    context.macro_variable_buffer[\n        assignment.variable_name\n    ] = assignment.value.on_parser2_eval_expression(context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.AxisSelectTokenHooksTokenHooks","title":"AxisSelectTokenHooksTokenHooks","text":"<p>             Bases: <code>AxisSelectTokenHooksTokenHooks</code></p> <p>Hooks for visiting axis select token (AS).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>class AxisSelectTokenHooksTokenHooks(\n    Parser2HooksBase.AxisSelectTokenHooksTokenHooks,\n):\n    \"\"\"Hooks for visiting axis select token (AS).\"\"\"\n\n    def on_parser_visit_token(\n        self,\n        token: AxisSelect,\n        context: Parser2Context,\n    ) -&gt; None:\n        \"\"\"Perform actions on the context implicated by this token.\n\n        Parameters\n        ----------\n        token: TokenT\n            The token that is being visited.\n        context : Parser2Context\n            The context on which to perform the actions.\n        \"\"\"\n        context.set_axis_correspondence(token.correspondence)\n        return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.AxisSelectTokenHooksTokenHooks.on_parser_visit_token","title":"on_parser_visit_token","text":"<pre><code>on_parser_visit_token(\n    token: AxisSelect, context: Parser2Context\n) -&gt; None\n</code></pre> <p>Perform actions on the context implicated by this token.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>AxisSelect</code> <p>The token that is being visited.</p> required <code>context</code> <code>Parser2Context</code> <p>The context on which to perform the actions.</p> required Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>def on_parser_visit_token(\n    self,\n    token: AxisSelect,\n    context: Parser2Context,\n) -&gt; None:\n    \"\"\"Perform actions on the context implicated by this token.\n\n    Parameters\n    ----------\n    token: TokenT\n        The token that is being visited.\n    context : Parser2Context\n        The context on which to perform the actions.\n    \"\"\"\n    context.set_axis_correspondence(token.correspondence)\n    return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.CommandDrawTokenHooks","title":"CommandDrawTokenHooks","text":"<p>             Bases: <code>CommandDrawTokenHooks</code></p> <p>Hooks for visiting draw token (D01).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>class CommandDrawTokenHooks(Parser2HooksBase.CommandDrawTokenHooks):\n    \"\"\"Hooks for visiting draw token (D01).\"\"\"\n\n    def on_parser_visit_token(\n        self,\n        token: D01Draw,\n        context: Parser2Context,\n    ) -&gt; None:\n        \"\"\"Called when parser visits a token.\n\n        This hook should perform all changes on context implicated by token type.\n\n        Parameters\n        ----------\n        token: TokenT\n            The token that is being visited.\n        context : Parser2Context\n            The context object containing information about the parser state.\n        \"\"\"\n        self.DRAW_MODE_DISPATCH_TABLE[context.get_draw_mode()](self, token, context)\n        return super().on_parser_visit_token(token, context)\n\n    def on_parser_visit_token_line(\n        self,\n        token: D01Draw,\n        context: Parser2Context,\n    ) -&gt; None:\n        \"\"\"Called when parser visits a token.\n\n        This hook should perform all changes on context implicated by token type.\n\n        Parameters\n        ----------\n        token: TokenT\n            The token that is being visited.\n        context : Parser2Context\n            The context object containing information about the parser state.\n        \"\"\"\n        state = context.get_state()\n\n        x = state.parse_coordinate(token.x)\n        y = state.parse_coordinate(token.y)\n\n        start_point = context.get_current_position()\n        end_point = Vector2D(x=x, y=y)\n\n        aperture_id = context.get_current_aperture_id() or throw(\n            ApertureNotSelected2Error(token),\n        )\n        aperture = context.get_aperture(aperture_id)\n\n        context.add_command(\n            Line2(\n                attributes=context.object_attributes,\n                aperture=aperture,\n                start_point=start_point,\n                end_point=end_point,\n                transform=context.get_state().get_aperture_transform(),\n            ),\n        )\n        context.set_current_position(end_point)\n\n    def on_parser_visit_token_arc(\n        self,\n        token: D01Draw,\n        context: Parser2Context,\n    ) -&gt; None:\n        \"\"\"Called when parser visits a token.\n\n        This hook should perform all changes on context implicated by token type.\n\n        Parameters\n        ----------\n        token: TokenT\n            The token that is being visited.\n        context : Parser2Context\n            The context object containing information about the parser state.\n        \"\"\"\n        state = context.get_state()\n\n        x = state.parse_coordinate(token.x)\n        y = state.parse_coordinate(token.y)\n        i = state.parse_coordinate(token.i)\n        j = state.parse_coordinate(token.j)\n\n        start_point = context.get_current_position()\n        end_point = Vector2D(x=x, y=y)\n        final_center_point = Vector2D.NULL\n\n        if context.get_is_multi_quadrant() is False:\n            # In single quadrant mode I and J offsets are unsigned, therefore we\n            # need to check all 4 possible center points. We will choose first\n            # valid, if anyone needs behavior strictly matching this from spec,\n            # they can always create issue.\n            for center_offset in (\n                Vector2D(x=i, y=j),\n                Vector2D(x=-i, y=j),\n                Vector2D(x=i, y=-j),\n                Vector2D(x=-i, y=-j),\n            ):\n                center_point = start_point + center_offset\n                relative_start_point = start_point - center_point\n                relative_end_point = end_point - center_point\n                # Calculate radius of arc from center to start point and end point,\n                # If they aren't equal, this center candidate is not valid and we\n                # can skip it.\n                if not math.isclose(\n                    relative_start_point.length().value,\n                    relative_end_point.length().value,\n                    rel_tol=1e-3,\n                ):\n                    continue\n\n                # Calculate angle between vector pointing from center of arc to\n                # start, and vector pointing from center of arc to end point. If\n                # this angle is above 90 degrees, we exceeded allowed angle size in\n                # single quadrant mode and need to try other possible center points.\n                clockwise_angle = relative_start_point.angle_between(\n                    relative_end_point,\n                )\n                if clockwise_angle &gt; MAX_SINGLE_QUADRANT_ANGLE:\n                    continue\n\n                final_center_point = center_point\n                break\n            else:\n                raise NoValidArcCenterFoundError(token)\n\n        else:\n            # In multi quadrant mode I and J offsets are signed, so we can simply\n            # use them to calculate center point relative to start point.\n            center_offset = Vector2D(x=i, y=j)\n            final_center_point = start_point + center_offset\n\n        aperture_id = context.get_current_aperture_id() or throw(\n            ApertureNotSelected2Error(token),\n        )\n        aperture = context.get_aperture(aperture_id)\n\n        context.add_command(\n            Arc2(\n                attributes=context.object_attributes,\n                aperture=aperture,\n                start_point=start_point,\n                end_point=end_point,\n                center_point=final_center_point,\n                transform=context.get_state().get_aperture_transform(),\n            ),\n        )\n        context.set_current_position(end_point)\n\n    def on_parser_visit_token_cc_arc(\n        self,\n        token: D01Draw,\n        context: Parser2Context,\n    ) -&gt; None:\n        \"\"\"Called when parser visits a token.\n\n        This hook should perform all changes on context implicated by token type.\n\n        Parameters\n        ----------\n        token: TokenT\n            The token that is being visited.\n        context : Parser2Context\n            The context object containing information about the parser state.\n        \"\"\"\n        state = context.get_state()\n\n        x = state.parse_coordinate(token.x)\n        y = state.parse_coordinate(token.y)\n        i = state.parse_coordinate(token.i)\n        j = state.parse_coordinate(token.j)\n\n        start_point = context.get_current_position()\n        end_point = Vector2D(x=x, y=y)\n        final_center_point = Vector2D.NULL\n\n        if context.get_is_multi_quadrant() is False:\n            for center_offset in (\n                Vector2D(x=i, y=j),\n                Vector2D(x=-i, y=j),\n                Vector2D(x=i, y=-j),\n                Vector2D(x=-i, y=-j),\n            ):\n                center_point = start_point + center_offset\n                relative_start_point = start_point - center_point\n                relative_end_point = end_point - center_point\n\n                if not math.isclose(\n                    relative_start_point.length().value,\n                    relative_end_point.length().value,\n                    rel_tol=1e-6,\n                ):\n                    continue\n\n                # Calculate angle between vector pointing from center of arc to\n                # start, and vector pointing from center of arc to end point. If\n                # this angle is above 90 degrees, we exceeded allowed angle size in\n                # single quadrant mode and need to try other possible center points.\n                clockwise_angle = relative_start_point.angle_between_cc(\n                    relative_end_point,\n                )\n                if clockwise_angle &gt; MAX_SINGLE_QUADRANT_ANGLE:\n                    continue\n\n                final_center_point = center_point\n                break\n            else:\n                raise NoValidArcCenterFoundError(token)\n\n        else:\n            center_offset = Vector2D(x=i, y=j)\n            final_center_point = start_point + center_offset\n\n        aperture_id = context.get_current_aperture_id() or throw(\n            ApertureNotSelected2Error(token),\n        )\n        aperture = context.get_aperture(aperture_id)\n\n        context.add_command(\n            CCArc2(\n                attributes=context.object_attributes,\n                aperture=aperture,\n                start_point=start_point,\n                end_point=end_point,\n                center_point=final_center_point,\n                transform=context.get_state().get_aperture_transform(),\n            ),\n        )\n\n        context.set_current_position(end_point)\n\n    DRAW_MODE_DISPATCH_TABLE = MappingProxyType(\n        {\n            DrawMode.Linear: on_parser_visit_token_line,\n            DrawMode.ClockwiseCircular: on_parser_visit_token_arc,\n            DrawMode.CounterclockwiseCircular: on_parser_visit_token_cc_arc,\n        },\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.CommandDrawTokenHooks.on_parser_visit_token","title":"on_parser_visit_token","text":"<pre><code>on_parser_visit_token(\n    token: D01Draw, context: Parser2Context\n) -&gt; None\n</code></pre> <p>Called when parser visits a token.</p> <p>This hook should perform all changes on context implicated by token type.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>D01Draw</code> <p>The token that is being visited.</p> required <code>context</code> <code>Parser2Context</code> <p>The context object containing information about the parser state.</p> required Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>def on_parser_visit_token(\n    self,\n    token: D01Draw,\n    context: Parser2Context,\n) -&gt; None:\n    \"\"\"Called when parser visits a token.\n\n    This hook should perform all changes on context implicated by token type.\n\n    Parameters\n    ----------\n    token: TokenT\n        The token that is being visited.\n    context : Parser2Context\n        The context object containing information about the parser state.\n    \"\"\"\n    self.DRAW_MODE_DISPATCH_TABLE[context.get_draw_mode()](self, token, context)\n    return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.CommandDrawTokenHooks.on_parser_visit_token_line","title":"on_parser_visit_token_line","text":"<pre><code>on_parser_visit_token_line(\n    token: D01Draw, context: Parser2Context\n) -&gt; None\n</code></pre> <p>Called when parser visits a token.</p> <p>This hook should perform all changes on context implicated by token type.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>D01Draw</code> <p>The token that is being visited.</p> required <code>context</code> <code>Parser2Context</code> <p>The context object containing information about the parser state.</p> required Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>def on_parser_visit_token_line(\n    self,\n    token: D01Draw,\n    context: Parser2Context,\n) -&gt; None:\n    \"\"\"Called when parser visits a token.\n\n    This hook should perform all changes on context implicated by token type.\n\n    Parameters\n    ----------\n    token: TokenT\n        The token that is being visited.\n    context : Parser2Context\n        The context object containing information about the parser state.\n    \"\"\"\n    state = context.get_state()\n\n    x = state.parse_coordinate(token.x)\n    y = state.parse_coordinate(token.y)\n\n    start_point = context.get_current_position()\n    end_point = Vector2D(x=x, y=y)\n\n    aperture_id = context.get_current_aperture_id() or throw(\n        ApertureNotSelected2Error(token),\n    )\n    aperture = context.get_aperture(aperture_id)\n\n    context.add_command(\n        Line2(\n            attributes=context.object_attributes,\n            aperture=aperture,\n            start_point=start_point,\n            end_point=end_point,\n            transform=context.get_state().get_aperture_transform(),\n        ),\n    )\n    context.set_current_position(end_point)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.CommandDrawTokenHooks.on_parser_visit_token_arc","title":"on_parser_visit_token_arc","text":"<pre><code>on_parser_visit_token_arc(\n    token: D01Draw, context: Parser2Context\n) -&gt; None\n</code></pre> <p>Called when parser visits a token.</p> <p>This hook should perform all changes on context implicated by token type.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>D01Draw</code> <p>The token that is being visited.</p> required <code>context</code> <code>Parser2Context</code> <p>The context object containing information about the parser state.</p> required Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>def on_parser_visit_token_arc(\n    self,\n    token: D01Draw,\n    context: Parser2Context,\n) -&gt; None:\n    \"\"\"Called when parser visits a token.\n\n    This hook should perform all changes on context implicated by token type.\n\n    Parameters\n    ----------\n    token: TokenT\n        The token that is being visited.\n    context : Parser2Context\n        The context object containing information about the parser state.\n    \"\"\"\n    state = context.get_state()\n\n    x = state.parse_coordinate(token.x)\n    y = state.parse_coordinate(token.y)\n    i = state.parse_coordinate(token.i)\n    j = state.parse_coordinate(token.j)\n\n    start_point = context.get_current_position()\n    end_point = Vector2D(x=x, y=y)\n    final_center_point = Vector2D.NULL\n\n    if context.get_is_multi_quadrant() is False:\n        # In single quadrant mode I and J offsets are unsigned, therefore we\n        # need to check all 4 possible center points. We will choose first\n        # valid, if anyone needs behavior strictly matching this from spec,\n        # they can always create issue.\n        for center_offset in (\n            Vector2D(x=i, y=j),\n            Vector2D(x=-i, y=j),\n            Vector2D(x=i, y=-j),\n            Vector2D(x=-i, y=-j),\n        ):\n            center_point = start_point + center_offset\n            relative_start_point = start_point - center_point\n            relative_end_point = end_point - center_point\n            # Calculate radius of arc from center to start point and end point,\n            # If they aren't equal, this center candidate is not valid and we\n            # can skip it.\n            if not math.isclose(\n                relative_start_point.length().value,\n                relative_end_point.length().value,\n                rel_tol=1e-3,\n            ):\n                continue\n\n            # Calculate angle between vector pointing from center of arc to\n            # start, and vector pointing from center of arc to end point. If\n            # this angle is above 90 degrees, we exceeded allowed angle size in\n            # single quadrant mode and need to try other possible center points.\n            clockwise_angle = relative_start_point.angle_between(\n                relative_end_point,\n            )\n            if clockwise_angle &gt; MAX_SINGLE_QUADRANT_ANGLE:\n                continue\n\n            final_center_point = center_point\n            break\n        else:\n            raise NoValidArcCenterFoundError(token)\n\n    else:\n        # In multi quadrant mode I and J offsets are signed, so we can simply\n        # use them to calculate center point relative to start point.\n        center_offset = Vector2D(x=i, y=j)\n        final_center_point = start_point + center_offset\n\n    aperture_id = context.get_current_aperture_id() or throw(\n        ApertureNotSelected2Error(token),\n    )\n    aperture = context.get_aperture(aperture_id)\n\n    context.add_command(\n        Arc2(\n            attributes=context.object_attributes,\n            aperture=aperture,\n            start_point=start_point,\n            end_point=end_point,\n            center_point=final_center_point,\n            transform=context.get_state().get_aperture_transform(),\n        ),\n    )\n    context.set_current_position(end_point)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.CommandDrawTokenHooks.on_parser_visit_token_cc_arc","title":"on_parser_visit_token_cc_arc","text":"<pre><code>on_parser_visit_token_cc_arc(\n    token: D01Draw, context: Parser2Context\n) -&gt; None\n</code></pre> <p>Called when parser visits a token.</p> <p>This hook should perform all changes on context implicated by token type.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>D01Draw</code> <p>The token that is being visited.</p> required <code>context</code> <code>Parser2Context</code> <p>The context object containing information about the parser state.</p> required Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>def on_parser_visit_token_cc_arc(\n    self,\n    token: D01Draw,\n    context: Parser2Context,\n) -&gt; None:\n    \"\"\"Called when parser visits a token.\n\n    This hook should perform all changes on context implicated by token type.\n\n    Parameters\n    ----------\n    token: TokenT\n        The token that is being visited.\n    context : Parser2Context\n        The context object containing information about the parser state.\n    \"\"\"\n    state = context.get_state()\n\n    x = state.parse_coordinate(token.x)\n    y = state.parse_coordinate(token.y)\n    i = state.parse_coordinate(token.i)\n    j = state.parse_coordinate(token.j)\n\n    start_point = context.get_current_position()\n    end_point = Vector2D(x=x, y=y)\n    final_center_point = Vector2D.NULL\n\n    if context.get_is_multi_quadrant() is False:\n        for center_offset in (\n            Vector2D(x=i, y=j),\n            Vector2D(x=-i, y=j),\n            Vector2D(x=i, y=-j),\n            Vector2D(x=-i, y=-j),\n        ):\n            center_point = start_point + center_offset\n            relative_start_point = start_point - center_point\n            relative_end_point = end_point - center_point\n\n            if not math.isclose(\n                relative_start_point.length().value,\n                relative_end_point.length().value,\n                rel_tol=1e-6,\n            ):\n                continue\n\n            # Calculate angle between vector pointing from center of arc to\n            # start, and vector pointing from center of arc to end point. If\n            # this angle is above 90 degrees, we exceeded allowed angle size in\n            # single quadrant mode and need to try other possible center points.\n            clockwise_angle = relative_start_point.angle_between_cc(\n                relative_end_point,\n            )\n            if clockwise_angle &gt; MAX_SINGLE_QUADRANT_ANGLE:\n                continue\n\n            final_center_point = center_point\n            break\n        else:\n            raise NoValidArcCenterFoundError(token)\n\n    else:\n        center_offset = Vector2D(x=i, y=j)\n        final_center_point = start_point + center_offset\n\n    aperture_id = context.get_current_aperture_id() or throw(\n        ApertureNotSelected2Error(token),\n    )\n    aperture = context.get_aperture(aperture_id)\n\n    context.add_command(\n        CCArc2(\n            attributes=context.object_attributes,\n            aperture=aperture,\n            start_point=start_point,\n            end_point=end_point,\n            center_point=final_center_point,\n            transform=context.get_state().get_aperture_transform(),\n        ),\n    )\n\n    context.set_current_position(end_point)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.CommandMoveTokenHooks","title":"CommandMoveTokenHooks","text":"<p>             Bases: <code>CommandMoveTokenHooks</code></p> <p>Hooks for visiting move token (D02).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>class CommandMoveTokenHooks(Parser2HooksBase.CommandMoveTokenHooks):\n    \"\"\"Hooks for visiting move token (D02).\"\"\"\n\n    def on_parser_visit_token(\n        self,\n        token: D02Move,\n        context: Parser2Context,\n    ) -&gt; None:\n        \"\"\"Called when parser visits a token.\n\n        This hook should perform all changes on context implicated by token type.\n\n        Parameters\n        ----------\n        token: TokenT\n            The token that is being visited.\n        context : Parser2Context\n            The context object containing information about the parser state.\n        \"\"\"\n        state = context.get_state()\n\n        x = state.parse_coordinate(token.x)\n        y = state.parse_coordinate(token.y)\n\n        destination_point = Vector2D(x=x, y=y)\n\n        context.set_current_position(destination_point)\n        return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.CommandMoveTokenHooks.on_parser_visit_token","title":"on_parser_visit_token","text":"<pre><code>on_parser_visit_token(\n    token: D02Move, context: Parser2Context\n) -&gt; None\n</code></pre> <p>Called when parser visits a token.</p> <p>This hook should perform all changes on context implicated by token type.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>D02Move</code> <p>The token that is being visited.</p> required <code>context</code> <code>Parser2Context</code> <p>The context object containing information about the parser state.</p> required Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>def on_parser_visit_token(\n    self,\n    token: D02Move,\n    context: Parser2Context,\n) -&gt; None:\n    \"\"\"Called when parser visits a token.\n\n    This hook should perform all changes on context implicated by token type.\n\n    Parameters\n    ----------\n    token: TokenT\n        The token that is being visited.\n    context : Parser2Context\n        The context object containing information about the parser state.\n    \"\"\"\n    state = context.get_state()\n\n    x = state.parse_coordinate(token.x)\n    y = state.parse_coordinate(token.y)\n\n    destination_point = Vector2D(x=x, y=y)\n\n    context.set_current_position(destination_point)\n    return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.CommandFlashTokenHooks","title":"CommandFlashTokenHooks","text":"<p>             Bases: <code>CommandFlashTokenHooks</code></p> <p>Hooks for visiting flash token (D03).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>class CommandFlashTokenHooks(Parser2HooksBase.CommandFlashTokenHooks):\n    \"\"\"Hooks for visiting flash token (D03).\"\"\"\n\n    def on_parser_visit_token(\n        self,\n        token: D03Flash,\n        context: Parser2Context,\n    ) -&gt; None:\n        \"\"\"Called when parser visits a token.\n\n        This hook should perform all changes on context implicated by token type.\n\n        Parameters\n        ----------\n        token: TokenT\n            The token that is being visited.\n        context : Parser2Context\n            The context object containing information about the parser state.\n        \"\"\"\n        state = context.get_state()\n\n        x = state.parse_coordinate(token.x)\n        y = state.parse_coordinate(token.y)\n\n        flash_point = Vector2D(x=x, y=y)\n\n        aperture_id = context.get_current_aperture_id() or throw(\n            ApertureNotSelected2Error(token),\n        )\n        aperture = context.get_aperture(aperture_id)\n\n        if isinstance(aperture, Block2):\n            context.add_command(\n                BufferCommand2(\n                    transform=context.get_state().get_aperture_transform(),\n                    command_buffer=aperture.command_buffer.get_transposed(\n                        flash_point,\n                    ),\n                ),\n            )\n\n        else:\n            context.add_command(\n                Flash2(\n                    attributes=context.object_attributes,\n                    aperture=aperture,\n                    flash_point=flash_point,\n                    transform=context.get_state().get_aperture_transform(),\n                ),\n            )\n\n        context.set_current_position(flash_point)\n        return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.CommandFlashTokenHooks.on_parser_visit_token","title":"on_parser_visit_token","text":"<pre><code>on_parser_visit_token(\n    token: D03Flash, context: Parser2Context\n) -&gt; None\n</code></pre> <p>Called when parser visits a token.</p> <p>This hook should perform all changes on context implicated by token type.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>D03Flash</code> <p>The token that is being visited.</p> required <code>context</code> <code>Parser2Context</code> <p>The context object containing information about the parser state.</p> required Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>def on_parser_visit_token(\n    self,\n    token: D03Flash,\n    context: Parser2Context,\n) -&gt; None:\n    \"\"\"Called when parser visits a token.\n\n    This hook should perform all changes on context implicated by token type.\n\n    Parameters\n    ----------\n    token: TokenT\n        The token that is being visited.\n    context : Parser2Context\n        The context object containing information about the parser state.\n    \"\"\"\n    state = context.get_state()\n\n    x = state.parse_coordinate(token.x)\n    y = state.parse_coordinate(token.y)\n\n    flash_point = Vector2D(x=x, y=y)\n\n    aperture_id = context.get_current_aperture_id() or throw(\n        ApertureNotSelected2Error(token),\n    )\n    aperture = context.get_aperture(aperture_id)\n\n    if isinstance(aperture, Block2):\n        context.add_command(\n            BufferCommand2(\n                transform=context.get_state().get_aperture_transform(),\n                command_buffer=aperture.command_buffer.get_transposed(\n                    flash_point,\n                ),\n            ),\n        )\n\n    else:\n        context.add_command(\n            Flash2(\n                attributes=context.object_attributes,\n                aperture=aperture,\n                flash_point=flash_point,\n                transform=context.get_state().get_aperture_transform(),\n            ),\n        )\n\n    context.set_current_position(flash_point)\n    return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.SelectApertureTokenHooks","title":"SelectApertureTokenHooks","text":"<p>             Bases: <code>SelectApertureTokenHooks</code></p> <p>Hooks for visiting select aperture token (DNN).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>class SelectApertureTokenHooks(Parser2HooksBase.SelectApertureTokenHooks):\n    \"\"\"Hooks for visiting select aperture token (DNN).\"\"\"\n\n    def on_parser_visit_token(\n        self,\n        token: DNNSelectAperture,\n        context: Parser2Context,\n    ) -&gt; None:\n        \"\"\"Called when parser visits a token.\n\n        This hook should perform all changes on context implicated by token type.\n\n        Parameters\n        ----------\n        token: TokenT\n            The token that is being visited.\n        context : Parser2Context\n            The context object containing information about the parser state.\n        \"\"\"\n        context.get_aperture(\n            token.aperture_id,\n        )  # Make sure aperture exists.\n        context.set_current_aperture_id(token.aperture_id)\n        return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.SelectApertureTokenHooks.on_parser_visit_token","title":"on_parser_visit_token","text":"<pre><code>on_parser_visit_token(\n    token: DNNSelectAperture, context: Parser2Context\n) -&gt; None\n</code></pre> <p>Called when parser visits a token.</p> <p>This hook should perform all changes on context implicated by token type.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>DNNSelectAperture</code> <p>The token that is being visited.</p> required <code>context</code> <code>Parser2Context</code> <p>The context object containing information about the parser state.</p> required Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>def on_parser_visit_token(\n    self,\n    token: DNNSelectAperture,\n    context: Parser2Context,\n) -&gt; None:\n    \"\"\"Called when parser visits a token.\n\n    This hook should perform all changes on context implicated by token type.\n\n    Parameters\n    ----------\n    token: TokenT\n        The token that is being visited.\n    context : Parser2Context\n        The context object containing information about the parser state.\n    \"\"\"\n    context.get_aperture(\n        token.aperture_id,\n    )  # Make sure aperture exists.\n    context.set_current_aperture_id(token.aperture_id)\n    return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.CoordinateFormatTokenHooks","title":"CoordinateFormatTokenHooks","text":"<p>             Bases: <code>CoordinateFormatTokenHooks</code></p> <p>Hooks for visiting coordinate format token (FS).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>class CoordinateFormatTokenHooks(Parser2HooksBase.CoordinateFormatTokenHooks):\n    \"\"\"Hooks for visiting coordinate format token (FS).\"\"\"\n\n    def on_parser_visit_token(\n        self,\n        token: CoordinateFormat,\n        context: Parser2Context,\n    ) -&gt; None:\n        \"\"\"Called when parser visits a token.\n\n        This hook should perform all changes on context implicated by token type.\n\n        Parameters\n        ----------\n        token: TokenT\n            The token that is being visited.\n        context : Parser2Context\n            The context object containing information about the parser state.\n        \"\"\"\n        context.set_coordinate_parser(\n            CoordinateParser.new(\n                x_format=token.x_format,\n                y_format=token.y_format,\n                coordinate_mode=token.coordinate_mode,\n                zeros_mode=token.zeros_mode,\n            ),\n        )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.CoordinateFormatTokenHooks.on_parser_visit_token","title":"on_parser_visit_token","text":"<pre><code>on_parser_visit_token(\n    token: CoordinateFormat, context: Parser2Context\n) -&gt; None\n</code></pre> <p>Called when parser visits a token.</p> <p>This hook should perform all changes on context implicated by token type.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>CoordinateFormat</code> <p>The token that is being visited.</p> required <code>context</code> <code>Parser2Context</code> <p>The context object containing information about the parser state.</p> required Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>def on_parser_visit_token(\n    self,\n    token: CoordinateFormat,\n    context: Parser2Context,\n) -&gt; None:\n    \"\"\"Called when parser visits a token.\n\n    This hook should perform all changes on context implicated by token type.\n\n    Parameters\n    ----------\n    token: TokenT\n        The token that is being visited.\n    context : Parser2Context\n        The context object containing information about the parser state.\n    \"\"\"\n    context.set_coordinate_parser(\n        CoordinateParser.new(\n            x_format=token.x_format,\n            y_format=token.y_format,\n            coordinate_mode=token.coordinate_mode,\n            zeros_mode=token.zeros_mode,\n        ),\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.SetLinearTokenHooks","title":"SetLinearTokenHooks","text":"<p>             Bases: <code>SetLinearTokenHooks</code></p> <p>Hooks for visiting set linear token (G01).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>class SetLinearTokenHooks(Parser2HooksBase.SetLinearTokenHooks):\n    \"\"\"Hooks for visiting set linear token (G01).\"\"\"\n\n    def on_parser_visit_token(\n        self,\n        token: SetLinear,\n        context: Parser2Context,\n    ) -&gt; None:\n        \"\"\"Called when parser visits a token.\n\n        This hook should perform all changes on context implicated by token type.\n\n        Parameters\n        ----------\n        token: TokenT\n            The token that is being visited.\n        context : Parser2Context\n            The context object containing information about the parser state.\n        \"\"\"\n        context.set_draw_mode(DrawMode.Linear)\n        return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.SetLinearTokenHooks.on_parser_visit_token","title":"on_parser_visit_token","text":"<pre><code>on_parser_visit_token(\n    token: SetLinear, context: Parser2Context\n) -&gt; None\n</code></pre> <p>Called when parser visits a token.</p> <p>This hook should perform all changes on context implicated by token type.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>SetLinear</code> <p>The token that is being visited.</p> required <code>context</code> <code>Parser2Context</code> <p>The context object containing information about the parser state.</p> required Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>def on_parser_visit_token(\n    self,\n    token: SetLinear,\n    context: Parser2Context,\n) -&gt; None:\n    \"\"\"Called when parser visits a token.\n\n    This hook should perform all changes on context implicated by token type.\n\n    Parameters\n    ----------\n    token: TokenT\n        The token that is being visited.\n    context : Parser2Context\n        The context object containing information about the parser state.\n    \"\"\"\n    context.set_draw_mode(DrawMode.Linear)\n    return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.SetClockwiseCircularTokenHooks","title":"SetClockwiseCircularTokenHooks","text":"<p>             Bases: <code>SetClockwiseCircularTokenHooks</code></p> <p>Hooks for visiting set clockwise circular token (G02).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>class SetClockwiseCircularTokenHooks(\n    Parser2HooksBase.SetClockwiseCircularTokenHooks,\n):\n    \"\"\"Hooks for visiting set clockwise circular token (G02).\"\"\"\n\n    def on_parser_visit_token(\n        self,\n        token: SetClockwiseCircular,\n        context: Parser2Context,\n    ) -&gt; None:\n        \"\"\"Called when parser visits a token.\n\n        This hook should perform all changes on context implicated by token type.\n\n        Parameters\n        ----------\n        token: TokenT\n            The token that is being visited.\n        context : Parser2Context\n            The context object containing information about the parser state.\n        \"\"\"\n        context.set_draw_mode(DrawMode.ClockwiseCircular)\n        return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.SetClockwiseCircularTokenHooks.on_parser_visit_token","title":"on_parser_visit_token","text":"<pre><code>on_parser_visit_token(\n    token: SetClockwiseCircular, context: Parser2Context\n) -&gt; None\n</code></pre> <p>Called when parser visits a token.</p> <p>This hook should perform all changes on context implicated by token type.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>SetClockwiseCircular</code> <p>The token that is being visited.</p> required <code>context</code> <code>Parser2Context</code> <p>The context object containing information about the parser state.</p> required Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>def on_parser_visit_token(\n    self,\n    token: SetClockwiseCircular,\n    context: Parser2Context,\n) -&gt; None:\n    \"\"\"Called when parser visits a token.\n\n    This hook should perform all changes on context implicated by token type.\n\n    Parameters\n    ----------\n    token: TokenT\n        The token that is being visited.\n    context : Parser2Context\n        The context object containing information about the parser state.\n    \"\"\"\n    context.set_draw_mode(DrawMode.ClockwiseCircular)\n    return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.SetCounterClockwiseCircularTokenHooks","title":"SetCounterClockwiseCircularTokenHooks","text":"<p>             Bases: <code>SetCounterClockwiseCircularTokenHooks</code></p> <p>Hooks for visiting set counter clockwise circular token (G03).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>class SetCounterClockwiseCircularTokenHooks(\n    Parser2HooksBase.SetCounterClockwiseCircularTokenHooks,\n):\n    \"\"\"Hooks for visiting set counter clockwise circular token (G03).\"\"\"\n\n    def on_parser_visit_token(\n        self,\n        token: SetCounterclockwiseCircular,\n        context: Parser2Context,\n    ) -&gt; None:\n        \"\"\"Called when parser visits a token.\n\n        This hook should perform all changes on context implicated by token type.\n\n        Parameters\n        ----------\n        token: TokenT\n            The token that is being visited.\n        context : Parser2Context\n            The context object containing information about the parser state.\n        \"\"\"\n        context.set_draw_mode(DrawMode.CounterclockwiseCircular)\n        return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.SetCounterClockwiseCircularTokenHooks.on_parser_visit_token","title":"on_parser_visit_token","text":"<pre><code>on_parser_visit_token(\n    token: SetCounterclockwiseCircular,\n    context: Parser2Context,\n) -&gt; None\n</code></pre> <p>Called when parser visits a token.</p> <p>This hook should perform all changes on context implicated by token type.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>SetCounterclockwiseCircular</code> <p>The token that is being visited.</p> required <code>context</code> <code>Parser2Context</code> <p>The context object containing information about the parser state.</p> required Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>def on_parser_visit_token(\n    self,\n    token: SetCounterclockwiseCircular,\n    context: Parser2Context,\n) -&gt; None:\n    \"\"\"Called when parser visits a token.\n\n    This hook should perform all changes on context implicated by token type.\n\n    Parameters\n    ----------\n    token: TokenT\n        The token that is being visited.\n    context : Parser2Context\n        The context object containing information about the parser state.\n    \"\"\"\n    context.set_draw_mode(DrawMode.CounterclockwiseCircular)\n    return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.CommentTokenHooks","title":"CommentTokenHooks","text":"<p>             Bases: <code>CommentTokenHooks</code></p> <p>Hooks for visiting comment token (G04).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>class CommentTokenHooks(Parser2HooksBase.CommentTokenHooks):\n    \"\"\"Hooks for visiting comment token (G04).\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.BeginRegionTokenHooks","title":"BeginRegionTokenHooks","text":"<p>             Bases: <code>BeginRegionTokenHooks</code></p> <p>Hooks for visiting begin region token (G36).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>class BeginRegionTokenHooks(Parser2HooksBase.BeginRegionTokenHooks):\n    \"\"\"Hooks for visiting begin region token (G36).\"\"\"\n\n    def on_parser_visit_token(\n        self,\n        token: BeginRegion,\n        context: Parser2Context,\n    ) -&gt; None:\n        \"\"\"Called when parser visits a token.\n\n        This hook should perform all changes on context implicated by token type.\n\n        Parameters\n        ----------\n        token: TokenT\n            The token that is being visited.\n        context : Parser2Context\n            The context object containing information about the parser state.\n        \"\"\"\n        context.set_is_region(is_region=True)\n        context.set_region_command_buffer()\n\n        return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.BeginRegionTokenHooks.on_parser_visit_token","title":"on_parser_visit_token","text":"<pre><code>on_parser_visit_token(\n    token: BeginRegion, context: Parser2Context\n) -&gt; None\n</code></pre> <p>Called when parser visits a token.</p> <p>This hook should perform all changes on context implicated by token type.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>BeginRegion</code> <p>The token that is being visited.</p> required <code>context</code> <code>Parser2Context</code> <p>The context object containing information about the parser state.</p> required Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>def on_parser_visit_token(\n    self,\n    token: BeginRegion,\n    context: Parser2Context,\n) -&gt; None:\n    \"\"\"Called when parser visits a token.\n\n    This hook should perform all changes on context implicated by token type.\n\n    Parameters\n    ----------\n    token: TokenT\n        The token that is being visited.\n    context : Parser2Context\n        The context object containing information about the parser state.\n    \"\"\"\n    context.set_is_region(is_region=True)\n    context.set_region_command_buffer()\n\n    return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.EndRegionTokenHooks","title":"EndRegionTokenHooks","text":"<p>             Bases: <code>EndRegionTokenHooks</code></p> <p>Hooks for visiting end region token (G37).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>class EndRegionTokenHooks(Parser2HooksBase.EndRegionTokenHooks):\n    \"\"\"Hooks for visiting end region token (G37).\"\"\"\n\n    def on_parser_visit_token(\n        self,\n        token: EndRegion,\n        context: Parser2Context,\n    ) -&gt; None:\n        \"\"\"Called when parser visits a token.\n\n        This hook should perform all changes on context implicated by token type.\n\n        Parameters\n        ----------\n        token: TokenT\n            The token that is being visited.\n        context : Parser2Context\n            The context object containing information about the parser state.\n        \"\"\"\n        context.set_is_region(is_region=False)\n        command_buffer = context.get_region_command_buffer()\n\n        context.add_command(\n            Region2(\n                aperture_attributes=context.aperture_attributes,\n                object_attributes=context.object_attributes,\n                command_buffer=command_buffer.get_readonly(),\n                transform=context.get_state().get_aperture_transform(),\n            ),\n        )\n\n        context.unset_region_command_buffer()\n        return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.EndRegionTokenHooks.on_parser_visit_token","title":"on_parser_visit_token","text":"<pre><code>on_parser_visit_token(\n    token: EndRegion, context: Parser2Context\n) -&gt; None\n</code></pre> <p>Called when parser visits a token.</p> <p>This hook should perform all changes on context implicated by token type.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>EndRegion</code> <p>The token that is being visited.</p> required <code>context</code> <code>Parser2Context</code> <p>The context object containing information about the parser state.</p> required Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>def on_parser_visit_token(\n    self,\n    token: EndRegion,\n    context: Parser2Context,\n) -&gt; None:\n    \"\"\"Called when parser visits a token.\n\n    This hook should perform all changes on context implicated by token type.\n\n    Parameters\n    ----------\n    token: TokenT\n        The token that is being visited.\n    context : Parser2Context\n        The context object containing information about the parser state.\n    \"\"\"\n    context.set_is_region(is_region=False)\n    command_buffer = context.get_region_command_buffer()\n\n    context.add_command(\n        Region2(\n            aperture_attributes=context.aperture_attributes,\n            object_attributes=context.object_attributes,\n            command_buffer=command_buffer.get_readonly(),\n            transform=context.get_state().get_aperture_transform(),\n        ),\n    )\n\n    context.unset_region_command_buffer()\n    return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.PrepareSelectApertureTokenHooks","title":"PrepareSelectApertureTokenHooks","text":"<p>             Bases: <code>PrepareSelectApertureTokenHooks</code></p> <p>Hooks for visiting prepare select aperture token (G54).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>class PrepareSelectApertureTokenHooks(\n    Parser2HooksBase.PrepareSelectApertureTokenHooks,\n):\n    \"\"\"Hooks for visiting prepare select aperture token (G54).\"\"\"\n\n    def on_parser_visit_token(\n        self,\n        token: G54SelectAperture,\n        context: Parser2Context,\n    ) -&gt; None:\n        \"\"\"Called when parser visits a token.\n\n        This hook should perform all changes on context implicated by token type.\n\n        Parameters\n        ----------\n        token: TokenT\n            The token that is being visited.\n        context : Parser2Context\n            The context object containing information about the parser state.\n        \"\"\"\n        self.hooks.select_aperture.on_parser_visit_token(token, context)\n        return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.PrepareSelectApertureTokenHooks.on_parser_visit_token","title":"on_parser_visit_token","text":"<pre><code>on_parser_visit_token(\n    token: G54SelectAperture, context: Parser2Context\n) -&gt; None\n</code></pre> <p>Called when parser visits a token.</p> <p>This hook should perform all changes on context implicated by token type.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>G54SelectAperture</code> <p>The token that is being visited.</p> required <code>context</code> <code>Parser2Context</code> <p>The context object containing information about the parser state.</p> required Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>def on_parser_visit_token(\n    self,\n    token: G54SelectAperture,\n    context: Parser2Context,\n) -&gt; None:\n    \"\"\"Called when parser visits a token.\n\n    This hook should perform all changes on context implicated by token type.\n\n    Parameters\n    ----------\n    token: TokenT\n        The token that is being visited.\n    context : Parser2Context\n        The context object containing information about the parser state.\n    \"\"\"\n    self.hooks.select_aperture.on_parser_visit_token(token, context)\n    return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.SetUnitInchTokenHooks","title":"SetUnitInchTokenHooks","text":"<p>             Bases: <code>SetUnitInchTokenHooks</code></p> <p>Hooks for visiting set unit inch token (G70).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>class SetUnitInchTokenHooks(Parser2HooksBase.SetUnitInchTokenHooks):\n    \"\"\"Hooks for visiting set unit inch token (G70).\"\"\"\n\n    def on_parser_visit_token(\n        self,\n        token: SetUnitInch,\n        context: Parser2Context,\n    ) -&gt; None:\n        \"\"\"Called when parser visits a token.\n\n        This hook should perform all changes on context implicated by token type.\n\n        Parameters\n        ----------\n        token: TokenT\n            The token that is being visited.\n        context : Parser2Context\n            The context object containing information about the parser state.\n        \"\"\"\n        context.set_draw_units(Unit.Inches)\n        return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.SetUnitInchTokenHooks.on_parser_visit_token","title":"on_parser_visit_token","text":"<pre><code>on_parser_visit_token(\n    token: SetUnitInch, context: Parser2Context\n) -&gt; None\n</code></pre> <p>Called when parser visits a token.</p> <p>This hook should perform all changes on context implicated by token type.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>SetUnitInch</code> <p>The token that is being visited.</p> required <code>context</code> <code>Parser2Context</code> <p>The context object containing information about the parser state.</p> required Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>def on_parser_visit_token(\n    self,\n    token: SetUnitInch,\n    context: Parser2Context,\n) -&gt; None:\n    \"\"\"Called when parser visits a token.\n\n    This hook should perform all changes on context implicated by token type.\n\n    Parameters\n    ----------\n    token: TokenT\n        The token that is being visited.\n    context : Parser2Context\n        The context object containing information about the parser state.\n    \"\"\"\n    context.set_draw_units(Unit.Inches)\n    return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.SetUnitMillimetersTokenHooks","title":"SetUnitMillimetersTokenHooks","text":"<p>             Bases: <code>SetUnitMillimetersTokenHooks</code></p> <p>Hooks for visiting set unit millimeters token (G71).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>class SetUnitMillimetersTokenHooks(Parser2HooksBase.SetUnitMillimetersTokenHooks):\n    \"\"\"Hooks for visiting set unit millimeters token (G71).\"\"\"\n\n    def on_parser_visit_token(\n        self,\n        token: SetUnitMillimeters,\n        context: Parser2Context,\n    ) -&gt; None:\n        \"\"\"Called when parser visits a token.\n\n        This hook should perform all changes on context implicated by token type.\n\n        Parameters\n        ----------\n        token: TokenT\n            The token that is being visited.\n        context : Parser2Context\n            The context object containing information about the parser state.\n        \"\"\"\n        context.set_draw_units(Unit.Millimeters)\n        return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.SetUnitMillimetersTokenHooks.on_parser_visit_token","title":"on_parser_visit_token","text":"<pre><code>on_parser_visit_token(\n    token: SetUnitMillimeters, context: Parser2Context\n) -&gt; None\n</code></pre> <p>Called when parser visits a token.</p> <p>This hook should perform all changes on context implicated by token type.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>SetUnitMillimeters</code> <p>The token that is being visited.</p> required <code>context</code> <code>Parser2Context</code> <p>The context object containing information about the parser state.</p> required Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>def on_parser_visit_token(\n    self,\n    token: SetUnitMillimeters,\n    context: Parser2Context,\n) -&gt; None:\n    \"\"\"Called when parser visits a token.\n\n    This hook should perform all changes on context implicated by token type.\n\n    Parameters\n    ----------\n    token: TokenT\n        The token that is being visited.\n    context : Parser2Context\n        The context object containing information about the parser state.\n    \"\"\"\n    context.set_draw_units(Unit.Millimeters)\n    return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.SetSingleQuadrantModeTokenHooks","title":"SetSingleQuadrantModeTokenHooks","text":"<p>             Bases: <code>SetSingleQuadrantModeTokenHooks</code></p> <p>Hooks for visiting set single-quadrant mode token (G74).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>class SetSingleQuadrantModeTokenHooks(\n    Parser2HooksBase.SetSingleQuadrantModeTokenHooks,\n):\n    \"\"\"Hooks for visiting set single-quadrant mode token (G74).\"\"\"\n\n    def on_parser_visit_token(\n        self,\n        token: SetSingleQuadrantMode,\n        context: Parser2Context,\n    ) -&gt; None:\n        \"\"\"Called when parser visits a token.\n\n        This hook should perform all changes on context implicated by token type.\n\n        Parameters\n        ----------\n        token: TokenT\n            The token that is being visited.\n        context : Parser2Context\n            The context object containing information about the parser state.\n        \"\"\"\n        context.set_is_multi_quadrant(is_multi_quadrant=False)\n        return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.SetSingleQuadrantModeTokenHooks.on_parser_visit_token","title":"on_parser_visit_token","text":"<pre><code>on_parser_visit_token(\n    token: SetSingleQuadrantMode, context: Parser2Context\n) -&gt; None\n</code></pre> <p>Called when parser visits a token.</p> <p>This hook should perform all changes on context implicated by token type.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>SetSingleQuadrantMode</code> <p>The token that is being visited.</p> required <code>context</code> <code>Parser2Context</code> <p>The context object containing information about the parser state.</p> required Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>def on_parser_visit_token(\n    self,\n    token: SetSingleQuadrantMode,\n    context: Parser2Context,\n) -&gt; None:\n    \"\"\"Called when parser visits a token.\n\n    This hook should perform all changes on context implicated by token type.\n\n    Parameters\n    ----------\n    token: TokenT\n        The token that is being visited.\n    context : Parser2Context\n        The context object containing information about the parser state.\n    \"\"\"\n    context.set_is_multi_quadrant(is_multi_quadrant=False)\n    return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.SetMultiQuadrantModeTokenHooks","title":"SetMultiQuadrantModeTokenHooks","text":"<p>             Bases: <code>SetMultiQuadrantModeTokenHooks</code></p> <p>Hooks for visiting set multi-quadrant mode token (G75).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>class SetMultiQuadrantModeTokenHooks(\n    Parser2HooksBase.SetMultiQuadrantModeTokenHooks,\n):\n    \"\"\"Hooks for visiting set multi-quadrant mode token (G75).\"\"\"\n\n    def on_parser_visit_token(\n        self,\n        token: SetMultiQuadrantMode,\n        context: Parser2Context,\n    ) -&gt; None:\n        \"\"\"Called when parser visits a token.\n\n        This hook should perform all changes on context implicated by token type.\n\n        Parameters\n        ----------\n        token: TokenT\n            The token that is being visited.\n        context : Parser2Context\n            The context object containing information about the parser state.\n        \"\"\"\n        context.set_is_multi_quadrant(is_multi_quadrant=True)\n        return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.SetMultiQuadrantModeTokenHooks.on_parser_visit_token","title":"on_parser_visit_token","text":"<pre><code>on_parser_visit_token(\n    token: SetMultiQuadrantMode, context: Parser2Context\n) -&gt; None\n</code></pre> <p>Called when parser visits a token.</p> <p>This hook should perform all changes on context implicated by token type.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>SetMultiQuadrantMode</code> <p>The token that is being visited.</p> required <code>context</code> <code>Parser2Context</code> <p>The context object containing information about the parser state.</p> required Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>def on_parser_visit_token(\n    self,\n    token: SetMultiQuadrantMode,\n    context: Parser2Context,\n) -&gt; None:\n    \"\"\"Called when parser visits a token.\n\n    This hook should perform all changes on context implicated by token type.\n\n    Parameters\n    ----------\n    token: TokenT\n        The token that is being visited.\n    context : Parser2Context\n        The context object containing information about the parser state.\n    \"\"\"\n    context.set_is_multi_quadrant(is_multi_quadrant=True)\n    return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.SetCoordinateAbsoluteTokenHooks","title":"SetCoordinateAbsoluteTokenHooks","text":"<p>             Bases: <code>SetCoordinateAbsoluteTokenHooks</code></p> <p>Hooks for visiting set coordinate absolute token (G90).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>class SetCoordinateAbsoluteTokenHooks(\n    Parser2HooksBase.SetCoordinateAbsoluteTokenHooks,\n):\n    \"\"\"Hooks for visiting set coordinate absolute token (G90).\"\"\"\n\n    def on_parser_visit_token(\n        self,\n        token: SetAbsoluteNotation,\n        context: Parser2Context,\n    ) -&gt; None:\n        \"\"\"Called when parser visits a token.\n\n        This hook should perform all changes on context implicated by token type.\n\n        Parameters\n        ----------\n        token: TokenT\n            The token that is being visited.\n        context : Parser2Context\n            The context object containing information about the parser state.\n        \"\"\"\n        # NOOP - only absolute format supported.\n        return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.SetCoordinateAbsoluteTokenHooks.on_parser_visit_token","title":"on_parser_visit_token","text":"<pre><code>on_parser_visit_token(\n    token: SetAbsoluteNotation, context: Parser2Context\n) -&gt; None\n</code></pre> <p>Called when parser visits a token.</p> <p>This hook should perform all changes on context implicated by token type.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>SetAbsoluteNotation</code> <p>The token that is being visited.</p> required <code>context</code> <code>Parser2Context</code> <p>The context object containing information about the parser state.</p> required Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>def on_parser_visit_token(\n    self,\n    token: SetAbsoluteNotation,\n    context: Parser2Context,\n) -&gt; None:\n    \"\"\"Called when parser visits a token.\n\n    This hook should perform all changes on context implicated by token type.\n\n    Parameters\n    ----------\n    token: TokenT\n        The token that is being visited.\n    context : Parser2Context\n        The context object containing information about the parser state.\n    \"\"\"\n    # NOOP - only absolute format supported.\n    return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.SetCoordinateIncrementalTokenHooks","title":"SetCoordinateIncrementalTokenHooks","text":"<p>             Bases: <code>SetCoordinateIncrementalTokenHooks</code></p> <p>Hooks for visiting set coordinate incremental token (G91).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>class SetCoordinateIncrementalTokenHooks(\n    Parser2HooksBase.SetCoordinateIncrementalTokenHooks,\n):\n    \"\"\"Hooks for visiting set coordinate incremental token (G91).\"\"\"\n\n    def on_parser_visit_token(\n        self,\n        token: SetIncrementalNotation,  # noqa: ARG002\n        context: Parser2Context,  # noqa: ARG002\n    ) -&gt; None:\n        \"\"\"Called when parser visits a token.\n\n        This hook should perform all changes on context implicated by token type.\n\n        Parameters\n        ----------\n        token: TokenT\n            The token that is being visited.\n        context : Parser2Context\n            The context object containing information about the parser state.\n        \"\"\"\n        raise IncrementalCoordinatesNotSupported2Error\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.SetCoordinateIncrementalTokenHooks.on_parser_visit_token","title":"on_parser_visit_token","text":"<pre><code>on_parser_visit_token(\n    token: SetIncrementalNotation, context: Parser2Context\n) -&gt; None\n</code></pre> <p>Called when parser visits a token.</p> <p>This hook should perform all changes on context implicated by token type.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>SetIncrementalNotation</code> <p>The token that is being visited.</p> required <code>context</code> <code>Parser2Context</code> <p>The context object containing information about the parser state.</p> required Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>def on_parser_visit_token(\n    self,\n    token: SetIncrementalNotation,  # noqa: ARG002\n    context: Parser2Context,  # noqa: ARG002\n) -&gt; None:\n    \"\"\"Called when parser visits a token.\n\n    This hook should perform all changes on context implicated by token type.\n\n    Parameters\n    ----------\n    token: TokenT\n        The token that is being visited.\n    context : Parser2Context\n        The context object containing information about the parser state.\n    \"\"\"\n    raise IncrementalCoordinatesNotSupported2Error\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.ImageNameTokenHooks","title":"ImageNameTokenHooks","text":"<p>             Bases: <code>ImageNameTokenHooks</code></p> <p>Hooks for visiting image name token (IN).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>class ImageNameTokenHooks(Parser2HooksBase.ImageNameTokenHooks):\n    \"\"\"Hooks for visiting image name token (IN).\"\"\"\n\n    def on_parser_visit_token(\n        self,\n        token: ImageName,\n        context: Parser2Context,\n    ) -&gt; None:\n        \"\"\"Called when parser visits a token.\n\n        This hook should perform all changes on context implicated by token type.\n\n        Parameters\n        ----------\n        token: TokenT\n            The token that is being visited.\n        context : Parser2Context\n            The context object containing information about the parser state.\n        \"\"\"\n        context.set_image_name(token.content)\n        return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.ImageNameTokenHooks.on_parser_visit_token","title":"on_parser_visit_token","text":"<pre><code>on_parser_visit_token(\n    token: ImageName, context: Parser2Context\n) -&gt; None\n</code></pre> <p>Called when parser visits a token.</p> <p>This hook should perform all changes on context implicated by token type.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>ImageName</code> <p>The token that is being visited.</p> required <code>context</code> <code>Parser2Context</code> <p>The context object containing information about the parser state.</p> required Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>def on_parser_visit_token(\n    self,\n    token: ImageName,\n    context: Parser2Context,\n) -&gt; None:\n    \"\"\"Called when parser visits a token.\n\n    This hook should perform all changes on context implicated by token type.\n\n    Parameters\n    ----------\n    token: TokenT\n        The token that is being visited.\n    context : Parser2Context\n        The context object containing information about the parser state.\n    \"\"\"\n    context.set_image_name(token.content)\n    return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.InvalidTokenHooks","title":"InvalidTokenHooks","text":"<p>             Bases: <code>InvalidTokenHooks</code></p> <p>Hooks for visiting invalid token.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>class InvalidTokenHooks(Parser2HooksBase.InvalidTokenHooks):\n    \"\"\"Hooks for visiting invalid token.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.ImagePolarityTokenHooks","title":"ImagePolarityTokenHooks","text":"<p>             Bases: <code>ImagePolarityTokenHooks</code></p> <p>Hooks for visiting image polarity token (IP).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>class ImagePolarityTokenHooks(Parser2HooksBase.ImagePolarityTokenHooks):\n    \"\"\"Hooks for visiting image polarity token (IP).\"\"\"\n\n    def on_parser_visit_token(\n        self,\n        token: ImagePolarity,\n        context: Parser2Context,\n    ) -&gt; None:\n        \"\"\"Called when parser visits a token.\n\n        This hook should perform all changes on context implicated by token type.\n\n        Parameters\n        ----------\n        token: TokenT\n            The token that is being visited.\n        context : Parser2Context\n            The context object containing information about the parser state.\n        \"\"\"\n        context.set_is_output_image_negation_required(\n            value=(token.image_polarity == ImagePolarityEnum.NEGATIVE),\n        )\n        return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.ImagePolarityTokenHooks.on_parser_visit_token","title":"on_parser_visit_token","text":"<pre><code>on_parser_visit_token(\n    token: ImagePolarity, context: Parser2Context\n) -&gt; None\n</code></pre> <p>Called when parser visits a token.</p> <p>This hook should perform all changes on context implicated by token type.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>ImagePolarity</code> <p>The token that is being visited.</p> required <code>context</code> <code>Parser2Context</code> <p>The context object containing information about the parser state.</p> required Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>def on_parser_visit_token(\n    self,\n    token: ImagePolarity,\n    context: Parser2Context,\n) -&gt; None:\n    \"\"\"Called when parser visits a token.\n\n    This hook should perform all changes on context implicated by token type.\n\n    Parameters\n    ----------\n    token: TokenT\n        The token that is being visited.\n    context : Parser2Context\n        The context object containing information about the parser state.\n    \"\"\"\n    context.set_is_output_image_negation_required(\n        value=(token.image_polarity == ImagePolarityEnum.NEGATIVE),\n    )\n    return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.LoadMirroringTokenHooks","title":"LoadMirroringTokenHooks","text":"<p>             Bases: <code>LoadMirroringTokenHooks</code></p> <p>Hooks for visiting load mirroring token (LM).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>class LoadMirroringTokenHooks(Parser2HooksBase.LoadMirroringTokenHooks):\n    \"\"\"Hooks for visiting load mirroring token (LM).\"\"\"\n\n    def on_parser_visit_token(\n        self,\n        token: LoadMirroring,\n        context: Parser2Context,\n    ) -&gt; None:\n        \"\"\"Called when parser visits a token.\n\n        This hook should perform all changes on context implicated by token type.\n\n        Parameters\n        ----------\n        token: TokenT\n            The token that is being visited.\n        context : Parser2Context\n            The context object containing information about the parser state.\n        \"\"\"\n        context.set_mirroring(token.mirroring)\n        return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.LoadMirroringTokenHooks.on_parser_visit_token","title":"on_parser_visit_token","text":"<pre><code>on_parser_visit_token(\n    token: LoadMirroring, context: Parser2Context\n) -&gt; None\n</code></pre> <p>Called when parser visits a token.</p> <p>This hook should perform all changes on context implicated by token type.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>LoadMirroring</code> <p>The token that is being visited.</p> required <code>context</code> <code>Parser2Context</code> <p>The context object containing information about the parser state.</p> required Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>def on_parser_visit_token(\n    self,\n    token: LoadMirroring,\n    context: Parser2Context,\n) -&gt; None:\n    \"\"\"Called when parser visits a token.\n\n    This hook should perform all changes on context implicated by token type.\n\n    Parameters\n    ----------\n    token: TokenT\n        The token that is being visited.\n    context : Parser2Context\n        The context object containing information about the parser state.\n    \"\"\"\n    context.set_mirroring(token.mirroring)\n    return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.LoadNameTokenHooks","title":"LoadNameTokenHooks","text":"<p>             Bases: <code>LoadNameTokenHooks</code></p> <p>Hooks for visiting load name token (LN).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>class LoadNameTokenHooks(Parser2HooksBase.LoadNameTokenHooks):\n    \"\"\"Hooks for visiting load name token (LN).\"\"\"\n\n    def on_parser_visit_token(\n        self,\n        token: LoadName,\n        context: Parser2Context,\n    ) -&gt; None:\n        \"\"\"Called when parser visits a token.\n\n        This hook should perform all changes on context implicated by token type.\n\n        Parameters\n        ----------\n        token: TokenT\n            The token that is being visited.\n        context : Parser2Context\n            The context object containing information about the parser state.\n        \"\"\"\n        context.set_file_name(token.content)\n        return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.LoadNameTokenHooks.on_parser_visit_token","title":"on_parser_visit_token","text":"<pre><code>on_parser_visit_token(\n    token: LoadName, context: Parser2Context\n) -&gt; None\n</code></pre> <p>Called when parser visits a token.</p> <p>This hook should perform all changes on context implicated by token type.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>LoadName</code> <p>The token that is being visited.</p> required <code>context</code> <code>Parser2Context</code> <p>The context object containing information about the parser state.</p> required Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>def on_parser_visit_token(\n    self,\n    token: LoadName,\n    context: Parser2Context,\n) -&gt; None:\n    \"\"\"Called when parser visits a token.\n\n    This hook should perform all changes on context implicated by token type.\n\n    Parameters\n    ----------\n    token: TokenT\n        The token that is being visited.\n    context : Parser2Context\n        The context object containing information about the parser state.\n    \"\"\"\n    context.set_file_name(token.content)\n    return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.LoadPolarityTokenHooks","title":"LoadPolarityTokenHooks","text":"<p>             Bases: <code>LoadPolarityTokenHooks</code></p> <p>Hooks for visiting load polarity token (LP).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>class LoadPolarityTokenHooks(Parser2HooksBase.LoadPolarityTokenHooks):\n    \"\"\"Hooks for visiting load polarity token (LP).\"\"\"\n\n    def on_parser_visit_token(\n        self,\n        token: LoadPolarity,\n        context: Parser2Context,\n    ) -&gt; None:\n        \"\"\"Called when parser visits a token.\n\n        This hook should perform all changes on context implicated by token type.\n\n        Parameters\n        ----------\n        token: TokenT\n            The token that is being visited.\n        context : Parser2Context\n            The context object containing information about the parser state.\n        \"\"\"\n        context.set_polarity(token.polarity)\n        return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.LoadPolarityTokenHooks.on_parser_visit_token","title":"on_parser_visit_token","text":"<pre><code>on_parser_visit_token(\n    token: LoadPolarity, context: Parser2Context\n) -&gt; None\n</code></pre> <p>Called when parser visits a token.</p> <p>This hook should perform all changes on context implicated by token type.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>LoadPolarity</code> <p>The token that is being visited.</p> required <code>context</code> <code>Parser2Context</code> <p>The context object containing information about the parser state.</p> required Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>def on_parser_visit_token(\n    self,\n    token: LoadPolarity,\n    context: Parser2Context,\n) -&gt; None:\n    \"\"\"Called when parser visits a token.\n\n    This hook should perform all changes on context implicated by token type.\n\n    Parameters\n    ----------\n    token: TokenT\n        The token that is being visited.\n    context : Parser2Context\n        The context object containing information about the parser state.\n    \"\"\"\n    context.set_polarity(token.polarity)\n    return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.LoadRotationTokenHooks","title":"LoadRotationTokenHooks","text":"<p>             Bases: <code>LoadRotationTokenHooks</code></p> <p>Hooks for visiting load rotation token (LR).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>class LoadRotationTokenHooks(Parser2HooksBase.LoadRotationTokenHooks):\n    \"\"\"Hooks for visiting load rotation token (LR).\"\"\"\n\n    def on_parser_visit_token(\n        self,\n        token: LoadRotation,\n        context: Parser2Context,\n    ) -&gt; None:\n        \"\"\"Called when parser visits a token.\n\n        This hook should perform all changes on context implicated by token type.\n\n        Parameters\n        ----------\n        token: TokenT\n            The token that is being visited.\n        context : Parser2Context\n            The context object containing information about the parser state.\n        \"\"\"\n        context.set_rotation(token.rotation)\n        return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.LoadRotationTokenHooks.on_parser_visit_token","title":"on_parser_visit_token","text":"<pre><code>on_parser_visit_token(\n    token: LoadRotation, context: Parser2Context\n) -&gt; None\n</code></pre> <p>Called when parser visits a token.</p> <p>This hook should perform all changes on context implicated by token type.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>LoadRotation</code> <p>The token that is being visited.</p> required <code>context</code> <code>Parser2Context</code> <p>The context object containing information about the parser state.</p> required Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>def on_parser_visit_token(\n    self,\n    token: LoadRotation,\n    context: Parser2Context,\n) -&gt; None:\n    \"\"\"Called when parser visits a token.\n\n    This hook should perform all changes on context implicated by token type.\n\n    Parameters\n    ----------\n    token: TokenT\n        The token that is being visited.\n    context : Parser2Context\n        The context object containing information about the parser state.\n    \"\"\"\n    context.set_rotation(token.rotation)\n    return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.LoadScalingTokenHooks","title":"LoadScalingTokenHooks","text":"<p>             Bases: <code>LoadScalingTokenHooks</code></p> <p>Hooks for visiting load scaling token (LS).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>class LoadScalingTokenHooks(Parser2HooksBase.LoadScalingTokenHooks):\n    \"\"\"Hooks for visiting load scaling token (LS).\"\"\"\n\n    def on_parser_visit_token(\n        self,\n        token: LoadScaling,\n        context: Parser2Context,\n    ) -&gt; None:\n        \"\"\"Called when parser visits a token.\n\n        This hook should perform all changes on context implicated by token type.\n\n        Parameters\n        ----------\n        token: TokenT\n            The token that is being visited.\n        context : Parser2Context\n            The context object containing information about the parser state.\n        \"\"\"\n        context.set_scaling(token.scaling)\n        return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.LoadScalingTokenHooks.on_parser_visit_token","title":"on_parser_visit_token","text":"<pre><code>on_parser_visit_token(\n    token: LoadScaling, context: Parser2Context\n) -&gt; None\n</code></pre> <p>Called when parser visits a token.</p> <p>This hook should perform all changes on context implicated by token type.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>LoadScaling</code> <p>The token that is being visited.</p> required <code>context</code> <code>Parser2Context</code> <p>The context object containing information about the parser state.</p> required Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>def on_parser_visit_token(\n    self,\n    token: LoadScaling,\n    context: Parser2Context,\n) -&gt; None:\n    \"\"\"Called when parser visits a token.\n\n    This hook should perform all changes on context implicated by token type.\n\n    Parameters\n    ----------\n    token: TokenT\n        The token that is being visited.\n    context : Parser2Context\n        The context object containing information about the parser state.\n    \"\"\"\n    context.set_scaling(token.scaling)\n    return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.ProgramStopTokenHooks","title":"ProgramStopTokenHooks","text":"<p>             Bases: <code>ProgramStopTokenHooks</code></p> <p>Hooks for visiting program stop token (M00).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>class ProgramStopTokenHooks(Parser2HooksBase.ProgramStopTokenHooks):\n    \"\"\"Hooks for visiting program stop token (M00).\"\"\"\n\n    def on_parser_visit_token(\n        self,\n        token: M00ProgramStop,  # noqa: ARG002\n        context: Parser2Context,\n    ) -&gt; None:\n        \"\"\"Called when parser visits a token.\n\n        This hook should perform all changes on context implicated by token type.\n\n        Parameters\n        ----------\n        token: TokenT\n            The token that is being visited.\n        context : Parser2Context\n            The context object containing information about the parser state.\n        \"\"\"\n        context.set_reached_program_stop()\n        context.halt_parser()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.ProgramStopTokenHooks.on_parser_visit_token","title":"on_parser_visit_token","text":"<pre><code>on_parser_visit_token(\n    token: M00ProgramStop, context: Parser2Context\n) -&gt; None\n</code></pre> <p>Called when parser visits a token.</p> <p>This hook should perform all changes on context implicated by token type.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>M00ProgramStop</code> <p>The token that is being visited.</p> required <code>context</code> <code>Parser2Context</code> <p>The context object containing information about the parser state.</p> required Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>def on_parser_visit_token(\n    self,\n    token: M00ProgramStop,  # noqa: ARG002\n    context: Parser2Context,\n) -&gt; None:\n    \"\"\"Called when parser visits a token.\n\n    This hook should perform all changes on context implicated by token type.\n\n    Parameters\n    ----------\n    token: TokenT\n        The token that is being visited.\n    context : Parser2Context\n        The context object containing information about the parser state.\n    \"\"\"\n    context.set_reached_program_stop()\n    context.halt_parser()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.OptionalStopTokenHooks","title":"OptionalStopTokenHooks","text":"<p>             Bases: <code>OptionalStopTokenHooks</code></p> <p>Hooks for visiting optional stop token (M01).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>class OptionalStopTokenHooks(Parser2HooksBase.OptionalStopTokenHooks):\n    \"\"\"Hooks for visiting optional stop token (M01).\"\"\"\n\n    def on_parser_visit_token(\n        self,\n        token: M01OptionalStop,  # noqa: ARG002\n        context: Parser2Context,\n    ) -&gt; None:\n        \"\"\"Handle child parsing being completed.\"\"\"\n        context.set_reached_optional_stop()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.OptionalStopTokenHooks.on_parser_visit_token","title":"on_parser_visit_token","text":"<pre><code>on_parser_visit_token(\n    token: M01OptionalStop, context: Parser2Context\n) -&gt; None\n</code></pre> <p>Handle child parsing being completed.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>def on_parser_visit_token(\n    self,\n    token: M01OptionalStop,  # noqa: ARG002\n    context: Parser2Context,\n) -&gt; None:\n    \"\"\"Handle child parsing being completed.\"\"\"\n    context.set_reached_optional_stop()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.EndOfFileTokenHooks","title":"EndOfFileTokenHooks","text":"<p>             Bases: <code>EndOfFileTokenHooks</code></p> <p>Hooks for visiting end of file token (M02).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>class EndOfFileTokenHooks(Parser2HooksBase.EndOfFileTokenHooks):\n    \"\"\"Hooks for visiting end of file token (M02).\"\"\"\n\n    def on_parser_visit_token(\n        self,\n        token: M02EndOfFile,  # noqa: ARG002\n        context: Parser2Context,\n    ) -&gt; None:\n        \"\"\"Called when parser visits a token.\n\n        This hook should perform all changes on context implicated by token type.\n\n        Parameters\n        ----------\n        token: TokenT\n            The token that is being visited.\n        context : Parser2Context\n            The context object containing information about the parser state.\n        \"\"\"\n        context.set_reached_end_of_file()\n        context.halt_parser()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.EndOfFileTokenHooks.on_parser_visit_token","title":"on_parser_visit_token","text":"<pre><code>on_parser_visit_token(\n    token: M02EndOfFile, context: Parser2Context\n) -&gt; None\n</code></pre> <p>Called when parser visits a token.</p> <p>This hook should perform all changes on context implicated by token type.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>M02EndOfFile</code> <p>The token that is being visited.</p> required <code>context</code> <code>Parser2Context</code> <p>The context object containing information about the parser state.</p> required Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>def on_parser_visit_token(\n    self,\n    token: M02EndOfFile,  # noqa: ARG002\n    context: Parser2Context,\n) -&gt; None:\n    \"\"\"Called when parser visits a token.\n\n    This hook should perform all changes on context implicated by token type.\n\n    Parameters\n    ----------\n    token: TokenT\n        The token that is being visited.\n    context : Parser2Context\n        The context object containing information about the parser state.\n    \"\"\"\n    context.set_reached_end_of_file()\n    context.halt_parser()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.UnitModeTokenHooks","title":"UnitModeTokenHooks","text":"<p>             Bases: <code>UnitModeTokenHooks</code></p> <p>Hooks for visiting unit mode token (MO).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>class UnitModeTokenHooks(Parser2HooksBase.UnitModeTokenHooks):\n    \"\"\"Hooks for visiting unit mode token (MO).\"\"\"\n\n    def on_parser_visit_token(\n        self,\n        token: UnitMode,\n        context: Parser2Context,\n    ) -&gt; None:\n        \"\"\"Called when parser visits a token.\n\n        This hook should perform all changes on context implicated by token type.\n\n        Parameters\n        ----------\n        token: TokenT\n            The token that is being visited.\n        context : Parser2Context\n            The context object containing information about the parser state.\n        \"\"\"\n        context.set_draw_units(token.unit)\n        return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.UnitModeTokenHooks.on_parser_visit_token","title":"on_parser_visit_token","text":"<pre><code>on_parser_visit_token(\n    token: UnitMode, context: Parser2Context\n) -&gt; None\n</code></pre> <p>Called when parser visits a token.</p> <p>This hook should perform all changes on context implicated by token type.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>UnitMode</code> <p>The token that is being visited.</p> required <code>context</code> <code>Parser2Context</code> <p>The context object containing information about the parser state.</p> required Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>def on_parser_visit_token(\n    self,\n    token: UnitMode,\n    context: Parser2Context,\n) -&gt; None:\n    \"\"\"Called when parser visits a token.\n\n    This hook should perform all changes on context implicated by token type.\n\n    Parameters\n    ----------\n    token: TokenT\n        The token that is being visited.\n    context : Parser2Context\n        The context object containing information about the parser state.\n    \"\"\"\n    context.set_draw_units(token.unit)\n    return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.ImageOffsetTokenHooks","title":"ImageOffsetTokenHooks","text":"<p>             Bases: <code>ImageOffsetTokenHooks</code></p> <p>Hooks for visiting image offset token (OF).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>class ImageOffsetTokenHooks(Parser2HooksBase.ImageOffsetTokenHooks):\n    \"\"\"Hooks for visiting image offset token (OF).\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.StepRepeatBeginTokenHooks","title":"StepRepeatBeginTokenHooks","text":"<p>             Bases: <code>StepRepeatBeginTokenHooks</code></p> <p>Hooks for visiting step and repeat begin token (SR).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>class StepRepeatBeginTokenHooks(Parser2HooksBase.StepRepeatBeginTokenHooks):\n    \"\"\"Hooks for visiting step and repeat begin token (SR).\"\"\"\n\n    def on_parser_visit_token(\n        self,\n        token: StepRepeatBegin,\n        context: Parser2Context,\n    ) -&gt; None:\n        \"\"\"Called when parser visits a token.\n\n        This hook should perform all changes on context implicated by token type.\n\n        Parameters\n        ----------\n        token: TokenT\n            The token that is being visited.\n        context : Parser2Context\n            The context object containing information about the parser state.\n        \"\"\"\n        context.set_state_before_step_and_repeat()\n\n        context.set_is_step_and_repeat(is_step_and_repeat=True)\n        context.set_x_repeat(token.x_repeat)\n        context.set_y_repeat(token.y_repeat)\n        context.set_x_step(Offset.new(token.x_step, unit=context.get_draw_units()))\n        context.set_y_step(Offset.new(token.y_step, unit=context.get_draw_units()))\n        context.set_step_and_repeat_command_buffer()\n\n        return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.StepRepeatBeginTokenHooks.on_parser_visit_token","title":"on_parser_visit_token","text":"<pre><code>on_parser_visit_token(\n    token: StepRepeatBegin, context: Parser2Context\n) -&gt; None\n</code></pre> <p>Called when parser visits a token.</p> <p>This hook should perform all changes on context implicated by token type.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>StepRepeatBegin</code> <p>The token that is being visited.</p> required <code>context</code> <code>Parser2Context</code> <p>The context object containing information about the parser state.</p> required Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>def on_parser_visit_token(\n    self,\n    token: StepRepeatBegin,\n    context: Parser2Context,\n) -&gt; None:\n    \"\"\"Called when parser visits a token.\n\n    This hook should perform all changes on context implicated by token type.\n\n    Parameters\n    ----------\n    token: TokenT\n        The token that is being visited.\n    context : Parser2Context\n        The context object containing information about the parser state.\n    \"\"\"\n    context.set_state_before_step_and_repeat()\n\n    context.set_is_step_and_repeat(is_step_and_repeat=True)\n    context.set_x_repeat(token.x_repeat)\n    context.set_y_repeat(token.y_repeat)\n    context.set_x_step(Offset.new(token.x_step, unit=context.get_draw_units()))\n    context.set_y_step(Offset.new(token.y_step, unit=context.get_draw_units()))\n    context.set_step_and_repeat_command_buffer()\n\n    return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.StepRepeatEndTokenHooks","title":"StepRepeatEndTokenHooks","text":"<p>             Bases: <code>StepRepeatEndTokenHooks</code></p> <p>Hooks for visiting step and repeat end token (SR).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>class StepRepeatEndTokenHooks(Parser2HooksBase.StepRepeatEndTokenHooks):\n    \"\"\"Hooks for visiting step and repeat end token (SR).\"\"\"\n\n    def on_parser_visit_token(\n        self,\n        token: StepRepeatEnd,\n        context: Parser2Context,\n    ) -&gt; None:\n        \"\"\"Called when parser visits a token.\n\n        This hook should perform all changes on context implicated by token type.\n\n        Parameters\n        ----------\n        token: TokenT\n            The token that is being visited.\n        context : Parser2Context\n            The context object containing information about the parser state.\n        \"\"\"\n        if context.get_is_step_and_repeat() is False:\n            raise StepAndRepeatNotInitializedError(token)\n\n        command_buffer = context.get_step_and_repeat_command_buffer().get_readonly()\n        commands: list[Command2] = []\n\n        for x_index in range(context.get_x_repeat()):\n            for y_index in range(context.get_y_repeat()):\n                buffer_command = BufferCommand2(\n                    transform=context.get_state().get_aperture_transform(),\n                    command_buffer=command_buffer,\n                ).get_transposed(\n                    Vector2D(\n                        x=(context.get_x_step() * x_index),\n                        y=(context.get_y_step() * y_index),\n                    ),\n                )\n                commands.append(buffer_command)\n\n        # Resets all variables, including is_step_and_repeat and possibly other\n        # set during recording of SR command block. Must be done before\n        # add_command() to push SR command buffers to main command buffers.\n        context.reset_state_to_pre_step_and_repeat()\n        context.unset_state_before_step_and_repeat()\n        context.unset_step_and_repeat_command_buffer()\n\n        for command in commands:\n            context.add_command(command)\n\n        return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.StepRepeatEndTokenHooks.on_parser_visit_token","title":"on_parser_visit_token","text":"<pre><code>on_parser_visit_token(\n    token: StepRepeatEnd, context: Parser2Context\n) -&gt; None\n</code></pre> <p>Called when parser visits a token.</p> <p>This hook should perform all changes on context implicated by token type.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>StepRepeatEnd</code> <p>The token that is being visited.</p> required <code>context</code> <code>Parser2Context</code> <p>The context object containing information about the parser state.</p> required Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>def on_parser_visit_token(\n    self,\n    token: StepRepeatEnd,\n    context: Parser2Context,\n) -&gt; None:\n    \"\"\"Called when parser visits a token.\n\n    This hook should perform all changes on context implicated by token type.\n\n    Parameters\n    ----------\n    token: TokenT\n        The token that is being visited.\n    context : Parser2Context\n        The context object containing information about the parser state.\n    \"\"\"\n    if context.get_is_step_and_repeat() is False:\n        raise StepAndRepeatNotInitializedError(token)\n\n    command_buffer = context.get_step_and_repeat_command_buffer().get_readonly()\n    commands: list[Command2] = []\n\n    for x_index in range(context.get_x_repeat()):\n        for y_index in range(context.get_y_repeat()):\n            buffer_command = BufferCommand2(\n                transform=context.get_state().get_aperture_transform(),\n                command_buffer=command_buffer,\n            ).get_transposed(\n                Vector2D(\n                    x=(context.get_x_step() * x_index),\n                    y=(context.get_y_step() * y_index),\n                ),\n            )\n            commands.append(buffer_command)\n\n    # Resets all variables, including is_step_and_repeat and possibly other\n    # set during recording of SR command block. Must be done before\n    # add_command() to push SR command buffers to main command buffers.\n    context.reset_state_to_pre_step_and_repeat()\n    context.unset_state_before_step_and_repeat()\n    context.unset_step_and_repeat_command_buffer()\n\n    for command in commands:\n        context.add_command(command)\n\n    return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.ApertureAttributeHooks","title":"ApertureAttributeHooks","text":"<p>             Bases: <code>ApertureAttributeHooks</code></p> <p>Hooks for visiting aperture attribute token (TA).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>class ApertureAttributeHooks(Parser2HooksBase.ApertureAttributeHooks):\n    \"\"\"Hooks for visiting aperture attribute token (TA).\"\"\"\n\n    def on_parser_visit_token(\n        self,\n        token: ApertureAttribute,\n        context: Parser2Context,\n    ) -&gt; None:\n        \"\"\"Called when parser visits a token.\n\n        This hook should perform all changes on context implicated by token type.\n\n        Parameters\n        ----------\n        token: TokenT\n            The token that is being visited.\n        context : Parser2Context\n            The context object containing information about the parser state.\n        \"\"\"\n        context.set_aperture_attribute(token.name, token.value)\n        return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.ApertureAttributeHooks.on_parser_visit_token","title":"on_parser_visit_token","text":"<pre><code>on_parser_visit_token(\n    token: ApertureAttribute, context: Parser2Context\n) -&gt; None\n</code></pre> <p>Called when parser visits a token.</p> <p>This hook should perform all changes on context implicated by token type.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>ApertureAttribute</code> <p>The token that is being visited.</p> required <code>context</code> <code>Parser2Context</code> <p>The context object containing information about the parser state.</p> required Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>def on_parser_visit_token(\n    self,\n    token: ApertureAttribute,\n    context: Parser2Context,\n) -&gt; None:\n    \"\"\"Called when parser visits a token.\n\n    This hook should perform all changes on context implicated by token type.\n\n    Parameters\n    ----------\n    token: TokenT\n        The token that is being visited.\n    context : Parser2Context\n        The context object containing information about the parser state.\n    \"\"\"\n    context.set_aperture_attribute(token.name, token.value)\n    return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.DeleteAttributeHooks","title":"DeleteAttributeHooks","text":"<p>             Bases: <code>DeleteAttributeHooks</code></p> <p>Hooks for visiting delete attribute token (TD).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>class DeleteAttributeHooks(Parser2HooksBase.DeleteAttributeHooks):\n    \"\"\"Hooks for visiting delete attribute token (TD).\"\"\"\n\n    def on_parser_visit_token(\n        self,\n        token: DeleteAttribute,\n        context: Parser2Context,\n    ) -&gt; None:\n        \"\"\"Called when parser visits a token.\n\n        This hook should perform all changes on context implicated by token type.\n\n        Parameters\n        ----------\n        token: TokenT\n            The token that is being visited.\n        context : Parser2Context\n            The context object containing information about the parser state.\n        \"\"\"\n        if token.name is not None:\n            context.delete_aperture_attribute(token.name)\n            context.delete_object_attribute(token.name)\n        else:\n            context.clear_aperture_attributes()\n            context.clear_object_attributes()\n        return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.DeleteAttributeHooks.on_parser_visit_token","title":"on_parser_visit_token","text":"<pre><code>on_parser_visit_token(\n    token: DeleteAttribute, context: Parser2Context\n) -&gt; None\n</code></pre> <p>Called when parser visits a token.</p> <p>This hook should perform all changes on context implicated by token type.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>DeleteAttribute</code> <p>The token that is being visited.</p> required <code>context</code> <code>Parser2Context</code> <p>The context object containing information about the parser state.</p> required Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>def on_parser_visit_token(\n    self,\n    token: DeleteAttribute,\n    context: Parser2Context,\n) -&gt; None:\n    \"\"\"Called when parser visits a token.\n\n    This hook should perform all changes on context implicated by token type.\n\n    Parameters\n    ----------\n    token: TokenT\n        The token that is being visited.\n    context : Parser2Context\n        The context object containing information about the parser state.\n    \"\"\"\n    if token.name is not None:\n        context.delete_aperture_attribute(token.name)\n        context.delete_object_attribute(token.name)\n    else:\n        context.clear_aperture_attributes()\n        context.clear_object_attributes()\n    return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.FileAttributeHooks","title":"FileAttributeHooks","text":"<p>             Bases: <code>FileAttributeHooks</code></p> <p>Hooks for visiting file attribute token (TF).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>class FileAttributeHooks(Parser2HooksBase.FileAttributeHooks):\n    \"\"\"Hooks for visiting file attribute token (TF).\"\"\"\n\n    def on_parser_visit_token(\n        self,\n        token: FileAttribute,\n        context: Parser2Context,\n    ) -&gt; None:\n        \"\"\"Called when parser visits a token.\n\n        This hook should perform all changes on context implicated by token type.\n\n        Parameters\n        ----------\n        token: TokenT\n            The token that is being visited.\n        context : Parser2Context\n            The context object containing information about the parser state.\n        \"\"\"\n        context.set_file_attribute(token.name, token.value)\n        return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.FileAttributeHooks.on_parser_visit_token","title":"on_parser_visit_token","text":"<pre><code>on_parser_visit_token(\n    token: FileAttribute, context: Parser2Context\n) -&gt; None\n</code></pre> <p>Called when parser visits a token.</p> <p>This hook should perform all changes on context implicated by token type.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>FileAttribute</code> <p>The token that is being visited.</p> required <code>context</code> <code>Parser2Context</code> <p>The context object containing information about the parser state.</p> required Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>def on_parser_visit_token(\n    self,\n    token: FileAttribute,\n    context: Parser2Context,\n) -&gt; None:\n    \"\"\"Called when parser visits a token.\n\n    This hook should perform all changes on context implicated by token type.\n\n    Parameters\n    ----------\n    token: TokenT\n        The token that is being visited.\n    context : Parser2Context\n        The context object containing information about the parser state.\n    \"\"\"\n    context.set_file_attribute(token.name, token.value)\n    return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.ObjectAttributeHooks","title":"ObjectAttributeHooks","text":"<p>             Bases: <code>ObjectAttributeHooks</code></p> <p>Hooks for visiting object attribute token (TO).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>class ObjectAttributeHooks(Parser2HooksBase.ObjectAttributeHooks):\n    \"\"\"Hooks for visiting object attribute token (TO).\"\"\"\n\n    def on_parser_visit_token(\n        self,\n        token: ObjectAttribute,\n        context: Parser2Context,\n    ) -&gt; None:\n        \"\"\"Called when parser visits a token.\n\n        This hook should perform all changes on context implicated by token type.\n\n        Parameters\n        ----------\n        token: TokenT\n            The token that is being visited.\n        context : Parser2Context\n            The context object containing information about the parser state.\n        \"\"\"\n        context.set_object_attribute(token.name, token.value)\n        return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks.html#pygerber.gerberx3.parser2.parser2hooks.Parser2Hooks.ObjectAttributeHooks.on_parser_visit_token","title":"on_parser_visit_token","text":"<pre><code>on_parser_visit_token(\n    token: ObjectAttribute, context: Parser2Context\n) -&gt; None\n</code></pre> <p>Called when parser visits a token.</p> <p>This hook should perform all changes on context implicated by token type.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>ObjectAttribute</code> <p>The token that is being visited.</p> required <code>context</code> <code>Parser2Context</code> <p>The context object containing information about the parser state.</p> required Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks.py</code> <pre><code>def on_parser_visit_token(\n    self,\n    token: ObjectAttribute,\n    context: Parser2Context,\n) -&gt; None:\n    \"\"\"Called when parser visits a token.\n\n    This hook should perform all changes on context implicated by token type.\n\n    Parameters\n    ----------\n    token: TokenT\n        The token that is being visited.\n    context : Parser2Context\n        The context object containing information about the parser state.\n    \"\"\"\n    context.set_object_attribute(token.name, token.value)\n    return super().on_parser_visit_token(token, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks_base.html","title":"parser2hooks_base","text":""},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks_base.html#pygerber.gerberx3.parser2.parser2hooks_base","title":"parser2hooks_base","text":"<p>Parser hooks interface class, for Gerber AST parser, version 2.</p>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks_base.html#pygerber.gerberx3.parser2.parser2hooks_base.TokenHooksBase","title":"TokenHooksBase","text":"<p>             Bases: <code>Generic[TokenT]</code></p> <p>Class for creating token visit hooks.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class TokenHooksBase(Generic[TokenT]):\n    \"\"\"Class for creating token visit hooks.\"\"\"\n\n    def __init__(self, hooks: Parser2HooksBase) -&gt; None:\n        self.hooks = hooks\n\n    def post_hooks_init(self) -&gt; None:\n        \"\"\"Called after all hooks are assigned.\"\"\"\n\n    def pre_parser_visit_token(\n        self,\n        token: TokenT,\n        context: Parser2Context,\n    ) -&gt; None:\n        \"\"\"Called before parser visits a token.\n\n        Parameters\n        ----------\n        token: TokenT\n            The token that will be visited.\n        context : Parser2Context\n            The context object containing information about the parser state.\n        \"\"\"\n\n    def on_parser_visit_token(\n        self,\n        token: TokenT,\n        context: Parser2Context,\n    ) -&gt; None:\n        \"\"\"Called when parser visits a token.\n\n        This hook should perform all changes on context implicated by token type.\n\n        Parameters\n        ----------\n        token: TokenT\n            The token that is being visited.\n        context : Parser2Context\n            The context object containing information about the parser state.\n        \"\"\"\n\n    def post_parser_visit_token(\n        self,\n        token: TokenT,\n        context: Parser2Context,\n    ) -&gt; None:\n        \"\"\"Called after parser visits a token.\n\n        Parameters\n        ----------\n        token: TokenT\n            The token that was visited.\n        context : Parser2Context\n            The context object containing information about the parser state.\n        \"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks_base.html#pygerber.gerberx3.parser2.parser2hooks_base.TokenHooksBase.post_hooks_init","title":"post_hooks_init","text":"<pre><code>post_hooks_init() -&gt; None\n</code></pre> <p>Called after all hooks are assigned.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>def post_hooks_init(self) -&gt; None:\n    \"\"\"Called after all hooks are assigned.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks_base.html#pygerber.gerberx3.parser2.parser2hooks_base.TokenHooksBase.pre_parser_visit_token","title":"pre_parser_visit_token","text":"<pre><code>pre_parser_visit_token(\n    token: TokenT, context: Parser2Context\n) -&gt; None\n</code></pre> <p>Called before parser visits a token.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>TokenT</code> <p>The token that will be visited.</p> required <code>context</code> <code>Parser2Context</code> <p>The context object containing information about the parser state.</p> required Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>def pre_parser_visit_token(\n    self,\n    token: TokenT,\n    context: Parser2Context,\n) -&gt; None:\n    \"\"\"Called before parser visits a token.\n\n    Parameters\n    ----------\n    token: TokenT\n        The token that will be visited.\n    context : Parser2Context\n        The context object containing information about the parser state.\n    \"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks_base.html#pygerber.gerberx3.parser2.parser2hooks_base.TokenHooksBase.on_parser_visit_token","title":"on_parser_visit_token","text":"<pre><code>on_parser_visit_token(\n    token: TokenT, context: Parser2Context\n) -&gt; None\n</code></pre> <p>Called when parser visits a token.</p> <p>This hook should perform all changes on context implicated by token type.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>TokenT</code> <p>The token that is being visited.</p> required <code>context</code> <code>Parser2Context</code> <p>The context object containing information about the parser state.</p> required Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>def on_parser_visit_token(\n    self,\n    token: TokenT,\n    context: Parser2Context,\n) -&gt; None:\n    \"\"\"Called when parser visits a token.\n\n    This hook should perform all changes on context implicated by token type.\n\n    Parameters\n    ----------\n    token: TokenT\n        The token that is being visited.\n    context : Parser2Context\n        The context object containing information about the parser state.\n    \"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks_base.html#pygerber.gerberx3.parser2.parser2hooks_base.TokenHooksBase.post_parser_visit_token","title":"post_parser_visit_token","text":"<pre><code>post_parser_visit_token(\n    token: TokenT, context: Parser2Context\n) -&gt; None\n</code></pre> <p>Called after parser visits a token.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>TokenT</code> <p>The token that was visited.</p> required <code>context</code> <code>Parser2Context</code> <p>The context object containing information about the parser state.</p> required Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>def post_parser_visit_token(\n    self,\n    token: TokenT,\n    context: Parser2Context,\n) -&gt; None:\n    \"\"\"Called after parser visits a token.\n\n    Parameters\n    ----------\n    token: TokenT\n        The token that was visited.\n    context : Parser2Context\n        The context object containing information about the parser state.\n    \"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks_base.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase","title":"Parser2HooksBase","text":"<p>Collection of overridable hooks for Gerber AST parser, version 2.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class Parser2HooksBase:\n    \"\"\"Collection of overridable hooks for Gerber AST parser, version 2.\"\"\"\n\n    def __init__(self) -&gt; None:  # noqa: PLR0915\n        super().__init__()\n        self.macro_begin = self.MacroBeginTokenHooks(self)\n        self.macro_code_1_circle = self.MacroCode1CircleTokenHooks(self)\n        self.macro_code_2_vector_line = self.MacroCode2VectorLineTokenHooks(self)\n        self.macro_code_4_outline = self.MacroCode4OutlineTokenHooks(self)\n        self.macro_code_5_polygon = self.MacroCode5PolygonTokenHooks(self)\n        self.macro_code_6_moire = self.MacroCode6MoireTokenHooks(self)\n        self.macro_code_7_thermal = self.MacroCode7ThermalTokenHooks(self)\n        self.macro_code_20_vector_line = self.MacroCode20VectorLineTokenHooks(self)\n        self.macro_code_21_center_line = self.MacroCode21CenterLineTokenHooks(self)\n        self.macro_code_22_lower_left_line = self.MacroCode22LowerLeftLineTokenHooks(\n            self,\n        )\n        self.macro_variable_assignment = self.MacroVariableAssignment(self)\n        self.macro_definition = self.MacroDefinitionTokenHooks(self)\n        self.macro_eval = self.MacroEvalHooks()\n\n        self.end_block_aperture = self.EndBlockApertureTokenHooks(self)\n        self.begin_block_aperture = self.BeginBlockApertureTokenHooks(self)\n\n        self.define_circle_aperture = self.DefineApertureCircleTokenHooks(self)\n        self.define_rectangle_aperture = self.DefineApertureRectangleTokenHooks(self)\n        self.define_obround_aperture = self.DefineApertureObroundTokenHooks(self)\n        self.define_polygon_aperture = self.DefineAperturePolygonTokenHooks(self)\n        self.define_macro_aperture = self.DefineApertureMacroTokenHooks(self)\n        self.define_aperture = self.DefineApertureTokenHooks(self)\n\n        self.axis_select = self.AxisSelectTokenHooksTokenHooks(self)\n\n        self.command_draw = self.CommandDrawTokenHooks(self)\n        self.command_move = self.CommandMoveTokenHooks(self)\n        self.command_flash = self.CommandFlashTokenHooks(self)\n\n        self.select_aperture = self.SelectApertureTokenHooks(self)\n        self.coordinate_format = self.CoordinateFormatTokenHooks(self)\n\n        self.set_linear = self.SetLinearTokenHooks(self)\n        self.set_clockwise_circular = self.SetClockwiseCircularTokenHooks(self)\n        self.set_counter_clockwise_circular = (\n            self.SetCounterClockwiseCircularTokenHooks(self)\n        )\n\n        self.comment = self.CommentTokenHooks(self)\n        self.begin_region = self.BeginRegionTokenHooks(self)\n        self.end_region = self.EndRegionTokenHooks(self)\n        self.prepare_select_aperture = self.PrepareSelectApertureTokenHooks(self)\n        self.set_unit_inch = self.SetUnitInchTokenHooks(self)\n        self.set_unit_millimeters = self.SetUnitMillimetersTokenHooks(self)\n\n        self.set_single_quadrant_mode = self.SetSingleQuadrantModeTokenHooks(self)\n        self.set_multi_quadrant_mode = self.SetMultiQuadrantModeTokenHooks(self)\n\n        self.set_coordinate_absolute = self.SetCoordinateAbsoluteTokenHooks(self)\n        self.set_coordinate_incremental = self.SetCoordinateIncrementalTokenHooks(self)\n\n        self.image_name = self.ImageNameTokenHooks(self)\n        self.invalid_token = self.InvalidTokenHooks(self)\n        self.image_polarity = self.ImagePolarityTokenHooks(self)\n        self.load_name = self.LoadNameTokenHooks(self)\n\n        self.load_mirroring = self.LoadMirroringTokenHooks(self)\n        self.load_polarity = self.LoadPolarityTokenHooks(self)\n        self.load_rotation = self.LoadRotationTokenHooks(self)\n        self.load_scaling = self.LoadScalingTokenHooks(self)\n\n        self.program_stop = self.ProgramStopTokenHooks(self)\n        self.optional_stop = self.OptionalStopTokenHooks(self)\n        self.end_of_file = self.EndOfFileTokenHooks(self)\n        self.unit_mode = self.UnitModeTokenHooks(self)\n        self.image_offset = self.ImageOffsetTokenHooks(self)\n\n        self.step_repeat_begin = self.StepRepeatBeginTokenHooks(self)\n        self.step_repeat_end = self.StepRepeatEndTokenHooks(self)\n\n        self.aperture_attribute = self.ApertureAttributeHooks(self)\n        self.delete_attribute = self.DeleteAttributeHooks(self)\n        self.file_attribute = self.FileAttributeHooks(self)\n        self.object_attribute = self.ObjectAttributeHooks(self)\n\n        self._call_post_hooks_init()\n\n    def _call_post_hooks_init(self) -&gt; None:  # noqa: PLR0915\n        self.macro_begin.post_hooks_init()\n        self.macro_code_1_circle.post_hooks_init()\n        self.macro_code_2_vector_line.post_hooks_init()\n        self.macro_code_4_outline.post_hooks_init()\n        self.macro_code_5_polygon.post_hooks_init()\n        self.macro_code_6_moire.post_hooks_init()\n        self.macro_code_7_thermal.post_hooks_init()\n        self.macro_code_20_vector_line.post_hooks_init()\n        self.macro_code_21_center_line.post_hooks_init()\n        self.macro_code_22_lower_left_line.post_hooks_init()\n        self.macro_variable_assignment.post_hooks_init()\n        self.macro_definition.post_hooks_init()\n\n        self.end_block_aperture.post_hooks_init()\n        self.begin_block_aperture.post_hooks_init()\n\n        self.define_circle_aperture.post_hooks_init()\n        self.define_rectangle_aperture.post_hooks_init()\n        self.define_obround_aperture.post_hooks_init()\n        self.define_polygon_aperture.post_hooks_init()\n        self.define_macro_aperture.post_hooks_init()\n        self.define_aperture.post_hooks_init()\n\n        self.axis_select.post_hooks_init()\n\n        self.command_draw.post_hooks_init()\n        self.command_move.post_hooks_init()\n        self.command_flash.post_hooks_init()\n\n        self.select_aperture.post_hooks_init()\n        self.coordinate_format.post_hooks_init()\n\n        self.set_linear.post_hooks_init()\n        self.set_clockwise_circular.post_hooks_init()\n        self.set_counter_clockwise_circular.post_hooks_init()\n\n        self.comment.post_hooks_init()\n        self.begin_region.post_hooks_init()\n        self.end_region.post_hooks_init()\n        self.prepare_select_aperture.post_hooks_init()\n\n        self.set_unit_inch.post_hooks_init()\n        self.set_unit_millimeters.post_hooks_init()\n\n        self.set_single_quadrant_mode.post_hooks_init()\n        self.set_multi_quadrant_mode.post_hooks_init()\n\n        self.set_coordinate_absolute.post_hooks_init()\n        self.set_coordinate_incremental.post_hooks_init()\n\n        self.image_name.post_hooks_init()\n        self.invalid_token.post_hooks_init()\n        self.image_polarity.post_hooks_init()\n        self.load_name.post_hooks_init()\n\n        self.load_mirroring.post_hooks_init()\n        self.load_polarity.post_hooks_init()\n        self.load_rotation.post_hooks_init()\n        self.load_scaling.post_hooks_init()\n\n        self.program_stop.post_hooks_init()\n        self.optional_stop.post_hooks_init()\n        self.end_of_file.post_hooks_init()\n        self.unit_mode.post_hooks_init()\n        self.image_offset.post_hooks_init()\n\n        self.step_repeat_begin.post_hooks_init()\n        self.step_repeat_end.post_hooks_init()\n\n        self.aperture_attribute.post_hooks_init()\n        self.delete_attribute.post_hooks_init()\n        self.file_attribute.post_hooks_init()\n        self.object_attribute.post_hooks_init()\n\n    def on_parser_init(self, parser: Parser2) -&gt; None:\n        \"\"\"Called after parser initialization.\"\"\"\n\n    def pre_parse(self, context: Parser2Context) -&gt; None:\n        \"\"\"Called before parsing starts.\"\"\"\n\n    def post_parse(self, context: Parser2Context) -&gt; None:\n        \"\"\"Called after parsing starts.\"\"\"\n\n    def on_parser_error(self, context: Parser2Context, error: Parser2Error) -&gt; None:\n        \"\"\"Called when parsing error is thrown.\"\"\"\n\n    def on_other_error(self, context: Parser2Context, error: Exception) -&gt; None:\n        \"\"\"Called when other error is thrown.\"\"\"\n\n    def pre_parser_visit_any_token(self, context: Parser2Context) -&gt; None:\n        \"\"\"Called before parser visits any token.\"\"\"\n\n    def post_parser_visit_any_token(self, context: Parser2Context) -&gt; None:\n        \"\"\"Called after parser visits any token.\"\"\"\n\n    class MacroBeginTokenHooks(TokenHooksBase[MacroBeginT]):\n        \"\"\"Hooks for visiting macro definition begin token (AM).\"\"\"\n\n    class MacroCode1CircleTokenHooks(TokenHooksBase[Code1CircleTokenT]):\n        \"\"\"Hooks for visiting macro primitive code 0 circle.\"\"\"\n\n    class MacroCode2VectorLineTokenHooks(TokenHooksBase[Code2VectorLineTokenT]):\n        \"\"\"Hooks for visiting macro primitive code 2 vector line.\"\"\"\n\n    class MacroCode4OutlineTokenHooks(TokenHooksBase[Code4OutlineTokenT]):\n        \"\"\"Hooks for visiting macro primitive code 4 outline.\"\"\"\n\n    class MacroCode5PolygonTokenHooks(TokenHooksBase[Code5PolygonTokenT]):\n        \"\"\"Hooks for visiting macro primitive code 5 polygon.\"\"\"\n\n    class MacroCode6MoireTokenHooks(TokenHooksBase[Code6MoireTokenT]):\n        \"\"\"Hooks for visiting macro primitive code 6 moire.\"\"\"\n\n    class MacroCode7ThermalTokenHooks(TokenHooksBase[Code7ThermalTokenT]):\n        \"\"\"Hooks for visiting macro primitive code 7 thermal.\"\"\"\n\n    class MacroCode20VectorLineTokenHooks(TokenHooksBase[Code20VectorLineTokenT]):\n        \"\"\"Hooks for visiting macro primitive code 20 vector line.\"\"\"\n\n    class MacroCode21CenterLineTokenHooks(TokenHooksBase[Code21CenterLineTokenT]):\n        \"\"\"Hooks for visiting macro primitive code 21 center line.\"\"\"\n\n    class MacroCode22LowerLeftLineTokenHooks(TokenHooksBase[Code22LowerLeftLineTokenT]):\n        \"\"\"Hooks for visiting macro primitive code 22 lower left line.\"\"\"\n\n    class MacroVariableAssignment(TokenHooksBase[MacroVariableAssignmentT]):\n        \"\"\"Hooks for visiting macro variable assignment token.\"\"\"\n\n    class MacroDefinitionTokenHooks(TokenHooksBase[MacroDefinitionT]):\n        \"\"\"Hooks for visiting macro definition token (AM).\"\"\"\n\n    class MacroEvalHooks:\n        \"\"\"Hooks called when evaluating macro aperture.\"\"\"\n\n        def on_code_1_circle(\n            self,\n            context: Parser2Context,\n            primitive: Code1Circle2,\n        ) -&gt; None:\n            \"\"\"Evaluate code 1 circle primitive.\"\"\"\n\n        def on_code_2_vector_line(\n            self,\n            context: Parser2Context,\n            primitive: Code2VectorLine2,\n        ) -&gt; None:\n            \"\"\"Evaluate code 2 vector line primitive.\"\"\"\n\n        def on_code_4_outline(\n            self,\n            context: Parser2Context,\n            primitive: Code4Outline2,\n        ) -&gt; None:\n            \"\"\"Evaluate code 4 outline primitive.\"\"\"\n\n        def on_code_5_polygon(\n            self,\n            context: Parser2Context,\n            primitive: Code5Polygon2,\n        ) -&gt; None:\n            \"\"\"Evaluate code 5 polygon primitive.\"\"\"\n\n        def on_code_6_moire(\n            self,\n            context: Parser2Context,\n            primitive: Code6Moire2,\n        ) -&gt; None:\n            \"\"\"Evaluate code 6 moire primitive.\"\"\"\n\n        def on_code_7_thermal(\n            self,\n            context: Parser2Context,\n            primitive: Code7Thermal2,\n        ) -&gt; None:\n            \"\"\"Evaluate code 7 thermal primitive.\"\"\"\n\n        def on_code_20_vector_line(\n            self,\n            context: Parser2Context,\n            primitive: Code20VectorLine2,\n        ) -&gt; None:\n            \"\"\"Evaluate code 20 vector line primitive.\"\"\"\n\n        def on_code_21_center_line(\n            self,\n            context: Parser2Context,\n            primitive: Code21CenterLine2,\n        ) -&gt; None:\n            \"\"\"Evaluate code 21 center line primitive.\"\"\"\n\n        def on_code_22_lower_left_line(\n            self,\n            context: Parser2Context,\n            primitive: Code22LowerLeftLine2,\n        ) -&gt; None:\n            \"\"\"Evaluate code 22 lower left line primitive.\"\"\"\n\n        def on_assignment(\n            self,\n            context: Parser2Context,\n            assignment: Assignment2,\n        ) -&gt; None:\n            \"\"\"Evaluate macro variable assignment statement.\"\"\"\n\n    class BeginBlockApertureTokenHooks(TokenHooksBase[BlockApertureBeginT]):\n        \"\"\"Hooks for visiting begin block aperture token (AB).\"\"\"\n\n    class EndBlockApertureTokenHooks(TokenHooksBase[BlockApertureEndT]):\n        \"\"\"Hooks for visiting end block aperture token (AB).\"\"\"\n\n    class DefineApertureCircleTokenHooks(TokenHooksBase[DefineCircleT]):\n        \"\"\"Hooks for visiting circle aperture definition token (ADD).\"\"\"\n\n    class DefineApertureRectangleTokenHooks(TokenHooksBase[DefineRectangleT]):\n        \"\"\"Hooks for visiting rectangle aperture definition token (ADD).\"\"\"\n\n    class DefineApertureObroundTokenHooks(TokenHooksBase[DefineObroundT]):\n        \"\"\"Hooks for visiting obround aperture definition token (ADD).\"\"\"\n\n    class DefineAperturePolygonTokenHooks(TokenHooksBase[DefinePolygonT]):\n        \"\"\"Hooks for visiting polygon aperture definition token (ADD).\"\"\"\n\n    class DefineApertureMacroTokenHooks(TokenHooksBase[DefineMacroT]):\n        \"\"\"Hooks for visiting macro aperture definition token (ADD).\"\"\"\n\n    class DefineApertureTokenHooks(TokenHooksBase[DefineAnyT]):\n        \"\"\"Hooks for visiting any aperture definition token (ADD).\"\"\"\n\n    class AxisSelectTokenHooksTokenHooks(TokenHooksBase[AxisSelectT]):\n        \"\"\"Hooks for visiting axis select token (AS).\"\"\"\n\n    class CommandDrawTokenHooks(TokenHooksBase[D01DrawT]):\n        \"\"\"Hooks for visiting draw token (D01).\"\"\"\n\n    class CommandMoveTokenHooks(TokenHooksBase[D02MoveT]):\n        \"\"\"Hooks for visiting move token (D02).\"\"\"\n\n    class CommandFlashTokenHooks(TokenHooksBase[D03FlashT]):\n        \"\"\"Hooks for visiting flash token (D03).\"\"\"\n\n    class SelectApertureTokenHooks(TokenHooksBase[DNNSelectApertureT]):\n        \"\"\"Hooks for visiting select aperture token (DNN).\"\"\"\n\n    class CoordinateFormatTokenHooks(TokenHooksBase[CoordinateFormatT]):\n        \"\"\"Hooks for visiting coordinate format token (FS).\"\"\"\n\n    class SetLinearTokenHooks(TokenHooksBase[SetLinearT]):\n        \"\"\"Hooks for visiting set linear token (G01).\"\"\"\n\n    class SetClockwiseCircularTokenHooks(TokenHooksBase[SetClockwiseCircularT]):\n        \"\"\"Hooks for visiting set clockwise circular token (G02).\"\"\"\n\n    class SetCounterClockwiseCircularTokenHooks(\n        TokenHooksBase[SetCounterclockwiseCircularT],\n    ):\n        \"\"\"Hooks for visiting set counter clockwise circular token (G03).\"\"\"\n\n    class CommentTokenHooks(TokenHooksBase[CommentT]):\n        \"\"\"Hooks for visiting comment token (G04).\"\"\"\n\n    class BeginRegionTokenHooks(TokenHooksBase[BeginRegionT]):\n        \"\"\"Hooks for visiting begin region token (G36).\"\"\"\n\n    class EndRegionTokenHooks(TokenHooksBase[EndRegionT]):\n        \"\"\"Hooks for visiting end region token (G37).\"\"\"\n\n    class PrepareSelectApertureTokenHooks(TokenHooksBase[G54SelectApertureT]):\n        \"\"\"Hooks for visiting prepare select aperture token (G54).\"\"\"\n\n    class SetUnitInchTokenHooks(TokenHooksBase[SetUnitInchT]):\n        \"\"\"Hooks for visiting set unit inch token (G70).\"\"\"\n\n    class SetUnitMillimetersTokenHooks(TokenHooksBase[SetUnitMillimetersT]):\n        \"\"\"Hooks for visiting set unit millimeters token (G71).\"\"\"\n\n    class SetSingleQuadrantModeTokenHooks(TokenHooksBase[SetSingleQuadrantModeT]):\n        \"\"\"Hooks for visiting set single-quadrant mode token (G74).\"\"\"\n\n    class SetMultiQuadrantModeTokenHooks(TokenHooksBase[SetMultiQuadrantModeT]):\n        \"\"\"Hooks for visiting set multi-quadrant mode token (G75).\"\"\"\n\n    class SetCoordinateAbsoluteTokenHooks(TokenHooksBase[SetAbsoluteNotationT]):\n        \"\"\"Hooks for visiting set coordinate absolute token (G90).\"\"\"\n\n    class SetCoordinateIncrementalTokenHooks(TokenHooksBase[SetIncrementalNotationT]):\n        \"\"\"Hooks for visiting set coordinate incremental token (G91).\"\"\"\n\n    class ImageNameTokenHooks(TokenHooksBase[ImageNameT]):\n        \"\"\"Hooks for visiting image name token (IN).\"\"\"\n\n    class InvalidTokenHooks(TokenHooksBase[InvalidTokenT]):\n        \"\"\"Hooks for visiting invalid token.\"\"\"\n\n    class ImagePolarityTokenHooks(TokenHooksBase[ImagePolarityT]):\n        \"\"\"Hooks for visiting image polarity token (IP).\"\"\"\n\n    class LoadMirroringTokenHooks(TokenHooksBase[LoadMirroringT]):\n        \"\"\"Hooks for visiting load mirroring token (LM).\"\"\"\n\n    class LoadNameTokenHooks(TokenHooksBase[LoadNameT]):\n        \"\"\"Hooks for visiting load name token (LN).\"\"\"\n\n    class LoadPolarityTokenHooks(TokenHooksBase[LoadPolarityT]):\n        \"\"\"Hooks for visiting load polarity token (LP).\"\"\"\n\n    class LoadRotationTokenHooks(TokenHooksBase[LoadRotationT]):\n        \"\"\"Hooks for visiting load rotation token (LR).\"\"\"\n\n    class LoadScalingTokenHooks(TokenHooksBase[LoadScalingT]):\n        \"\"\"Hooks for visiting load scaling token (LS).\"\"\"\n\n    class ProgramStopTokenHooks(TokenHooksBase[M00ProgramStopT]):\n        \"\"\"Hooks for visiting program stop token (M00).\"\"\"\n\n    class OptionalStopTokenHooks(TokenHooksBase[M01OptionalStopT]):\n        \"\"\"Hooks for visiting optional stop token (M01).\"\"\"\n\n    class EndOfFileTokenHooks(TokenHooksBase[M02EndOfFileT]):\n        \"\"\"Hooks for visiting end of file token (M02).\"\"\"\n\n    class UnitModeTokenHooks(TokenHooksBase[UnitModeT]):\n        \"\"\"Hooks for visiting unit mode token (MO).\"\"\"\n\n    class ImageOffsetTokenHooks(TokenHooksBase[ImageOffsetT]):\n        \"\"\"Hooks for visiting image offset token (OF).\"\"\"\n\n    class StepRepeatBeginTokenHooks(TokenHooksBase[StepRepeatBeginT]):\n        \"\"\"Hooks for visiting step and repeat begin token (SR).\"\"\"\n\n    class StepRepeatEndTokenHooks(TokenHooksBase[StepRepeatEndT]):\n        \"\"\"Hooks for visiting step and repeat end token (SR).\"\"\"\n\n    class ApertureAttributeHooks(TokenHooksBase[ApertureAttributeT]):\n        \"\"\"Hooks for visiting aperture attribute token (TA).\"\"\"\n\n    class DeleteAttributeHooks(TokenHooksBase[DeleteAttributeT]):\n        \"\"\"Hooks for visiting delete attribute token (TD).\"\"\"\n\n    class FileAttributeHooks(TokenHooksBase[FileAttributeT]):\n        \"\"\"Hooks for visiting file attribute token (TF).\"\"\"\n\n    class ObjectAttributeHooks(TokenHooksBase[ObjectAttributeT]):\n        \"\"\"Hooks for visiting object attribute token (TO).\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks_base.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.MacroBeginTokenHooks","title":"MacroBeginTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[MacroBeginT]</code></p> <p>Hooks for visiting macro definition begin token (AM).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class MacroBeginTokenHooks(TokenHooksBase[MacroBeginT]):\n    \"\"\"Hooks for visiting macro definition begin token (AM).\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks_base.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.MacroCode1CircleTokenHooks","title":"MacroCode1CircleTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[Code1CircleTokenT]</code></p> <p>Hooks for visiting macro primitive code 0 circle.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class MacroCode1CircleTokenHooks(TokenHooksBase[Code1CircleTokenT]):\n    \"\"\"Hooks for visiting macro primitive code 0 circle.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks_base.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.MacroCode2VectorLineTokenHooks","title":"MacroCode2VectorLineTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[Code2VectorLineTokenT]</code></p> <p>Hooks for visiting macro primitive code 2 vector line.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class MacroCode2VectorLineTokenHooks(TokenHooksBase[Code2VectorLineTokenT]):\n    \"\"\"Hooks for visiting macro primitive code 2 vector line.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks_base.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.MacroCode4OutlineTokenHooks","title":"MacroCode4OutlineTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[Code4OutlineTokenT]</code></p> <p>Hooks for visiting macro primitive code 4 outline.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class MacroCode4OutlineTokenHooks(TokenHooksBase[Code4OutlineTokenT]):\n    \"\"\"Hooks for visiting macro primitive code 4 outline.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks_base.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.MacroCode5PolygonTokenHooks","title":"MacroCode5PolygonTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[Code5PolygonTokenT]</code></p> <p>Hooks for visiting macro primitive code 5 polygon.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class MacroCode5PolygonTokenHooks(TokenHooksBase[Code5PolygonTokenT]):\n    \"\"\"Hooks for visiting macro primitive code 5 polygon.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks_base.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.MacroCode6MoireTokenHooks","title":"MacroCode6MoireTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[Code6MoireTokenT]</code></p> <p>Hooks for visiting macro primitive code 6 moire.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class MacroCode6MoireTokenHooks(TokenHooksBase[Code6MoireTokenT]):\n    \"\"\"Hooks for visiting macro primitive code 6 moire.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks_base.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.MacroCode7ThermalTokenHooks","title":"MacroCode7ThermalTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[Code7ThermalTokenT]</code></p> <p>Hooks for visiting macro primitive code 7 thermal.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class MacroCode7ThermalTokenHooks(TokenHooksBase[Code7ThermalTokenT]):\n    \"\"\"Hooks for visiting macro primitive code 7 thermal.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks_base.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.MacroCode20VectorLineTokenHooks","title":"MacroCode20VectorLineTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[Code20VectorLineTokenT]</code></p> <p>Hooks for visiting macro primitive code 20 vector line.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class MacroCode20VectorLineTokenHooks(TokenHooksBase[Code20VectorLineTokenT]):\n    \"\"\"Hooks for visiting macro primitive code 20 vector line.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks_base.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.MacroCode21CenterLineTokenHooks","title":"MacroCode21CenterLineTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[Code21CenterLineTokenT]</code></p> <p>Hooks for visiting macro primitive code 21 center line.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class MacroCode21CenterLineTokenHooks(TokenHooksBase[Code21CenterLineTokenT]):\n    \"\"\"Hooks for visiting macro primitive code 21 center line.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks_base.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.MacroCode22LowerLeftLineTokenHooks","title":"MacroCode22LowerLeftLineTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[Code22LowerLeftLineTokenT]</code></p> <p>Hooks for visiting macro primitive code 22 lower left line.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class MacroCode22LowerLeftLineTokenHooks(TokenHooksBase[Code22LowerLeftLineTokenT]):\n    \"\"\"Hooks for visiting macro primitive code 22 lower left line.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks_base.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.MacroVariableAssignment","title":"MacroVariableAssignment","text":"<p>             Bases: <code>TokenHooksBase[MacroVariableAssignmentT]</code></p> <p>Hooks for visiting macro variable assignment token.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class MacroVariableAssignment(TokenHooksBase[MacroVariableAssignmentT]):\n    \"\"\"Hooks for visiting macro variable assignment token.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks_base.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.MacroDefinitionTokenHooks","title":"MacroDefinitionTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[MacroDefinitionT]</code></p> <p>Hooks for visiting macro definition token (AM).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class MacroDefinitionTokenHooks(TokenHooksBase[MacroDefinitionT]):\n    \"\"\"Hooks for visiting macro definition token (AM).\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks_base.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.MacroEvalHooks","title":"MacroEvalHooks","text":"<p>Hooks called when evaluating macro aperture.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class MacroEvalHooks:\n    \"\"\"Hooks called when evaluating macro aperture.\"\"\"\n\n    def on_code_1_circle(\n        self,\n        context: Parser2Context,\n        primitive: Code1Circle2,\n    ) -&gt; None:\n        \"\"\"Evaluate code 1 circle primitive.\"\"\"\n\n    def on_code_2_vector_line(\n        self,\n        context: Parser2Context,\n        primitive: Code2VectorLine2,\n    ) -&gt; None:\n        \"\"\"Evaluate code 2 vector line primitive.\"\"\"\n\n    def on_code_4_outline(\n        self,\n        context: Parser2Context,\n        primitive: Code4Outline2,\n    ) -&gt; None:\n        \"\"\"Evaluate code 4 outline primitive.\"\"\"\n\n    def on_code_5_polygon(\n        self,\n        context: Parser2Context,\n        primitive: Code5Polygon2,\n    ) -&gt; None:\n        \"\"\"Evaluate code 5 polygon primitive.\"\"\"\n\n    def on_code_6_moire(\n        self,\n        context: Parser2Context,\n        primitive: Code6Moire2,\n    ) -&gt; None:\n        \"\"\"Evaluate code 6 moire primitive.\"\"\"\n\n    def on_code_7_thermal(\n        self,\n        context: Parser2Context,\n        primitive: Code7Thermal2,\n    ) -&gt; None:\n        \"\"\"Evaluate code 7 thermal primitive.\"\"\"\n\n    def on_code_20_vector_line(\n        self,\n        context: Parser2Context,\n        primitive: Code20VectorLine2,\n    ) -&gt; None:\n        \"\"\"Evaluate code 20 vector line primitive.\"\"\"\n\n    def on_code_21_center_line(\n        self,\n        context: Parser2Context,\n        primitive: Code21CenterLine2,\n    ) -&gt; None:\n        \"\"\"Evaluate code 21 center line primitive.\"\"\"\n\n    def on_code_22_lower_left_line(\n        self,\n        context: Parser2Context,\n        primitive: Code22LowerLeftLine2,\n    ) -&gt; None:\n        \"\"\"Evaluate code 22 lower left line primitive.\"\"\"\n\n    def on_assignment(\n        self,\n        context: Parser2Context,\n        assignment: Assignment2,\n    ) -&gt; None:\n        \"\"\"Evaluate macro variable assignment statement.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks_base.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.MacroEvalHooks.on_code_1_circle","title":"on_code_1_circle","text":"<pre><code>on_code_1_circle(\n    context: Parser2Context, primitive: Code1Circle2\n) -&gt; None\n</code></pre> <p>Evaluate code 1 circle primitive.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>def on_code_1_circle(\n    self,\n    context: Parser2Context,\n    primitive: Code1Circle2,\n) -&gt; None:\n    \"\"\"Evaluate code 1 circle primitive.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks_base.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.MacroEvalHooks.on_code_2_vector_line","title":"on_code_2_vector_line","text":"<pre><code>on_code_2_vector_line(\n    context: Parser2Context, primitive: Code2VectorLine2\n) -&gt; None\n</code></pre> <p>Evaluate code 2 vector line primitive.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>def on_code_2_vector_line(\n    self,\n    context: Parser2Context,\n    primitive: Code2VectorLine2,\n) -&gt; None:\n    \"\"\"Evaluate code 2 vector line primitive.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks_base.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.MacroEvalHooks.on_code_4_outline","title":"on_code_4_outline","text":"<pre><code>on_code_4_outline(\n    context: Parser2Context, primitive: Code4Outline2\n) -&gt; None\n</code></pre> <p>Evaluate code 4 outline primitive.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>def on_code_4_outline(\n    self,\n    context: Parser2Context,\n    primitive: Code4Outline2,\n) -&gt; None:\n    \"\"\"Evaluate code 4 outline primitive.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks_base.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.MacroEvalHooks.on_code_5_polygon","title":"on_code_5_polygon","text":"<pre><code>on_code_5_polygon(\n    context: Parser2Context, primitive: Code5Polygon2\n) -&gt; None\n</code></pre> <p>Evaluate code 5 polygon primitive.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>def on_code_5_polygon(\n    self,\n    context: Parser2Context,\n    primitive: Code5Polygon2,\n) -&gt; None:\n    \"\"\"Evaluate code 5 polygon primitive.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks_base.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.MacroEvalHooks.on_code_6_moire","title":"on_code_6_moire","text":"<pre><code>on_code_6_moire(\n    context: Parser2Context, primitive: Code6Moire2\n) -&gt; None\n</code></pre> <p>Evaluate code 6 moire primitive.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>def on_code_6_moire(\n    self,\n    context: Parser2Context,\n    primitive: Code6Moire2,\n) -&gt; None:\n    \"\"\"Evaluate code 6 moire primitive.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks_base.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.MacroEvalHooks.on_code_7_thermal","title":"on_code_7_thermal","text":"<pre><code>on_code_7_thermal(\n    context: Parser2Context, primitive: Code7Thermal2\n) -&gt; None\n</code></pre> <p>Evaluate code 7 thermal primitive.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>def on_code_7_thermal(\n    self,\n    context: Parser2Context,\n    primitive: Code7Thermal2,\n) -&gt; None:\n    \"\"\"Evaluate code 7 thermal primitive.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks_base.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.MacroEvalHooks.on_code_20_vector_line","title":"on_code_20_vector_line","text":"<pre><code>on_code_20_vector_line(\n    context: Parser2Context, primitive: Code20VectorLine2\n) -&gt; None\n</code></pre> <p>Evaluate code 20 vector line primitive.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>def on_code_20_vector_line(\n    self,\n    context: Parser2Context,\n    primitive: Code20VectorLine2,\n) -&gt; None:\n    \"\"\"Evaluate code 20 vector line primitive.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks_base.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.MacroEvalHooks.on_code_21_center_line","title":"on_code_21_center_line","text":"<pre><code>on_code_21_center_line(\n    context: Parser2Context, primitive: Code21CenterLine2\n) -&gt; None\n</code></pre> <p>Evaluate code 21 center line primitive.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>def on_code_21_center_line(\n    self,\n    context: Parser2Context,\n    primitive: Code21CenterLine2,\n) -&gt; None:\n    \"\"\"Evaluate code 21 center line primitive.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks_base.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.MacroEvalHooks.on_code_22_lower_left_line","title":"on_code_22_lower_left_line","text":"<pre><code>on_code_22_lower_left_line(\n    context: Parser2Context, primitive: Code22LowerLeftLine2\n) -&gt; None\n</code></pre> <p>Evaluate code 22 lower left line primitive.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>def on_code_22_lower_left_line(\n    self,\n    context: Parser2Context,\n    primitive: Code22LowerLeftLine2,\n) -&gt; None:\n    \"\"\"Evaluate code 22 lower left line primitive.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks_base.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.MacroEvalHooks.on_assignment","title":"on_assignment","text":"<pre><code>on_assignment(\n    context: Parser2Context, assignment: Assignment2\n) -&gt; None\n</code></pre> <p>Evaluate macro variable assignment statement.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>def on_assignment(\n    self,\n    context: Parser2Context,\n    assignment: Assignment2,\n) -&gt; None:\n    \"\"\"Evaluate macro variable assignment statement.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks_base.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.BeginBlockApertureTokenHooks","title":"BeginBlockApertureTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[BlockApertureBeginT]</code></p> <p>Hooks for visiting begin block aperture token (AB).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class BeginBlockApertureTokenHooks(TokenHooksBase[BlockApertureBeginT]):\n    \"\"\"Hooks for visiting begin block aperture token (AB).\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks_base.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.EndBlockApertureTokenHooks","title":"EndBlockApertureTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[BlockApertureEndT]</code></p> <p>Hooks for visiting end block aperture token (AB).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class EndBlockApertureTokenHooks(TokenHooksBase[BlockApertureEndT]):\n    \"\"\"Hooks for visiting end block aperture token (AB).\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks_base.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.DefineApertureCircleTokenHooks","title":"DefineApertureCircleTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[DefineCircleT]</code></p> <p>Hooks for visiting circle aperture definition token (ADD).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class DefineApertureCircleTokenHooks(TokenHooksBase[DefineCircleT]):\n    \"\"\"Hooks for visiting circle aperture definition token (ADD).\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks_base.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.DefineApertureRectangleTokenHooks","title":"DefineApertureRectangleTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[DefineRectangleT]</code></p> <p>Hooks for visiting rectangle aperture definition token (ADD).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class DefineApertureRectangleTokenHooks(TokenHooksBase[DefineRectangleT]):\n    \"\"\"Hooks for visiting rectangle aperture definition token (ADD).\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks_base.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.DefineApertureObroundTokenHooks","title":"DefineApertureObroundTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[DefineObroundT]</code></p> <p>Hooks for visiting obround aperture definition token (ADD).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class DefineApertureObroundTokenHooks(TokenHooksBase[DefineObroundT]):\n    \"\"\"Hooks for visiting obround aperture definition token (ADD).\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks_base.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.DefineAperturePolygonTokenHooks","title":"DefineAperturePolygonTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[DefinePolygonT]</code></p> <p>Hooks for visiting polygon aperture definition token (ADD).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class DefineAperturePolygonTokenHooks(TokenHooksBase[DefinePolygonT]):\n    \"\"\"Hooks for visiting polygon aperture definition token (ADD).\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks_base.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.DefineApertureMacroTokenHooks","title":"DefineApertureMacroTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[DefineMacroT]</code></p> <p>Hooks for visiting macro aperture definition token (ADD).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class DefineApertureMacroTokenHooks(TokenHooksBase[DefineMacroT]):\n    \"\"\"Hooks for visiting macro aperture definition token (ADD).\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks_base.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.DefineApertureTokenHooks","title":"DefineApertureTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[DefineAnyT]</code></p> <p>Hooks for visiting any aperture definition token (ADD).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class DefineApertureTokenHooks(TokenHooksBase[DefineAnyT]):\n    \"\"\"Hooks for visiting any aperture definition token (ADD).\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks_base.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.AxisSelectTokenHooksTokenHooks","title":"AxisSelectTokenHooksTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[AxisSelectT]</code></p> <p>Hooks for visiting axis select token (AS).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class AxisSelectTokenHooksTokenHooks(TokenHooksBase[AxisSelectT]):\n    \"\"\"Hooks for visiting axis select token (AS).\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks_base.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.CommandDrawTokenHooks","title":"CommandDrawTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[D01DrawT]</code></p> <p>Hooks for visiting draw token (D01).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class CommandDrawTokenHooks(TokenHooksBase[D01DrawT]):\n    \"\"\"Hooks for visiting draw token (D01).\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks_base.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.CommandMoveTokenHooks","title":"CommandMoveTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[D02MoveT]</code></p> <p>Hooks for visiting move token (D02).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class CommandMoveTokenHooks(TokenHooksBase[D02MoveT]):\n    \"\"\"Hooks for visiting move token (D02).\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks_base.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.CommandFlashTokenHooks","title":"CommandFlashTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[D03FlashT]</code></p> <p>Hooks for visiting flash token (D03).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class CommandFlashTokenHooks(TokenHooksBase[D03FlashT]):\n    \"\"\"Hooks for visiting flash token (D03).\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks_base.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.SelectApertureTokenHooks","title":"SelectApertureTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[DNNSelectApertureT]</code></p> <p>Hooks for visiting select aperture token (DNN).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class SelectApertureTokenHooks(TokenHooksBase[DNNSelectApertureT]):\n    \"\"\"Hooks for visiting select aperture token (DNN).\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks_base.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.CoordinateFormatTokenHooks","title":"CoordinateFormatTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[CoordinateFormatT]</code></p> <p>Hooks for visiting coordinate format token (FS).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class CoordinateFormatTokenHooks(TokenHooksBase[CoordinateFormatT]):\n    \"\"\"Hooks for visiting coordinate format token (FS).\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks_base.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.SetLinearTokenHooks","title":"SetLinearTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[SetLinearT]</code></p> <p>Hooks for visiting set linear token (G01).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class SetLinearTokenHooks(TokenHooksBase[SetLinearT]):\n    \"\"\"Hooks for visiting set linear token (G01).\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks_base.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.SetClockwiseCircularTokenHooks","title":"SetClockwiseCircularTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[SetClockwiseCircularT]</code></p> <p>Hooks for visiting set clockwise circular token (G02).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class SetClockwiseCircularTokenHooks(TokenHooksBase[SetClockwiseCircularT]):\n    \"\"\"Hooks for visiting set clockwise circular token (G02).\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks_base.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.SetCounterClockwiseCircularTokenHooks","title":"SetCounterClockwiseCircularTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[SetCounterclockwiseCircularT]</code></p> <p>Hooks for visiting set counter clockwise circular token (G03).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class SetCounterClockwiseCircularTokenHooks(\n    TokenHooksBase[SetCounterclockwiseCircularT],\n):\n    \"\"\"Hooks for visiting set counter clockwise circular token (G03).\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks_base.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.CommentTokenHooks","title":"CommentTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[CommentT]</code></p> <p>Hooks for visiting comment token (G04).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class CommentTokenHooks(TokenHooksBase[CommentT]):\n    \"\"\"Hooks for visiting comment token (G04).\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks_base.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.BeginRegionTokenHooks","title":"BeginRegionTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[BeginRegionT]</code></p> <p>Hooks for visiting begin region token (G36).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class BeginRegionTokenHooks(TokenHooksBase[BeginRegionT]):\n    \"\"\"Hooks for visiting begin region token (G36).\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks_base.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.EndRegionTokenHooks","title":"EndRegionTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[EndRegionT]</code></p> <p>Hooks for visiting end region token (G37).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class EndRegionTokenHooks(TokenHooksBase[EndRegionT]):\n    \"\"\"Hooks for visiting end region token (G37).\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks_base.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.PrepareSelectApertureTokenHooks","title":"PrepareSelectApertureTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[G54SelectApertureT]</code></p> <p>Hooks for visiting prepare select aperture token (G54).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class PrepareSelectApertureTokenHooks(TokenHooksBase[G54SelectApertureT]):\n    \"\"\"Hooks for visiting prepare select aperture token (G54).\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks_base.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.SetUnitInchTokenHooks","title":"SetUnitInchTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[SetUnitInchT]</code></p> <p>Hooks for visiting set unit inch token (G70).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class SetUnitInchTokenHooks(TokenHooksBase[SetUnitInchT]):\n    \"\"\"Hooks for visiting set unit inch token (G70).\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks_base.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.SetUnitMillimetersTokenHooks","title":"SetUnitMillimetersTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[SetUnitMillimetersT]</code></p> <p>Hooks for visiting set unit millimeters token (G71).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class SetUnitMillimetersTokenHooks(TokenHooksBase[SetUnitMillimetersT]):\n    \"\"\"Hooks for visiting set unit millimeters token (G71).\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks_base.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.SetSingleQuadrantModeTokenHooks","title":"SetSingleQuadrantModeTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[SetSingleQuadrantModeT]</code></p> <p>Hooks for visiting set single-quadrant mode token (G74).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class SetSingleQuadrantModeTokenHooks(TokenHooksBase[SetSingleQuadrantModeT]):\n    \"\"\"Hooks for visiting set single-quadrant mode token (G74).\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks_base.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.SetMultiQuadrantModeTokenHooks","title":"SetMultiQuadrantModeTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[SetMultiQuadrantModeT]</code></p> <p>Hooks for visiting set multi-quadrant mode token (G75).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class SetMultiQuadrantModeTokenHooks(TokenHooksBase[SetMultiQuadrantModeT]):\n    \"\"\"Hooks for visiting set multi-quadrant mode token (G75).\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks_base.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.SetCoordinateAbsoluteTokenHooks","title":"SetCoordinateAbsoluteTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[SetAbsoluteNotationT]</code></p> <p>Hooks for visiting set coordinate absolute token (G90).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class SetCoordinateAbsoluteTokenHooks(TokenHooksBase[SetAbsoluteNotationT]):\n    \"\"\"Hooks for visiting set coordinate absolute token (G90).\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks_base.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.SetCoordinateIncrementalTokenHooks","title":"SetCoordinateIncrementalTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[SetIncrementalNotationT]</code></p> <p>Hooks for visiting set coordinate incremental token (G91).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class SetCoordinateIncrementalTokenHooks(TokenHooksBase[SetIncrementalNotationT]):\n    \"\"\"Hooks for visiting set coordinate incremental token (G91).\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks_base.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.ImageNameTokenHooks","title":"ImageNameTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[ImageNameT]</code></p> <p>Hooks for visiting image name token (IN).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class ImageNameTokenHooks(TokenHooksBase[ImageNameT]):\n    \"\"\"Hooks for visiting image name token (IN).\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks_base.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.InvalidTokenHooks","title":"InvalidTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[InvalidTokenT]</code></p> <p>Hooks for visiting invalid token.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class InvalidTokenHooks(TokenHooksBase[InvalidTokenT]):\n    \"\"\"Hooks for visiting invalid token.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks_base.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.ImagePolarityTokenHooks","title":"ImagePolarityTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[ImagePolarityT]</code></p> <p>Hooks for visiting image polarity token (IP).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class ImagePolarityTokenHooks(TokenHooksBase[ImagePolarityT]):\n    \"\"\"Hooks for visiting image polarity token (IP).\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks_base.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.LoadMirroringTokenHooks","title":"LoadMirroringTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[LoadMirroringT]</code></p> <p>Hooks for visiting load mirroring token (LM).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class LoadMirroringTokenHooks(TokenHooksBase[LoadMirroringT]):\n    \"\"\"Hooks for visiting load mirroring token (LM).\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks_base.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.LoadNameTokenHooks","title":"LoadNameTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[LoadNameT]</code></p> <p>Hooks for visiting load name token (LN).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class LoadNameTokenHooks(TokenHooksBase[LoadNameT]):\n    \"\"\"Hooks for visiting load name token (LN).\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks_base.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.LoadPolarityTokenHooks","title":"LoadPolarityTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[LoadPolarityT]</code></p> <p>Hooks for visiting load polarity token (LP).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class LoadPolarityTokenHooks(TokenHooksBase[LoadPolarityT]):\n    \"\"\"Hooks for visiting load polarity token (LP).\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks_base.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.LoadRotationTokenHooks","title":"LoadRotationTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[LoadRotationT]</code></p> <p>Hooks for visiting load rotation token (LR).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class LoadRotationTokenHooks(TokenHooksBase[LoadRotationT]):\n    \"\"\"Hooks for visiting load rotation token (LR).\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks_base.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.LoadScalingTokenHooks","title":"LoadScalingTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[LoadScalingT]</code></p> <p>Hooks for visiting load scaling token (LS).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class LoadScalingTokenHooks(TokenHooksBase[LoadScalingT]):\n    \"\"\"Hooks for visiting load scaling token (LS).\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks_base.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.ProgramStopTokenHooks","title":"ProgramStopTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[M00ProgramStopT]</code></p> <p>Hooks for visiting program stop token (M00).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class ProgramStopTokenHooks(TokenHooksBase[M00ProgramStopT]):\n    \"\"\"Hooks for visiting program stop token (M00).\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks_base.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.OptionalStopTokenHooks","title":"OptionalStopTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[M01OptionalStopT]</code></p> <p>Hooks for visiting optional stop token (M01).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class OptionalStopTokenHooks(TokenHooksBase[M01OptionalStopT]):\n    \"\"\"Hooks for visiting optional stop token (M01).\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks_base.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.EndOfFileTokenHooks","title":"EndOfFileTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[M02EndOfFileT]</code></p> <p>Hooks for visiting end of file token (M02).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class EndOfFileTokenHooks(TokenHooksBase[M02EndOfFileT]):\n    \"\"\"Hooks for visiting end of file token (M02).\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks_base.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.UnitModeTokenHooks","title":"UnitModeTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[UnitModeT]</code></p> <p>Hooks for visiting unit mode token (MO).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class UnitModeTokenHooks(TokenHooksBase[UnitModeT]):\n    \"\"\"Hooks for visiting unit mode token (MO).\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks_base.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.ImageOffsetTokenHooks","title":"ImageOffsetTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[ImageOffsetT]</code></p> <p>Hooks for visiting image offset token (OF).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class ImageOffsetTokenHooks(TokenHooksBase[ImageOffsetT]):\n    \"\"\"Hooks for visiting image offset token (OF).\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks_base.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.StepRepeatBeginTokenHooks","title":"StepRepeatBeginTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[StepRepeatBeginT]</code></p> <p>Hooks for visiting step and repeat begin token (SR).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class StepRepeatBeginTokenHooks(TokenHooksBase[StepRepeatBeginT]):\n    \"\"\"Hooks for visiting step and repeat begin token (SR).\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks_base.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.StepRepeatEndTokenHooks","title":"StepRepeatEndTokenHooks","text":"<p>             Bases: <code>TokenHooksBase[StepRepeatEndT]</code></p> <p>Hooks for visiting step and repeat end token (SR).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class StepRepeatEndTokenHooks(TokenHooksBase[StepRepeatEndT]):\n    \"\"\"Hooks for visiting step and repeat end token (SR).\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks_base.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.ApertureAttributeHooks","title":"ApertureAttributeHooks","text":"<p>             Bases: <code>TokenHooksBase[ApertureAttributeT]</code></p> <p>Hooks for visiting aperture attribute token (TA).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class ApertureAttributeHooks(TokenHooksBase[ApertureAttributeT]):\n    \"\"\"Hooks for visiting aperture attribute token (TA).\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks_base.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.DeleteAttributeHooks","title":"DeleteAttributeHooks","text":"<p>             Bases: <code>TokenHooksBase[DeleteAttributeT]</code></p> <p>Hooks for visiting delete attribute token (TD).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class DeleteAttributeHooks(TokenHooksBase[DeleteAttributeT]):\n    \"\"\"Hooks for visiting delete attribute token (TD).\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks_base.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.FileAttributeHooks","title":"FileAttributeHooks","text":"<p>             Bases: <code>TokenHooksBase[FileAttributeT]</code></p> <p>Hooks for visiting file attribute token (TF).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class FileAttributeHooks(TokenHooksBase[FileAttributeT]):\n    \"\"\"Hooks for visiting file attribute token (TF).\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks_base.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.ObjectAttributeHooks","title":"ObjectAttributeHooks","text":"<p>             Bases: <code>TokenHooksBase[ObjectAttributeT]</code></p> <p>Hooks for visiting object attribute token (TO).</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>class ObjectAttributeHooks(TokenHooksBase[ObjectAttributeT]):\n    \"\"\"Hooks for visiting object attribute token (TO).\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks_base.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.on_parser_init","title":"on_parser_init","text":"<pre><code>on_parser_init(parser: Parser2) -&gt; None\n</code></pre> <p>Called after parser initialization.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>def on_parser_init(self, parser: Parser2) -&gt; None:\n    \"\"\"Called after parser initialization.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks_base.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.pre_parse","title":"pre_parse","text":"<pre><code>pre_parse(context: Parser2Context) -&gt; None\n</code></pre> <p>Called before parsing starts.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>def pre_parse(self, context: Parser2Context) -&gt; None:\n    \"\"\"Called before parsing starts.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks_base.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.post_parse","title":"post_parse","text":"<pre><code>post_parse(context: Parser2Context) -&gt; None\n</code></pre> <p>Called after parsing starts.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>def post_parse(self, context: Parser2Context) -&gt; None:\n    \"\"\"Called after parsing starts.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks_base.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.on_parser_error","title":"on_parser_error","text":"<pre><code>on_parser_error(\n    context: Parser2Context, error: Parser2Error\n) -&gt; None\n</code></pre> <p>Called when parsing error is thrown.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>def on_parser_error(self, context: Parser2Context, error: Parser2Error) -&gt; None:\n    \"\"\"Called when parsing error is thrown.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks_base.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.on_other_error","title":"on_other_error","text":"<pre><code>on_other_error(\n    context: Parser2Context, error: Exception\n) -&gt; None\n</code></pre> <p>Called when other error is thrown.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>def on_other_error(self, context: Parser2Context, error: Exception) -&gt; None:\n    \"\"\"Called when other error is thrown.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks_base.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.pre_parser_visit_any_token","title":"pre_parser_visit_any_token","text":"<pre><code>pre_parser_visit_any_token(context: Parser2Context) -&gt; None\n</code></pre> <p>Called before parser visits any token.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>def pre_parser_visit_any_token(self, context: Parser2Context) -&gt; None:\n    \"\"\"Called before parser visits any token.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/parser2hooks_base.html#pygerber.gerberx3.parser2.parser2hooks_base.Parser2HooksBase.post_parser_visit_any_token","title":"post_parser_visit_any_token","text":"<pre><code>post_parser_visit_any_token(\n    context: Parser2Context,\n) -&gt; None\n</code></pre> <p>Called after parser visits any token.</p> Source code in <code>src/pygerber/gerberx3/parser2/parser2hooks_base.py</code> <pre><code>def post_parser_visit_any_token(self, context: Parser2Context) -&gt; None:\n    \"\"\"Called after parser visits any token.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html","title":"state2","text":""},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2","title":"state2","text":"<p>Alternative implementation of Gerber AST parser state, version 2.</p> <p>Parser state is immutable and composed out of multiple sub objects. This approach allows for cheap storage and updates of parser state, as whenever parser state is updated, only one value must be changed, while rest of the structures remain unchanged and only references to them are copied.</p>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2Constants","title":"State2Constants","text":"<p>             Bases: <code>FrozenGeneralModel</code></p> <p>Collection of rarely changing (usually once per AST) parser constants.</p> <p>This class represents the state constants used in the Gerber parser. It contains properties for various parser constants such as draw units, coordinate format, polarity, mirroring, rotation, scaling, image polarity, and file name. These constants are typically set once per AST (Abstract Syntax Tree) and are used throughout the parsing process.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>class State2Constants(FrozenGeneralModel):\n    \"\"\"Collection of rarely changing (usually once per AST) parser constants.\n\n    This class represents the state constants used in the Gerber parser. It contains\n    properties for various parser constants such as draw units, coordinate format,\n    polarity, mirroring, rotation, scaling, image polarity, and file name. These\n    constants are typically set once per AST (Abstract Syntax Tree) and are used\n    throughout the parsing process.\n    \"\"\"\n\n    draw_units: Optional[Unit] = Field(default=None)\n    \"\"\"The draw units used for the Gerber file. (Spec reference: 4.2.1)\"\"\"\n\n    coordinate_parser: Optional[CoordinateParser] = Field(default=None)\n    \"\"\"The coordinate format specification, including the number of decimals.\n    (Spec reference: 4.2.2)\"\"\"\n\n    is_output_image_negation_required: bool = Field(default=False)\n    \"\"\"Flag indicating whether image polarity flipping is required.\n    (Spec reference: 8.1.4)\"\"\"\n\n    image_name: Optional[str] = Field(default=None)\n    \"\"\"The name of the image. (Spec reference: 8.1.3)\"\"\"\n\n    file_name: Optional[str] = Field(default=None)\n    \"\"\"The name of the file. (Spec reference: 8.1.6)\"\"\"\n\n    axis_correspondence: AxisCorrespondence = Field(default=AxisCorrespondence.AXBY)\n    \"\"\"Correspondence between the X, Y data axes and the A, B output device axes.\n    It does not affect the image in computer to computer data exchange. It only\n    has an effect how the image is positioned on an output device.\"\"\"\n\n    def get_draw_units(self) -&gt; Unit:\n        \"\"\"Get the draw units.\n\n        This method returns the draw units used for the Gerber file.\n\n        Returns\n        -------\n        Unit\n            The draw units.\n\n        Raises\n        ------\n        UnitNotSet2Error\n            If the draw units are not set.\n        \"\"\"\n        if self.draw_units is None:\n            raise UnitNotSet2Error\n        return self.draw_units\n\n    def set_draw_units(self, draw_units: Unit) -&gt; Self:\n        \"\"\"Set the draw units for the state.\n\n        This method updates the draw units of the state and returns a new instance of\n        the state with the updated draw units.\n\n        Parameters\n        ----------\n        draw_units : Unit\n            The draw units to be set.\n\n        Returns\n        -------\n        Self\n            A new instance of the state with the updated draw units.\n        \"\"\"\n        return self.model_copy(\n            update={\n                \"draw_units\": draw_units,\n            },\n        )\n\n    def get_coordinate_parser(self) -&gt; CoordinateParser:\n        \"\"\"Get coordinate_parser property value.\"\"\"\n        if self.coordinate_parser is None:\n            raise CoordinateFormatNotSet2Error\n        return self.coordinate_parser\n\n    def set_coordinate_parser(self, coordinate_parser: CoordinateParser) -&gt; Self:\n        \"\"\"Set the coordinate_parser property value.\"\"\"\n        return self.model_copy(\n            update={\n                \"coordinate_parser\": coordinate_parser,\n            },\n        )\n\n    def get_is_output_image_negation_required(self) -&gt; bool:\n        \"\"\"Get is_output_image_negation_required property value.\"\"\"\n        return self.is_output_image_negation_required\n\n    def set_is_output_image_negation_required(\n        self,\n        value: bool,  # noqa: FBT001\n    ) -&gt; Self:\n        \"\"\"Set the is_output_image_negation_required property value.\"\"\"\n        return self.model_copy(\n            update={\n                \"is_output_image_negation_required\": value,\n            },\n        )\n\n    def get_image_name(self) -&gt; Optional[str]:\n        \"\"\"Get image_name property value.\"\"\"\n        return self.image_name\n\n    def set_image_name(self, image_name: Optional[str]) -&gt; Self:\n        \"\"\"Set the image_name property value.\"\"\"\n        return self.model_copy(\n            update={\n                \"image_name\": image_name,\n            },\n        )\n\n    def get_file_name(self) -&gt; Optional[str]:\n        \"\"\"Get file_name property value.\"\"\"\n        return self.file_name\n\n    def set_file_name(self, file_name: Optional[str]) -&gt; Self:\n        \"\"\"Set the file_name property value.\"\"\"\n        return self.model_copy(\n            update={\n                \"file_name\": file_name,\n            },\n        )\n\n    def get_axis_correspondence(self) -&gt; AxisCorrespondence:\n        \"\"\"Get token axis correspondence property value.\"\"\"\n        return self.axis_correspondence\n\n    def set_axis_correspondence(self, axis_correspondence: AxisCorrespondence) -&gt; Self:\n        \"\"\"Set token axis correspondence property value.\"\"\"\n        return self.model_copy(\n            update={\n                \"axis_correspondence\": axis_correspondence,\n            },\n        )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2Constants.draw_units","title":"draw_units  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>draw_units: Optional[Unit] = Field(default=None)\n</code></pre> <p>The draw units used for the Gerber file. (Spec reference: 4.2.1)</p>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2Constants.coordinate_parser","title":"coordinate_parser  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>coordinate_parser: Optional[CoordinateParser] = Field(\n    default=None\n)\n</code></pre> <p>The coordinate format specification, including the number of decimals. (Spec reference: 4.2.2)</p>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2Constants.is_output_image_negation_required","title":"is_output_image_negation_required  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>is_output_image_negation_required: bool = Field(\n    default=False\n)\n</code></pre> <p>Flag indicating whether image polarity flipping is required. (Spec reference: 8.1.4)</p>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2Constants.image_name","title":"image_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>image_name: Optional[str] = Field(default=None)\n</code></pre> <p>The name of the image. (Spec reference: 8.1.3)</p>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2Constants.file_name","title":"file_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>file_name: Optional[str] = Field(default=None)\n</code></pre> <p>The name of the file. (Spec reference: 8.1.6)</p>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2Constants.axis_correspondence","title":"axis_correspondence  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>axis_correspondence: AxisCorrespondence = Field(\n    default=AXBY\n)\n</code></pre> <p>Correspondence between the X, Y data axes and the A, B output device axes. It does not affect the image in computer to computer data exchange. It only has an effect how the image is positioned on an output device.</p>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2Constants.get_draw_units","title":"get_draw_units","text":"<pre><code>get_draw_units() -&gt; Unit\n</code></pre> <p>Get the draw units.</p> <p>This method returns the draw units used for the Gerber file.</p> <p>Returns:</p> Type Description <code>Unit</code> <p>The draw units.</p> <p>Raises:</p> Type Description <code>UnitNotSet2Error</code> <p>If the draw units are not set.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def get_draw_units(self) -&gt; Unit:\n    \"\"\"Get the draw units.\n\n    This method returns the draw units used for the Gerber file.\n\n    Returns\n    -------\n    Unit\n        The draw units.\n\n    Raises\n    ------\n    UnitNotSet2Error\n        If the draw units are not set.\n    \"\"\"\n    if self.draw_units is None:\n        raise UnitNotSet2Error\n    return self.draw_units\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2Constants.set_draw_units","title":"set_draw_units","text":"<pre><code>set_draw_units(draw_units: Unit) -&gt; Self\n</code></pre> <p>Set the draw units for the state.</p> <p>This method updates the draw units of the state and returns a new instance of the state with the updated draw units.</p> <p>Parameters:</p> Name Type Description Default <code>draw_units</code> <code>Unit</code> <p>The draw units to be set.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>A new instance of the state with the updated draw units.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def set_draw_units(self, draw_units: Unit) -&gt; Self:\n    \"\"\"Set the draw units for the state.\n\n    This method updates the draw units of the state and returns a new instance of\n    the state with the updated draw units.\n\n    Parameters\n    ----------\n    draw_units : Unit\n        The draw units to be set.\n\n    Returns\n    -------\n    Self\n        A new instance of the state with the updated draw units.\n    \"\"\"\n    return self.model_copy(\n        update={\n            \"draw_units\": draw_units,\n        },\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2Constants.get_coordinate_parser","title":"get_coordinate_parser","text":"<pre><code>get_coordinate_parser() -&gt; CoordinateParser\n</code></pre> <p>Get coordinate_parser property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def get_coordinate_parser(self) -&gt; CoordinateParser:\n    \"\"\"Get coordinate_parser property value.\"\"\"\n    if self.coordinate_parser is None:\n        raise CoordinateFormatNotSet2Error\n    return self.coordinate_parser\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2Constants.set_coordinate_parser","title":"set_coordinate_parser","text":"<pre><code>set_coordinate_parser(\n    coordinate_parser: CoordinateParser,\n) -&gt; Self\n</code></pre> <p>Set the coordinate_parser property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def set_coordinate_parser(self, coordinate_parser: CoordinateParser) -&gt; Self:\n    \"\"\"Set the coordinate_parser property value.\"\"\"\n    return self.model_copy(\n        update={\n            \"coordinate_parser\": coordinate_parser,\n        },\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2Constants.get_is_output_image_negation_required","title":"get_is_output_image_negation_required","text":"<pre><code>get_is_output_image_negation_required() -&gt; bool\n</code></pre> <p>Get is_output_image_negation_required property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def get_is_output_image_negation_required(self) -&gt; bool:\n    \"\"\"Get is_output_image_negation_required property value.\"\"\"\n    return self.is_output_image_negation_required\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2Constants.set_is_output_image_negation_required","title":"set_is_output_image_negation_required","text":"<pre><code>set_is_output_image_negation_required(value: bool) -&gt; Self\n</code></pre> <p>Set the is_output_image_negation_required property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def set_is_output_image_negation_required(\n    self,\n    value: bool,  # noqa: FBT001\n) -&gt; Self:\n    \"\"\"Set the is_output_image_negation_required property value.\"\"\"\n    return self.model_copy(\n        update={\n            \"is_output_image_negation_required\": value,\n        },\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2Constants.get_image_name","title":"get_image_name","text":"<pre><code>get_image_name() -&gt; Optional[str]\n</code></pre> <p>Get image_name property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def get_image_name(self) -&gt; Optional[str]:\n    \"\"\"Get image_name property value.\"\"\"\n    return self.image_name\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2Constants.set_image_name","title":"set_image_name","text":"<pre><code>set_image_name(image_name: Optional[str]) -&gt; Self\n</code></pre> <p>Set the image_name property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def set_image_name(self, image_name: Optional[str]) -&gt; Self:\n    \"\"\"Set the image_name property value.\"\"\"\n    return self.model_copy(\n        update={\n            \"image_name\": image_name,\n        },\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2Constants.get_file_name","title":"get_file_name","text":"<pre><code>get_file_name() -&gt; Optional[str]\n</code></pre> <p>Get file_name property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def get_file_name(self) -&gt; Optional[str]:\n    \"\"\"Get file_name property value.\"\"\"\n    return self.file_name\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2Constants.set_file_name","title":"set_file_name","text":"<pre><code>set_file_name(file_name: Optional[str]) -&gt; Self\n</code></pre> <p>Set the file_name property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def set_file_name(self, file_name: Optional[str]) -&gt; Self:\n    \"\"\"Set the file_name property value.\"\"\"\n    return self.model_copy(\n        update={\n            \"file_name\": file_name,\n        },\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2Constants.get_axis_correspondence","title":"get_axis_correspondence","text":"<pre><code>get_axis_correspondence() -&gt; AxisCorrespondence\n</code></pre> <p>Get token axis correspondence property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def get_axis_correspondence(self) -&gt; AxisCorrespondence:\n    \"\"\"Get token axis correspondence property value.\"\"\"\n    return self.axis_correspondence\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2Constants.set_axis_correspondence","title":"set_axis_correspondence","text":"<pre><code>set_axis_correspondence(\n    axis_correspondence: AxisCorrespondence,\n) -&gt; Self\n</code></pre> <p>Set token axis correspondence property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def set_axis_correspondence(self, axis_correspondence: AxisCorrespondence) -&gt; Self:\n    \"\"\"Set token axis correspondence property value.\"\"\"\n    return self.model_copy(\n        update={\n            \"axis_correspondence\": axis_correspondence,\n        },\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.ApertureTransform","title":"ApertureTransform","text":"<p>             Bases: <code>FrozenGeneralModel</code></p> <p>Proxy for accessing Parser2State from the moment of creation of command.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>class ApertureTransform(FrozenGeneralModel):\n    \"\"\"Proxy for accessing Parser2State from the moment of creation of command.\"\"\"\n\n    polarity: Polarity = Field(default=Polarity.Dark)\n    \"\"\"The polarity object transformation parameter. (Spec reference: 4.9.2)\"\"\"\n\n    mirroring: Mirroring = Field(default=Mirroring.NoMirroring)\n    \"\"\"The mirror object transformation parameter. (Spec reference: 4.9.3)\"\"\"\n\n    rotation: Decimal = Field(default=Decimal(\"0.0\"))\n    \"\"\"The rotation object transformation parameter. (Spec reference: 4.9.4)\"\"\"\n\n    scaling: Decimal = Field(default=Decimal(\"1.0\"))\n    \"\"\"The scale object transformation parameter. (Spec reference: 4.9.5)\"\"\"\n\n    def get_polarity(self) -&gt; Polarity:\n        \"\"\"Get polarity property value.\"\"\"\n        return self.polarity\n\n    def set_polarity(self, polarity: Polarity) -&gt; Self:\n        \"\"\"Set the polarity property value.\"\"\"\n        return self.model_copy(\n            update={\n                \"polarity\": polarity,\n            },\n        )\n\n    def get_mirroring(self) -&gt; Mirroring:\n        \"\"\"Get mirroring property value.\"\"\"\n        return self.mirroring\n\n    def set_mirroring(self, mirroring: Mirroring) -&gt; Self:\n        \"\"\"Set the mirroring property value.\"\"\"\n        return self.model_copy(\n            update={\n                \"mirroring\": mirroring,\n            },\n        )\n\n    def get_rotation(self) -&gt; Decimal:\n        \"\"\"Get rotation property value.\"\"\"\n        return self.rotation\n\n    def set_rotation(self, rotation: Decimal) -&gt; Self:\n        \"\"\"Set the rotation property value.\"\"\"\n        return self.model_copy(\n            update={\n                \"rotation\": rotation,\n            },\n        )\n\n    def get_scaling(self) -&gt; Decimal:\n        \"\"\"Get scaling property value.\"\"\"\n        return self.scaling\n\n    def set_scaling(self, scaling: Decimal) -&gt; Self:\n        \"\"\"Set the scaling property value.\"\"\"\n        return self.model_copy(\n            update={\n                \"scaling\": scaling,\n            },\n        )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.ApertureTransform.polarity","title":"polarity  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>polarity: Polarity = Field(default=Dark)\n</code></pre> <p>The polarity object transformation parameter. (Spec reference: 4.9.2)</p>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.ApertureTransform.mirroring","title":"mirroring  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mirroring: Mirroring = Field(default=NoMirroring)\n</code></pre> <p>The mirror object transformation parameter. (Spec reference: 4.9.3)</p>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.ApertureTransform.rotation","title":"rotation  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rotation: Decimal = Field(default=Decimal('0.0'))\n</code></pre> <p>The rotation object transformation parameter. (Spec reference: 4.9.4)</p>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.ApertureTransform.scaling","title":"scaling  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>scaling: Decimal = Field(default=Decimal('1.0'))\n</code></pre> <p>The scale object transformation parameter. (Spec reference: 4.9.5)</p>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.ApertureTransform.get_polarity","title":"get_polarity","text":"<pre><code>get_polarity() -&gt; Polarity\n</code></pre> <p>Get polarity property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def get_polarity(self) -&gt; Polarity:\n    \"\"\"Get polarity property value.\"\"\"\n    return self.polarity\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.ApertureTransform.set_polarity","title":"set_polarity","text":"<pre><code>set_polarity(polarity: Polarity) -&gt; Self\n</code></pre> <p>Set the polarity property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def set_polarity(self, polarity: Polarity) -&gt; Self:\n    \"\"\"Set the polarity property value.\"\"\"\n    return self.model_copy(\n        update={\n            \"polarity\": polarity,\n        },\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.ApertureTransform.get_mirroring","title":"get_mirroring","text":"<pre><code>get_mirroring() -&gt; Mirroring\n</code></pre> <p>Get mirroring property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def get_mirroring(self) -&gt; Mirroring:\n    \"\"\"Get mirroring property value.\"\"\"\n    return self.mirroring\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.ApertureTransform.set_mirroring","title":"set_mirroring","text":"<pre><code>set_mirroring(mirroring: Mirroring) -&gt; Self\n</code></pre> <p>Set the mirroring property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def set_mirroring(self, mirroring: Mirroring) -&gt; Self:\n    \"\"\"Set the mirroring property value.\"\"\"\n    return self.model_copy(\n        update={\n            \"mirroring\": mirroring,\n        },\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.ApertureTransform.get_rotation","title":"get_rotation","text":"<pre><code>get_rotation() -&gt; Decimal\n</code></pre> <p>Get rotation property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def get_rotation(self) -&gt; Decimal:\n    \"\"\"Get rotation property value.\"\"\"\n    return self.rotation\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.ApertureTransform.set_rotation","title":"set_rotation","text":"<pre><code>set_rotation(rotation: Decimal) -&gt; Self\n</code></pre> <p>Set the rotation property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def set_rotation(self, rotation: Decimal) -&gt; Self:\n    \"\"\"Set the rotation property value.\"\"\"\n    return self.model_copy(\n        update={\n            \"rotation\": rotation,\n        },\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.ApertureTransform.get_scaling","title":"get_scaling","text":"<pre><code>get_scaling() -&gt; Decimal\n</code></pre> <p>Get scaling property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def get_scaling(self) -&gt; Decimal:\n    \"\"\"Get scaling property value.\"\"\"\n    return self.scaling\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.ApertureTransform.set_scaling","title":"set_scaling","text":"<pre><code>set_scaling(scaling: Decimal) -&gt; Self\n</code></pre> <p>Set the scaling property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def set_scaling(self, scaling: Decimal) -&gt; Self:\n    \"\"\"Set the scaling property value.\"\"\"\n    return self.model_copy(\n        update={\n            \"scaling\": scaling,\n        },\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2MacroIndex","title":"State2MacroIndex","text":"<p>             Bases: <code>ImmutableMapping[str, ApertureMacro2]</code></p> <p>Index of all macros defined in Gerber AST until currently parsed token.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>class State2MacroIndex(ImmutableMapping[str, ApertureMacro2]):\n    \"\"\"Index of all macros defined in Gerber AST until currently parsed token.\"\"\"\n\n    def set_macro(self, __id: str, __macro: ApertureMacro2) -&gt; Self:\n        \"\"\"Add new macro to macros index.\"\"\"\n        # TODO(argmaster): Add warning handling.  # noqa: TD003\n        return self.update(__id, __macro)\n\n    def get_macro(self, __id: str) -&gt; ApertureMacro2:\n        \"\"\"Get existing macro from index. When macro is missing KeyError is\n        raised.\n        \"\"\"\n        return self.mapping[__id]\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2MacroIndex.set_macro","title":"set_macro","text":"<pre><code>set_macro(__id: str, __macro: ApertureMacro2) -&gt; Self\n</code></pre> <p>Add new macro to macros index.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def set_macro(self, __id: str, __macro: ApertureMacro2) -&gt; Self:\n    \"\"\"Add new macro to macros index.\"\"\"\n    # TODO(argmaster): Add warning handling.  # noqa: TD003\n    return self.update(__id, __macro)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2MacroIndex.get_macro","title":"get_macro","text":"<pre><code>get_macro(__id: str) -&gt; ApertureMacro2\n</code></pre> <p>Get existing macro from index. When macro is missing KeyError is raised.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def get_macro(self, __id: str) -&gt; ApertureMacro2:\n    \"\"\"Get existing macro from index. When macro is missing KeyError is\n    raised.\n    \"\"\"\n    return self.mapping[__id]\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2DrawFlags","title":"State2DrawFlags","text":"<p>             Bases: <code>FrozenGeneralModel</code></p> <p>Collection of drawing flags of Gerber AST parser, version 2.</p> <p>This class represents the drawing flags used in the Gerber AST parser. It contains properties to control various drawing modes and settings.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>class State2DrawFlags(FrozenGeneralModel):\n    \"\"\"Collection of drawing flags of Gerber AST parser, version 2.\n\n    This class represents the drawing flags used in the Gerber AST parser.\n    It contains properties to control various drawing modes and settings.\n    \"\"\"\n\n    draw_mode: DrawMode = DrawMode.Linear\n    \"\"\"The current draw mode (linear, clockwise circular, or counterclockwise circular).\n    \"\"\"\n    is_region: bool = False\n    \"\"\"Indicates whether the current statement is a region statement.\"\"\"\n    is_aperture_block: bool = False\n    \"\"\"Indicates whether the current statement is an aperture block statement.\"\"\"\n    aperture_block_id: Optional[ApertureID] = Field(default=None)\n    \"\"\"The ID of the current aperture block, if any.\"\"\"\n    is_multi_quadrant: bool = False\n    \"\"\"Indicates whether the multi-quadrant mode is enabled.\"\"\"\n\n    def get_draw_mode(self) -&gt; DrawMode:\n        \"\"\"Get the current draw mode.\n\n        Returns\n        -------\n            DrawMode: The current draw mode.\n\n        \"\"\"\n        return self.draw_mode\n\n    def set_draw_mode(self, draw_mode: DrawMode) -&gt; State2DrawFlags:\n        \"\"\"Set the draw mode.\n\n        Args:\n        ----\n            draw_mode (DrawMode): The new draw mode.\n\n        Returns:\n        -------\n            State2DrawFlags: A new instance of State2DrawFlags with the updated draw\n            mode.\n\n        \"\"\"\n        return self.model_copy(\n            update={\n                \"draw_mode\": draw_mode,\n            },\n        )\n\n    def get_is_region(self) -&gt; bool:\n        \"\"\"Check if the current statement is a region statement.\n\n        Returns\n        -------\n            bool: True if the current statement is a region statement, False otherwise.\n\n        \"\"\"\n        return self.is_region\n\n    def set_is_region(self, val: bool) -&gt; State2DrawFlags:  # noqa: FBT001\n        \"\"\"Set the flag indicating whether the current statement is a region statement.\n\n        Args:\n        ----\n            val (bool): True if the current statement is a region statement, False\n            otherwise.\n\n        Returns:\n        -------\n            State2DrawFlags: A new instance of State2DrawFlags with the updated flag.\n\n        \"\"\"\n        return self.model_copy(\n            update={\n                \"is_region\": val,\n            },\n        )\n\n    def get_is_aperture_block(self) -&gt; bool:\n        \"\"\"Check if the current statement is an aperture block statement.\n\n        Returns\n        -------\n            bool: True if the current statement is an aperture block statement, False\n            otherwise.\n\n        \"\"\"\n        return self.is_aperture_block\n\n    def set_is_aperture_block(self, val: bool) -&gt; State2DrawFlags:  # noqa: FBT001\n        \"\"\"Set the flag indicating whether the current statement is an aperture block\n        statement.\n\n        Args:\n        ----\n            val (bool): True if the current statement is an aperture block statement,\n            False otherwise.\n\n        Returns:\n        -------\n            State2DrawFlags: A new instance of State2DrawFlags with the updated flag.\n\n        \"\"\"\n        return self.model_copy(\n            update={\n                \"is_aperture_block\": val,\n            },\n        )\n\n    def get_aperture_block_id(self) -&gt; Optional[ApertureID]:\n        \"\"\"Get the ID of the current aperture block.\n\n        This method returns the ID of the current aperture block.\n\n        Returns\n        -------\n        Optional[ApertureID]\n            The ID of the current aperture block, or None if no aperture block is set.\n        \"\"\"\n        return self.aperture_block_id\n\n    def set_aperture_block_id(\n        self,\n        aperture_block_id: Optional[ApertureID],\n    ) -&gt; State2DrawFlags:\n        \"\"\"Set the ID of the current aperture block.\n\n        This method sets the ID of the current aperture block.\n\n        Parameters\n        ----------\n        aperture_block_id : Optional[ApertureID]\n            The ID of the current aperture block.\n\n        Returns\n        -------\n        State2DrawFlags\n            A new instance of the State2DrawFlags with the updated flag.\n        \"\"\"\n        return self.model_copy(\n            update={\n                \"aperture_block_id\": aperture_block_id,\n            },\n        )\n\n    def get_is_multi_quadrant(self) -&gt; bool:\n        \"\"\"Check if the multi-quadrant mode is enabled.\n\n        Returns\n        -------\n            bool: True if the multi-quadrant mode is enabled, False otherwise.\n\n        \"\"\"\n        return self.is_multi_quadrant\n\n    def set_is_multi_quadrant(self, val: bool) -&gt; Self:  # noqa: FBT001\n        \"\"\"Set the flag indicating whether the multi-quadrant mode is enabled.\n\n        Args:\n        ----\n            val (bool): True to enable the multi-quadrant mode, False to disable it.\n\n        Returns:\n        -------\n            State2DrawFlags: A new instance of State2DrawFlags with the updated flag.\n\n        \"\"\"\n        return self.model_copy(\n            update={\n                \"is_multi_quadrant\": val,\n            },\n        )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2DrawFlags.draw_mode","title":"draw_mode  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>draw_mode: DrawMode = Linear\n</code></pre> <p>The current draw mode (linear, clockwise circular, or counterclockwise circular).</p>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2DrawFlags.is_region","title":"is_region  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>is_region: bool = False\n</code></pre> <p>Indicates whether the current statement is a region statement.</p>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2DrawFlags.is_aperture_block","title":"is_aperture_block  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>is_aperture_block: bool = False\n</code></pre> <p>Indicates whether the current statement is an aperture block statement.</p>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2DrawFlags.aperture_block_id","title":"aperture_block_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>aperture_block_id: Optional[ApertureID] = Field(\n    default=None\n)\n</code></pre> <p>The ID of the current aperture block, if any.</p>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2DrawFlags.is_multi_quadrant","title":"is_multi_quadrant  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>is_multi_quadrant: bool = False\n</code></pre> <p>Indicates whether the multi-quadrant mode is enabled.</p>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2DrawFlags.get_draw_mode","title":"get_draw_mode","text":"<pre><code>get_draw_mode() -&gt; DrawMode\n</code></pre> <p>Get the current draw mode.</p> <p>Returns:</p> Type Description <code>    DrawMode: The current draw mode.</code> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def get_draw_mode(self) -&gt; DrawMode:\n    \"\"\"Get the current draw mode.\n\n    Returns\n    -------\n        DrawMode: The current draw mode.\n\n    \"\"\"\n    return self.draw_mode\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2DrawFlags.set_draw_mode","title":"set_draw_mode","text":"<pre><code>set_draw_mode(draw_mode: DrawMode) -&gt; State2DrawFlags\n</code></pre> <p>Set the draw mode.</p> Args: <pre><code>draw_mode (DrawMode): The new draw mode.\n</code></pre> Returns: <pre><code>State2DrawFlags: A new instance of State2DrawFlags with the updated draw\nmode.\n</code></pre> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def set_draw_mode(self, draw_mode: DrawMode) -&gt; State2DrawFlags:\n    \"\"\"Set the draw mode.\n\n    Args:\n    ----\n        draw_mode (DrawMode): The new draw mode.\n\n    Returns:\n    -------\n        State2DrawFlags: A new instance of State2DrawFlags with the updated draw\n        mode.\n\n    \"\"\"\n    return self.model_copy(\n        update={\n            \"draw_mode\": draw_mode,\n        },\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2DrawFlags.get_is_region","title":"get_is_region","text":"<pre><code>get_is_region() -&gt; bool\n</code></pre> <p>Check if the current statement is a region statement.</p> <p>Returns:</p> Type Description <code>    bool: True if the current statement is a region statement, False otherwise.</code> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def get_is_region(self) -&gt; bool:\n    \"\"\"Check if the current statement is a region statement.\n\n    Returns\n    -------\n        bool: True if the current statement is a region statement, False otherwise.\n\n    \"\"\"\n    return self.is_region\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2DrawFlags.set_is_region","title":"set_is_region","text":"<pre><code>set_is_region(val: bool) -&gt; State2DrawFlags\n</code></pre> <p>Set the flag indicating whether the current statement is a region statement.</p> Args: <pre><code>val (bool): True if the current statement is a region statement, False\notherwise.\n</code></pre> Returns: <pre><code>State2DrawFlags: A new instance of State2DrawFlags with the updated flag.\n</code></pre> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def set_is_region(self, val: bool) -&gt; State2DrawFlags:  # noqa: FBT001\n    \"\"\"Set the flag indicating whether the current statement is a region statement.\n\n    Args:\n    ----\n        val (bool): True if the current statement is a region statement, False\n        otherwise.\n\n    Returns:\n    -------\n        State2DrawFlags: A new instance of State2DrawFlags with the updated flag.\n\n    \"\"\"\n    return self.model_copy(\n        update={\n            \"is_region\": val,\n        },\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2DrawFlags.get_is_aperture_block","title":"get_is_aperture_block","text":"<pre><code>get_is_aperture_block() -&gt; bool\n</code></pre> <p>Check if the current statement is an aperture block statement.</p> <p>Returns:</p> Type Description <code>    bool: True if the current statement is an aperture block statement, False</code> <p>otherwise.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def get_is_aperture_block(self) -&gt; bool:\n    \"\"\"Check if the current statement is an aperture block statement.\n\n    Returns\n    -------\n        bool: True if the current statement is an aperture block statement, False\n        otherwise.\n\n    \"\"\"\n    return self.is_aperture_block\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2DrawFlags.set_is_aperture_block","title":"set_is_aperture_block","text":"<pre><code>set_is_aperture_block(val: bool) -&gt; State2DrawFlags\n</code></pre> <p>Set the flag indicating whether the current statement is an aperture block statement.</p> Args: <pre><code>val (bool): True if the current statement is an aperture block statement,\nFalse otherwise.\n</code></pre> Returns: <pre><code>State2DrawFlags: A new instance of State2DrawFlags with the updated flag.\n</code></pre> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def set_is_aperture_block(self, val: bool) -&gt; State2DrawFlags:  # noqa: FBT001\n    \"\"\"Set the flag indicating whether the current statement is an aperture block\n    statement.\n\n    Args:\n    ----\n        val (bool): True if the current statement is an aperture block statement,\n        False otherwise.\n\n    Returns:\n    -------\n        State2DrawFlags: A new instance of State2DrawFlags with the updated flag.\n\n    \"\"\"\n    return self.model_copy(\n        update={\n            \"is_aperture_block\": val,\n        },\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2DrawFlags.get_aperture_block_id","title":"get_aperture_block_id","text":"<pre><code>get_aperture_block_id() -&gt; Optional[ApertureID]\n</code></pre> <p>Get the ID of the current aperture block.</p> <p>This method returns the ID of the current aperture block.</p> <p>Returns:</p> Type Description <code>Optional[ApertureID]</code> <p>The ID of the current aperture block, or None if no aperture block is set.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def get_aperture_block_id(self) -&gt; Optional[ApertureID]:\n    \"\"\"Get the ID of the current aperture block.\n\n    This method returns the ID of the current aperture block.\n\n    Returns\n    -------\n    Optional[ApertureID]\n        The ID of the current aperture block, or None if no aperture block is set.\n    \"\"\"\n    return self.aperture_block_id\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2DrawFlags.set_aperture_block_id","title":"set_aperture_block_id","text":"<pre><code>set_aperture_block_id(\n    aperture_block_id: Optional[ApertureID],\n) -&gt; State2DrawFlags\n</code></pre> <p>Set the ID of the current aperture block.</p> <p>This method sets the ID of the current aperture block.</p> <p>Parameters:</p> Name Type Description Default <code>aperture_block_id</code> <code>Optional[ApertureID]</code> <p>The ID of the current aperture block.</p> required <p>Returns:</p> Type Description <code>State2DrawFlags</code> <p>A new instance of the State2DrawFlags with the updated flag.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def set_aperture_block_id(\n    self,\n    aperture_block_id: Optional[ApertureID],\n) -&gt; State2DrawFlags:\n    \"\"\"Set the ID of the current aperture block.\n\n    This method sets the ID of the current aperture block.\n\n    Parameters\n    ----------\n    aperture_block_id : Optional[ApertureID]\n        The ID of the current aperture block.\n\n    Returns\n    -------\n    State2DrawFlags\n        A new instance of the State2DrawFlags with the updated flag.\n    \"\"\"\n    return self.model_copy(\n        update={\n            \"aperture_block_id\": aperture_block_id,\n        },\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2DrawFlags.get_is_multi_quadrant","title":"get_is_multi_quadrant","text":"<pre><code>get_is_multi_quadrant() -&gt; bool\n</code></pre> <p>Check if the multi-quadrant mode is enabled.</p> <p>Returns:</p> Type Description <code>    bool: True if the multi-quadrant mode is enabled, False otherwise.</code> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def get_is_multi_quadrant(self) -&gt; bool:\n    \"\"\"Check if the multi-quadrant mode is enabled.\n\n    Returns\n    -------\n        bool: True if the multi-quadrant mode is enabled, False otherwise.\n\n    \"\"\"\n    return self.is_multi_quadrant\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2DrawFlags.set_is_multi_quadrant","title":"set_is_multi_quadrant","text":"<pre><code>set_is_multi_quadrant(val: bool) -&gt; Self\n</code></pre> <p>Set the flag indicating whether the multi-quadrant mode is enabled.</p> Args: <pre><code>val (bool): True to enable the multi-quadrant mode, False to disable it.\n</code></pre> Returns: <pre><code>State2DrawFlags: A new instance of State2DrawFlags with the updated flag.\n</code></pre> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def set_is_multi_quadrant(self, val: bool) -&gt; Self:  # noqa: FBT001\n    \"\"\"Set the flag indicating whether the multi-quadrant mode is enabled.\n\n    Args:\n    ----\n        val (bool): True to enable the multi-quadrant mode, False to disable it.\n\n    Returns:\n    -------\n        State2DrawFlags: A new instance of State2DrawFlags with the updated flag.\n\n    \"\"\"\n    return self.model_copy(\n        update={\n            \"is_multi_quadrant\": val,\n        },\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.StepAndRepeatState2","title":"StepAndRepeatState2","text":"<p>             Bases: <code>FrozenGeneralModel</code></p> <p>Step and Repeat state maintainer.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>class StepAndRepeatState2(FrozenGeneralModel):\n    \"\"\"Step and Repeat state maintainer.\"\"\"\n\n    is_step_and_repeat: bool = False\n    \"\"\"Indicates whether the current statement is a step and repeat statement.\"\"\"\n\n    x_repeat: int = 0\n    \"\"\"Number of repeats in the X direction.\"\"\"\n\n    y_repeat: int = 0\n    \"\"\"Number of repeats in the Y direction.\"\"\"\n\n    x_step: Offset = Offset.NULL\n    \"\"\"Step repeat distance in X direction.\"\"\"\n\n    y_step: Offset = Offset.NULL\n    \"\"\"Step repeat distance in Y direction.\"\"\"\n\n    def get_is_step_and_repeat(self) -&gt; bool:\n        \"\"\"Check if the current statement is a step and repeat statement.\n\n        Returns\n        -------\n            bool: True if the current statement is a step and repeat statement, False\n            otherwise.\n\n        \"\"\"\n        return self.is_step_and_repeat\n\n    def set_is_step_and_repeat(self, val: bool) -&gt; StepAndRepeatState2:  # noqa: FBT001\n        \"\"\"Set the flag indicating whether the current statement is a step and repeat\n        statement.\n\n        Args:\n        ----\n            val (bool): True if the current statement is a step and repeat statement,\n            False otherwise.\n\n        Returns:\n        -------\n            State2DrawFlags: A new instance of State2DrawFlags with the updated flag.\n\n        \"\"\"\n        return self.model_copy(\n            update={\n                \"is_step_and_repeat\": val,\n            },\n        )\n\n    def get_x_repeat(self) -&gt; int:\n        \"\"\"Get x_repeat property value.\"\"\"\n        return self.x_repeat\n\n    def set_x_repeat(self, val: int) -&gt; StepAndRepeatState2:\n        \"\"\"Set the x_repeat property value.\"\"\"\n        return self.model_copy(\n            update={\n                \"x_repeat\": val,\n            },\n        )\n\n    def get_y_repeat(self) -&gt; int:\n        \"\"\"Get y_repeat property value.\"\"\"\n        return self.y_repeat\n\n    def set_y_repeat(self, val: int) -&gt; StepAndRepeatState2:\n        \"\"\"Set the y_repeat property value.\"\"\"\n        return self.model_copy(\n            update={\n                \"y_repeat\": val,\n            },\n        )\n\n    def get_x_step(self) -&gt; Offset:\n        \"\"\"Get x_step property value.\"\"\"\n        return self.x_step\n\n    def set_x_step(self, val: Offset) -&gt; StepAndRepeatState2:\n        \"\"\"Set the x_step property value.\"\"\"\n        return self.model_copy(\n            update={\n                \"x_step\": val,\n            },\n        )\n\n    def get_y_step(self) -&gt; Offset:\n        \"\"\"Get y_step property value.\"\"\"\n        return self.y_step\n\n    def set_y_step(self, val: Offset) -&gt; Self:\n        \"\"\"Set the y_step property value.\"\"\"\n        return self.model_copy(\n            update={\n                \"y_step\": val,\n            },\n        )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.StepAndRepeatState2.is_step_and_repeat","title":"is_step_and_repeat  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>is_step_and_repeat: bool = False\n</code></pre> <p>Indicates whether the current statement is a step and repeat statement.</p>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.StepAndRepeatState2.x_repeat","title":"x_repeat  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>x_repeat: int = 0\n</code></pre> <p>Number of repeats in the X direction.</p>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.StepAndRepeatState2.y_repeat","title":"y_repeat  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>y_repeat: int = 0\n</code></pre> <p>Number of repeats in the Y direction.</p>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.StepAndRepeatState2.x_step","title":"x_step  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>x_step: Offset = NULL\n</code></pre> <p>Step repeat distance in X direction.</p>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.StepAndRepeatState2.y_step","title":"y_step  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>y_step: Offset = NULL\n</code></pre> <p>Step repeat distance in Y direction.</p>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.StepAndRepeatState2.get_is_step_and_repeat","title":"get_is_step_and_repeat","text":"<pre><code>get_is_step_and_repeat() -&gt; bool\n</code></pre> <p>Check if the current statement is a step and repeat statement.</p> <p>Returns:</p> Type Description <code>    bool: True if the current statement is a step and repeat statement, False</code> <p>otherwise.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def get_is_step_and_repeat(self) -&gt; bool:\n    \"\"\"Check if the current statement is a step and repeat statement.\n\n    Returns\n    -------\n        bool: True if the current statement is a step and repeat statement, False\n        otherwise.\n\n    \"\"\"\n    return self.is_step_and_repeat\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.StepAndRepeatState2.set_is_step_and_repeat","title":"set_is_step_and_repeat","text":"<pre><code>set_is_step_and_repeat(val: bool) -&gt; StepAndRepeatState2\n</code></pre> <p>Set the flag indicating whether the current statement is a step and repeat statement.</p> Args: <pre><code>val (bool): True if the current statement is a step and repeat statement,\nFalse otherwise.\n</code></pre> Returns: <pre><code>State2DrawFlags: A new instance of State2DrawFlags with the updated flag.\n</code></pre> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def set_is_step_and_repeat(self, val: bool) -&gt; StepAndRepeatState2:  # noqa: FBT001\n    \"\"\"Set the flag indicating whether the current statement is a step and repeat\n    statement.\n\n    Args:\n    ----\n        val (bool): True if the current statement is a step and repeat statement,\n        False otherwise.\n\n    Returns:\n    -------\n        State2DrawFlags: A new instance of State2DrawFlags with the updated flag.\n\n    \"\"\"\n    return self.model_copy(\n        update={\n            \"is_step_and_repeat\": val,\n        },\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.StepAndRepeatState2.get_x_repeat","title":"get_x_repeat","text":"<pre><code>get_x_repeat() -&gt; int\n</code></pre> <p>Get x_repeat property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def get_x_repeat(self) -&gt; int:\n    \"\"\"Get x_repeat property value.\"\"\"\n    return self.x_repeat\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.StepAndRepeatState2.set_x_repeat","title":"set_x_repeat","text":"<pre><code>set_x_repeat(val: int) -&gt; StepAndRepeatState2\n</code></pre> <p>Set the x_repeat property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def set_x_repeat(self, val: int) -&gt; StepAndRepeatState2:\n    \"\"\"Set the x_repeat property value.\"\"\"\n    return self.model_copy(\n        update={\n            \"x_repeat\": val,\n        },\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.StepAndRepeatState2.get_y_repeat","title":"get_y_repeat","text":"<pre><code>get_y_repeat() -&gt; int\n</code></pre> <p>Get y_repeat property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def get_y_repeat(self) -&gt; int:\n    \"\"\"Get y_repeat property value.\"\"\"\n    return self.y_repeat\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.StepAndRepeatState2.set_y_repeat","title":"set_y_repeat","text":"<pre><code>set_y_repeat(val: int) -&gt; StepAndRepeatState2\n</code></pre> <p>Set the y_repeat property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def set_y_repeat(self, val: int) -&gt; StepAndRepeatState2:\n    \"\"\"Set the y_repeat property value.\"\"\"\n    return self.model_copy(\n        update={\n            \"y_repeat\": val,\n        },\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.StepAndRepeatState2.get_x_step","title":"get_x_step","text":"<pre><code>get_x_step() -&gt; Offset\n</code></pre> <p>Get x_step property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def get_x_step(self) -&gt; Offset:\n    \"\"\"Get x_step property value.\"\"\"\n    return self.x_step\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.StepAndRepeatState2.set_x_step","title":"set_x_step","text":"<pre><code>set_x_step(val: Offset) -&gt; StepAndRepeatState2\n</code></pre> <p>Set the x_step property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def set_x_step(self, val: Offset) -&gt; StepAndRepeatState2:\n    \"\"\"Set the x_step property value.\"\"\"\n    return self.model_copy(\n        update={\n            \"x_step\": val,\n        },\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.StepAndRepeatState2.get_y_step","title":"get_y_step","text":"<pre><code>get_y_step() -&gt; Offset\n</code></pre> <p>Get y_step property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def get_y_step(self) -&gt; Offset:\n    \"\"\"Get y_step property value.\"\"\"\n    return self.y_step\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.StepAndRepeatState2.set_y_step","title":"set_y_step","text":"<pre><code>set_y_step(val: Offset) -&gt; Self\n</code></pre> <p>Set the y_step property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def set_y_step(self, val: Offset) -&gt; Self:\n    \"\"\"Set the y_step property value.\"\"\"\n    return self.model_copy(\n        update={\n            \"y_step\": val,\n        },\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2","title":"State2","text":"<p>             Bases: <code>FrozenGeneralModel</code></p> <p>Gerber AST parser, version 2, parsing state.</p> <p>This object is immutable and intended way to update the state is through setters which return updated copy of state.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>class State2(FrozenGeneralModel):\n    \"\"\"Gerber AST parser, version 2, parsing state.\n\n    This object is immutable and intended way to update the state is through setters\n    which return updated copy of state.\n    \"\"\"\n\n    constants: State2Constants = Field(default_factory=State2Constants)\n    \"\"\"Collection of rarely changing Gerber state constants.\"\"\"\n\n    def get_constants(self) -&gt; State2Constants:\n        \"\"\"Get constants property value.\"\"\"\n        return self.constants\n\n    def set_constants(self, constants: State2Constants) -&gt; Self:\n        \"\"\"Set the constants property value.\"\"\"\n        return self.model_copy(\n            update={\n                \"constants\": constants,\n            },\n        )\n\n    def get_draw_units(self) -&gt; Unit:\n        \"\"\"Get draw_units property value.\"\"\"\n        return self.get_constants().get_draw_units()\n\n    def set_draw_units(self, draw_units: Unit) -&gt; Self:\n        \"\"\"Set the draw_units property value.\"\"\"\n        return self.set_constants(self.get_constants().set_draw_units(draw_units))\n\n    def get_coordinate_parser(self) -&gt; CoordinateParser:\n        \"\"\"Get coordinate_parser property value.\"\"\"\n        return self.get_constants().get_coordinate_parser()\n\n    def set_coordinate_parser(self, coordinate_parser: CoordinateParser) -&gt; Self:\n        \"\"\"Set the coordinate_parser property value.\"\"\"\n        return self.set_constants(\n            self.get_constants().set_coordinate_parser(coordinate_parser),\n        )\n\n    aperture_transform: ApertureTransform = Field(default_factory=ApertureTransform)\n\n    def get_aperture_transform(self) -&gt; ApertureTransform:\n        \"\"\"Get aperture_transform property value.\"\"\"\n        return self.aperture_transform\n\n    def set_aperture_transform(self, aperture_transform: ApertureTransform) -&gt; Self:\n        \"\"\"Set the aperture_transform property value.\"\"\"\n        return self.model_copy(\n            update={\n                \"aperture_transform\": aperture_transform,\n            },\n        )\n\n    def get_polarity(self) -&gt; Polarity:\n        \"\"\"Get polarity property value.\"\"\"\n        return self.get_aperture_transform().get_polarity()\n\n    def set_polarity(self, polarity: Polarity) -&gt; Self:\n        \"\"\"Set the polarity property value.\"\"\"\n        return self.set_aperture_transform(\n            self.get_aperture_transform().set_polarity(polarity),\n        )\n\n    def get_mirroring(self) -&gt; Mirroring:\n        \"\"\"Get mirroring property value.\"\"\"\n        return self.get_aperture_transform().get_mirroring()\n\n    def set_mirroring(self, mirroring: Mirroring) -&gt; Self:\n        \"\"\"Set the mirroring property value.\"\"\"\n        return self.set_aperture_transform(\n            self.get_aperture_transform().set_mirroring(mirroring),\n        )\n\n    def get_rotation(self) -&gt; Decimal:\n        \"\"\"Get rotation property value.\"\"\"\n        return self.get_aperture_transform().get_rotation()\n\n    def set_rotation(self, rotation: Decimal) -&gt; Self:\n        \"\"\"Set the rotation property value.\"\"\"\n        return self.set_aperture_transform(\n            self.get_aperture_transform().set_rotation(rotation),\n        )\n\n    def get_scaling(self) -&gt; Decimal:\n        \"\"\"Get scaling property value.\"\"\"\n        return self.get_aperture_transform().get_scaling()\n\n    def set_scaling(self, scaling: Decimal) -&gt; Self:\n        \"\"\"Set the scaling property value.\"\"\"\n        return self.set_aperture_transform(\n            self.get_aperture_transform().set_scaling(scaling),\n        )\n\n    def get_is_output_image_negation_required(self) -&gt; bool:\n        \"\"\"Get is_output_image_negation_required property value.\"\"\"\n        return self.get_constants().get_is_output_image_negation_required()\n\n    def set_is_output_image_negation_required(\n        self,\n        value: bool,  # noqa: FBT001\n    ) -&gt; Self:\n        \"\"\"Set the is_output_image_negation_required property value.\"\"\"\n        return self.set_constants(\n            self.get_constants().set_is_output_image_negation_required(value),\n        )\n\n    def get_image_name(self) -&gt; Optional[str]:\n        \"\"\"Get image_name property value.\"\"\"\n        return self.get_constants().get_image_name()\n\n    def set_image_name(self, image_name: Optional[str]) -&gt; Self:\n        \"\"\"Set the image_name property value.\"\"\"\n        return self.set_constants(self.get_constants().set_image_name(image_name))\n\n    def get_file_name(self) -&gt; Optional[str]:\n        \"\"\"Get file_name property value.\"\"\"\n        return self.get_constants().get_file_name()\n\n    def set_file_name(self, file_name: Optional[str]) -&gt; Self:\n        \"\"\"Set the file_name property value.\"\"\"\n        return self.set_constants(self.get_constants().set_file_name(file_name))\n\n    def get_axis_correspondence(self) -&gt; AxisCorrespondence:\n        \"\"\"Get token axis correspondence property value.\"\"\"\n        return self.get_constants().get_axis_correspondence()\n\n    def set_axis_correspondence(self, axis_correspondence: AxisCorrespondence) -&gt; Self:\n        \"\"\"Set token axis correspondence property value.\"\"\"\n        return self.set_constants(\n            self.get_constants().set_axis_correspondence(axis_correspondence),\n        )\n\n    flags: State2DrawFlags = Field(default_factory=State2DrawFlags)\n    \"\"\"Collection of more often changing Gerber state flags.\"\"\"\n\n    def get_flags(self) -&gt; State2DrawFlags:\n        \"\"\"Get flags property value.\"\"\"\n        return self.flags\n\n    def set_flags(self, flags: State2DrawFlags) -&gt; Self:\n        \"\"\"Set the flags property value.\"\"\"\n        return self.model_copy(\n            update={\n                \"flags\": flags,\n            },\n        )\n\n    def get_draw_mode(self) -&gt; DrawMode:\n        \"\"\"Get draw_mode property value.\"\"\"\n        return self.get_flags().get_draw_mode()\n\n    def set_draw_mode(self, draw_mode: DrawMode) -&gt; Self:\n        \"\"\"Set the draw_mode property value.\"\"\"\n        return self.set_flags(self.get_flags().set_draw_mode(draw_mode))\n\n    def get_is_region(self) -&gt; bool:\n        \"\"\"Get is_region property value.\"\"\"\n        return self.get_flags().get_is_region()\n\n    def set_is_region(self, is_region: bool) -&gt; Self:  # noqa: FBT001\n        \"\"\"Set the is_region property value.\"\"\"\n        return self.set_flags(self.get_flags().set_is_region(is_region))\n\n    def get_is_aperture_block(self) -&gt; bool:\n        \"\"\"Get is_aperture_block property value.\"\"\"\n        return self.get_flags().get_is_aperture_block()\n\n    def set_is_aperture_block(self, is_aperture_block: bool) -&gt; Self:  # noqa: FBT001\n        \"\"\"Set the is_aperture_block property value.\"\"\"\n        return self.set_flags(\n            self.get_flags().set_is_aperture_block(is_aperture_block),\n        )\n\n    def get_aperture_block_id(self) -&gt; Optional[ApertureID]:\n        \"\"\"Get aperture_block_id property value.\"\"\"\n        return self.get_flags().get_aperture_block_id()\n\n    def set_aperture_block_id(self, aperture_block_id: Optional[ApertureID]) -&gt; Self:\n        \"\"\"Set the aperture_block_id property value.\"\"\"\n        return self.set_flags(\n            self.get_flags().set_aperture_block_id(aperture_block_id),\n        )\n\n    def get_is_multi_quadrant(self) -&gt; bool:\n        \"\"\"Get is_aperture_block property value.\"\"\"\n        return self.get_flags().get_is_multi_quadrant()\n\n    def set_is_multi_quadrant(self, is_multi_quadrant: bool) -&gt; Self:  # noqa: FBT001\n        \"\"\"Set the is_aperture_block property value.\"\"\"\n        return self.set_flags(\n            self.get_flags().set_is_multi_quadrant(is_multi_quadrant),\n        )\n\n    step_repeat: StepAndRepeatState2 = Field(default_factory=StepAndRepeatState2)\n\n    def get_step_and_repeat(self) -&gt; StepAndRepeatState2:\n        \"\"\"Get step_repeat property value.\"\"\"\n        return self.step_repeat\n\n    def set_step_and_repeat(self, step_and_repeat: StepAndRepeatState2) -&gt; Self:\n        \"\"\"Set step_repeat property value.\"\"\"\n        return self.model_copy(\n            update={\n                \"step_repeat\": step_and_repeat,\n            },\n        )\n\n    def get_is_step_and_repeat(self) -&gt; bool:\n        \"\"\"Get is_step_and_repeat property value.\"\"\"\n        return self.get_step_and_repeat().get_is_step_and_repeat()\n\n    def set_is_step_and_repeat(self, is_step_and_repeat: bool) -&gt; Self:  # noqa: FBT001\n        \"\"\"Set the is_step_and_repeat property value.\"\"\"\n        return self.set_step_and_repeat(\n            self.get_step_and_repeat().set_is_step_and_repeat(is_step_and_repeat),\n        )\n\n    def get_x_repeat(self) -&gt; int:\n        \"\"\"Get x_repeat property value.\"\"\"\n        return self.get_step_and_repeat().get_x_repeat()\n\n    def set_x_repeat(self, value: int) -&gt; Self:\n        \"\"\"Set the x_repeat property value.\"\"\"\n        return self.set_step_and_repeat(\n            self.get_step_and_repeat().set_x_repeat(value),\n        )\n\n    def get_y_repeat(self) -&gt; int:\n        \"\"\"Get y_repeat property value.\"\"\"\n        return self.get_step_and_repeat().get_y_repeat()\n\n    def set_y_repeat(self, value: int) -&gt; Self:\n        \"\"\"Set the y_repeat property value.\"\"\"\n        return self.set_step_and_repeat(\n            self.get_step_and_repeat().set_y_repeat(value),\n        )\n\n    def get_x_step(self) -&gt; Offset:\n        \"\"\"Get x_step property value.\"\"\"\n        return self.get_step_and_repeat().get_x_step()\n\n    def set_x_step(self, value: Offset) -&gt; Self:\n        \"\"\"Set the x_repeat property value.\"\"\"\n        return self.set_step_and_repeat(\n            self.get_step_and_repeat().set_x_step(value),\n        )\n\n    def get_y_step(self) -&gt; Offset:\n        \"\"\"Get y_step property value.\"\"\"\n        return self.get_step_and_repeat().get_y_step()\n\n    def set_y_step(self, value: Offset) -&gt; Self:\n        \"\"\"Set the y_repeat property value.\"\"\"\n        return self.set_step_and_repeat(\n            self.get_step_and_repeat().set_y_step(value),\n        )\n\n    current_position: Vector2D = Vector2D(x=Offset.NULL, y=Offset.NULL)\n    \"\"\"Current position of drawing head.\"\"\"\n\n    def get_current_position(self) -&gt; Vector2D:\n        \"\"\"Get current_position property value.\"\"\"\n        return self.current_position\n\n    def set_current_position(self, current_position: Vector2D) -&gt; Self:\n        \"\"\"Set the current_position property value.\"\"\"\n        return self.model_copy(\n            update={\n                \"current_position\": current_position,\n            },\n        )\n\n    current_aperture_id: Optional[ApertureID] = None\n    \"\"\"Reference to currently selected aperture.\"\"\"\n\n    def get_current_aperture_id(self) -&gt; Optional[ApertureID]:\n        \"\"\"Get current_aperture property value.\"\"\"\n        return self.current_aperture_id\n\n    def set_current_aperture_id(self, current_aperture: Optional[ApertureID]) -&gt; Self:\n        \"\"\"Set the current_aperture property value.\"\"\"\n        return self.model_copy(\n            update={\n                \"current_aperture_id\": current_aperture,\n            },\n        )\n\n    macros: State2MacroIndex = Field(default_factory=State2MacroIndex)\n    \"\"\"Collection of all macros defined until given point in code.\"\"\"\n\n    def get_macro(self, __key: str) -&gt; ApertureMacro2:\n        \"\"\"Get macros property value.\"\"\"\n        return self.macros.get_macro(__key)\n\n    def set_macro(self, __key: str, __value: ApertureMacro2) -&gt; Self:\n        \"\"\"Set the macros property value.\"\"\"\n        return self.model_copy(\n            update={\n                \"macros\": self.macros.set_macro(__key, __value),\n            },\n        )\n\n    def parse_coordinate(self, coordinate: Coordinate) -&gt; Offset:\n        \"\"\"Parse a coordinate and convert it to an Offset.\n\n        This method parses a given coordinate and converts it to an Offset object.\n        It handles missing X, Y by substituting them with the current\n        position and missing I, J by substituting them with NULL offset.\n\n        Parameters\n        ----------\n        coordinate : Coordinate\n            The coordinate to be parsed.\n\n        Returns\n        -------\n        Offset\n            The parsed coordinate converted to an Offset object.\n        \"\"\"\n        if coordinate.coordinate_type == CoordinateType.MISSING_X:\n            return self.current_position.x\n\n        if coordinate.coordinate_type == CoordinateType.MISSING_Y:\n            return self.current_position.y\n\n        if coordinate.coordinate_type == CoordinateType.MISSING_I:\n            return Offset.NULL\n\n        if coordinate.coordinate_type == CoordinateType.MISSING_J:\n            return Offset.NULL\n\n        return Offset.new(\n            self.get_coordinate_parser().parse(coordinate),\n            unit=self.get_draw_units(),\n        )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2.constants","title":"constants  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>constants: State2Constants = Field(\n    default_factory=State2Constants\n)\n</code></pre> <p>Collection of rarely changing Gerber state constants.</p>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2.flags","title":"flags  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>flags: State2DrawFlags = Field(\n    default_factory=State2DrawFlags\n)\n</code></pre> <p>Collection of more often changing Gerber state flags.</p>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2.current_position","title":"current_position  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>current_position: Vector2D = Vector2D(x=NULL, y=NULL)\n</code></pre> <p>Current position of drawing head.</p>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2.current_aperture_id","title":"current_aperture_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>current_aperture_id: Optional[ApertureID] = None\n</code></pre> <p>Reference to currently selected aperture.</p>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2.macros","title":"macros  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>macros: State2MacroIndex = Field(\n    default_factory=State2MacroIndex\n)\n</code></pre> <p>Collection of all macros defined until given point in code.</p>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2.get_constants","title":"get_constants","text":"<pre><code>get_constants() -&gt; State2Constants\n</code></pre> <p>Get constants property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def get_constants(self) -&gt; State2Constants:\n    \"\"\"Get constants property value.\"\"\"\n    return self.constants\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2.set_constants","title":"set_constants","text":"<pre><code>set_constants(constants: State2Constants) -&gt; Self\n</code></pre> <p>Set the constants property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def set_constants(self, constants: State2Constants) -&gt; Self:\n    \"\"\"Set the constants property value.\"\"\"\n    return self.model_copy(\n        update={\n            \"constants\": constants,\n        },\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2.get_draw_units","title":"get_draw_units","text":"<pre><code>get_draw_units() -&gt; Unit\n</code></pre> <p>Get draw_units property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def get_draw_units(self) -&gt; Unit:\n    \"\"\"Get draw_units property value.\"\"\"\n    return self.get_constants().get_draw_units()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2.set_draw_units","title":"set_draw_units","text":"<pre><code>set_draw_units(draw_units: Unit) -&gt; Self\n</code></pre> <p>Set the draw_units property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def set_draw_units(self, draw_units: Unit) -&gt; Self:\n    \"\"\"Set the draw_units property value.\"\"\"\n    return self.set_constants(self.get_constants().set_draw_units(draw_units))\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2.get_coordinate_parser","title":"get_coordinate_parser","text":"<pre><code>get_coordinate_parser() -&gt; CoordinateParser\n</code></pre> <p>Get coordinate_parser property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def get_coordinate_parser(self) -&gt; CoordinateParser:\n    \"\"\"Get coordinate_parser property value.\"\"\"\n    return self.get_constants().get_coordinate_parser()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2.set_coordinate_parser","title":"set_coordinate_parser","text":"<pre><code>set_coordinate_parser(\n    coordinate_parser: CoordinateParser,\n) -&gt; Self\n</code></pre> <p>Set the coordinate_parser property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def set_coordinate_parser(self, coordinate_parser: CoordinateParser) -&gt; Self:\n    \"\"\"Set the coordinate_parser property value.\"\"\"\n    return self.set_constants(\n        self.get_constants().set_coordinate_parser(coordinate_parser),\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2.get_aperture_transform","title":"get_aperture_transform","text":"<pre><code>get_aperture_transform() -&gt; ApertureTransform\n</code></pre> <p>Get aperture_transform property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def get_aperture_transform(self) -&gt; ApertureTransform:\n    \"\"\"Get aperture_transform property value.\"\"\"\n    return self.aperture_transform\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2.set_aperture_transform","title":"set_aperture_transform","text":"<pre><code>set_aperture_transform(\n    aperture_transform: ApertureTransform,\n) -&gt; Self\n</code></pre> <p>Set the aperture_transform property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def set_aperture_transform(self, aperture_transform: ApertureTransform) -&gt; Self:\n    \"\"\"Set the aperture_transform property value.\"\"\"\n    return self.model_copy(\n        update={\n            \"aperture_transform\": aperture_transform,\n        },\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2.get_polarity","title":"get_polarity","text":"<pre><code>get_polarity() -&gt; Polarity\n</code></pre> <p>Get polarity property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def get_polarity(self) -&gt; Polarity:\n    \"\"\"Get polarity property value.\"\"\"\n    return self.get_aperture_transform().get_polarity()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2.set_polarity","title":"set_polarity","text":"<pre><code>set_polarity(polarity: Polarity) -&gt; Self\n</code></pre> <p>Set the polarity property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def set_polarity(self, polarity: Polarity) -&gt; Self:\n    \"\"\"Set the polarity property value.\"\"\"\n    return self.set_aperture_transform(\n        self.get_aperture_transform().set_polarity(polarity),\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2.get_mirroring","title":"get_mirroring","text":"<pre><code>get_mirroring() -&gt; Mirroring\n</code></pre> <p>Get mirroring property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def get_mirroring(self) -&gt; Mirroring:\n    \"\"\"Get mirroring property value.\"\"\"\n    return self.get_aperture_transform().get_mirroring()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2.set_mirroring","title":"set_mirroring","text":"<pre><code>set_mirroring(mirroring: Mirroring) -&gt; Self\n</code></pre> <p>Set the mirroring property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def set_mirroring(self, mirroring: Mirroring) -&gt; Self:\n    \"\"\"Set the mirroring property value.\"\"\"\n    return self.set_aperture_transform(\n        self.get_aperture_transform().set_mirroring(mirroring),\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2.get_rotation","title":"get_rotation","text":"<pre><code>get_rotation() -&gt; Decimal\n</code></pre> <p>Get rotation property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def get_rotation(self) -&gt; Decimal:\n    \"\"\"Get rotation property value.\"\"\"\n    return self.get_aperture_transform().get_rotation()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2.set_rotation","title":"set_rotation","text":"<pre><code>set_rotation(rotation: Decimal) -&gt; Self\n</code></pre> <p>Set the rotation property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def set_rotation(self, rotation: Decimal) -&gt; Self:\n    \"\"\"Set the rotation property value.\"\"\"\n    return self.set_aperture_transform(\n        self.get_aperture_transform().set_rotation(rotation),\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2.get_scaling","title":"get_scaling","text":"<pre><code>get_scaling() -&gt; Decimal\n</code></pre> <p>Get scaling property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def get_scaling(self) -&gt; Decimal:\n    \"\"\"Get scaling property value.\"\"\"\n    return self.get_aperture_transform().get_scaling()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2.set_scaling","title":"set_scaling","text":"<pre><code>set_scaling(scaling: Decimal) -&gt; Self\n</code></pre> <p>Set the scaling property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def set_scaling(self, scaling: Decimal) -&gt; Self:\n    \"\"\"Set the scaling property value.\"\"\"\n    return self.set_aperture_transform(\n        self.get_aperture_transform().set_scaling(scaling),\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2.get_is_output_image_negation_required","title":"get_is_output_image_negation_required","text":"<pre><code>get_is_output_image_negation_required() -&gt; bool\n</code></pre> <p>Get is_output_image_negation_required property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def get_is_output_image_negation_required(self) -&gt; bool:\n    \"\"\"Get is_output_image_negation_required property value.\"\"\"\n    return self.get_constants().get_is_output_image_negation_required()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2.set_is_output_image_negation_required","title":"set_is_output_image_negation_required","text":"<pre><code>set_is_output_image_negation_required(value: bool) -&gt; Self\n</code></pre> <p>Set the is_output_image_negation_required property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def set_is_output_image_negation_required(\n    self,\n    value: bool,  # noqa: FBT001\n) -&gt; Self:\n    \"\"\"Set the is_output_image_negation_required property value.\"\"\"\n    return self.set_constants(\n        self.get_constants().set_is_output_image_negation_required(value),\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2.get_image_name","title":"get_image_name","text":"<pre><code>get_image_name() -&gt; Optional[str]\n</code></pre> <p>Get image_name property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def get_image_name(self) -&gt; Optional[str]:\n    \"\"\"Get image_name property value.\"\"\"\n    return self.get_constants().get_image_name()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2.set_image_name","title":"set_image_name","text":"<pre><code>set_image_name(image_name: Optional[str]) -&gt; Self\n</code></pre> <p>Set the image_name property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def set_image_name(self, image_name: Optional[str]) -&gt; Self:\n    \"\"\"Set the image_name property value.\"\"\"\n    return self.set_constants(self.get_constants().set_image_name(image_name))\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2.get_file_name","title":"get_file_name","text":"<pre><code>get_file_name() -&gt; Optional[str]\n</code></pre> <p>Get file_name property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def get_file_name(self) -&gt; Optional[str]:\n    \"\"\"Get file_name property value.\"\"\"\n    return self.get_constants().get_file_name()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2.set_file_name","title":"set_file_name","text":"<pre><code>set_file_name(file_name: Optional[str]) -&gt; Self\n</code></pre> <p>Set the file_name property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def set_file_name(self, file_name: Optional[str]) -&gt; Self:\n    \"\"\"Set the file_name property value.\"\"\"\n    return self.set_constants(self.get_constants().set_file_name(file_name))\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2.get_axis_correspondence","title":"get_axis_correspondence","text":"<pre><code>get_axis_correspondence() -&gt; AxisCorrespondence\n</code></pre> <p>Get token axis correspondence property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def get_axis_correspondence(self) -&gt; AxisCorrespondence:\n    \"\"\"Get token axis correspondence property value.\"\"\"\n    return self.get_constants().get_axis_correspondence()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2.set_axis_correspondence","title":"set_axis_correspondence","text":"<pre><code>set_axis_correspondence(\n    axis_correspondence: AxisCorrespondence,\n) -&gt; Self\n</code></pre> <p>Set token axis correspondence property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def set_axis_correspondence(self, axis_correspondence: AxisCorrespondence) -&gt; Self:\n    \"\"\"Set token axis correspondence property value.\"\"\"\n    return self.set_constants(\n        self.get_constants().set_axis_correspondence(axis_correspondence),\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2.get_flags","title":"get_flags","text":"<pre><code>get_flags() -&gt; State2DrawFlags\n</code></pre> <p>Get flags property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def get_flags(self) -&gt; State2DrawFlags:\n    \"\"\"Get flags property value.\"\"\"\n    return self.flags\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2.set_flags","title":"set_flags","text":"<pre><code>set_flags(flags: State2DrawFlags) -&gt; Self\n</code></pre> <p>Set the flags property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def set_flags(self, flags: State2DrawFlags) -&gt; Self:\n    \"\"\"Set the flags property value.\"\"\"\n    return self.model_copy(\n        update={\n            \"flags\": flags,\n        },\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2.get_draw_mode","title":"get_draw_mode","text":"<pre><code>get_draw_mode() -&gt; DrawMode\n</code></pre> <p>Get draw_mode property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def get_draw_mode(self) -&gt; DrawMode:\n    \"\"\"Get draw_mode property value.\"\"\"\n    return self.get_flags().get_draw_mode()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2.set_draw_mode","title":"set_draw_mode","text":"<pre><code>set_draw_mode(draw_mode: DrawMode) -&gt; Self\n</code></pre> <p>Set the draw_mode property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def set_draw_mode(self, draw_mode: DrawMode) -&gt; Self:\n    \"\"\"Set the draw_mode property value.\"\"\"\n    return self.set_flags(self.get_flags().set_draw_mode(draw_mode))\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2.get_is_region","title":"get_is_region","text":"<pre><code>get_is_region() -&gt; bool\n</code></pre> <p>Get is_region property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def get_is_region(self) -&gt; bool:\n    \"\"\"Get is_region property value.\"\"\"\n    return self.get_flags().get_is_region()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2.set_is_region","title":"set_is_region","text":"<pre><code>set_is_region(is_region: bool) -&gt; Self\n</code></pre> <p>Set the is_region property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def set_is_region(self, is_region: bool) -&gt; Self:  # noqa: FBT001\n    \"\"\"Set the is_region property value.\"\"\"\n    return self.set_flags(self.get_flags().set_is_region(is_region))\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2.get_is_aperture_block","title":"get_is_aperture_block","text":"<pre><code>get_is_aperture_block() -&gt; bool\n</code></pre> <p>Get is_aperture_block property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def get_is_aperture_block(self) -&gt; bool:\n    \"\"\"Get is_aperture_block property value.\"\"\"\n    return self.get_flags().get_is_aperture_block()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2.set_is_aperture_block","title":"set_is_aperture_block","text":"<pre><code>set_is_aperture_block(is_aperture_block: bool) -&gt; Self\n</code></pre> <p>Set the is_aperture_block property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def set_is_aperture_block(self, is_aperture_block: bool) -&gt; Self:  # noqa: FBT001\n    \"\"\"Set the is_aperture_block property value.\"\"\"\n    return self.set_flags(\n        self.get_flags().set_is_aperture_block(is_aperture_block),\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2.get_aperture_block_id","title":"get_aperture_block_id","text":"<pre><code>get_aperture_block_id() -&gt; Optional[ApertureID]\n</code></pre> <p>Get aperture_block_id property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def get_aperture_block_id(self) -&gt; Optional[ApertureID]:\n    \"\"\"Get aperture_block_id property value.\"\"\"\n    return self.get_flags().get_aperture_block_id()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2.set_aperture_block_id","title":"set_aperture_block_id","text":"<pre><code>set_aperture_block_id(\n    aperture_block_id: Optional[ApertureID],\n) -&gt; Self\n</code></pre> <p>Set the aperture_block_id property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def set_aperture_block_id(self, aperture_block_id: Optional[ApertureID]) -&gt; Self:\n    \"\"\"Set the aperture_block_id property value.\"\"\"\n    return self.set_flags(\n        self.get_flags().set_aperture_block_id(aperture_block_id),\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2.get_is_multi_quadrant","title":"get_is_multi_quadrant","text":"<pre><code>get_is_multi_quadrant() -&gt; bool\n</code></pre> <p>Get is_aperture_block property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def get_is_multi_quadrant(self) -&gt; bool:\n    \"\"\"Get is_aperture_block property value.\"\"\"\n    return self.get_flags().get_is_multi_quadrant()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2.set_is_multi_quadrant","title":"set_is_multi_quadrant","text":"<pre><code>set_is_multi_quadrant(is_multi_quadrant: bool) -&gt; Self\n</code></pre> <p>Set the is_aperture_block property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def set_is_multi_quadrant(self, is_multi_quadrant: bool) -&gt; Self:  # noqa: FBT001\n    \"\"\"Set the is_aperture_block property value.\"\"\"\n    return self.set_flags(\n        self.get_flags().set_is_multi_quadrant(is_multi_quadrant),\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2.get_step_and_repeat","title":"get_step_and_repeat","text":"<pre><code>get_step_and_repeat() -&gt; StepAndRepeatState2\n</code></pre> <p>Get step_repeat property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def get_step_and_repeat(self) -&gt; StepAndRepeatState2:\n    \"\"\"Get step_repeat property value.\"\"\"\n    return self.step_repeat\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2.set_step_and_repeat","title":"set_step_and_repeat","text":"<pre><code>set_step_and_repeat(\n    step_and_repeat: StepAndRepeatState2,\n) -&gt; Self\n</code></pre> <p>Set step_repeat property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def set_step_and_repeat(self, step_and_repeat: StepAndRepeatState2) -&gt; Self:\n    \"\"\"Set step_repeat property value.\"\"\"\n    return self.model_copy(\n        update={\n            \"step_repeat\": step_and_repeat,\n        },\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2.get_is_step_and_repeat","title":"get_is_step_and_repeat","text":"<pre><code>get_is_step_and_repeat() -&gt; bool\n</code></pre> <p>Get is_step_and_repeat property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def get_is_step_and_repeat(self) -&gt; bool:\n    \"\"\"Get is_step_and_repeat property value.\"\"\"\n    return self.get_step_and_repeat().get_is_step_and_repeat()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2.set_is_step_and_repeat","title":"set_is_step_and_repeat","text":"<pre><code>set_is_step_and_repeat(is_step_and_repeat: bool) -&gt; Self\n</code></pre> <p>Set the is_step_and_repeat property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def set_is_step_and_repeat(self, is_step_and_repeat: bool) -&gt; Self:  # noqa: FBT001\n    \"\"\"Set the is_step_and_repeat property value.\"\"\"\n    return self.set_step_and_repeat(\n        self.get_step_and_repeat().set_is_step_and_repeat(is_step_and_repeat),\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2.get_x_repeat","title":"get_x_repeat","text":"<pre><code>get_x_repeat() -&gt; int\n</code></pre> <p>Get x_repeat property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def get_x_repeat(self) -&gt; int:\n    \"\"\"Get x_repeat property value.\"\"\"\n    return self.get_step_and_repeat().get_x_repeat()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2.set_x_repeat","title":"set_x_repeat","text":"<pre><code>set_x_repeat(value: int) -&gt; Self\n</code></pre> <p>Set the x_repeat property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def set_x_repeat(self, value: int) -&gt; Self:\n    \"\"\"Set the x_repeat property value.\"\"\"\n    return self.set_step_and_repeat(\n        self.get_step_and_repeat().set_x_repeat(value),\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2.get_y_repeat","title":"get_y_repeat","text":"<pre><code>get_y_repeat() -&gt; int\n</code></pre> <p>Get y_repeat property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def get_y_repeat(self) -&gt; int:\n    \"\"\"Get y_repeat property value.\"\"\"\n    return self.get_step_and_repeat().get_y_repeat()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2.set_y_repeat","title":"set_y_repeat","text":"<pre><code>set_y_repeat(value: int) -&gt; Self\n</code></pre> <p>Set the y_repeat property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def set_y_repeat(self, value: int) -&gt; Self:\n    \"\"\"Set the y_repeat property value.\"\"\"\n    return self.set_step_and_repeat(\n        self.get_step_and_repeat().set_y_repeat(value),\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2.get_x_step","title":"get_x_step","text":"<pre><code>get_x_step() -&gt; Offset\n</code></pre> <p>Get x_step property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def get_x_step(self) -&gt; Offset:\n    \"\"\"Get x_step property value.\"\"\"\n    return self.get_step_and_repeat().get_x_step()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2.set_x_step","title":"set_x_step","text":"<pre><code>set_x_step(value: Offset) -&gt; Self\n</code></pre> <p>Set the x_repeat property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def set_x_step(self, value: Offset) -&gt; Self:\n    \"\"\"Set the x_repeat property value.\"\"\"\n    return self.set_step_and_repeat(\n        self.get_step_and_repeat().set_x_step(value),\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2.get_y_step","title":"get_y_step","text":"<pre><code>get_y_step() -&gt; Offset\n</code></pre> <p>Get y_step property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def get_y_step(self) -&gt; Offset:\n    \"\"\"Get y_step property value.\"\"\"\n    return self.get_step_and_repeat().get_y_step()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2.set_y_step","title":"set_y_step","text":"<pre><code>set_y_step(value: Offset) -&gt; Self\n</code></pre> <p>Set the y_repeat property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def set_y_step(self, value: Offset) -&gt; Self:\n    \"\"\"Set the y_repeat property value.\"\"\"\n    return self.set_step_and_repeat(\n        self.get_step_and_repeat().set_y_step(value),\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2.get_current_position","title":"get_current_position","text":"<pre><code>get_current_position() -&gt; Vector2D\n</code></pre> <p>Get current_position property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def get_current_position(self) -&gt; Vector2D:\n    \"\"\"Get current_position property value.\"\"\"\n    return self.current_position\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2.set_current_position","title":"set_current_position","text":"<pre><code>set_current_position(current_position: Vector2D) -&gt; Self\n</code></pre> <p>Set the current_position property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def set_current_position(self, current_position: Vector2D) -&gt; Self:\n    \"\"\"Set the current_position property value.\"\"\"\n    return self.model_copy(\n        update={\n            \"current_position\": current_position,\n        },\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2.get_current_aperture_id","title":"get_current_aperture_id","text":"<pre><code>get_current_aperture_id() -&gt; Optional[ApertureID]\n</code></pre> <p>Get current_aperture property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def get_current_aperture_id(self) -&gt; Optional[ApertureID]:\n    \"\"\"Get current_aperture property value.\"\"\"\n    return self.current_aperture_id\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2.set_current_aperture_id","title":"set_current_aperture_id","text":"<pre><code>set_current_aperture_id(\n    current_aperture: Optional[ApertureID],\n) -&gt; Self\n</code></pre> <p>Set the current_aperture property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def set_current_aperture_id(self, current_aperture: Optional[ApertureID]) -&gt; Self:\n    \"\"\"Set the current_aperture property value.\"\"\"\n    return self.model_copy(\n        update={\n            \"current_aperture_id\": current_aperture,\n        },\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2.get_macro","title":"get_macro","text":"<pre><code>get_macro(__key: str) -&gt; ApertureMacro2\n</code></pre> <p>Get macros property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def get_macro(self, __key: str) -&gt; ApertureMacro2:\n    \"\"\"Get macros property value.\"\"\"\n    return self.macros.get_macro(__key)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2.set_macro","title":"set_macro","text":"<pre><code>set_macro(__key: str, __value: ApertureMacro2) -&gt; Self\n</code></pre> <p>Set the macros property value.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def set_macro(self, __key: str, __value: ApertureMacro2) -&gt; Self:\n    \"\"\"Set the macros property value.\"\"\"\n    return self.model_copy(\n        update={\n            \"macros\": self.macros.set_macro(__key, __value),\n        },\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/state2.html#pygerber.gerberx3.parser2.state2.State2.parse_coordinate","title":"parse_coordinate","text":"<pre><code>parse_coordinate(coordinate: Coordinate) -&gt; Offset\n</code></pre> <p>Parse a coordinate and convert it to an Offset.</p> <p>This method parses a given coordinate and converts it to an Offset object. It handles missing X, Y by substituting them with the current position and missing I, J by substituting them with NULL offset.</p> <p>Parameters:</p> Name Type Description Default <code>coordinate</code> <code>Coordinate</code> <p>The coordinate to be parsed.</p> required <p>Returns:</p> Type Description <code>Offset</code> <p>The parsed coordinate converted to an Offset object.</p> Source code in <code>src/pygerber/gerberx3/parser2/state2.py</code> <pre><code>def parse_coordinate(self, coordinate: Coordinate) -&gt; Offset:\n    \"\"\"Parse a coordinate and convert it to an Offset.\n\n    This method parses a given coordinate and converts it to an Offset object.\n    It handles missing X, Y by substituting them with the current\n    position and missing I, J by substituting them with NULL offset.\n\n    Parameters\n    ----------\n    coordinate : Coordinate\n        The coordinate to be parsed.\n\n    Returns\n    -------\n    Offset\n        The parsed coordinate converted to an Offset object.\n    \"\"\"\n    if coordinate.coordinate_type == CoordinateType.MISSING_X:\n        return self.current_position.x\n\n    if coordinate.coordinate_type == CoordinateType.MISSING_Y:\n        return self.current_position.y\n\n    if coordinate.coordinate_type == CoordinateType.MISSING_I:\n        return Offset.NULL\n\n    if coordinate.coordinate_type == CoordinateType.MISSING_J:\n        return Offset.NULL\n\n    return Offset.new(\n        self.get_coordinate_parser().parse(coordinate),\n        unit=self.get_draw_units(),\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/apertures2/__init__.html","title":"init","text":""},{"location":"reference/pygerber/gerberx3/parser2/apertures2/__init__.html#pygerber.gerberx3.parser2.apertures2","title":"apertures2","text":"<p>Parser level abstraction of aperture info for Gerber AST parser, version 2.</p>"},{"location":"reference/pygerber/gerberx3/parser2/apertures2/aperture2.html","title":"aperture2","text":""},{"location":"reference/pygerber/gerberx3/parser2/apertures2/aperture2.html#pygerber.gerberx3.parser2.apertures2.aperture2","title":"aperture2","text":"<p>Parser level abstraction of aperture info for Gerber AST parser, version 2.</p>"},{"location":"reference/pygerber/gerberx3/parser2/apertures2/aperture2.html#pygerber.gerberx3.parser2.apertures2.aperture2.Aperture2","title":"Aperture2","text":"<p>             Bases: <code>FrozenGeneralModel</code></p> <p>Parser level abstraction of aperture info.</p> Source code in <code>src/pygerber/gerberx3/parser2/apertures2/aperture2.py</code> <pre><code>class Aperture2(FrozenGeneralModel):\n    \"\"\"Parser level abstraction of aperture info.\"\"\"\n\n    attributes: ApertureAttributes = Field(default_factory=ImmutableMapping)\n\n    def render_flash(self, renderer: Renderer2, command: Flash2) -&gt; None:\n        \"\"\"Render draw operation.\"\"\"\n        raise NotImplementedError\n\n    def get_bounding_box(self) -&gt; BoundingBox:\n        \"\"\"Return bounding box of aperture.\"\"\"\n        raise NotImplementedError\n\n    def get_stroke_width(self) -&gt; Offset:\n        \"\"\"Get stroke width of command.\"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/apertures2/aperture2.html#pygerber.gerberx3.parser2.apertures2.aperture2.Aperture2.render_flash","title":"render_flash","text":"<pre><code>render_flash(renderer: Renderer2, command: Flash2) -&gt; None\n</code></pre> <p>Render draw operation.</p> Source code in <code>src/pygerber/gerberx3/parser2/apertures2/aperture2.py</code> <pre><code>def render_flash(self, renderer: Renderer2, command: Flash2) -&gt; None:\n    \"\"\"Render draw operation.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/apertures2/aperture2.html#pygerber.gerberx3.parser2.apertures2.aperture2.Aperture2.get_bounding_box","title":"get_bounding_box","text":"<pre><code>get_bounding_box() -&gt; BoundingBox\n</code></pre> <p>Return bounding box of aperture.</p> Source code in <code>src/pygerber/gerberx3/parser2/apertures2/aperture2.py</code> <pre><code>def get_bounding_box(self) -&gt; BoundingBox:\n    \"\"\"Return bounding box of aperture.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/apertures2/aperture2.html#pygerber.gerberx3.parser2.apertures2.aperture2.Aperture2.get_stroke_width","title":"get_stroke_width","text":"<pre><code>get_stroke_width() -&gt; Offset\n</code></pre> <p>Get stroke width of command.</p> Source code in <code>src/pygerber/gerberx3/parser2/apertures2/aperture2.py</code> <pre><code>def get_stroke_width(self) -&gt; Offset:\n    \"\"\"Get stroke width of command.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/apertures2/block2.html","title":"block2","text":""},{"location":"reference/pygerber/gerberx3/parser2/apertures2/block2.html#pygerber.gerberx3.parser2.apertures2.block2","title":"block2","text":"<p>Parser level abstraction of block aperture info for Gerber AST parser, version 2.</p>"},{"location":"reference/pygerber/gerberx3/parser2/apertures2/block2.html#pygerber.gerberx3.parser2.apertures2.block2.Block2","title":"Block2","text":"<p>             Bases: <code>Aperture2</code></p> <p>Parser level abstraction of aperture info for block aperture.</p> Source code in <code>src/pygerber/gerberx3/parser2/apertures2/block2.py</code> <pre><code>class Block2(Aperture2):\n    \"\"\"Parser level abstraction of aperture info for block aperture.\"\"\"\n\n    command_buffer: ReadonlyCommandBuffer2\n\n    def render_flash(self, renderer: Renderer2, command: Flash2) -&gt; None:\n        \"\"\"Render draw operation.\"\"\"\n        # Block apertures are resolved into series of commands at parser level.\n        raise NotImplementedError\n\n    def get_bounding_box(self) -&gt; BoundingBox:\n        \"\"\"Return bounding box of aperture.\"\"\"\n        return self.command_buffer.get_bounding_box()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/apertures2/block2.html#pygerber.gerberx3.parser2.apertures2.block2.Block2.render_flash","title":"render_flash","text":"<pre><code>render_flash(renderer: Renderer2, command: Flash2) -&gt; None\n</code></pre> <p>Render draw operation.</p> Source code in <code>src/pygerber/gerberx3/parser2/apertures2/block2.py</code> <pre><code>def render_flash(self, renderer: Renderer2, command: Flash2) -&gt; None:\n    \"\"\"Render draw operation.\"\"\"\n    # Block apertures are resolved into series of commands at parser level.\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/apertures2/block2.html#pygerber.gerberx3.parser2.apertures2.block2.Block2.get_bounding_box","title":"get_bounding_box","text":"<pre><code>get_bounding_box() -&gt; BoundingBox\n</code></pre> <p>Return bounding box of aperture.</p> Source code in <code>src/pygerber/gerberx3/parser2/apertures2/block2.py</code> <pre><code>def get_bounding_box(self) -&gt; BoundingBox:\n    \"\"\"Return bounding box of aperture.\"\"\"\n    return self.command_buffer.get_bounding_box()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/apertures2/circle2.html","title":"circle2","text":""},{"location":"reference/pygerber/gerberx3/parser2/apertures2/circle2.html#pygerber.gerberx3.parser2.apertures2.circle2","title":"circle2","text":"<p>Parser level abstraction of circle aperture info for Gerber AST parser, version 2.</p>"},{"location":"reference/pygerber/gerberx3/parser2/apertures2/circle2.html#pygerber.gerberx3.parser2.apertures2.circle2.Circle2","title":"Circle2","text":"<p>             Bases: <code>Aperture2</code></p> <p>Parser level abstraction of aperture info for circle aperture.</p> Source code in <code>src/pygerber/gerberx3/parser2/apertures2/circle2.py</code> <pre><code>class Circle2(Aperture2):\n    \"\"\"Parser level abstraction of aperture info for circle aperture.\"\"\"\n\n    diameter: Offset\n    hole_diameter: Optional[Offset]\n\n    def render_flash(self, renderer: Renderer2, command: Flash2) -&gt; None:\n        \"\"\"Render draw operation.\"\"\"\n        renderer.hooks.render_flash_circle(command, self)\n\n    def get_bounding_box(self) -&gt; BoundingBox:\n        \"\"\"Get bounding box of draw operation.\"\"\"\n        return BoundingBox.from_diameter(self.diameter)\n\n    def get_stroke_width(self) -&gt; Offset:\n        \"\"\"Get stroke width of command.\"\"\"\n        return self.diameter\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/apertures2/circle2.html#pygerber.gerberx3.parser2.apertures2.circle2.Circle2.render_flash","title":"render_flash","text":"<pre><code>render_flash(renderer: Renderer2, command: Flash2) -&gt; None\n</code></pre> <p>Render draw operation.</p> Source code in <code>src/pygerber/gerberx3/parser2/apertures2/circle2.py</code> <pre><code>def render_flash(self, renderer: Renderer2, command: Flash2) -&gt; None:\n    \"\"\"Render draw operation.\"\"\"\n    renderer.hooks.render_flash_circle(command, self)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/apertures2/circle2.html#pygerber.gerberx3.parser2.apertures2.circle2.Circle2.get_bounding_box","title":"get_bounding_box","text":"<pre><code>get_bounding_box() -&gt; BoundingBox\n</code></pre> <p>Get bounding box of draw operation.</p> Source code in <code>src/pygerber/gerberx3/parser2/apertures2/circle2.py</code> <pre><code>def get_bounding_box(self) -&gt; BoundingBox:\n    \"\"\"Get bounding box of draw operation.\"\"\"\n    return BoundingBox.from_diameter(self.diameter)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/apertures2/circle2.html#pygerber.gerberx3.parser2.apertures2.circle2.Circle2.get_stroke_width","title":"get_stroke_width","text":"<pre><code>get_stroke_width() -&gt; Offset\n</code></pre> <p>Get stroke width of command.</p> Source code in <code>src/pygerber/gerberx3/parser2/apertures2/circle2.py</code> <pre><code>def get_stroke_width(self) -&gt; Offset:\n    \"\"\"Get stroke width of command.\"\"\"\n    return self.diameter\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/apertures2/circle2.html#pygerber.gerberx3.parser2.apertures2.circle2.NoCircle2","title":"NoCircle2","text":"<p>             Bases: <code>Circle2</code></p> <p>Dummy aperture representing case when aperture is not needed but has to be given to denote width of draw line command.</p> Source code in <code>src/pygerber/gerberx3/parser2/apertures2/circle2.py</code> <pre><code>class NoCircle2(Circle2):\n    \"\"\"Dummy aperture representing case when aperture is not needed but has to be\n    given to denote width of draw line command.\n    \"\"\"\n\n    def render_flash(self, renderer: Renderer2, command: Flash2) -&gt; None:\n        \"\"\"Render draw operation.\"\"\"\n        renderer.hooks.render_flash_no_circle(command, self)\n\n    def get_bounding_box(self) -&gt; BoundingBox:\n        \"\"\"Get bounding box of draw operation.\"\"\"\n        return BoundingBox.NULL\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/apertures2/circle2.html#pygerber.gerberx3.parser2.apertures2.circle2.NoCircle2.render_flash","title":"render_flash","text":"<pre><code>render_flash(renderer: Renderer2, command: Flash2) -&gt; None\n</code></pre> <p>Render draw operation.</p> Source code in <code>src/pygerber/gerberx3/parser2/apertures2/circle2.py</code> <pre><code>def render_flash(self, renderer: Renderer2, command: Flash2) -&gt; None:\n    \"\"\"Render draw operation.\"\"\"\n    renderer.hooks.render_flash_no_circle(command, self)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/apertures2/circle2.html#pygerber.gerberx3.parser2.apertures2.circle2.NoCircle2.get_bounding_box","title":"get_bounding_box","text":"<pre><code>get_bounding_box() -&gt; BoundingBox\n</code></pre> <p>Get bounding box of draw operation.</p> Source code in <code>src/pygerber/gerberx3/parser2/apertures2/circle2.py</code> <pre><code>def get_bounding_box(self) -&gt; BoundingBox:\n    \"\"\"Get bounding box of draw operation.\"\"\"\n    return BoundingBox.NULL\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/apertures2/macro2.html","title":"macro2","text":""},{"location":"reference/pygerber/gerberx3/parser2/apertures2/macro2.html#pygerber.gerberx3.parser2.apertures2.macro2","title":"macro2","text":"<p>Parser level abstraction of macro aperture info for Gerber AST parser, version 2.</p>"},{"location":"reference/pygerber/gerberx3/parser2/apertures2/macro2.html#pygerber.gerberx3.parser2.apertures2.macro2.Macro2","title":"Macro2","text":"<p>             Bases: <code>Aperture2</code></p> <p>Parser level abstraction of aperture info for macro aperture.</p> Source code in <code>src/pygerber/gerberx3/parser2/apertures2/macro2.py</code> <pre><code>class Macro2(Aperture2):\n    \"\"\"Parser level abstraction of aperture info for macro aperture.\"\"\"\n\n    command_buffer: ReadonlyCommandBuffer2\n\n    def render_flash(self, renderer: Renderer2, command: Flash2) -&gt; None:\n        \"\"\"Render draw operation.\"\"\"\n        renderer.hooks.render_flash_macro(command, self)\n\n    def get_bounding_box(self) -&gt; BoundingBox:\n        \"\"\"Return bounding box of aperture.\"\"\"\n        return self.command_buffer.get_bounding_box()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/apertures2/macro2.html#pygerber.gerberx3.parser2.apertures2.macro2.Macro2.render_flash","title":"render_flash","text":"<pre><code>render_flash(renderer: Renderer2, command: Flash2) -&gt; None\n</code></pre> <p>Render draw operation.</p> Source code in <code>src/pygerber/gerberx3/parser2/apertures2/macro2.py</code> <pre><code>def render_flash(self, renderer: Renderer2, command: Flash2) -&gt; None:\n    \"\"\"Render draw operation.\"\"\"\n    renderer.hooks.render_flash_macro(command, self)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/apertures2/macro2.html#pygerber.gerberx3.parser2.apertures2.macro2.Macro2.get_bounding_box","title":"get_bounding_box","text":"<pre><code>get_bounding_box() -&gt; BoundingBox\n</code></pre> <p>Return bounding box of aperture.</p> Source code in <code>src/pygerber/gerberx3/parser2/apertures2/macro2.py</code> <pre><code>def get_bounding_box(self) -&gt; BoundingBox:\n    \"\"\"Return bounding box of aperture.\"\"\"\n    return self.command_buffer.get_bounding_box()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/apertures2/obround2.html","title":"obround2","text":""},{"location":"reference/pygerber/gerberx3/parser2/apertures2/obround2.html#pygerber.gerberx3.parser2.apertures2.obround2","title":"obround2","text":"<p>Parser level abstraction of obround aperture info for Gerber AST parser, version 2.</p>"},{"location":"reference/pygerber/gerberx3/parser2/apertures2/obround2.html#pygerber.gerberx3.parser2.apertures2.obround2.Obround2","title":"Obround2","text":"<p>             Bases: <code>Aperture2</code></p> <p>Parser level abstraction of aperture info for obround aperture.</p> Source code in <code>src/pygerber/gerberx3/parser2/apertures2/obround2.py</code> <pre><code>class Obround2(Aperture2):\n    \"\"\"Parser level abstraction of aperture info for obround aperture.\"\"\"\n\n    x_size: Offset\n    y_size: Offset\n    hole_diameter: Optional[Offset]\n\n    def render_flash(self, renderer: Renderer2, command: Flash2) -&gt; None:\n        \"\"\"Render draw operation.\"\"\"\n        renderer.hooks.render_flash_obround(command, self)\n\n    def get_bounding_box(self) -&gt; BoundingBox:\n        \"\"\"Return bounding box of aperture.\"\"\"\n        return BoundingBox.from_rectangle(self.x_size, self.y_size)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/apertures2/obround2.html#pygerber.gerberx3.parser2.apertures2.obround2.Obround2.render_flash","title":"render_flash","text":"<pre><code>render_flash(renderer: Renderer2, command: Flash2) -&gt; None\n</code></pre> <p>Render draw operation.</p> Source code in <code>src/pygerber/gerberx3/parser2/apertures2/obround2.py</code> <pre><code>def render_flash(self, renderer: Renderer2, command: Flash2) -&gt; None:\n    \"\"\"Render draw operation.\"\"\"\n    renderer.hooks.render_flash_obround(command, self)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/apertures2/obround2.html#pygerber.gerberx3.parser2.apertures2.obround2.Obround2.get_bounding_box","title":"get_bounding_box","text":"<pre><code>get_bounding_box() -&gt; BoundingBox\n</code></pre> <p>Return bounding box of aperture.</p> Source code in <code>src/pygerber/gerberx3/parser2/apertures2/obround2.py</code> <pre><code>def get_bounding_box(self) -&gt; BoundingBox:\n    \"\"\"Return bounding box of aperture.\"\"\"\n    return BoundingBox.from_rectangle(self.x_size, self.y_size)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/apertures2/polygon2.html","title":"polygon2","text":""},{"location":"reference/pygerber/gerberx3/parser2/apertures2/polygon2.html#pygerber.gerberx3.parser2.apertures2.polygon2","title":"polygon2","text":"<p>Parser level abstraction of polygon aperture info for Gerber AST parser, version 2.</p>"},{"location":"reference/pygerber/gerberx3/parser2/apertures2/polygon2.html#pygerber.gerberx3.parser2.apertures2.polygon2.Polygon2","title":"Polygon2","text":"<p>             Bases: <code>Aperture2</code></p> <p>Parser level abstraction of aperture info for polygon aperture.</p> Source code in <code>src/pygerber/gerberx3/parser2/apertures2/polygon2.py</code> <pre><code>class Polygon2(Aperture2):\n    \"\"\"Parser level abstraction of aperture info for polygon aperture.\"\"\"\n\n    outer_diameter: Offset\n    number_vertices: int\n    rotation: Decimal\n    hole_diameter: Optional[Offset]\n\n    def render_flash(self, renderer: Renderer2, command: Flash2) -&gt; None:\n        \"\"\"Render draw operation.\"\"\"\n        renderer.hooks.render_flash_polygon(command, self)\n\n    def get_bounding_box(self) -&gt; BoundingBox:\n        \"\"\"Return bounding box of aperture.\"\"\"\n        return BoundingBox.from_diameter(self.outer_diameter)\n\n    def get_stroke_width(self) -&gt; Offset:\n        \"\"\"Get stroke width of command.\"\"\"\n        return self.outer_diameter\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/apertures2/polygon2.html#pygerber.gerberx3.parser2.apertures2.polygon2.Polygon2.render_flash","title":"render_flash","text":"<pre><code>render_flash(renderer: Renderer2, command: Flash2) -&gt; None\n</code></pre> <p>Render draw operation.</p> Source code in <code>src/pygerber/gerberx3/parser2/apertures2/polygon2.py</code> <pre><code>def render_flash(self, renderer: Renderer2, command: Flash2) -&gt; None:\n    \"\"\"Render draw operation.\"\"\"\n    renderer.hooks.render_flash_polygon(command, self)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/apertures2/polygon2.html#pygerber.gerberx3.parser2.apertures2.polygon2.Polygon2.get_bounding_box","title":"get_bounding_box","text":"<pre><code>get_bounding_box() -&gt; BoundingBox\n</code></pre> <p>Return bounding box of aperture.</p> Source code in <code>src/pygerber/gerberx3/parser2/apertures2/polygon2.py</code> <pre><code>def get_bounding_box(self) -&gt; BoundingBox:\n    \"\"\"Return bounding box of aperture.\"\"\"\n    return BoundingBox.from_diameter(self.outer_diameter)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/apertures2/polygon2.html#pygerber.gerberx3.parser2.apertures2.polygon2.Polygon2.get_stroke_width","title":"get_stroke_width","text":"<pre><code>get_stroke_width() -&gt; Offset\n</code></pre> <p>Get stroke width of command.</p> Source code in <code>src/pygerber/gerberx3/parser2/apertures2/polygon2.py</code> <pre><code>def get_stroke_width(self) -&gt; Offset:\n    \"\"\"Get stroke width of command.\"\"\"\n    return self.outer_diameter\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/apertures2/rectangle2.html","title":"rectangle2","text":""},{"location":"reference/pygerber/gerberx3/parser2/apertures2/rectangle2.html#pygerber.gerberx3.parser2.apertures2.rectangle2","title":"rectangle2","text":"<p>Parser level abstraction of rectangle aperture info for Gerber AST parser, version 2.</p>"},{"location":"reference/pygerber/gerberx3/parser2/apertures2/rectangle2.html#pygerber.gerberx3.parser2.apertures2.rectangle2.Rectangle2","title":"Rectangle2","text":"<p>             Bases: <code>Aperture2</code></p> <p>Parser level abstraction of aperture info for rectangle aperture.</p> Source code in <code>src/pygerber/gerberx3/parser2/apertures2/rectangle2.py</code> <pre><code>class Rectangle2(Aperture2):\n    \"\"\"Parser level abstraction of aperture info for rectangle aperture.\"\"\"\n\n    x_size: Offset\n    y_size: Offset\n    hole_diameter: Optional[Offset]\n\n    def render_flash(self, renderer: Renderer2, command: Flash2) -&gt; None:\n        \"\"\"Render draw operation.\"\"\"\n        renderer.hooks.render_flash_rectangle(command, self)\n\n    def get_stroke_width(self) -&gt; Offset:\n        \"\"\"Return stroke width of aperture.\"\"\"\n        return (self.x_size + self.y_size) / 2\n\n    def get_bounding_box(self) -&gt; BoundingBox:\n        \"\"\"Return bounding box of aperture.\"\"\"\n        return BoundingBox.from_rectangle(self.x_size, self.y_size)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/apertures2/rectangle2.html#pygerber.gerberx3.parser2.apertures2.rectangle2.Rectangle2.render_flash","title":"render_flash","text":"<pre><code>render_flash(renderer: Renderer2, command: Flash2) -&gt; None\n</code></pre> <p>Render draw operation.</p> Source code in <code>src/pygerber/gerberx3/parser2/apertures2/rectangle2.py</code> <pre><code>def render_flash(self, renderer: Renderer2, command: Flash2) -&gt; None:\n    \"\"\"Render draw operation.\"\"\"\n    renderer.hooks.render_flash_rectangle(command, self)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/apertures2/rectangle2.html#pygerber.gerberx3.parser2.apertures2.rectangle2.Rectangle2.get_stroke_width","title":"get_stroke_width","text":"<pre><code>get_stroke_width() -&gt; Offset\n</code></pre> <p>Return stroke width of aperture.</p> Source code in <code>src/pygerber/gerberx3/parser2/apertures2/rectangle2.py</code> <pre><code>def get_stroke_width(self) -&gt; Offset:\n    \"\"\"Return stroke width of aperture.\"\"\"\n    return (self.x_size + self.y_size) / 2\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/apertures2/rectangle2.html#pygerber.gerberx3.parser2.apertures2.rectangle2.Rectangle2.get_bounding_box","title":"get_bounding_box","text":"<pre><code>get_bounding_box() -&gt; BoundingBox\n</code></pre> <p>Return bounding box of aperture.</p> Source code in <code>src/pygerber/gerberx3/parser2/apertures2/rectangle2.py</code> <pre><code>def get_bounding_box(self) -&gt; BoundingBox:\n    \"\"\"Return bounding box of aperture.\"\"\"\n    return BoundingBox.from_rectangle(self.x_size, self.y_size)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/commands2/__init__.html","title":"init","text":""},{"location":"reference/pygerber/gerberx3/parser2/commands2/__init__.html#pygerber.gerberx3.parser2.commands2","title":"commands2","text":"<p>Parser level abstraction of draw operation info for Gerber AST parser, version 2.</p>"},{"location":"reference/pygerber/gerberx3/parser2/commands2/aperture_draw_command2.html","title":"aperture_draw_command2","text":""},{"location":"reference/pygerber/gerberx3/parser2/commands2/aperture_draw_command2.html#pygerber.gerberx3.parser2.commands2.aperture_draw_command2","title":"aperture_draw_command2","text":"<p>Parser level abstraction of draw operation which utilizes apertures for Gerber AST parser, version 2.</p>"},{"location":"reference/pygerber/gerberx3/parser2/commands2/aperture_draw_command2.html#pygerber.gerberx3.parser2.commands2.aperture_draw_command2.ApertureDrawCommand2","title":"ApertureDrawCommand2","text":"<p>             Bases: <code>Command2</code></p> <p>Parser level abstraction of draw operation for Gerber AST parser, version 2.</p> Source code in <code>src/pygerber/gerberx3/parser2/commands2/aperture_draw_command2.py</code> <pre><code>class ApertureDrawCommand2(Command2):\n    \"\"\"Parser level abstraction of draw operation for Gerber AST parser, version 2.\"\"\"\n\n    attributes: ObjectAttributes = Field(default_factory=ObjectAttributes)\n    aperture: Aperture2\n\n    def __str__(self) -&gt; str:\n        return f\"{self.__class__.__qualname__}()\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/commands2/arc2.html","title":"arc2","text":""},{"location":"reference/pygerber/gerberx3/parser2/commands2/arc2.html#pygerber.gerberx3.parser2.commands2.arc2","title":"arc2","text":"<p>Parser level abstraction of draw arc operation for Gerber AST parser, version 2.</p>"},{"location":"reference/pygerber/gerberx3/parser2/commands2/arc2.html#pygerber.gerberx3.parser2.commands2.arc2.Arc2","title":"Arc2","text":"<p>             Bases: <code>ApertureDrawCommand2</code></p> <p>Parser level abstraction of draw arc operation for Gerber AST parser, version 2.</p> Source code in <code>src/pygerber/gerberx3/parser2/commands2/arc2.py</code> <pre><code>class Arc2(ApertureDrawCommand2):\n    \"\"\"Parser level abstraction of draw arc operation for Gerber AST parser,\n    version 2.\n    \"\"\"\n\n    start_point: Vector2D\n    end_point: Vector2D\n    center_point: Vector2D\n\n    def get_relative_start_point(self) -&gt; Vector2D:\n        \"\"\"Get starting point relative to arc center.\"\"\"\n        return self.start_point - self.center_point\n\n    def get_relative_end_point(self) -&gt; Vector2D:\n        \"\"\"Get ending point relative to arc center.\"\"\"\n        return self.end_point - self.center_point\n\n    def get_relative_center_point(self) -&gt; Vector2D:\n        \"\"\"Get center point relative to arc center.\"\"\"\n        return self.center_point - self.center_point\n\n    def get_radius(self) -&gt; Offset:\n        \"\"\"Get radius of circle arc.\"\"\"\n        return self.get_relative_start_point().length()\n\n    def get_bounding_box(self) -&gt; BoundingBox:\n        \"\"\"Return bounding box of arc.\"\"\"\n        return (\n            BoundingBox.from_diameter(\n                (self.get_radius() * 2) + (self.aperture.get_stroke_width() * 2),\n            )\n            + self.center_point\n        )\n\n    def get_mirrored(self, mirror: Mirroring) -&gt; Self:\n        \"\"\"Get mirrored command.\"\"\"\n        return self.model_copy(\n            update={\n                \"start_point\": self.start_point.get_mirrored(mirror),\n                \"end_point\": self.end_point.get_mirrored(mirror),\n                \"center_point\": self.center_point.get_mirrored(mirror),\n            },\n        )\n\n    def get_transposed(self, vector: Vector2D) -&gt; Self:\n        \"\"\"Get transposed command.\"\"\"\n        return self.model_copy(\n            update={\n                \"start_point\": self.start_point + vector,\n                \"end_point\": self.end_point + vector,\n                \"center_point\": self.center_point + vector,\n            },\n        )\n\n    def render(self, renderer: Renderer2) -&gt; None:\n        \"\"\"Render draw operation.\"\"\"\n        renderer.hooks.render_arc(self)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/commands2/arc2.html#pygerber.gerberx3.parser2.commands2.arc2.Arc2.get_relative_start_point","title":"get_relative_start_point","text":"<pre><code>get_relative_start_point() -&gt; Vector2D\n</code></pre> <p>Get starting point relative to arc center.</p> Source code in <code>src/pygerber/gerberx3/parser2/commands2/arc2.py</code> <pre><code>def get_relative_start_point(self) -&gt; Vector2D:\n    \"\"\"Get starting point relative to arc center.\"\"\"\n    return self.start_point - self.center_point\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/commands2/arc2.html#pygerber.gerberx3.parser2.commands2.arc2.Arc2.get_relative_end_point","title":"get_relative_end_point","text":"<pre><code>get_relative_end_point() -&gt; Vector2D\n</code></pre> <p>Get ending point relative to arc center.</p> Source code in <code>src/pygerber/gerberx3/parser2/commands2/arc2.py</code> <pre><code>def get_relative_end_point(self) -&gt; Vector2D:\n    \"\"\"Get ending point relative to arc center.\"\"\"\n    return self.end_point - self.center_point\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/commands2/arc2.html#pygerber.gerberx3.parser2.commands2.arc2.Arc2.get_relative_center_point","title":"get_relative_center_point","text":"<pre><code>get_relative_center_point() -&gt; Vector2D\n</code></pre> <p>Get center point relative to arc center.</p> Source code in <code>src/pygerber/gerberx3/parser2/commands2/arc2.py</code> <pre><code>def get_relative_center_point(self) -&gt; Vector2D:\n    \"\"\"Get center point relative to arc center.\"\"\"\n    return self.center_point - self.center_point\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/commands2/arc2.html#pygerber.gerberx3.parser2.commands2.arc2.Arc2.get_radius","title":"get_radius","text":"<pre><code>get_radius() -&gt; Offset\n</code></pre> <p>Get radius of circle arc.</p> Source code in <code>src/pygerber/gerberx3/parser2/commands2/arc2.py</code> <pre><code>def get_radius(self) -&gt; Offset:\n    \"\"\"Get radius of circle arc.\"\"\"\n    return self.get_relative_start_point().length()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/commands2/arc2.html#pygerber.gerberx3.parser2.commands2.arc2.Arc2.get_bounding_box","title":"get_bounding_box","text":"<pre><code>get_bounding_box() -&gt; BoundingBox\n</code></pre> <p>Return bounding box of arc.</p> Source code in <code>src/pygerber/gerberx3/parser2/commands2/arc2.py</code> <pre><code>def get_bounding_box(self) -&gt; BoundingBox:\n    \"\"\"Return bounding box of arc.\"\"\"\n    return (\n        BoundingBox.from_diameter(\n            (self.get_radius() * 2) + (self.aperture.get_stroke_width() * 2),\n        )\n        + self.center_point\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/commands2/arc2.html#pygerber.gerberx3.parser2.commands2.arc2.Arc2.get_mirrored","title":"get_mirrored","text":"<pre><code>get_mirrored(mirror: Mirroring) -&gt; Self\n</code></pre> <p>Get mirrored command.</p> Source code in <code>src/pygerber/gerberx3/parser2/commands2/arc2.py</code> <pre><code>def get_mirrored(self, mirror: Mirroring) -&gt; Self:\n    \"\"\"Get mirrored command.\"\"\"\n    return self.model_copy(\n        update={\n            \"start_point\": self.start_point.get_mirrored(mirror),\n            \"end_point\": self.end_point.get_mirrored(mirror),\n            \"center_point\": self.center_point.get_mirrored(mirror),\n        },\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/commands2/arc2.html#pygerber.gerberx3.parser2.commands2.arc2.Arc2.get_transposed","title":"get_transposed","text":"<pre><code>get_transposed(vector: Vector2D) -&gt; Self\n</code></pre> <p>Get transposed command.</p> Source code in <code>src/pygerber/gerberx3/parser2/commands2/arc2.py</code> <pre><code>def get_transposed(self, vector: Vector2D) -&gt; Self:\n    \"\"\"Get transposed command.\"\"\"\n    return self.model_copy(\n        update={\n            \"start_point\": self.start_point + vector,\n            \"end_point\": self.end_point + vector,\n            \"center_point\": self.center_point + vector,\n        },\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/commands2/arc2.html#pygerber.gerberx3.parser2.commands2.arc2.Arc2.render","title":"render","text":"<pre><code>render(renderer: Renderer2) -&gt; None\n</code></pre> <p>Render draw operation.</p> Source code in <code>src/pygerber/gerberx3/parser2/commands2/arc2.py</code> <pre><code>def render(self, renderer: Renderer2) -&gt; None:\n    \"\"\"Render draw operation.\"\"\"\n    renderer.hooks.render_arc(self)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/commands2/arc2.html#pygerber.gerberx3.parser2.commands2.arc2.CCArc2","title":"CCArc2","text":"<p>             Bases: <code>Arc2</code></p> <p>Parser level abstraction of draw counterclockwise arc operation for Gerber AST parser, version 2.</p> Source code in <code>src/pygerber/gerberx3/parser2/commands2/arc2.py</code> <pre><code>class CCArc2(Arc2):\n    \"\"\"Parser level abstraction of draw counterclockwise arc operation for Gerber AST\n    parser, version 2.\n    \"\"\"\n\n    def render(self, renderer: Renderer2) -&gt; None:\n        \"\"\"Render draw operation.\"\"\"\n        renderer.hooks.render_cc_arc(self)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/commands2/arc2.html#pygerber.gerberx3.parser2.commands2.arc2.CCArc2.render","title":"render","text":"<pre><code>render(renderer: Renderer2) -&gt; None\n</code></pre> <p>Render draw operation.</p> Source code in <code>src/pygerber/gerberx3/parser2/commands2/arc2.py</code> <pre><code>def render(self, renderer: Renderer2) -&gt; None:\n    \"\"\"Render draw operation.\"\"\"\n    renderer.hooks.render_cc_arc(self)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/commands2/buffer_command2.html","title":"buffer_command2","text":""},{"location":"reference/pygerber/gerberx3/parser2/commands2/buffer_command2.html#pygerber.gerberx3.parser2.commands2.buffer_command2","title":"buffer_command2","text":"<p>Parser level abstraction of command that consists of multiple commands for Gerber AST parser, version 2.</p>"},{"location":"reference/pygerber/gerberx3/parser2/commands2/buffer_command2.html#pygerber.gerberx3.parser2.commands2.buffer_command2.BufferCommand2","title":"BufferCommand2","text":"<p>             Bases: <code>Command2</code></p> <p>Parser level abstraction of command that consists of multiple commands for Gerber AST parser, version 2.</p> Source code in <code>src/pygerber/gerberx3/parser2/commands2/buffer_command2.py</code> <pre><code>class BufferCommand2(Command2):\n    \"\"\"Parser level abstraction of command that consists of multiple commands for Gerber\n    AST parser, version 2.\n    \"\"\"\n\n    command_buffer: ReadonlyCommandBuffer2\n\n    def get_mirrored(self, mirror: Mirroring) -&gt; Self:\n        \"\"\"Get mirrored command.\"\"\"\n        return self.model_copy(\n            update={\n                \"command_buffer\": self.command_buffer.get_mirrored(mirror),\n            },\n        )\n\n    def get_transposed(self, vector: Vector2D) -&gt; Self:\n        \"\"\"Get transposed command.\"\"\"\n        return self.model_copy(\n            update={\n                \"command_buffer\": self.command_buffer.get_transposed(vector),\n            },\n        )\n\n    def get_bounding_box(self) -&gt; BoundingBox:\n        \"\"\"Get bounding box of draw operation.\"\"\"\n        return self.command_buffer.get_bounding_box()\n\n    def render(self, renderer: Renderer2) -&gt; None:\n        \"\"\"Render draw operation.\"\"\"\n        renderer.hooks.render_buffer(self)\n\n    def __len__(self) -&gt; int:\n        \"\"\"Return length of buffered commands.\"\"\"\n        return len(self.command_buffer)\n\n    def __iter__(self) -&gt; Iterator[Command2]:  # type: ignore[override]\n        \"\"\"Iterate over buffered draw commands.\"\"\"\n        yield from self.command_buffer\n\n    def __getitem__(self, index: int) -&gt; Command2:\n        \"\"\"Get item by index from commands.\"\"\"\n        return self.command_buffer[index]\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/commands2/buffer_command2.html#pygerber.gerberx3.parser2.commands2.buffer_command2.BufferCommand2.get_mirrored","title":"get_mirrored","text":"<pre><code>get_mirrored(mirror: Mirroring) -&gt; Self\n</code></pre> <p>Get mirrored command.</p> Source code in <code>src/pygerber/gerberx3/parser2/commands2/buffer_command2.py</code> <pre><code>def get_mirrored(self, mirror: Mirroring) -&gt; Self:\n    \"\"\"Get mirrored command.\"\"\"\n    return self.model_copy(\n        update={\n            \"command_buffer\": self.command_buffer.get_mirrored(mirror),\n        },\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/commands2/buffer_command2.html#pygerber.gerberx3.parser2.commands2.buffer_command2.BufferCommand2.get_transposed","title":"get_transposed","text":"<pre><code>get_transposed(vector: Vector2D) -&gt; Self\n</code></pre> <p>Get transposed command.</p> Source code in <code>src/pygerber/gerberx3/parser2/commands2/buffer_command2.py</code> <pre><code>def get_transposed(self, vector: Vector2D) -&gt; Self:\n    \"\"\"Get transposed command.\"\"\"\n    return self.model_copy(\n        update={\n            \"command_buffer\": self.command_buffer.get_transposed(vector),\n        },\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/commands2/buffer_command2.html#pygerber.gerberx3.parser2.commands2.buffer_command2.BufferCommand2.get_bounding_box","title":"get_bounding_box","text":"<pre><code>get_bounding_box() -&gt; BoundingBox\n</code></pre> <p>Get bounding box of draw operation.</p> Source code in <code>src/pygerber/gerberx3/parser2/commands2/buffer_command2.py</code> <pre><code>def get_bounding_box(self) -&gt; BoundingBox:\n    \"\"\"Get bounding box of draw operation.\"\"\"\n    return self.command_buffer.get_bounding_box()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/commands2/buffer_command2.html#pygerber.gerberx3.parser2.commands2.buffer_command2.BufferCommand2.render","title":"render","text":"<pre><code>render(renderer: Renderer2) -&gt; None\n</code></pre> <p>Render draw operation.</p> Source code in <code>src/pygerber/gerberx3/parser2/commands2/buffer_command2.py</code> <pre><code>def render(self, renderer: Renderer2) -&gt; None:\n    \"\"\"Render draw operation.\"\"\"\n    renderer.hooks.render_buffer(self)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/commands2/buffer_command2.html#pygerber.gerberx3.parser2.commands2.buffer_command2.BufferCommand2.__len__","title":"__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre> <p>Return length of buffered commands.</p> Source code in <code>src/pygerber/gerberx3/parser2/commands2/buffer_command2.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Return length of buffered commands.\"\"\"\n    return len(self.command_buffer)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/commands2/buffer_command2.html#pygerber.gerberx3.parser2.commands2.buffer_command2.BufferCommand2.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; Iterator[Command2]\n</code></pre> <p>Iterate over buffered draw commands.</p> Source code in <code>src/pygerber/gerberx3/parser2/commands2/buffer_command2.py</code> <pre><code>def __iter__(self) -&gt; Iterator[Command2]:  # type: ignore[override]\n    \"\"\"Iterate over buffered draw commands.\"\"\"\n    yield from self.command_buffer\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/commands2/buffer_command2.html#pygerber.gerberx3.parser2.commands2.buffer_command2.BufferCommand2.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(index: int) -&gt; Command2\n</code></pre> <p>Get item by index from commands.</p> Source code in <code>src/pygerber/gerberx3/parser2/commands2/buffer_command2.py</code> <pre><code>def __getitem__(self, index: int) -&gt; Command2:\n    \"\"\"Get item by index from commands.\"\"\"\n    return self.command_buffer[index]\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/commands2/command2.html","title":"command2","text":""},{"location":"reference/pygerber/gerberx3/parser2/commands2/command2.html#pygerber.gerberx3.parser2.commands2.command2","title":"command2","text":"<p>Parser level abstraction of draw operation for Gerber AST parser, version 2.</p>"},{"location":"reference/pygerber/gerberx3/parser2/commands2/command2.html#pygerber.gerberx3.parser2.commands2.command2.Command2","title":"Command2","text":"<p>             Bases: <code>FrozenGeneralModel</code></p> <p>Parser level abstraction of draw operation for Gerber AST parser, version 2.</p> Source code in <code>src/pygerber/gerberx3/parser2/commands2/command2.py</code> <pre><code>class Command2(FrozenGeneralModel):\n    \"\"\"Parser level abstraction of draw operation for Gerber AST parser, version 2.\"\"\"\n\n    transform: ApertureTransform\n\n    def get_bounding_box(self) -&gt; BoundingBox:\n        \"\"\"Get bounding box of draw operation.\"\"\"\n        raise NotImplementedError\n\n    def get_mirrored(self, mirror: Mirroring) -&gt; Self:\n        \"\"\"Get mirrored command.\"\"\"\n        raise NotImplementedError\n\n    def get_transposed(self, vector: Vector2D) -&gt; Self:\n        \"\"\"Get transposed command.\"\"\"\n        raise NotImplementedError\n\n    def render(self, hooks: Renderer2) -&gt; None:\n        \"\"\"Render draw operation.\"\"\"\n        raise NotImplementedError\n\n    def command_to_json(self) -&gt; str:\n        \"\"\"Dump draw operation.\"\"\"\n        return json.dumps(\n            {\n                \"cls\": f\"{self.__module__}.{self.__class__.__qualname__}\",\n                \"dict\": json.loads(self.model_dump_json()),\n            },\n        )\n\n    def __str__(self) -&gt; str:\n        return f\"{self.__class__.__qualname__}()\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/commands2/command2.html#pygerber.gerberx3.parser2.commands2.command2.Command2.get_bounding_box","title":"get_bounding_box","text":"<pre><code>get_bounding_box() -&gt; BoundingBox\n</code></pre> <p>Get bounding box of draw operation.</p> Source code in <code>src/pygerber/gerberx3/parser2/commands2/command2.py</code> <pre><code>def get_bounding_box(self) -&gt; BoundingBox:\n    \"\"\"Get bounding box of draw operation.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/commands2/command2.html#pygerber.gerberx3.parser2.commands2.command2.Command2.get_mirrored","title":"get_mirrored","text":"<pre><code>get_mirrored(mirror: Mirroring) -&gt; Self\n</code></pre> <p>Get mirrored command.</p> Source code in <code>src/pygerber/gerberx3/parser2/commands2/command2.py</code> <pre><code>def get_mirrored(self, mirror: Mirroring) -&gt; Self:\n    \"\"\"Get mirrored command.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/commands2/command2.html#pygerber.gerberx3.parser2.commands2.command2.Command2.get_transposed","title":"get_transposed","text":"<pre><code>get_transposed(vector: Vector2D) -&gt; Self\n</code></pre> <p>Get transposed command.</p> Source code in <code>src/pygerber/gerberx3/parser2/commands2/command2.py</code> <pre><code>def get_transposed(self, vector: Vector2D) -&gt; Self:\n    \"\"\"Get transposed command.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/commands2/command2.html#pygerber.gerberx3.parser2.commands2.command2.Command2.render","title":"render","text":"<pre><code>render(hooks: Renderer2) -&gt; None\n</code></pre> <p>Render draw operation.</p> Source code in <code>src/pygerber/gerberx3/parser2/commands2/command2.py</code> <pre><code>def render(self, hooks: Renderer2) -&gt; None:\n    \"\"\"Render draw operation.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/commands2/command2.html#pygerber.gerberx3.parser2.commands2.command2.Command2.command_to_json","title":"command_to_json","text":"<pre><code>command_to_json() -&gt; str\n</code></pre> <p>Dump draw operation.</p> Source code in <code>src/pygerber/gerberx3/parser2/commands2/command2.py</code> <pre><code>def command_to_json(self) -&gt; str:\n    \"\"\"Dump draw operation.\"\"\"\n    return json.dumps(\n        {\n            \"cls\": f\"{self.__module__}.{self.__class__.__qualname__}\",\n            \"dict\": json.loads(self.model_dump_json()),\n        },\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/commands2/flash2.html","title":"flash2","text":""},{"location":"reference/pygerber/gerberx3/parser2/commands2/flash2.html#pygerber.gerberx3.parser2.commands2.flash2","title":"flash2","text":"<p>Parser level abstraction of flash operation for Gerber AST parser, version 2.</p>"},{"location":"reference/pygerber/gerberx3/parser2/commands2/flash2.html#pygerber.gerberx3.parser2.commands2.flash2.Flash2","title":"Flash2","text":"<p>             Bases: <code>ApertureDrawCommand2</code></p> <p>Parser level abstraction of flash operation for Gerber AST parser, version 2.</p> Source code in <code>src/pygerber/gerberx3/parser2/commands2/flash2.py</code> <pre><code>class Flash2(ApertureDrawCommand2):\n    \"\"\"Parser level abstraction of flash operation for Gerber AST parser,\n    version 2.\n    \"\"\"\n\n    flash_point: Vector2D\n\n    def get_mirrored(self, mirror: Mirroring) -&gt; Self:\n        \"\"\"Get mirrored command.\"\"\"\n        return self.model_copy(\n            update={\n                \"flash_point\": self.flash_point.get_mirrored(mirror),\n            },\n        )\n\n    def get_transposed(self, vector: Vector2D) -&gt; Self:\n        \"\"\"Get transposed command.\"\"\"\n        return self.model_copy(\n            update={\n                \"flash_point\": self.flash_point + vector,\n            },\n        )\n\n    def render(self, renderer: Renderer2) -&gt; None:\n        \"\"\"Render draw operation.\"\"\"\n        self.aperture.render_flash(renderer, self)\n\n    def get_bounding_box(self) -&gt; BoundingBox:\n        \"\"\"Get bounding box of draw operation.\"\"\"\n        return self.aperture.get_bounding_box() + self.flash_point\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/commands2/flash2.html#pygerber.gerberx3.parser2.commands2.flash2.Flash2.get_mirrored","title":"get_mirrored","text":"<pre><code>get_mirrored(mirror: Mirroring) -&gt; Self\n</code></pre> <p>Get mirrored command.</p> Source code in <code>src/pygerber/gerberx3/parser2/commands2/flash2.py</code> <pre><code>def get_mirrored(self, mirror: Mirroring) -&gt; Self:\n    \"\"\"Get mirrored command.\"\"\"\n    return self.model_copy(\n        update={\n            \"flash_point\": self.flash_point.get_mirrored(mirror),\n        },\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/commands2/flash2.html#pygerber.gerberx3.parser2.commands2.flash2.Flash2.get_transposed","title":"get_transposed","text":"<pre><code>get_transposed(vector: Vector2D) -&gt; Self\n</code></pre> <p>Get transposed command.</p> Source code in <code>src/pygerber/gerberx3/parser2/commands2/flash2.py</code> <pre><code>def get_transposed(self, vector: Vector2D) -&gt; Self:\n    \"\"\"Get transposed command.\"\"\"\n    return self.model_copy(\n        update={\n            \"flash_point\": self.flash_point + vector,\n        },\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/commands2/flash2.html#pygerber.gerberx3.parser2.commands2.flash2.Flash2.render","title":"render","text":"<pre><code>render(renderer: Renderer2) -&gt; None\n</code></pre> <p>Render draw operation.</p> Source code in <code>src/pygerber/gerberx3/parser2/commands2/flash2.py</code> <pre><code>def render(self, renderer: Renderer2) -&gt; None:\n    \"\"\"Render draw operation.\"\"\"\n    self.aperture.render_flash(renderer, self)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/commands2/flash2.html#pygerber.gerberx3.parser2.commands2.flash2.Flash2.get_bounding_box","title":"get_bounding_box","text":"<pre><code>get_bounding_box() -&gt; BoundingBox\n</code></pre> <p>Get bounding box of draw operation.</p> Source code in <code>src/pygerber/gerberx3/parser2/commands2/flash2.py</code> <pre><code>def get_bounding_box(self) -&gt; BoundingBox:\n    \"\"\"Get bounding box of draw operation.\"\"\"\n    return self.aperture.get_bounding_box() + self.flash_point\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/commands2/line2.html","title":"line2","text":""},{"location":"reference/pygerber/gerberx3/parser2/commands2/line2.html#pygerber.gerberx3.parser2.commands2.line2","title":"line2","text":"<p>Parser level abstraction of draw line operation for Gerber AST parser, version 2.</p>"},{"location":"reference/pygerber/gerberx3/parser2/commands2/line2.html#pygerber.gerberx3.parser2.commands2.line2.Line2","title":"Line2","text":"<p>             Bases: <code>ApertureDrawCommand2</code></p> <p>Parser level abstraction of draw line operation for Gerber AST parser, version 2.</p> Source code in <code>src/pygerber/gerberx3/parser2/commands2/line2.py</code> <pre><code>class Line2(ApertureDrawCommand2):\n    \"\"\"Parser level abstraction of draw line operation for Gerber AST parser,\n    version 2.\n    \"\"\"\n\n    start_point: Vector2D\n    end_point: Vector2D\n\n    def get_bounding_box(self) -&gt; BoundingBox:\n        \"\"\"Return bounding box of draw operation.\"\"\"\n        vertex_box = self.aperture.get_bounding_box()\n        return (vertex_box + self.start_point) + (vertex_box + self.end_point)\n\n    def get_mirrored(self, mirror: Mirroring) -&gt; Self:\n        \"\"\"Get mirrored command.\"\"\"\n        return self.model_copy(\n            update={\n                \"start_point\": self.start_point.get_mirrored(mirror),\n                \"end_point\": self.end_point.get_mirrored(mirror),\n            },\n        )\n\n    def get_transposed(self, vector: Vector2D) -&gt; Self:\n        \"\"\"Get transposed command.\"\"\"\n        return self.model_copy(\n            update={\n                \"start_point\": self.start_point + vector,\n                \"end_point\": self.end_point + vector,\n            },\n        )\n\n    def render(self, renderer: Renderer2) -&gt; None:\n        \"\"\"Render draw operation.\"\"\"\n        renderer.hooks.render_line(self)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/commands2/line2.html#pygerber.gerberx3.parser2.commands2.line2.Line2.get_bounding_box","title":"get_bounding_box","text":"<pre><code>get_bounding_box() -&gt; BoundingBox\n</code></pre> <p>Return bounding box of draw operation.</p> Source code in <code>src/pygerber/gerberx3/parser2/commands2/line2.py</code> <pre><code>def get_bounding_box(self) -&gt; BoundingBox:\n    \"\"\"Return bounding box of draw operation.\"\"\"\n    vertex_box = self.aperture.get_bounding_box()\n    return (vertex_box + self.start_point) + (vertex_box + self.end_point)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/commands2/line2.html#pygerber.gerberx3.parser2.commands2.line2.Line2.get_mirrored","title":"get_mirrored","text":"<pre><code>get_mirrored(mirror: Mirroring) -&gt; Self\n</code></pre> <p>Get mirrored command.</p> Source code in <code>src/pygerber/gerberx3/parser2/commands2/line2.py</code> <pre><code>def get_mirrored(self, mirror: Mirroring) -&gt; Self:\n    \"\"\"Get mirrored command.\"\"\"\n    return self.model_copy(\n        update={\n            \"start_point\": self.start_point.get_mirrored(mirror),\n            \"end_point\": self.end_point.get_mirrored(mirror),\n        },\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/commands2/line2.html#pygerber.gerberx3.parser2.commands2.line2.Line2.get_transposed","title":"get_transposed","text":"<pre><code>get_transposed(vector: Vector2D) -&gt; Self\n</code></pre> <p>Get transposed command.</p> Source code in <code>src/pygerber/gerberx3/parser2/commands2/line2.py</code> <pre><code>def get_transposed(self, vector: Vector2D) -&gt; Self:\n    \"\"\"Get transposed command.\"\"\"\n    return self.model_copy(\n        update={\n            \"start_point\": self.start_point + vector,\n            \"end_point\": self.end_point + vector,\n        },\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/commands2/line2.html#pygerber.gerberx3.parser2.commands2.line2.Line2.render","title":"render","text":"<pre><code>render(renderer: Renderer2) -&gt; None\n</code></pre> <p>Render draw operation.</p> Source code in <code>src/pygerber/gerberx3/parser2/commands2/line2.py</code> <pre><code>def render(self, renderer: Renderer2) -&gt; None:\n    \"\"\"Render draw operation.\"\"\"\n    renderer.hooks.render_line(self)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/commands2/region2.html","title":"region2","text":""},{"location":"reference/pygerber/gerberx3/parser2/commands2/region2.html#pygerber.gerberx3.parser2.commands2.region2","title":"region2","text":"<p>Parser level abstraction of draw region operation for Gerber AST parser, version 2.</p>"},{"location":"reference/pygerber/gerberx3/parser2/commands2/region2.html#pygerber.gerberx3.parser2.commands2.region2.Region2","title":"Region2","text":"<p>             Bases: <code>BufferCommand2</code></p> <p>Parser level abstraction of draw region operation for Gerber AST parser, version 2.</p> Source code in <code>src/pygerber/gerberx3/parser2/commands2/region2.py</code> <pre><code>class Region2(BufferCommand2):\n    \"\"\"Parser level abstraction of draw region operation for Gerber AST parser,\n    version 2.\n    \"\"\"\n\n    aperture_attributes: ApertureAttributes = Field(default_factory=ApertureAttributes)\n    object_attributes: ObjectAttributes = Field(default_factory=ObjectAttributes)\n    command_buffer: ReadonlyCommandBuffer2\n\n    def command_to_json(self) -&gt; str:\n        \"\"\"Dump draw operation.\"\"\"\n        return f\"\"\"{{ \"cls\": \"{self.__module__}.{self.__class__.__qualname__}\", \"dict\": {{\n        \"polarity\": \"{self.transform.polarity.value}\",\n        \"aperture_attributes\": {self.aperture_attributes.model_dump_json()},\n        \"command_buffer\": {self.command_buffer.model_dump_json()},\n        \"command_buffer\": {\n            self.command_buffer.debug_buffer_to_json(8)}\n    }}\n}}\"\"\"  # noqa: E501\n\n    def render(self, renderer: Renderer2) -&gt; None:\n        \"\"\"Render draw operation.\"\"\"\n        renderer.hooks.render_region(self)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/commands2/region2.html#pygerber.gerberx3.parser2.commands2.region2.Region2.command_to_json","title":"command_to_json","text":"<pre><code>command_to_json() -&gt; str\n</code></pre> <p>Dump draw operation.</p> Source code in <code>src/pygerber/gerberx3/parser2/commands2/region2.py</code> <pre><code>    def command_to_json(self) -&gt; str:\n        \"\"\"Dump draw operation.\"\"\"\n        return f\"\"\"{{ \"cls\": \"{self.__module__}.{self.__class__.__qualname__}\", \"dict\": {{\n        \"polarity\": \"{self.transform.polarity.value}\",\n        \"aperture_attributes\": {self.aperture_attributes.model_dump_json()},\n        \"command_buffer\": {self.command_buffer.model_dump_json()},\n        \"command_buffer\": {\n            self.command_buffer.debug_buffer_to_json(8)}\n    }}\n}}\"\"\"  # noqa: E501\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/commands2/region2.html#pygerber.gerberx3.parser2.commands2.region2.Region2.render","title":"render","text":"<pre><code>render(renderer: Renderer2) -&gt; None\n</code></pre> <p>Render draw operation.</p> Source code in <code>src/pygerber/gerberx3/parser2/commands2/region2.py</code> <pre><code>def render(self, renderer: Renderer2) -&gt; None:\n    \"\"\"Render draw operation.\"\"\"\n    renderer.hooks.render_region(self)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/macro2/__init__.html","title":"init","text":""},{"location":"reference/pygerber/gerberx3/parser2/macro2/__init__.html#pygerber.gerberx3.parser2.macro2","title":"macro2","text":"<p>Macro elements used to construct a macro aperture template.</p>"},{"location":"reference/pygerber/gerberx3/parser2/macro2/assignment2.html","title":"assignment2","text":""},{"location":"reference/pygerber/gerberx3/parser2/macro2/assignment2.html#pygerber.gerberx3.parser2.macro2.assignment2","title":"assignment2","text":"<p><code>assignment2</code> module contains a <code>Assignment2</code> class wrapping variable assignment within macro definition.</p>"},{"location":"reference/pygerber/gerberx3/parser2/macro2/assignment2.html#pygerber.gerberx3.parser2.macro2.assignment2.Assignment2","title":"Assignment2","text":"<p>             Bases: <code>Statement2</code></p> <p>Variable assignment.</p> Source code in <code>src/pygerber/gerberx3/parser2/macro2/assignment2.py</code> <pre><code>class Assignment2(Statement2):\n    \"\"\"Variable assignment.\"\"\"\n\n    variable_name: str\n    value: Expression2\n\n    def on_parser2_eval_statement(self, context: Parser2Context) -&gt; None:\n        \"\"\"Evaluate macro to create concrete macro aperture.\"\"\"\n        context.hooks.macro_eval.on_assignment(context, self)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/macro2/assignment2.html#pygerber.gerberx3.parser2.macro2.assignment2.Assignment2.on_parser2_eval_statement","title":"on_parser2_eval_statement","text":"<pre><code>on_parser2_eval_statement(context: Parser2Context) -&gt; None\n</code></pre> <p>Evaluate macro to create concrete macro aperture.</p> Source code in <code>src/pygerber/gerberx3/parser2/macro2/assignment2.py</code> <pre><code>def on_parser2_eval_statement(self, context: Parser2Context) -&gt; None:\n    \"\"\"Evaluate macro to create concrete macro aperture.\"\"\"\n    context.hooks.macro_eval.on_assignment(context, self)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/macro2/element2.html","title":"element2","text":""},{"location":"reference/pygerber/gerberx3/parser2/macro2/element2.html#pygerber.gerberx3.parser2.macro2.element2","title":"element2","text":"<p>Base class for creating macro elements.</p>"},{"location":"reference/pygerber/gerberx3/parser2/macro2/element2.html#pygerber.gerberx3.parser2.macro2.element2.Element2","title":"Element2","text":"<p>             Bases: <code>FrozenGeneralModel</code></p> <p>Base class for creating macro elements.</p> Source code in <code>src/pygerber/gerberx3/parser2/macro2/element2.py</code> <pre><code>class Element2(FrozenGeneralModel):\n    \"\"\"Base class for creating macro elements.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/macro2/enums.html","title":"enums","text":""},{"location":"reference/pygerber/gerberx3/parser2/macro2/enums.html#pygerber.gerberx3.parser2.macro2.enums","title":"enums","text":"<p><code>enums</code> module contains Exposure2 enumeration containing possible macro primitive exposures.</p>"},{"location":"reference/pygerber/gerberx3/parser2/macro2/enums.html#pygerber.gerberx3.parser2.macro2.enums.Exposure","title":"Exposure","text":"<p>             Bases: <code>Enum</code></p> <p>Macro primitive exposure.</p> Source code in <code>src/pygerber/gerberx3/parser2/macro2/enums.py</code> <pre><code>class Exposure(Enum):\n    \"\"\"Macro primitive exposure.\"\"\"\n\n    ON = 1\n    OFF = 0\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/macro2/macro2.html","title":"macro2","text":""},{"location":"reference/pygerber/gerberx3/parser2/macro2/macro2.html#pygerber.gerberx3.parser2.macro2.macro2","title":"macro2","text":"<p>Container for aperture macro elements.</p>"},{"location":"reference/pygerber/gerberx3/parser2/macro2/macro2.html#pygerber.gerberx3.parser2.macro2.macro2.ApertureMacro2","title":"ApertureMacro2","text":"<p>             Bases: <code>FrozenGeneralModel</code></p> <p>Container for the elements contained within an aperture macro.</p> Source code in <code>src/pygerber/gerberx3/parser2/macro2/macro2.py</code> <pre><code>class ApertureMacro2(FrozenGeneralModel):\n    \"\"\"Container for the elements contained within an aperture macro.\"\"\"\n\n    name: str\n    statements: ReadonlyStatementBuffer2\n\n    def on_parser2_eval_statement(self, context: Parser2Context) -&gt; None:\n        \"\"\"Evaluate macro to create concrete macro aperture.\"\"\"\n        for stmt in self.statements:\n            stmt.on_parser2_eval_statement(context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/macro2/macro2.html#pygerber.gerberx3.parser2.macro2.macro2.ApertureMacro2.on_parser2_eval_statement","title":"on_parser2_eval_statement","text":"<pre><code>on_parser2_eval_statement(context: Parser2Context) -&gt; None\n</code></pre> <p>Evaluate macro to create concrete macro aperture.</p> Source code in <code>src/pygerber/gerberx3/parser2/macro2/macro2.py</code> <pre><code>def on_parser2_eval_statement(self, context: Parser2Context) -&gt; None:\n    \"\"\"Evaluate macro to create concrete macro aperture.\"\"\"\n    for stmt in self.statements:\n        stmt.on_parser2_eval_statement(context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/macro2/point2.html","title":"point2","text":""},{"location":"reference/pygerber/gerberx3/parser2/macro2/point2.html#pygerber.gerberx3.parser2.macro2.point2","title":"point2","text":"<p>Container for two macro expressions tied together as point in 2D space.</p>"},{"location":"reference/pygerber/gerberx3/parser2/macro2/point2.html#pygerber.gerberx3.parser2.macro2.point2.Point2","title":"Point2","text":"<p>             Bases: <code>Element2</code></p> <p>Pair of two expressions representing a point in 2D space.</p> Source code in <code>src/pygerber/gerberx3/parser2/macro2/point2.py</code> <pre><code>class Point2(Element2):\n    \"\"\"Pair of two expressions representing a point in 2D space.\"\"\"\n\n    x: Expression2\n    y: Expression2\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/macro2/statement2.html","title":"statement2","text":""},{"location":"reference/pygerber/gerberx3/parser2/macro2/statement2.html#pygerber.gerberx3.parser2.macro2.statement2","title":"statement2","text":"<p>Macro statement base class.</p> <p>A statement is everything what have to appear alone, for example a primitive or a variable assignment. Statements by themselves can't be reduced to numerical value during macro evaluation.</p>"},{"location":"reference/pygerber/gerberx3/parser2/macro2/statement2.html#pygerber.gerberx3.parser2.macro2.statement2.Statement2","title":"Statement2","text":"<p>             Bases: <code>Element2</code></p> <p>Macro statement base class.</p> <p>A statement is everything what have to appear alone, for example a primitive or a variable assignment. Statements by themselves can't be reduced to numerical value during macro evaluation.</p> Source code in <code>src/pygerber/gerberx3/parser2/macro2/statement2.py</code> <pre><code>class Statement2(Element2):\n    \"\"\"Macro statement base class.\n\n    A statement is everything what have to appear alone, for example a primitive or a\n    variable assignment. Statements by themselves can't be reduced to numerical value\n    during macro evaluation.\n    \"\"\"\n\n    def on_parser2_eval_statement(self, context: Parser2Context) -&gt; None:\n        \"\"\"Evaluate macro to create concrete macro aperture.\"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/macro2/statement2.html#pygerber.gerberx3.parser2.macro2.statement2.Statement2.on_parser2_eval_statement","title":"on_parser2_eval_statement","text":"<pre><code>on_parser2_eval_statement(context: Parser2Context) -&gt; None\n</code></pre> <p>Evaluate macro to create concrete macro aperture.</p> Source code in <code>src/pygerber/gerberx3/parser2/macro2/statement2.py</code> <pre><code>def on_parser2_eval_statement(self, context: Parser2Context) -&gt; None:\n    \"\"\"Evaluate macro to create concrete macro aperture.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/macro2/statement_buffer2.html","title":"statement_buffer2","text":""},{"location":"reference/pygerber/gerberx3/parser2/macro2/statement_buffer2.html#pygerber.gerberx3.parser2.macro2.statement_buffer2","title":"statement_buffer2","text":"<p>Module contains class `StatementBuffer2 for macro statements.</p>"},{"location":"reference/pygerber/gerberx3/parser2/macro2/statement_buffer2.html#pygerber.gerberx3.parser2.macro2.statement_buffer2.StatementBuffer2","title":"StatementBuffer2","text":"<p>Buffer for macro statements.</p> Source code in <code>src/pygerber/gerberx3/parser2/macro2/statement_buffer2.py</code> <pre><code>class StatementBuffer2:\n    \"\"\"Buffer for macro statements.\"\"\"\n\n    def __init__(self) -&gt; None:\n        self.statements: list[Statement2] = []\n\n    def add_statement(self, statement: Statement2) -&gt; None:\n        \"\"\"Append a complete statement to the buffer.\"\"\"\n        self.statements.append(statement)\n\n    def get_readonly(self) -&gt; ReadonlyStatementBuffer2:\n        \"\"\"Return readonly buffer.\"\"\"\n        return ReadonlyStatementBuffer2(statements=self.statements)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/macro2/statement_buffer2.html#pygerber.gerberx3.parser2.macro2.statement_buffer2.StatementBuffer2.add_statement","title":"add_statement","text":"<pre><code>add_statement(statement: Statement2) -&gt; None\n</code></pre> <p>Append a complete statement to the buffer.</p> Source code in <code>src/pygerber/gerberx3/parser2/macro2/statement_buffer2.py</code> <pre><code>def add_statement(self, statement: Statement2) -&gt; None:\n    \"\"\"Append a complete statement to the buffer.\"\"\"\n    self.statements.append(statement)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/macro2/statement_buffer2.html#pygerber.gerberx3.parser2.macro2.statement_buffer2.StatementBuffer2.get_readonly","title":"get_readonly","text":"<pre><code>get_readonly() -&gt; ReadonlyStatementBuffer2\n</code></pre> <p>Return readonly buffer.</p> Source code in <code>src/pygerber/gerberx3/parser2/macro2/statement_buffer2.py</code> <pre><code>def get_readonly(self) -&gt; ReadonlyStatementBuffer2:\n    \"\"\"Return readonly buffer.\"\"\"\n    return ReadonlyStatementBuffer2(statements=self.statements)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/macro2/statement_buffer2.html#pygerber.gerberx3.parser2.macro2.statement_buffer2.ReadonlyStatementBuffer2","title":"ReadonlyStatementBuffer2","text":"<p>             Bases: <code>FrozenGeneralModel</code></p> <p>Read-only macro statement buffer.</p> Source code in <code>src/pygerber/gerberx3/parser2/macro2/statement_buffer2.py</code> <pre><code>class ReadonlyStatementBuffer2(FrozenGeneralModel):\n    \"\"\"Read-only macro statement buffer.\"\"\"\n\n    statements: List[Statement2]\n\n    def __len__(self) -&gt; int:\n        \"\"\"Return length of buffered commands.\"\"\"\n        return len(self.statements)\n\n    def __iter__(self) -&gt; Iterator[Statement2]:  # type: ignore[override]\n        \"\"\"Iterate over buffered draw commands.\"\"\"\n        yield from self.statements\n\n    def __getitem__(self, position: int) -&gt; Statement2:\n        \"\"\"Get draw command at position.\"\"\"\n        return self.statements[position]\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/macro2/statement_buffer2.html#pygerber.gerberx3.parser2.macro2.statement_buffer2.ReadonlyStatementBuffer2.__len__","title":"__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre> <p>Return length of buffered commands.</p> Source code in <code>src/pygerber/gerberx3/parser2/macro2/statement_buffer2.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Return length of buffered commands.\"\"\"\n    return len(self.statements)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/macro2/statement_buffer2.html#pygerber.gerberx3.parser2.macro2.statement_buffer2.ReadonlyStatementBuffer2.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; Iterator[Statement2]\n</code></pre> <p>Iterate over buffered draw commands.</p> Source code in <code>src/pygerber/gerberx3/parser2/macro2/statement_buffer2.py</code> <pre><code>def __iter__(self) -&gt; Iterator[Statement2]:  # type: ignore[override]\n    \"\"\"Iterate over buffered draw commands.\"\"\"\n    yield from self.statements\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/macro2/statement_buffer2.html#pygerber.gerberx3.parser2.macro2.statement_buffer2.ReadonlyStatementBuffer2.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(position: int) -&gt; Statement2\n</code></pre> <p>Get draw command at position.</p> Source code in <code>src/pygerber/gerberx3/parser2/macro2/statement_buffer2.py</code> <pre><code>def __getitem__(self, position: int) -&gt; Statement2:\n    \"\"\"Get draw command at position.\"\"\"\n    return self.statements[position]\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/macro2/expressions2/__init__.html","title":"init","text":""},{"location":"reference/pygerber/gerberx3/parser2/macro2/expressions2/__init__.html#pygerber.gerberx3.parser2.macro2.expressions2","title":"expressions2","text":"<p><code>expressions2</code> package contains all macro expressions.</p>"},{"location":"reference/pygerber/gerberx3/parser2/macro2/expressions2/binary2.html","title":"binary2","text":""},{"location":"reference/pygerber/gerberx3/parser2/macro2/expressions2/binary2.html#pygerber.gerberx3.parser2.macro2.expressions2.binary2","title":"binary2","text":"<p><code>binary2</code> module contain classes wrapping binary operations within macro.</p>"},{"location":"reference/pygerber/gerberx3/parser2/macro2/expressions2/binary2.html#pygerber.gerberx3.parser2.macro2.expressions2.binary2.BinaryOperator2","title":"BinaryOperator2","text":"<p>             Bases: <code>Expression2</code></p> <p>Single binary operation.</p> Source code in <code>src/pygerber/gerberx3/parser2/macro2/expressions2/binary2.py</code> <pre><code>class BinaryOperator2(Expression2):\n    \"\"\"Single binary operation.\"\"\"\n\n    lhs: Expression2\n    rhs: Expression2\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/macro2/expressions2/binary2.html#pygerber.gerberx3.parser2.macro2.expressions2.binary2.Addition2","title":"Addition2","text":"<p>             Bases: <code>BinaryOperator2</code></p> <p>Addition expression.</p> Source code in <code>src/pygerber/gerberx3/parser2/macro2/expressions2/binary2.py</code> <pre><code>class Addition2(BinaryOperator2):\n    \"\"\"Addition expression.\"\"\"\n\n    def on_parser2_eval_expression(self, context: Parser2Context) -&gt; Decimal:\n        \"\"\"Reduce expression to numerical value.\"\"\"\n        return self.lhs.on_parser2_eval_expression(\n            context,\n        ) + self.rhs.on_parser2_eval_expression(context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/macro2/expressions2/binary2.html#pygerber.gerberx3.parser2.macro2.expressions2.binary2.Addition2.on_parser2_eval_expression","title":"on_parser2_eval_expression","text":"<pre><code>on_parser2_eval_expression(\n    context: Parser2Context,\n) -&gt; Decimal\n</code></pre> <p>Reduce expression to numerical value.</p> Source code in <code>src/pygerber/gerberx3/parser2/macro2/expressions2/binary2.py</code> <pre><code>def on_parser2_eval_expression(self, context: Parser2Context) -&gt; Decimal:\n    \"\"\"Reduce expression to numerical value.\"\"\"\n    return self.lhs.on_parser2_eval_expression(\n        context,\n    ) + self.rhs.on_parser2_eval_expression(context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/macro2/expressions2/binary2.html#pygerber.gerberx3.parser2.macro2.expressions2.binary2.Subtraction2","title":"Subtraction2","text":"<p>             Bases: <code>BinaryOperator2</code></p> <p>Subtract expression.</p> Source code in <code>src/pygerber/gerberx3/parser2/macro2/expressions2/binary2.py</code> <pre><code>class Subtraction2(BinaryOperator2):\n    \"\"\"Subtract expression.\"\"\"\n\n    def on_parser2_eval_expression(self, context: Parser2Context) -&gt; Decimal:\n        \"\"\"Reduce expression to numerical value.\"\"\"\n        return self.lhs.on_parser2_eval_expression(\n            context,\n        ) - self.rhs.on_parser2_eval_expression(context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/macro2/expressions2/binary2.html#pygerber.gerberx3.parser2.macro2.expressions2.binary2.Subtraction2.on_parser2_eval_expression","title":"on_parser2_eval_expression","text":"<pre><code>on_parser2_eval_expression(\n    context: Parser2Context,\n) -&gt; Decimal\n</code></pre> <p>Reduce expression to numerical value.</p> Source code in <code>src/pygerber/gerberx3/parser2/macro2/expressions2/binary2.py</code> <pre><code>def on_parser2_eval_expression(self, context: Parser2Context) -&gt; Decimal:\n    \"\"\"Reduce expression to numerical value.\"\"\"\n    return self.lhs.on_parser2_eval_expression(\n        context,\n    ) - self.rhs.on_parser2_eval_expression(context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/macro2/expressions2/binary2.html#pygerber.gerberx3.parser2.macro2.expressions2.binary2.Multiplication2","title":"Multiplication2","text":"<p>             Bases: <code>BinaryOperator2</code></p> <p>Multiply expression.</p> Source code in <code>src/pygerber/gerberx3/parser2/macro2/expressions2/binary2.py</code> <pre><code>class Multiplication2(BinaryOperator2):\n    \"\"\"Multiply expression.\"\"\"\n\n    def on_parser2_eval_expression(self, context: Parser2Context) -&gt; Decimal:\n        \"\"\"Reduce expression to numerical value.\"\"\"\n        return self.lhs.on_parser2_eval_expression(\n            context,\n        ) * self.rhs.on_parser2_eval_expression(context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/macro2/expressions2/binary2.html#pygerber.gerberx3.parser2.macro2.expressions2.binary2.Multiplication2.on_parser2_eval_expression","title":"on_parser2_eval_expression","text":"<pre><code>on_parser2_eval_expression(\n    context: Parser2Context,\n) -&gt; Decimal\n</code></pre> <p>Reduce expression to numerical value.</p> Source code in <code>src/pygerber/gerberx3/parser2/macro2/expressions2/binary2.py</code> <pre><code>def on_parser2_eval_expression(self, context: Parser2Context) -&gt; Decimal:\n    \"\"\"Reduce expression to numerical value.\"\"\"\n    return self.lhs.on_parser2_eval_expression(\n        context,\n    ) * self.rhs.on_parser2_eval_expression(context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/macro2/expressions2/binary2.html#pygerber.gerberx3.parser2.macro2.expressions2.binary2.Division2","title":"Division2","text":"<p>             Bases: <code>BinaryOperator2</code></p> <p>Divide expression.</p> Source code in <code>src/pygerber/gerberx3/parser2/macro2/expressions2/binary2.py</code> <pre><code>class Division2(BinaryOperator2):\n    \"\"\"Divide expression.\"\"\"\n\n    def on_parser2_eval_expression(self, context: Parser2Context) -&gt; Decimal:\n        \"\"\"Reduce expression to numerical value.\"\"\"\n        return self.lhs.on_parser2_eval_expression(\n            context,\n        ) / self.rhs.on_parser2_eval_expression(context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/macro2/expressions2/binary2.html#pygerber.gerberx3.parser2.macro2.expressions2.binary2.Division2.on_parser2_eval_expression","title":"on_parser2_eval_expression","text":"<pre><code>on_parser2_eval_expression(\n    context: Parser2Context,\n) -&gt; Decimal\n</code></pre> <p>Reduce expression to numerical value.</p> Source code in <code>src/pygerber/gerberx3/parser2/macro2/expressions2/binary2.py</code> <pre><code>def on_parser2_eval_expression(self, context: Parser2Context) -&gt; Decimal:\n    \"\"\"Reduce expression to numerical value.\"\"\"\n    return self.lhs.on_parser2_eval_expression(\n        context,\n    ) / self.rhs.on_parser2_eval_expression(context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/macro2/expressions2/constant2.html","title":"constant2","text":""},{"location":"reference/pygerber/gerberx3/parser2/macro2/expressions2/constant2.html#pygerber.gerberx3.parser2.macro2.expressions2.constant2","title":"constant2","text":"<p><code>constant2</code> module contain class wrapping constant value in macro definition.</p>"},{"location":"reference/pygerber/gerberx3/parser2/macro2/expressions2/constant2.html#pygerber.gerberx3.parser2.macro2.expressions2.constant2.Constant2","title":"Constant2","text":"<p>             Bases: <code>Expression2</code></p> <p>Class wrapping constant value in macro definition.</p> Source code in <code>src/pygerber/gerberx3/parser2/macro2/expressions2/constant2.py</code> <pre><code>class Constant2(Expression2):\n    \"\"\"Class wrapping constant value in macro definition.\"\"\"\n\n    value: Decimal\n\n    def on_parser2_eval_expression(\n        self,\n        context: Parser2Context,  # noqa: ARG002\n    ) -&gt; Decimal:\n        \"\"\"Reduce expression to numerical value.\"\"\"\n        return self.value\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/macro2/expressions2/constant2.html#pygerber.gerberx3.parser2.macro2.expressions2.constant2.Constant2.on_parser2_eval_expression","title":"on_parser2_eval_expression","text":"<pre><code>on_parser2_eval_expression(\n    context: Parser2Context,\n) -&gt; Decimal\n</code></pre> <p>Reduce expression to numerical value.</p> Source code in <code>src/pygerber/gerberx3/parser2/macro2/expressions2/constant2.py</code> <pre><code>def on_parser2_eval_expression(\n    self,\n    context: Parser2Context,  # noqa: ARG002\n) -&gt; Decimal:\n    \"\"\"Reduce expression to numerical value.\"\"\"\n    return self.value\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/macro2/expressions2/expression2.html","title":"expression2","text":""},{"location":"reference/pygerber/gerberx3/parser2/macro2/expressions2/expression2.html#pygerber.gerberx3.parser2.macro2.expressions2.expression2","title":"expression2","text":"<p>Macro expression base class, a part which can be used to build more complicated expressions.</p> <p>Example of macro expression would be a variable reference, a constant or addition, everything what can be composed into more complicated structures, but doesn't appear alone as a macro content. Expressions can be reduced to numerical value during macro evaluation.</p>"},{"location":"reference/pygerber/gerberx3/parser2/macro2/expressions2/expression2.html#pygerber.gerberx3.parser2.macro2.expressions2.expression2.Expression2","title":"Expression2","text":"<p>             Bases: <code>Element2</code></p> <p>Macro expression base class, a part which can be used to build more complicated expressions.</p> <p>Example of macro expression would be a variable reference, a constant or addition, everything what can be composed into more complicated structures, but doesn't appear alone as a macro content. Expressions can be reduced to numerical value during macro evaluation.</p> Source code in <code>src/pygerber/gerberx3/parser2/macro2/expressions2/expression2.py</code> <pre><code>class Expression2(Element2):\n    \"\"\"Macro expression base class, a part which can be used to build more complicated\n    expressions.\n\n    Example of macro expression would be a variable reference, a constant or addition,\n    everything what can be composed into more complicated structures, but doesn't appear\n    alone as a macro content. Expressions can be reduced to numerical value during macro\n    evaluation.\n    \"\"\"\n\n    def on_parser2_eval_expression(self, context: Parser2Context) -&gt; Decimal:\n        \"\"\"Reduce expression to numerical value.\"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/macro2/expressions2/expression2.html#pygerber.gerberx3.parser2.macro2.expressions2.expression2.Expression2.on_parser2_eval_expression","title":"on_parser2_eval_expression","text":"<pre><code>on_parser2_eval_expression(\n    context: Parser2Context,\n) -&gt; Decimal\n</code></pre> <p>Reduce expression to numerical value.</p> Source code in <code>src/pygerber/gerberx3/parser2/macro2/expressions2/expression2.py</code> <pre><code>def on_parser2_eval_expression(self, context: Parser2Context) -&gt; Decimal:\n    \"\"\"Reduce expression to numerical value.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/macro2/expressions2/unary2.html","title":"unary2","text":""},{"location":"reference/pygerber/gerberx3/parser2/macro2/expressions2/unary2.html#pygerber.gerberx3.parser2.macro2.expressions2.unary2","title":"unary2","text":"<p><code>unary2</code> module contain classes wrapping unary operations within macro.</p>"},{"location":"reference/pygerber/gerberx3/parser2/macro2/expressions2/unary2.html#pygerber.gerberx3.parser2.macro2.expressions2.unary2.UnaryOperator2","title":"UnaryOperator2","text":"<p>             Bases: <code>Expression2</code></p> <p>Single binary operation.</p> Source code in <code>src/pygerber/gerberx3/parser2/macro2/expressions2/unary2.py</code> <pre><code>class UnaryOperator2(Expression2):\n    \"\"\"Single binary operation.\"\"\"\n\n    op: Expression2\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/macro2/expressions2/unary2.html#pygerber.gerberx3.parser2.macro2.expressions2.unary2.Negation2","title":"Negation2","text":"<p>             Bases: <code>UnaryOperator2</code></p> <p>Unary minus operation.</p> Source code in <code>src/pygerber/gerberx3/parser2/macro2/expressions2/unary2.py</code> <pre><code>class Negation2(UnaryOperator2):\n    \"\"\"Unary minus operation.\"\"\"\n\n    def on_parser2_eval_expression(self, context: Parser2Context) -&gt; Decimal:\n        \"\"\"Reduce expression to numerical value.\"\"\"\n        return -self.op.on_parser2_eval_expression(context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/macro2/expressions2/unary2.html#pygerber.gerberx3.parser2.macro2.expressions2.unary2.Negation2.on_parser2_eval_expression","title":"on_parser2_eval_expression","text":"<pre><code>on_parser2_eval_expression(\n    context: Parser2Context,\n) -&gt; Decimal\n</code></pre> <p>Reduce expression to numerical value.</p> Source code in <code>src/pygerber/gerberx3/parser2/macro2/expressions2/unary2.py</code> <pre><code>def on_parser2_eval_expression(self, context: Parser2Context) -&gt; Decimal:\n    \"\"\"Reduce expression to numerical value.\"\"\"\n    return -self.op.on_parser2_eval_expression(context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/macro2/expressions2/unary2.html#pygerber.gerberx3.parser2.macro2.expressions2.unary2.Positive2","title":"Positive2","text":"<p>             Bases: <code>UnaryOperator2</code></p> <p>Unary plus operation.</p> Source code in <code>src/pygerber/gerberx3/parser2/macro2/expressions2/unary2.py</code> <pre><code>class Positive2(UnaryOperator2):\n    \"\"\"Unary plus operation.\"\"\"\n\n    def on_parser2_eval_expression(self, context: Parser2Context) -&gt; Decimal:\n        \"\"\"Reduce expression to numerical value.\"\"\"\n        return self.op.on_parser2_eval_expression(context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/macro2/expressions2/unary2.html#pygerber.gerberx3.parser2.macro2.expressions2.unary2.Positive2.on_parser2_eval_expression","title":"on_parser2_eval_expression","text":"<pre><code>on_parser2_eval_expression(\n    context: Parser2Context,\n) -&gt; Decimal\n</code></pre> <p>Reduce expression to numerical value.</p> Source code in <code>src/pygerber/gerberx3/parser2/macro2/expressions2/unary2.py</code> <pre><code>def on_parser2_eval_expression(self, context: Parser2Context) -&gt; Decimal:\n    \"\"\"Reduce expression to numerical value.\"\"\"\n    return self.op.on_parser2_eval_expression(context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/macro2/expressions2/variable_name.html","title":"variable_name","text":""},{"location":"reference/pygerber/gerberx3/parser2/macro2/expressions2/variable_name.html#pygerber.gerberx3.parser2.macro2.expressions2.variable_name","title":"variable_name","text":"<p>Module <code>variable_name.py</code> contains a class <code>VariableName</code> used to wrap variable name.</p>"},{"location":"reference/pygerber/gerberx3/parser2/macro2/expressions2/variable_name.html#pygerber.gerberx3.parser2.macro2.expressions2.variable_name.VariableName2","title":"VariableName2","text":"<p>             Bases: <code>Expression2</code></p> <p>Class wrapping variable name in macro definition.</p> Source code in <code>src/pygerber/gerberx3/parser2/macro2/expressions2/variable_name.py</code> <pre><code>class VariableName2(Expression2):\n    \"\"\"Class wrapping variable name in macro definition.\"\"\"\n\n    name: str\n\n    def on_parser2_eval_expression(self, context: Parser2Context) -&gt; Decimal:\n        \"\"\"Reduce expression to numerical value.\"\"\"\n        return context.macro_variable_buffer[self.name]\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/macro2/expressions2/variable_name.html#pygerber.gerberx3.parser2.macro2.expressions2.variable_name.VariableName2.on_parser2_eval_expression","title":"on_parser2_eval_expression","text":"<pre><code>on_parser2_eval_expression(\n    context: Parser2Context,\n) -&gt; Decimal\n</code></pre> <p>Reduce expression to numerical value.</p> Source code in <code>src/pygerber/gerberx3/parser2/macro2/expressions2/variable_name.py</code> <pre><code>def on_parser2_eval_expression(self, context: Parser2Context) -&gt; Decimal:\n    \"\"\"Reduce expression to numerical value.\"\"\"\n    return context.macro_variable_buffer[self.name]\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/macro2/primitives2/__init__.html","title":"init","text":""},{"location":"reference/pygerber/gerberx3/parser2/macro2/primitives2/__init__.html#pygerber.gerberx3.parser2.macro2.primitives2","title":"primitives2","text":"<p>Package primitives2 contain all macro primitives.</p>"},{"location":"reference/pygerber/gerberx3/parser2/macro2/primitives2/code_1_circle2.html","title":"code_1_circle2","text":""},{"location":"reference/pygerber/gerberx3/parser2/macro2/primitives2/code_1_circle2.html#pygerber.gerberx3.parser2.macro2.primitives2.code_1_circle2","title":"code_1_circle2","text":"<p>Macro primitive circle.</p>"},{"location":"reference/pygerber/gerberx3/parser2/macro2/primitives2/code_1_circle2.html#pygerber.gerberx3.parser2.macro2.primitives2.code_1_circle2.Code1Circle2","title":"Code1Circle2","text":"<p>             Bases: <code>Primitive2</code></p> <p>Circle macro primitive.</p> Source code in <code>src/pygerber/gerberx3/parser2/macro2/primitives2/code_1_circle2.py</code> <pre><code>class Code1Circle2(Primitive2):\n    \"\"\"Circle macro primitive.\"\"\"\n\n    exposure: Expression2\n    diameter: Expression2\n    center_x: Expression2\n    center_y: Expression2\n    rotation: Expression2\n\n    def on_parser2_eval_statement(self, context: Parser2Context) -&gt; None:\n        \"\"\"Evaluate macro to create concrete macro aperture.\"\"\"\n        context.hooks.macro_eval.on_code_1_circle(context, self)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/macro2/primitives2/code_1_circle2.html#pygerber.gerberx3.parser2.macro2.primitives2.code_1_circle2.Code1Circle2.on_parser2_eval_statement","title":"on_parser2_eval_statement","text":"<pre><code>on_parser2_eval_statement(context: Parser2Context) -&gt; None\n</code></pre> <p>Evaluate macro to create concrete macro aperture.</p> Source code in <code>src/pygerber/gerberx3/parser2/macro2/primitives2/code_1_circle2.py</code> <pre><code>def on_parser2_eval_statement(self, context: Parser2Context) -&gt; None:\n    \"\"\"Evaluate macro to create concrete macro aperture.\"\"\"\n    context.hooks.macro_eval.on_code_1_circle(context, self)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/macro2/primitives2/code_20_vector_line2.html","title":"code_20_vector_line2","text":""},{"location":"reference/pygerber/gerberx3/parser2/macro2/primitives2/code_20_vector_line2.html#pygerber.gerberx3.parser2.macro2.primitives2.code_20_vector_line2","title":"code_20_vector_line2","text":"<p>Macro primitive vector line.</p>"},{"location":"reference/pygerber/gerberx3/parser2/macro2/primitives2/code_20_vector_line2.html#pygerber.gerberx3.parser2.macro2.primitives2.code_20_vector_line2.Code20VectorLine2","title":"Code20VectorLine2","text":"<p>             Bases: <code>Primitive2</code></p> <p>Vector line macro primitive.</p> Source code in <code>src/pygerber/gerberx3/parser2/macro2/primitives2/code_20_vector_line2.py</code> <pre><code>class Code20VectorLine2(Primitive2):\n    \"\"\"Vector line macro primitive.\"\"\"\n\n    exposure: Expression2\n    width: Expression2\n    start_x: Expression2\n    start_y: Expression2\n    end_x: Expression2\n    end_y: Expression2\n    rotation: Expression2\n\n    def on_parser2_eval_statement(self, context: Parser2Context) -&gt; None:\n        \"\"\"Evaluate macro to create concrete macro aperture.\"\"\"\n        context.hooks.macro_eval.on_code_20_vector_line(context, self)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/macro2/primitives2/code_20_vector_line2.html#pygerber.gerberx3.parser2.macro2.primitives2.code_20_vector_line2.Code20VectorLine2.on_parser2_eval_statement","title":"on_parser2_eval_statement","text":"<pre><code>on_parser2_eval_statement(context: Parser2Context) -&gt; None\n</code></pre> <p>Evaluate macro to create concrete macro aperture.</p> Source code in <code>src/pygerber/gerberx3/parser2/macro2/primitives2/code_20_vector_line2.py</code> <pre><code>def on_parser2_eval_statement(self, context: Parser2Context) -&gt; None:\n    \"\"\"Evaluate macro to create concrete macro aperture.\"\"\"\n    context.hooks.macro_eval.on_code_20_vector_line(context, self)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/macro2/primitives2/code_21_center_line2.html","title":"code_21_center_line2","text":""},{"location":"reference/pygerber/gerberx3/parser2/macro2/primitives2/code_21_center_line2.html#pygerber.gerberx3.parser2.macro2.primitives2.code_21_center_line2","title":"code_21_center_line2","text":"<p>Macro primitive center line.</p>"},{"location":"reference/pygerber/gerberx3/parser2/macro2/primitives2/code_21_center_line2.html#pygerber.gerberx3.parser2.macro2.primitives2.code_21_center_line2.Code21CenterLine2","title":"Code21CenterLine2","text":"<p>             Bases: <code>Primitive2</code></p> <p>Center line macro primitive.</p> Source code in <code>src/pygerber/gerberx3/parser2/macro2/primitives2/code_21_center_line2.py</code> <pre><code>class Code21CenterLine2(Primitive2):\n    \"\"\"Center line macro primitive.\"\"\"\n\n    exposure: Expression2\n    width: Expression2\n    height: Expression2\n    center_x: Expression2\n    center_y: Expression2\n    rotation: Expression2\n\n    def on_parser2_eval_statement(self, context: Parser2Context) -&gt; None:\n        \"\"\"Evaluate macro to create concrete macro aperture.\"\"\"\n        context.hooks.macro_eval.on_code_21_center_line(context, self)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/macro2/primitives2/code_21_center_line2.html#pygerber.gerberx3.parser2.macro2.primitives2.code_21_center_line2.Code21CenterLine2.on_parser2_eval_statement","title":"on_parser2_eval_statement","text":"<pre><code>on_parser2_eval_statement(context: Parser2Context) -&gt; None\n</code></pre> <p>Evaluate macro to create concrete macro aperture.</p> Source code in <code>src/pygerber/gerberx3/parser2/macro2/primitives2/code_21_center_line2.py</code> <pre><code>def on_parser2_eval_statement(self, context: Parser2Context) -&gt; None:\n    \"\"\"Evaluate macro to create concrete macro aperture.\"\"\"\n    context.hooks.macro_eval.on_code_21_center_line(context, self)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/macro2/primitives2/code_22_lower_left_line2.html","title":"code_22_lower_left_line2","text":""},{"location":"reference/pygerber/gerberx3/parser2/macro2/primitives2/code_22_lower_left_line2.html#pygerber.gerberx3.parser2.macro2.primitives2.code_22_lower_left_line2","title":"code_22_lower_left_line2","text":"<p>Code 22 lower left line macro primitive.</p>"},{"location":"reference/pygerber/gerberx3/parser2/macro2/primitives2/code_22_lower_left_line2.html#pygerber.gerberx3.parser2.macro2.primitives2.code_22_lower_left_line2.Code22LowerLeftLine2","title":"Code22LowerLeftLine2","text":"<p>             Bases: <code>Primitive2</code></p> <p>Code 22 lower left line macro primitive.</p> Source code in <code>src/pygerber/gerberx3/parser2/macro2/primitives2/code_22_lower_left_line2.py</code> <pre><code>class Code22LowerLeftLine2(Primitive2):\n    \"\"\"Code 22 lower left line macro primitive.\"\"\"\n\n    def on_parser2_eval_statement(self, context: Parser2Context) -&gt; None:\n        \"\"\"Evaluate macro to create concrete macro aperture.\"\"\"\n        context.hooks.macro_eval.on_code_22_lower_left_line(context, self)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/macro2/primitives2/code_22_lower_left_line2.html#pygerber.gerberx3.parser2.macro2.primitives2.code_22_lower_left_line2.Code22LowerLeftLine2.on_parser2_eval_statement","title":"on_parser2_eval_statement","text":"<pre><code>on_parser2_eval_statement(context: Parser2Context) -&gt; None\n</code></pre> <p>Evaluate macro to create concrete macro aperture.</p> Source code in <code>src/pygerber/gerberx3/parser2/macro2/primitives2/code_22_lower_left_line2.py</code> <pre><code>def on_parser2_eval_statement(self, context: Parser2Context) -&gt; None:\n    \"\"\"Evaluate macro to create concrete macro aperture.\"\"\"\n    context.hooks.macro_eval.on_code_22_lower_left_line(context, self)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/macro2/primitives2/code_2_vector_line2.html","title":"code_2_vector_line2","text":""},{"location":"reference/pygerber/gerberx3/parser2/macro2/primitives2/code_2_vector_line2.html#pygerber.gerberx3.parser2.macro2.primitives2.code_2_vector_line2","title":"code_2_vector_line2","text":"<p>Vector line macro primitive.</p>"},{"location":"reference/pygerber/gerberx3/parser2/macro2/primitives2/code_2_vector_line2.html#pygerber.gerberx3.parser2.macro2.primitives2.code_2_vector_line2.Code2VectorLine2","title":"Code2VectorLine2","text":"<p>             Bases: <code>Primitive2</code></p> <p>Vector line macro primitive.</p> Source code in <code>src/pygerber/gerberx3/parser2/macro2/primitives2/code_2_vector_line2.py</code> <pre><code>class Code2VectorLine2(Primitive2):\n    \"\"\"Vector line macro primitive.\"\"\"\n\n    def on_parser2_eval_statement(self, context: Parser2Context) -&gt; None:\n        \"\"\"Evaluate macro to create concrete macro aperture.\"\"\"\n        context.hooks.macro_eval.on_code_2_vector_line(context, self)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/macro2/primitives2/code_2_vector_line2.html#pygerber.gerberx3.parser2.macro2.primitives2.code_2_vector_line2.Code2VectorLine2.on_parser2_eval_statement","title":"on_parser2_eval_statement","text":"<pre><code>on_parser2_eval_statement(context: Parser2Context) -&gt; None\n</code></pre> <p>Evaluate macro to create concrete macro aperture.</p> Source code in <code>src/pygerber/gerberx3/parser2/macro2/primitives2/code_2_vector_line2.py</code> <pre><code>def on_parser2_eval_statement(self, context: Parser2Context) -&gt; None:\n    \"\"\"Evaluate macro to create concrete macro aperture.\"\"\"\n    context.hooks.macro_eval.on_code_2_vector_line(context, self)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/macro2/primitives2/code_4_outline2.html","title":"code_4_outline2","text":""},{"location":"reference/pygerber/gerberx3/parser2/macro2/primitives2/code_4_outline2.html#pygerber.gerberx3.parser2.macro2.primitives2.code_4_outline2","title":"code_4_outline2","text":"<p>Outline macro primitive.</p>"},{"location":"reference/pygerber/gerberx3/parser2/macro2/primitives2/code_4_outline2.html#pygerber.gerberx3.parser2.macro2.primitives2.code_4_outline2.Code4Outline2","title":"Code4Outline2","text":"<p>             Bases: <code>Primitive2</code></p> <p>Vector line macro primitive.</p> Source code in <code>src/pygerber/gerberx3/parser2/macro2/primitives2/code_4_outline2.py</code> <pre><code>class Code4Outline2(Primitive2):\n    \"\"\"Vector line macro primitive.\"\"\"\n\n    exposure: Expression2\n    vertex_count: Expression2\n    start_x: Expression2\n    start_y: Expression2\n    points: List[Point2]\n    rotation: Expression2\n\n    def on_parser2_eval_statement(self, context: Parser2Context) -&gt; None:\n        \"\"\"Evaluate macro to create concrete macro aperture.\"\"\"\n        context.hooks.macro_eval.on_code_4_outline(context, self)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/macro2/primitives2/code_4_outline2.html#pygerber.gerberx3.parser2.macro2.primitives2.code_4_outline2.Code4Outline2.on_parser2_eval_statement","title":"on_parser2_eval_statement","text":"<pre><code>on_parser2_eval_statement(context: Parser2Context) -&gt; None\n</code></pre> <p>Evaluate macro to create concrete macro aperture.</p> Source code in <code>src/pygerber/gerberx3/parser2/macro2/primitives2/code_4_outline2.py</code> <pre><code>def on_parser2_eval_statement(self, context: Parser2Context) -&gt; None:\n    \"\"\"Evaluate macro to create concrete macro aperture.\"\"\"\n    context.hooks.macro_eval.on_code_4_outline(context, self)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/macro2/primitives2/code_5_polygon2.html","title":"code_5_polygon2","text":""},{"location":"reference/pygerber/gerberx3/parser2/macro2/primitives2/code_5_polygon2.html#pygerber.gerberx3.parser2.macro2.primitives2.code_5_polygon2","title":"code_5_polygon2","text":"<p>Macro primitive polygon.</p>"},{"location":"reference/pygerber/gerberx3/parser2/macro2/primitives2/code_5_polygon2.html#pygerber.gerberx3.parser2.macro2.primitives2.code_5_polygon2.Code5Polygon2","title":"Code5Polygon2","text":"<p>             Bases: <code>Primitive2</code></p> <p>Polygon macro primitive.</p> Source code in <code>src/pygerber/gerberx3/parser2/macro2/primitives2/code_5_polygon2.py</code> <pre><code>class Code5Polygon2(Primitive2):\n    \"\"\"Polygon macro primitive.\"\"\"\n\n    # 5 Polygon Exposure, # vertices, Center X, Center Y, Diameter, Rotation 4.5.1.7\n\n    exposure: Expression2\n    number_of_vertices: Expression2\n    center_x: Expression2\n    center_y: Expression2\n    diameter: Expression2\n    rotation: Expression2\n\n    def on_parser2_eval_statement(self, context: Parser2Context) -&gt; None:\n        \"\"\"Evaluate macro to create concrete macro aperture.\"\"\"\n        context.hooks.macro_eval.on_code_5_polygon(context, self)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/macro2/primitives2/code_5_polygon2.html#pygerber.gerberx3.parser2.macro2.primitives2.code_5_polygon2.Code5Polygon2.on_parser2_eval_statement","title":"on_parser2_eval_statement","text":"<pre><code>on_parser2_eval_statement(context: Parser2Context) -&gt; None\n</code></pre> <p>Evaluate macro to create concrete macro aperture.</p> Source code in <code>src/pygerber/gerberx3/parser2/macro2/primitives2/code_5_polygon2.py</code> <pre><code>def on_parser2_eval_statement(self, context: Parser2Context) -&gt; None:\n    \"\"\"Evaluate macro to create concrete macro aperture.\"\"\"\n    context.hooks.macro_eval.on_code_5_polygon(context, self)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/macro2/primitives2/code_6_moire2.html","title":"code_6_moire2","text":""},{"location":"reference/pygerber/gerberx3/parser2/macro2/primitives2/code_6_moire2.html#pygerber.gerberx3.parser2.macro2.primitives2.code_6_moire2","title":"code_6_moire2","text":"<p>Macro primitive Moire.</p>"},{"location":"reference/pygerber/gerberx3/parser2/macro2/primitives2/code_6_moire2.html#pygerber.gerberx3.parser2.macro2.primitives2.code_6_moire2.Code6Moire2","title":"Code6Moire2","text":"<p>             Bases: <code>Primitive2</code></p> <p>Moire macro primitive.</p> Source code in <code>src/pygerber/gerberx3/parser2/macro2/primitives2/code_6_moire2.py</code> <pre><code>class Code6Moire2(Primitive2):\n    \"\"\"Moire macro primitive.\"\"\"\n\n    def on_parser2_eval_statement(self, context: Parser2Context) -&gt; None:\n        \"\"\"Evaluate macro to create concrete macro aperture.\"\"\"\n        context.hooks.macro_eval.on_code_6_moire(context, self)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/macro2/primitives2/code_6_moire2.html#pygerber.gerberx3.parser2.macro2.primitives2.code_6_moire2.Code6Moire2.on_parser2_eval_statement","title":"on_parser2_eval_statement","text":"<pre><code>on_parser2_eval_statement(context: Parser2Context) -&gt; None\n</code></pre> <p>Evaluate macro to create concrete macro aperture.</p> Source code in <code>src/pygerber/gerberx3/parser2/macro2/primitives2/code_6_moire2.py</code> <pre><code>def on_parser2_eval_statement(self, context: Parser2Context) -&gt; None:\n    \"\"\"Evaluate macro to create concrete macro aperture.\"\"\"\n    context.hooks.macro_eval.on_code_6_moire(context, self)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/macro2/primitives2/code_7_thermal2.html","title":"code_7_thermal2","text":""},{"location":"reference/pygerber/gerberx3/parser2/macro2/primitives2/code_7_thermal2.html#pygerber.gerberx3.parser2.macro2.primitives2.code_7_thermal2","title":"code_7_thermal2","text":"<p>Thermal macro primitive.</p>"},{"location":"reference/pygerber/gerberx3/parser2/macro2/primitives2/code_7_thermal2.html#pygerber.gerberx3.parser2.macro2.primitives2.code_7_thermal2.Code7Thermal2","title":"Code7Thermal2","text":"<p>             Bases: <code>Primitive2</code></p> <p>Thermal macro primitive.</p> Source code in <code>src/pygerber/gerberx3/parser2/macro2/primitives2/code_7_thermal2.py</code> <pre><code>class Code7Thermal2(Primitive2):\n    \"\"\"Thermal macro primitive.\"\"\"\n\n    center_x: Expression2\n    center_y: Expression2\n    outer_diameter: Expression2\n    inner_diameter: Expression2\n    gap: Expression2\n    rotation: Expression2\n\n    def on_parser2_eval_statement(self, context: Parser2Context) -&gt; None:\n        \"\"\"Evaluate macro to create concrete macro aperture.\"\"\"\n        context.hooks.macro_eval.on_code_7_thermal(context, self)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/macro2/primitives2/code_7_thermal2.html#pygerber.gerberx3.parser2.macro2.primitives2.code_7_thermal2.Code7Thermal2.on_parser2_eval_statement","title":"on_parser2_eval_statement","text":"<pre><code>on_parser2_eval_statement(context: Parser2Context) -&gt; None\n</code></pre> <p>Evaluate macro to create concrete macro aperture.</p> Source code in <code>src/pygerber/gerberx3/parser2/macro2/primitives2/code_7_thermal2.py</code> <pre><code>def on_parser2_eval_statement(self, context: Parser2Context) -&gt; None:\n    \"\"\"Evaluate macro to create concrete macro aperture.\"\"\"\n    context.hooks.macro_eval.on_code_7_thermal(context, self)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/parser2/macro2/primitives2/primitive2.html","title":"primitive2","text":""},{"location":"reference/pygerber/gerberx3/parser2/macro2/primitives2/primitive2.html#pygerber.gerberx3.parser2.macro2.primitives2.primitive2","title":"primitive2","text":"<p>Macro primitive base class.</p>"},{"location":"reference/pygerber/gerberx3/parser2/macro2/primitives2/primitive2.html#pygerber.gerberx3.parser2.macro2.primitives2.primitive2.Primitive2","title":"Primitive2","text":"<p>             Bases: <code>Statement2</code></p> <p>Macro primitive base class.</p> Source code in <code>src/pygerber/gerberx3/parser2/macro2/primitives2/primitive2.py</code> <pre><code>class Primitive2(Statement2):\n    \"\"\"Macro primitive base class.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/renderer2/__init__.html","title":"init","text":""},{"location":"reference/pygerber/gerberx3/renderer2/__init__.html#pygerber.gerberx3.renderer2","title":"renderer2","text":"<p>Package <code>backend2</code> contains classes implementing Gerber rendering for command buffers generated by Parser2 based Gerber source.</p>"},{"location":"reference/pygerber/gerberx3/renderer2/abstract.html","title":"abstract","text":""},{"location":"reference/pygerber/gerberx3/renderer2/abstract.html#pygerber.gerberx3.renderer2.abstract","title":"abstract","text":"<p>Module contains base class Rendering backend for Parser2 based Gerber data structures.</p>"},{"location":"reference/pygerber/gerberx3/renderer2/abstract.html#pygerber.gerberx3.renderer2.abstract.Renderer2","title":"Renderer2","text":"<p>Rendering backend base class for Parser2 based Gerber data structures.</p> Source code in <code>src/pygerber/gerberx3/renderer2/abstract.py</code> <pre><code>class Renderer2:\n    \"\"\"Rendering backend base class for Parser2 based Gerber data structures.\"\"\"\n\n    def __init__(self, hooks: Renderer2HooksABC) -&gt; None:\n        self.hooks = hooks\n\n    def render(self, command_buffer: ReadonlyCommandBuffer2) -&gt; ImageRef:\n        \"\"\"Render Gerber structures.\"\"\"\n        for _ in self.render_iter(command_buffer):\n            pass\n\n        return self.get_image_ref()\n\n    def get_image_ref(self) -&gt; ImageRef:\n        \"\"\"Get reference to render image.\"\"\"\n        return self.hooks.get_image_ref()\n\n    def render_iter(\n        self,\n        command_buffer: ReadonlyCommandBuffer2,\n    ) -&gt; Generator[Command2, None, None]:\n        \"\"\"Iterate over commands in buffer and render image for each command.\"\"\"\n        self.hooks.init(self, command_buffer)\n        for command in command_buffer:\n            command.render(self)\n            yield command\n        self.hooks.finalize()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/renderer2/abstract.html#pygerber.gerberx3.renderer2.abstract.Renderer2.render","title":"render","text":"<pre><code>render(command_buffer: ReadonlyCommandBuffer2) -&gt; ImageRef\n</code></pre> <p>Render Gerber structures.</p> Source code in <code>src/pygerber/gerberx3/renderer2/abstract.py</code> <pre><code>def render(self, command_buffer: ReadonlyCommandBuffer2) -&gt; ImageRef:\n    \"\"\"Render Gerber structures.\"\"\"\n    for _ in self.render_iter(command_buffer):\n        pass\n\n    return self.get_image_ref()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/renderer2/abstract.html#pygerber.gerberx3.renderer2.abstract.Renderer2.get_image_ref","title":"get_image_ref","text":"<pre><code>get_image_ref() -&gt; ImageRef\n</code></pre> <p>Get reference to render image.</p> Source code in <code>src/pygerber/gerberx3/renderer2/abstract.py</code> <pre><code>def get_image_ref(self) -&gt; ImageRef:\n    \"\"\"Get reference to render image.\"\"\"\n    return self.hooks.get_image_ref()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/renderer2/abstract.html#pygerber.gerberx3.renderer2.abstract.Renderer2.render_iter","title":"render_iter","text":"<pre><code>render_iter(\n    command_buffer: ReadonlyCommandBuffer2,\n) -&gt; Generator[Command2, None, None]\n</code></pre> <p>Iterate over commands in buffer and render image for each command.</p> Source code in <code>src/pygerber/gerberx3/renderer2/abstract.py</code> <pre><code>def render_iter(\n    self,\n    command_buffer: ReadonlyCommandBuffer2,\n) -&gt; Generator[Command2, None, None]:\n    \"\"\"Iterate over commands in buffer and render image for each command.\"\"\"\n    self.hooks.init(self, command_buffer)\n    for command in command_buffer:\n        command.render(self)\n        yield command\n    self.hooks.finalize()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/renderer2/abstract.html#pygerber.gerberx3.renderer2.abstract.Renderer2HooksABC","title":"Renderer2HooksABC","text":"<p>Hooks for implementing rendering of Gerber structures to a target format.</p> Source code in <code>src/pygerber/gerberx3/renderer2/abstract.py</code> <pre><code>class Renderer2HooksABC:\n    \"\"\"Hooks for implementing rendering of Gerber structures to a target format.\"\"\"\n\n    def init(self, renderer: Renderer2, command_buffer: ReadonlyCommandBuffer2) -&gt; None:\n        \"\"\"Initialize rendering.\"\"\"\n\n    def render_line(self, command: Line2) -&gt; None:\n        \"\"\"Render line to target image.\"\"\"\n\n    def render_arc(self, command: Arc2) -&gt; None:\n        \"\"\"Render arc to target image.\"\"\"\n\n    def render_cc_arc(self, command: Arc2) -&gt; None:\n        \"\"\"Render arc to target image.\"\"\"\n\n    def render_flash_circle(self, command: Flash2, aperture: Circle2) -&gt; None:\n        \"\"\"Render flash circle to target image.\"\"\"\n\n    def render_flash_no_circle(self, command: Flash2, aperture: NoCircle2) -&gt; None:\n        \"\"\"Render flash no circle aperture to target image.\"\"\"\n\n    def render_flash_rectangle(self, command: Flash2, aperture: Rectangle2) -&gt; None:\n        \"\"\"Render flash rectangle to target image.\"\"\"\n\n    def render_flash_obround(self, command: Flash2, aperture: Obround2) -&gt; None:\n        \"\"\"Render flash obround to target image.\"\"\"\n\n    def render_flash_polygon(self, command: Flash2, aperture: Polygon2) -&gt; None:\n        \"\"\"Render flash polygon to target image.\"\"\"\n\n    def render_flash_macro(self, command: Flash2, aperture: Macro2) -&gt; None:\n        \"\"\"Render flash macro aperture to target image.\"\"\"\n\n    def render_buffer(self, command: BufferCommand2) -&gt; None:\n        \"\"\"Render buffer command, performing no writes.\"\"\"\n\n    def render_region(self, command: Region2) -&gt; None:\n        \"\"\"Render region to target image.\"\"\"\n\n    def get_image_ref(self) -&gt; ImageRef:\n        \"\"\"Get reference to render image.\"\"\"\n        raise NotImplementedError\n\n    def finalize(self) -&gt; None:\n        \"\"\"Finalize rendering.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/renderer2/abstract.html#pygerber.gerberx3.renderer2.abstract.Renderer2HooksABC.init","title":"init","text":"<pre><code>init(\n    renderer: Renderer2,\n    command_buffer: ReadonlyCommandBuffer2,\n) -&gt; None\n</code></pre> <p>Initialize rendering.</p> Source code in <code>src/pygerber/gerberx3/renderer2/abstract.py</code> <pre><code>def init(self, renderer: Renderer2, command_buffer: ReadonlyCommandBuffer2) -&gt; None:\n    \"\"\"Initialize rendering.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/renderer2/abstract.html#pygerber.gerberx3.renderer2.abstract.Renderer2HooksABC.render_line","title":"render_line","text":"<pre><code>render_line(command: Line2) -&gt; None\n</code></pre> <p>Render line to target image.</p> Source code in <code>src/pygerber/gerberx3/renderer2/abstract.py</code> <pre><code>def render_line(self, command: Line2) -&gt; None:\n    \"\"\"Render line to target image.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/renderer2/abstract.html#pygerber.gerberx3.renderer2.abstract.Renderer2HooksABC.render_arc","title":"render_arc","text":"<pre><code>render_arc(command: Arc2) -&gt; None\n</code></pre> <p>Render arc to target image.</p> Source code in <code>src/pygerber/gerberx3/renderer2/abstract.py</code> <pre><code>def render_arc(self, command: Arc2) -&gt; None:\n    \"\"\"Render arc to target image.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/renderer2/abstract.html#pygerber.gerberx3.renderer2.abstract.Renderer2HooksABC.render_cc_arc","title":"render_cc_arc","text":"<pre><code>render_cc_arc(command: Arc2) -&gt; None\n</code></pre> <p>Render arc to target image.</p> Source code in <code>src/pygerber/gerberx3/renderer2/abstract.py</code> <pre><code>def render_cc_arc(self, command: Arc2) -&gt; None:\n    \"\"\"Render arc to target image.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/renderer2/abstract.html#pygerber.gerberx3.renderer2.abstract.Renderer2HooksABC.render_flash_circle","title":"render_flash_circle","text":"<pre><code>render_flash_circle(\n    command: Flash2, aperture: Circle2\n) -&gt; None\n</code></pre> <p>Render flash circle to target image.</p> Source code in <code>src/pygerber/gerberx3/renderer2/abstract.py</code> <pre><code>def render_flash_circle(self, command: Flash2, aperture: Circle2) -&gt; None:\n    \"\"\"Render flash circle to target image.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/renderer2/abstract.html#pygerber.gerberx3.renderer2.abstract.Renderer2HooksABC.render_flash_no_circle","title":"render_flash_no_circle","text":"<pre><code>render_flash_no_circle(\n    command: Flash2, aperture: NoCircle2\n) -&gt; None\n</code></pre> <p>Render flash no circle aperture to target image.</p> Source code in <code>src/pygerber/gerberx3/renderer2/abstract.py</code> <pre><code>def render_flash_no_circle(self, command: Flash2, aperture: NoCircle2) -&gt; None:\n    \"\"\"Render flash no circle aperture to target image.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/renderer2/abstract.html#pygerber.gerberx3.renderer2.abstract.Renderer2HooksABC.render_flash_rectangle","title":"render_flash_rectangle","text":"<pre><code>render_flash_rectangle(\n    command: Flash2, aperture: Rectangle2\n) -&gt; None\n</code></pre> <p>Render flash rectangle to target image.</p> Source code in <code>src/pygerber/gerberx3/renderer2/abstract.py</code> <pre><code>def render_flash_rectangle(self, command: Flash2, aperture: Rectangle2) -&gt; None:\n    \"\"\"Render flash rectangle to target image.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/renderer2/abstract.html#pygerber.gerberx3.renderer2.abstract.Renderer2HooksABC.render_flash_obround","title":"render_flash_obround","text":"<pre><code>render_flash_obround(\n    command: Flash2, aperture: Obround2\n) -&gt; None\n</code></pre> <p>Render flash obround to target image.</p> Source code in <code>src/pygerber/gerberx3/renderer2/abstract.py</code> <pre><code>def render_flash_obround(self, command: Flash2, aperture: Obround2) -&gt; None:\n    \"\"\"Render flash obround to target image.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/renderer2/abstract.html#pygerber.gerberx3.renderer2.abstract.Renderer2HooksABC.render_flash_polygon","title":"render_flash_polygon","text":"<pre><code>render_flash_polygon(\n    command: Flash2, aperture: Polygon2\n) -&gt; None\n</code></pre> <p>Render flash polygon to target image.</p> Source code in <code>src/pygerber/gerberx3/renderer2/abstract.py</code> <pre><code>def render_flash_polygon(self, command: Flash2, aperture: Polygon2) -&gt; None:\n    \"\"\"Render flash polygon to target image.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/renderer2/abstract.html#pygerber.gerberx3.renderer2.abstract.Renderer2HooksABC.render_flash_macro","title":"render_flash_macro","text":"<pre><code>render_flash_macro(\n    command: Flash2, aperture: Macro2\n) -&gt; None\n</code></pre> <p>Render flash macro aperture to target image.</p> Source code in <code>src/pygerber/gerberx3/renderer2/abstract.py</code> <pre><code>def render_flash_macro(self, command: Flash2, aperture: Macro2) -&gt; None:\n    \"\"\"Render flash macro aperture to target image.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/renderer2/abstract.html#pygerber.gerberx3.renderer2.abstract.Renderer2HooksABC.render_buffer","title":"render_buffer","text":"<pre><code>render_buffer(command: BufferCommand2) -&gt; None\n</code></pre> <p>Render buffer command, performing no writes.</p> Source code in <code>src/pygerber/gerberx3/renderer2/abstract.py</code> <pre><code>def render_buffer(self, command: BufferCommand2) -&gt; None:\n    \"\"\"Render buffer command, performing no writes.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/renderer2/abstract.html#pygerber.gerberx3.renderer2.abstract.Renderer2HooksABC.render_region","title":"render_region","text":"<pre><code>render_region(command: Region2) -&gt; None\n</code></pre> <p>Render region to target image.</p> Source code in <code>src/pygerber/gerberx3/renderer2/abstract.py</code> <pre><code>def render_region(self, command: Region2) -&gt; None:\n    \"\"\"Render region to target image.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/renderer2/abstract.html#pygerber.gerberx3.renderer2.abstract.Renderer2HooksABC.get_image_ref","title":"get_image_ref","text":"<pre><code>get_image_ref() -&gt; ImageRef\n</code></pre> <p>Get reference to render image.</p> Source code in <code>src/pygerber/gerberx3/renderer2/abstract.py</code> <pre><code>def get_image_ref(self) -&gt; ImageRef:\n    \"\"\"Get reference to render image.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/pygerber/gerberx3/renderer2/abstract.html#pygerber.gerberx3.renderer2.abstract.Renderer2HooksABC.finalize","title":"finalize","text":"<pre><code>finalize() -&gt; None\n</code></pre> <p>Finalize rendering.</p> Source code in <code>src/pygerber/gerberx3/renderer2/abstract.py</code> <pre><code>def finalize(self) -&gt; None:\n    \"\"\"Finalize rendering.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/renderer2/abstract.html#pygerber.gerberx3.renderer2.abstract.ImageRef","title":"ImageRef","text":"<p>Generic container for reference to rendered image.</p> Source code in <code>src/pygerber/gerberx3/renderer2/abstract.py</code> <pre><code>class ImageRef:\n    \"\"\"Generic container for reference to rendered image.\"\"\"\n\n    def save_to(\n        self,\n        dest: BytesIO | Path | str,\n        options: Optional[FormatOptions] = None,\n    ) -&gt; None:\n        \"\"\"Save rendered image.\"\"\"\n        if isinstance(dest, str):\n            dest = Path(dest)\n        if isinstance(dest, Path):\n            with dest.open(\"wb\") as output:\n                return self._save_to_io(output, options)\n        else:\n            return self._save_to_io(dest, options)\n\n    def _save_to_io(\n        self,\n        output: BinaryIO,\n        options: Optional[FormatOptions] = None,\n    ) -&gt; None:\n        \"\"\"Save rendered image to bytes stream buffer.\"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"reference/pygerber/gerberx3/renderer2/abstract.html#pygerber.gerberx3.renderer2.abstract.ImageRef.save_to","title":"save_to","text":"<pre><code>save_to(\n    dest: BytesIO | Path | str,\n    options: Optional[FormatOptions] = None,\n) -&gt; None\n</code></pre> <p>Save rendered image.</p> Source code in <code>src/pygerber/gerberx3/renderer2/abstract.py</code> <pre><code>def save_to(\n    self,\n    dest: BytesIO | Path | str,\n    options: Optional[FormatOptions] = None,\n) -&gt; None:\n    \"\"\"Save rendered image.\"\"\"\n    if isinstance(dest, str):\n        dest = Path(dest)\n    if isinstance(dest, Path):\n        with dest.open(\"wb\") as output:\n            return self._save_to_io(output, options)\n    else:\n        return self._save_to_io(dest, options)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/renderer2/abstract.html#pygerber.gerberx3.renderer2.abstract.FormatOptions","title":"FormatOptions","text":"<p>Base class for representing of possible format options.</p> Source code in <code>src/pygerber/gerberx3/renderer2/abstract.py</code> <pre><code>class FormatOptions:\n    \"\"\"Base class for representing of possible format options.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/renderer2/errors2.html","title":"errors2","text":""},{"location":"reference/pygerber/gerberx3/renderer2/errors2.html#pygerber.gerberx3.renderer2.errors2","title":"errors2","text":"<p>Module contains exceptions raised by rendering backends.</p>"},{"location":"reference/pygerber/gerberx3/renderer2/errors2.html#pygerber.gerberx3.renderer2.errors2.Renderer2Error","title":"Renderer2Error","text":"<p>             Bases: <code>Exception</code></p> <p>Base class for exceptions raised by rendering backends.</p> Source code in <code>src/pygerber/gerberx3/renderer2/errors2.py</code> <pre><code>class Renderer2Error(Exception):\n    \"\"\"Base class for exceptions raised by rendering backends.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/renderer2/errors2.html#pygerber.gerberx3.renderer2.errors2.SvgRenderer2Error","title":"SvgRenderer2Error","text":"<p>             Bases: <code>Renderer2Error</code></p> <p>Error raised by SVG rendering backend.</p> Source code in <code>src/pygerber/gerberx3/renderer2/errors2.py</code> <pre><code>class SvgRenderer2Error(Renderer2Error):\n    \"\"\"Error raised by SVG rendering backend.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/renderer2/errors2.html#pygerber.gerberx3.renderer2.errors2.DRAWSVGNotAvailableError","title":"DRAWSVGNotAvailableError","text":"<p>             Bases: <code>SvgRenderer2Error</code></p> <p>Raised when <code>drawsvg</code> can't be imported, probably because it was not installed.</p> <p>You can install it with <code>pip install pygerber[svg]</code>.</p> Source code in <code>src/pygerber/gerberx3/renderer2/errors2.py</code> <pre><code>class DRAWSVGNotAvailableError(SvgRenderer2Error):\n    \"\"\"Raised when `drawsvg` can't be imported, probably because it was not installed.\n\n    You can install it with `pip install pygerber[svg]`.\n    \"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/renderer2/svg.html","title":"svg","text":""},{"location":"reference/pygerber/gerberx3/renderer2/svg.html#pygerber.gerberx3.renderer2.svg","title":"svg","text":"<p>Module contains implementation of Gerber rendering backend outputting SVG files.</p>"},{"location":"reference/pygerber/gerberx3/renderer2/svg.html#pygerber.gerberx3.renderer2.svg.SvgRenderer2","title":"SvgRenderer2","text":"<p>             Bases: <code>Renderer2</code></p> <p>Rendering backend class for rendering SVG images.</p> Source code in <code>src/pygerber/gerberx3/renderer2/svg.py</code> <pre><code>class SvgRenderer2(Renderer2):\n    \"\"\"Rendering backend class for rendering SVG images.\"\"\"\n\n    def __init__(\n        self,\n        hooks: Optional[SvgRenderer2Hooks] = None,\n    ) -&gt; None:\n        hooks = SvgRenderer2Hooks() if hooks is None else hooks\n        super().__init__(hooks)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/renderer2/svg.html#pygerber.gerberx3.renderer2.svg.SvgRenderingFrame","title":"SvgRenderingFrame  <code>dataclass</code>","text":"<p>Rendering variable container.</p> Source code in <code>src/pygerber/gerberx3/renderer2/svg.py</code> <pre><code>@dataclass\nclass SvgRenderingFrame:\n    \"\"\"Rendering variable container.\"\"\"\n\n    command_buffer: ReadonlyCommandBuffer2\n    bounding_box: BoundingBox\n    normalize_origin_to_0_0: bool\n    mask: drawsvg.Mask = field(default_factory=drawsvg.Mask)\n    layer: drawsvg.Group = field(default_factory=drawsvg.Group)\n    polarity: Optional[Polarity] = None\n    is_region: bool = False\n    flip_y: bool = True\n</code></pre>"},{"location":"reference/pygerber/gerberx3/renderer2/svg.html#pygerber.gerberx3.renderer2.svg.SvgRenderer2Hooks","title":"SvgRenderer2Hooks","text":"<p>             Bases: <code>Renderer2HooksABC</code></p> <p>Rendering backend hooks used to render SVG images.</p> Source code in <code>src/pygerber/gerberx3/renderer2/svg.py</code> <pre><code>class SvgRenderer2Hooks(Renderer2HooksABC):\n    \"\"\"Rendering backend hooks used to render SVG images.\"\"\"\n\n    renderer: SvgRenderer2\n\n    def __init__(\n        self,\n        color_scheme: ColorScheme = ColorScheme.DEBUG_1,\n        scale: Decimal = Decimal(\"1\"),\n        *,\n        flip_y: bool = True,\n    ) -&gt; None:\n        if not IS_SVG_BACKEND_AVAILABLE:\n            raise DRAWSVGNotAvailableError\n        self.color_scheme = color_scheme\n        self.scale = scale\n        self.flip_y = flip_y\n\n    def init(\n        self,\n        renderer: Renderer2,\n        command_buffer: ReadonlyCommandBuffer2,\n    ) -&gt; None:\n        \"\"\"Initialize rendering hooks.\"\"\"\n        if not isinstance(renderer, SvgRenderer2):\n            raise NotImplementedError\n\n        self.renderer = renderer\n        self.command_buffer = command_buffer\n        self.rendering_stack: list[SvgRenderingFrame] = [\n            SvgRenderingFrame(\n                command_buffer=self.command_buffer,\n                bounding_box=self.command_buffer.get_bounding_box(),\n                normalize_origin_to_0_0=True,\n                flip_y=self.flip_y,\n            ),\n        ]\n        self.apertures: dict[str, drawsvg.Group] = {}\n\n    def push_render_frame(\n        self,\n        cmd: ReadonlyCommandBuffer2,\n        *,\n        normalize_origin_to_0_0: bool,\n        flip_y: bool,\n    ) -&gt; None:\n        \"\"\"Push new segment render frame.\"\"\"\n        self.rendering_stack.append(\n            SvgRenderingFrame(\n                command_buffer=cmd,\n                bounding_box=cmd.get_bounding_box(),\n                normalize_origin_to_0_0=normalize_origin_to_0_0,\n                flip_y=flip_y,\n            ),\n        )\n\n    def pop_render_frame(self) -&gt; SvgRenderingFrame:\n        \"\"\"Pop segment render frame.\"\"\"\n        if len(self.rendering_stack) &lt;= 1:\n            raise RuntimeError\n        return self.rendering_stack.pop()\n\n    @property\n    def frame(self) -&gt; SvgRenderingFrame:\n        \"\"\"Get current rendering stack frame.\"\"\"\n        return self.rendering_stack[-1]\n\n    def get_layer(self, polarity: Polarity) -&gt; drawsvg.Group | drawsvg.Mask:\n        \"\"\"Get image layer.\"\"\"\n        if self.frame.polarity is None or polarity != self.frame.polarity:\n            self.frame.polarity = polarity\n            if polarity == Polarity.Dark:\n                self._new_layer(with_mask=False)\n            else:\n                self._new_layer(with_mask=True)\n\n        if self.frame.polarity == Polarity.Dark:\n            return self.frame.layer\n\n        return self.frame.mask\n\n    def _new_layer(self, *, with_mask: bool) -&gt; None:\n        \"\"\"Create new layer including previous layer.\"\"\"\n        if with_mask:\n            self.frame.mask = self._make_mask(self.frame.bounding_box)\n            new_layer = drawsvg.Group(mask=self.frame.mask)\n        else:\n            new_layer = drawsvg.Group()\n\n        new_layer.append(self.frame.layer)\n\n        self.frame.layer = new_layer\n\n    def convert_x(self, x: Offset) -&gt; Decimal:\n        \"\"\"Convert y offset to y coordinate in image space.\"\"\"\n        if self.frame.normalize_origin_to_0_0:\n            origin_offset_x = self.frame.bounding_box.min_x.as_millimeters()\n        else:\n            origin_offset_x = Decimal(0)\n\n        corrected_position_x = x.as_millimeters() - origin_offset_x\n\n        return corrected_position_x * self.scale\n\n    def convert_y(self, y: Offset) -&gt; Decimal:\n        \"\"\"Convert y offset to y coordinate in image space.\"\"\"\n        return self._convert_y(\n            y,\n            normalize_origin_to_0_0=self.frame.normalize_origin_to_0_0,\n            flip_y=self.frame.flip_y,\n        )\n\n    def _convert_y(\n        self,\n        y: Offset,\n        *,\n        normalize_origin_to_0_0: bool,\n        flip_y: bool,\n    ) -&gt; Decimal:\n        \"\"\"Convert y offset to pixel y coordinate.\"\"\"\n        if normalize_origin_to_0_0:\n            origin_offset_y = self.frame.bounding_box.min_y.as_millimeters()\n        else:\n            origin_offset_y = Decimal(0)\n\n        corrected_position_y = y.as_millimeters() - origin_offset_y\n\n        if flip_y:\n            flipped_position_y = (\n                self.frame.bounding_box.height.as_millimeters() - corrected_position_y\n            )\n            return flipped_position_y * self.scale\n        return corrected_position_y * self.scale\n\n    def convert_size(self, diameter: Offset) -&gt; Decimal:\n        \"\"\"Convert y offset to pixel y coordinate.\"\"\"\n        return diameter.as_millimeters() * self.scale\n\n    def get_color(self, polarity: Polarity) -&gt; str:\n        \"\"\"Get color for specified polarity.\"\"\"\n        if self.frame.is_region:\n            if polarity == Polarity.Dark:\n                return self.color_scheme.solid_region_color.to_hex()\n            return \"black\"\n\n        if polarity == Polarity.Dark:\n            return self.color_scheme.solid_color.to_hex()\n        return \"black\"\n\n    def get_aperture(self, aperture_id: int, color: str) -&gt; Optional[drawsvg.Group]:\n        \"\"\"Get SVG group representing aperture.\"\"\"\n        return self.apertures.get(self._get_aperture_id(aperture_id, color))\n\n    def _get_aperture_id(self, aperture_id: int, color: str) -&gt; str:\n        \"\"\"Return combined ID for listed aperture.\"\"\"\n        return f\"{color}+{aperture_id}\"\n\n    def set_aperture(\n        self,\n        aperture_id: int,\n        color: str,\n        aperture: drawsvg.Group,\n    ) -&gt; None:\n        \"\"\"Set SVG group representing aperture.\"\"\"\n        self.apertures[self._get_aperture_id(aperture_id, color)] = aperture\n\n    def render_line(self, command: Line2) -&gt; None:\n        \"\"\"Render line to target image.\"\"\"\n        color = self.get_color(command.transform.polarity)\n\n        command.aperture.render_flash(\n            self.renderer,\n            Flash2(\n                transform=command.transform,\n                attributes=command.attributes,\n                aperture=command.aperture,\n                flash_point=command.start_point,\n            ),\n        )\n\n        parallel_vector = command.start_point - command.end_point\n        perpendicular_vector = parallel_vector.perpendicular()\n        normalized_perpendicular_vector = perpendicular_vector.normalize()\n        point_offset = normalized_perpendicular_vector * (\n            command.aperture.get_stroke_width() / 2.0\n        )\n\n        p0 = command.start_point - point_offset\n        p1 = command.start_point + point_offset\n        p2 = command.end_point + point_offset\n        p3 = command.end_point - point_offset\n\n        rectangle = drawsvg.Lines(\n            self.convert_x(p0.x),\n            self.convert_y(p0.y),\n            self.convert_x(p1.x),\n            self.convert_y(p1.y),\n            self.convert_x(p2.x),\n            self.convert_y(p2.y),\n            self.convert_x(p3.x),\n            self.convert_y(p3.y),\n            fill=color,\n            close=True,\n        )\n        self.get_layer(command.transform.polarity).append(rectangle)\n\n        command.aperture.render_flash(\n            self.renderer,\n            Flash2(\n                transform=command.transform,\n                attributes=command.attributes,\n                aperture=command.aperture,\n                flash_point=command.end_point,\n            ),\n        )\n\n    def render_arc(self, command: Arc2) -&gt; None:\n        \"\"\"Render arc to target image.\"\"\"\n        color = self.get_color(command.transform.polarity)\n        # Arcs which start and end point overlaps are completely invisible in SVG.\n        # Therefore we need to replace them with two half-full-arcs.\n        # THB spec recommends doing it when exporting Gerber files, to avoid problems\n        # with floating point numbers, but I guess nobody does that.\n        if command.start_point == command.end_point:\n            # This is a vector from center to start point, so we can invert it and\n            # apply it twice to get the point on the opposite side of the center point.\n            relative = command.get_relative_start_point()\n            # Now we cen recursively invoke self with two modified copies of this\n            # command.\n            self.render_arc(\n                command.model_copy(\n                    update={\n                        \"start_point\": command.start_point,\n                        \"end_point\": command.start_point - (relative * 2),\n                    },\n                ),\n            )\n            self.render_arc(\n                command.model_copy(\n                    update={\n                        \"start_point\": command.start_point - (relative * 2),\n                        \"end_point\": command.start_point,\n                    },\n                ),\n            )\n            return\n\n        command.aperture.render_flash(\n            self.renderer,\n            Flash2(\n                transform=command.transform,\n                attributes=command.attributes,\n                aperture=command.aperture,\n                flash_point=command.start_point,\n            ),\n        )\n        # First we calculate perpendicular vector. This vector is always pointing\n        # from the center, thus it is perpendicular to arc.\n        # Then we can normalize it and multiply by half of aperture diameter,\n        # effectively giving us vector pointing to inner/outer edge of line.\n        # We can ignore the fact that we don't know which point (inner/outer) we\n        # have, as long as we get the same every time, then we can pair it with\n        # corresponding vector made from end point and create single arc,\n        # Then invert both vectors and draw second arc.\n        start_perpendicular_vector = command.get_relative_start_point()\n        start_normalized_perpendicular_vector = start_perpendicular_vector.normalize()\n        start_point_offset = start_normalized_perpendicular_vector * (\n            command.aperture.get_stroke_width() / 2.0\n        )\n\n        end_perpendicular_vector = command.get_relative_end_point()\n        end_normalized_perpendicular_vector = end_perpendicular_vector.normalize()\n        end_point_offset = end_normalized_perpendicular_vector * (\n            command.aperture.get_stroke_width() / 2.0\n        )\n\n        arc_path = drawsvg.Path(fill=color)\n\n        # Determine start point of inner arc.\n        start_inner = command.start_point + start_point_offset\n        end_inner = command.end_point + end_point_offset\n        # Move path ptr to inner arc start point.\n        arc_path.M(\n            self.convert_x(start_inner.x),\n            self.convert_y(start_inner.y),\n        )\n        self.render_arc_to_path(\n            command.model_copy(\n                update={\n                    \"start_point\": start_inner,\n                    \"end_point\": end_inner,\n                },\n            ),\n            arc_path,\n        )\n        # Determine start point of outer arc.\n        # This arc have to be in reverse direction, so we swap start/end points.\n        start_outer = command.end_point - end_point_offset\n        end_outer = command.start_point - start_point_offset\n        # Draw line between end of inner arc and start of outer arc.\n        arc_path.L(\n            self.convert_x(start_outer.x),\n            self.convert_y(start_outer.y),\n        )\n        self.render_cc_arc_to_path(\n            CCArc2(\n                transform=command.transform,\n                attributes=command.attributes,\n                aperture=command.aperture,\n                start_point=start_outer,\n                center_point=command.center_point,\n                end_point=end_outer,\n            ),\n            arc_path,\n        )\n        # Close arc box by drawing line between end of outer arc and start of inner\n        arc_path.Z()\n        self.get_layer(command.transform.polarity).append(arc_path)\n\n        command.aperture.render_flash(\n            self.renderer,\n            Flash2(\n                transform=command.transform,\n                attributes=command.attributes,\n                aperture=command.aperture,\n                flash_point=command.end_point,\n            ),\n        )\n\n    def render_cc_arc(self, command: Arc2) -&gt; None:\n        \"\"\"Render arc to target image.\"\"\"\n        self.render_arc(\n            command.model_copy(\n                update={\n                    \"start_point\": command.end_point,\n                    \"end_point\": command.start_point,\n                },\n            ),\n        )\n\n    def render_flash_circle(self, command: Flash2, aperture: Circle2) -&gt; None:\n        \"\"\"Render flash circle to target image.\"\"\"\n        color = self.get_color(command.transform.polarity)\n        aperture_group = self.get_aperture(id(aperture), color)\n\n        if aperture_group is None:\n            mask = self._make_mask(aperture.get_bounding_box(), aperture.hole_diameter)\n            aperture_group = drawsvg.Group(mask=mask)\n            aperture_group.append(\n                drawsvg.Circle(\n                    cx=0,\n                    cy=0,\n                    r=self.convert_size(aperture.diameter) / Decimal(\"2.0\"),\n                    fill=color,\n                ),\n            )\n            self.set_aperture(id(aperture), color, aperture_group)\n\n        self.get_layer(command.transform.polarity).append(\n            drawsvg.Use(\n                aperture_group,\n                x=self.convert_x(command.flash_point.x),\n                y=self.convert_y(command.flash_point.y),\n            ),\n        )\n\n    def _make_mask(\n        self,\n        bbox: BoundingBox,\n        hole_diameter: Optional[Offset] = None,\n    ) -&gt; drawsvg.Mask:\n        mask = drawsvg.Mask()\n        mask.append(\n            drawsvg.Rectangle(\n                x=self.convert_size(bbox.min_x),\n                y=self.convert_size(bbox.min_y),\n                width=self.convert_size(bbox.width),\n                height=self.convert_size(bbox.height),\n                fill=\"white\",\n            ),\n        )\n        if hole_diameter is not None:\n            central_circle = drawsvg.Circle(\n                cx=0,\n                cy=0,\n                r=self.convert_size(hole_diameter) / 2,\n                fill=\"black\",\n            )\n            mask.append(central_circle)\n        return mask\n\n    def render_flash_no_circle(self, command: Flash2, aperture: NoCircle2) -&gt; None:\n        \"\"\"Render flash no circle aperture to target image.\"\"\"\n\n    def render_flash_rectangle(self, command: Flash2, aperture: Rectangle2) -&gt; None:\n        \"\"\"Render flash rectangle to target image.\"\"\"\n        color = self.get_color(command.transform.polarity)\n        aperture_group = self.get_aperture(id(aperture), color)\n\n        if aperture_group is None:\n            mask = self._make_mask(aperture.get_bounding_box(), aperture.hole_diameter)\n            aperture_group = drawsvg.Group(mask=mask)\n            aperture_group.append(\n                drawsvg.Rectangle(\n                    -self.convert_size(aperture.x_size) / 2,\n                    -self.convert_size(aperture.y_size) / 2,\n                    self.convert_size(aperture.x_size),\n                    self.convert_size(aperture.y_size),\n                    fill=color,\n                ),\n            )\n            self.set_aperture(id(aperture), color, aperture_group)\n\n        self.get_layer(command.transform.polarity).append(\n            drawsvg.Use(\n                aperture_group,\n                self.convert_x(command.flash_point.x),\n                self.convert_y(command.flash_point.y),\n            ),\n        )\n\n    def render_flash_obround(self, command: Flash2, aperture: Obround2) -&gt; None:\n        \"\"\"Render flash obround to target image.\"\"\"\n        color = self.get_color(command.transform.polarity)\n        aperture_group = self.get_aperture(id(aperture), color)\n\n        if aperture_group is None:\n            mask = self._make_mask(aperture.get_bounding_box(), aperture.hole_diameter)\n            aperture_group = drawsvg.Group(mask=mask)\n            x_size = self.convert_size(aperture.x_size)\n            y_size = self.convert_size(aperture.y_size)\n            radius = x_size.min(y_size) / Decimal(\"2.0\")\n\n            aperture_group.append(\n                drawsvg.Rectangle(\n                    -self.convert_size(aperture.x_size) / 2,\n                    -self.convert_size(aperture.y_size) / 2,\n                    x_size,\n                    y_size,\n                    fill=color,\n                    rx=radius,\n                    ry=radius,\n                ),\n            )\n            self.set_aperture(id(aperture), color, aperture_group)\n\n        self.get_layer(command.transform.polarity).append(\n            drawsvg.Use(\n                aperture_group,\n                self.convert_x(command.flash_point.x),\n                self.convert_y(command.flash_point.y),\n            ),\n        )\n\n    def render_flash_polygon(self, command: Flash2, aperture: Polygon2) -&gt; None:\n        \"\"\"Render flash polygon to target image.\"\"\"\n        color = self.get_color(command.transform.polarity)\n        aperture_group = self.get_aperture(id(aperture), color)\n\n        if aperture_group is None:\n            mask = self._make_mask(aperture.get_bounding_box(), aperture.hole_diameter)\n            aperture_group = drawsvg.Group(mask=mask)\n\n            number_of_vertices = aperture.number_vertices\n            initial_angle = aperture.rotation\n            inner_angle = Decimal(\"360\") / Decimal(number_of_vertices)\n\n            radius_vector = Vector2D.UNIT_X * (aperture.outer_diameter / Decimal(\"2.0\"))\n            rotated_radius_vector = radius_vector.rotate_around_origin(initial_angle)\n\n            p = drawsvg.Path(fill=color)\n            p.M(\n                self.convert_size(rotated_radius_vector.x),\n                self.convert_size(rotated_radius_vector.y),\n            )\n\n            for i in range(1, number_of_vertices):\n                rotation_angle = inner_angle * i + initial_angle\n                rotated_radius_vector = radius_vector.rotate_around_origin(\n                    rotation_angle,\n                )\n                p.L(\n                    self.convert_size(rotated_radius_vector.x),\n                    self.convert_size(rotated_radius_vector.y),\n                )\n\n            p.Z()\n\n            aperture_group.append(p)\n            self.set_aperture(id(aperture), color, aperture_group)\n\n        self.get_layer(command.transform.polarity).append(\n            drawsvg.Use(\n                aperture_group,\n                self.convert_x(command.flash_point.x),\n                self.convert_y(command.flash_point.y),\n            ),\n        )\n\n    def render_flash_macro(self, command: Flash2, aperture: Macro2) -&gt; None:\n        \"\"\"Render flash macro aperture to target image.\"\"\"\n        color = self.get_color(command.transform.polarity)\n        aperture_group = self.get_aperture(id(aperture), color)\n\n        if aperture_group is None:\n            self.push_render_frame(\n                aperture.command_buffer,\n                normalize_origin_to_0_0=False,\n                flip_y=False,\n            )\n            for cmd in aperture.command_buffer:\n                cmd.render(self.renderer)\n\n            frame = self.pop_render_frame()\n            self.set_aperture(id(aperture), color, frame.layer)\n\n        self.get_layer(command.transform.polarity).append(\n            drawsvg.Use(\n                aperture_group,\n                x=self.convert_x(command.flash_point.x),\n                y=self.convert_y(command.flash_point.y),\n            ),\n        )\n\n    def render_buffer(self, command: BufferCommand2) -&gt; None:\n        \"\"\"Render buffer command, performing no writes.\"\"\"\n        for cmd in command:\n            cmd.render(self.renderer)\n\n    def render_region(self, command: Region2) -&gt; None:\n        \"\"\"Render region to target image.\"\"\"\n        if len(command.command_buffer) == 0:\n            return\n\n        self.frame.is_region = True\n\n        color = self.get_color(command.transform.polarity)\n        region = drawsvg.Path(fill=color)\n\n        for cmd in command.command_buffer:\n            if isinstance(cmd, (Line2, Arc2, CCArc2)):\n                region.M(\n                    self.convert_x(cmd.start_point.x),\n                    self.convert_y(cmd.start_point.y),\n                )\n                break\n\n        for cmd in command.command_buffer:\n            if isinstance(cmd, Line2):\n                self.render_line_to_path(cmd, region)\n            elif isinstance(cmd, Arc2):\n                self.render_arc_to_path(cmd, region)\n            elif isinstance(cmd, CCArc2):\n                self.render_cc_arc_to_path(cmd, region)\n            else:\n                raise NotImplementedError\n\n        region.Z()\n        self.get_layer(command.transform.polarity).append(region)\n\n        self.frame.is_region = False\n\n    def render_line_to_path(self, command: Line2, path: drawsvg.Path) -&gt; None:\n        \"\"\"Render line region boundary.\"\"\"\n        path.L(\n            self.convert_x(command.end_point.x),\n            self.convert_y(command.end_point.y),\n        )\n\n    def render_arc_to_path(self, command: Arc2, path: drawsvg.Path) -&gt; None:\n        \"\"\"Render line region boundary.\"\"\"\n        relative_start_vector = command.get_relative_start_point()\n        relative_end_vector = command.get_relative_end_point()\n\n        angle_clockwise = relative_start_vector.angle_between(relative_end_vector)\n        angle_counter_clockwise = relative_start_vector.angle_between_cc(\n            relative_end_vector,\n        )\n        # We want to render clockwise angle, so if cc angle is bigger, we need to\n        # choose small angle.\n        large_arc = angle_clockwise &gt;= angle_counter_clockwise\n        sweep = 1\n\n        path.A(\n            rx=self.convert_size(command.get_radius()),\n            ry=self.convert_size(command.get_radius()),\n            ex=self.convert_x(command.end_point.x),\n            ey=self.convert_y(command.end_point.y),\n            rot=0,\n            large_arc=large_arc,\n            sweep=sweep,\n        )\n\n    def render_cc_arc_to_path(self, command: CCArc2, path: drawsvg.Path) -&gt; None:\n        \"\"\"Render line region boundary.\"\"\"\n        relative_start_vector = command.get_relative_start_point()\n        relative_end_vector = command.get_relative_end_point()\n\n        angle_clockwise = relative_start_vector.angle_between(relative_end_vector)\n        angle_counter_clockwise = relative_start_vector.angle_between_cc(\n            relative_end_vector,\n        )\n        # We want to render clockwise angle, so if cc angle is bigger, we need to\n        # choose small angle.\n        large_arc = not (angle_clockwise &gt;= angle_counter_clockwise)\n        sweep = 0\n\n        path.A(\n            rx=self.convert_size(command.get_radius()),\n            ry=self.convert_size(command.get_radius()),\n            ex=self.convert_x(command.end_point.x),\n            ey=self.convert_y(command.end_point.y),\n            rot=0,\n            large_arc=large_arc,\n            sweep=sweep,\n        )\n\n    def get_image_ref(self) -&gt; ImageRef:\n        \"\"\"Get reference to render image.\"\"\"\n        return SvgImageRef(self.drawing)\n\n    def finalize(self) -&gt; None:\n        \"\"\"Finalize rendering.\"\"\"\n        if len(self.rendering_stack) &gt; 1:\n            self.rendering_stack = [self.rendering_stack[0]]\n        elif len(self.rendering_stack) &lt; 1:\n            raise RuntimeError\n\n        width = self.convert_size(self.frame.bounding_box.width)\n        height = self.convert_size(self.frame.bounding_box.height)\n        self.drawing = drawsvg.Drawing(\n            width=width,\n            height=height,\n        )\n        self.drawing.append(self.get_layer(Polarity.Dark))\n</code></pre>"},{"location":"reference/pygerber/gerberx3/renderer2/svg.html#pygerber.gerberx3.renderer2.svg.SvgRenderer2Hooks.frame","title":"frame  <code>property</code>","text":"<pre><code>frame: SvgRenderingFrame\n</code></pre> <p>Get current rendering stack frame.</p>"},{"location":"reference/pygerber/gerberx3/renderer2/svg.html#pygerber.gerberx3.renderer2.svg.SvgRenderer2Hooks.init","title":"init","text":"<pre><code>init(\n    renderer: Renderer2,\n    command_buffer: ReadonlyCommandBuffer2,\n) -&gt; None\n</code></pre> <p>Initialize rendering hooks.</p> Source code in <code>src/pygerber/gerberx3/renderer2/svg.py</code> <pre><code>def init(\n    self,\n    renderer: Renderer2,\n    command_buffer: ReadonlyCommandBuffer2,\n) -&gt; None:\n    \"\"\"Initialize rendering hooks.\"\"\"\n    if not isinstance(renderer, SvgRenderer2):\n        raise NotImplementedError\n\n    self.renderer = renderer\n    self.command_buffer = command_buffer\n    self.rendering_stack: list[SvgRenderingFrame] = [\n        SvgRenderingFrame(\n            command_buffer=self.command_buffer,\n            bounding_box=self.command_buffer.get_bounding_box(),\n            normalize_origin_to_0_0=True,\n            flip_y=self.flip_y,\n        ),\n    ]\n    self.apertures: dict[str, drawsvg.Group] = {}\n</code></pre>"},{"location":"reference/pygerber/gerberx3/renderer2/svg.html#pygerber.gerberx3.renderer2.svg.SvgRenderer2Hooks.push_render_frame","title":"push_render_frame","text":"<pre><code>push_render_frame(\n    cmd: ReadonlyCommandBuffer2,\n    *,\n    normalize_origin_to_0_0: bool,\n    flip_y: bool\n) -&gt; None\n</code></pre> <p>Push new segment render frame.</p> Source code in <code>src/pygerber/gerberx3/renderer2/svg.py</code> <pre><code>def push_render_frame(\n    self,\n    cmd: ReadonlyCommandBuffer2,\n    *,\n    normalize_origin_to_0_0: bool,\n    flip_y: bool,\n) -&gt; None:\n    \"\"\"Push new segment render frame.\"\"\"\n    self.rendering_stack.append(\n        SvgRenderingFrame(\n            command_buffer=cmd,\n            bounding_box=cmd.get_bounding_box(),\n            normalize_origin_to_0_0=normalize_origin_to_0_0,\n            flip_y=flip_y,\n        ),\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/renderer2/svg.html#pygerber.gerberx3.renderer2.svg.SvgRenderer2Hooks.pop_render_frame","title":"pop_render_frame","text":"<pre><code>pop_render_frame() -&gt; SvgRenderingFrame\n</code></pre> <p>Pop segment render frame.</p> Source code in <code>src/pygerber/gerberx3/renderer2/svg.py</code> <pre><code>def pop_render_frame(self) -&gt; SvgRenderingFrame:\n    \"\"\"Pop segment render frame.\"\"\"\n    if len(self.rendering_stack) &lt;= 1:\n        raise RuntimeError\n    return self.rendering_stack.pop()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/renderer2/svg.html#pygerber.gerberx3.renderer2.svg.SvgRenderer2Hooks.get_layer","title":"get_layer","text":"<pre><code>get_layer(\n    polarity: Polarity,\n) -&gt; drawsvg.Group | drawsvg.Mask\n</code></pre> <p>Get image layer.</p> Source code in <code>src/pygerber/gerberx3/renderer2/svg.py</code> <pre><code>def get_layer(self, polarity: Polarity) -&gt; drawsvg.Group | drawsvg.Mask:\n    \"\"\"Get image layer.\"\"\"\n    if self.frame.polarity is None or polarity != self.frame.polarity:\n        self.frame.polarity = polarity\n        if polarity == Polarity.Dark:\n            self._new_layer(with_mask=False)\n        else:\n            self._new_layer(with_mask=True)\n\n    if self.frame.polarity == Polarity.Dark:\n        return self.frame.layer\n\n    return self.frame.mask\n</code></pre>"},{"location":"reference/pygerber/gerberx3/renderer2/svg.html#pygerber.gerberx3.renderer2.svg.SvgRenderer2Hooks.convert_x","title":"convert_x","text":"<pre><code>convert_x(x: Offset) -&gt; Decimal\n</code></pre> <p>Convert y offset to y coordinate in image space.</p> Source code in <code>src/pygerber/gerberx3/renderer2/svg.py</code> <pre><code>def convert_x(self, x: Offset) -&gt; Decimal:\n    \"\"\"Convert y offset to y coordinate in image space.\"\"\"\n    if self.frame.normalize_origin_to_0_0:\n        origin_offset_x = self.frame.bounding_box.min_x.as_millimeters()\n    else:\n        origin_offset_x = Decimal(0)\n\n    corrected_position_x = x.as_millimeters() - origin_offset_x\n\n    return corrected_position_x * self.scale\n</code></pre>"},{"location":"reference/pygerber/gerberx3/renderer2/svg.html#pygerber.gerberx3.renderer2.svg.SvgRenderer2Hooks.convert_y","title":"convert_y","text":"<pre><code>convert_y(y: Offset) -&gt; Decimal\n</code></pre> <p>Convert y offset to y coordinate in image space.</p> Source code in <code>src/pygerber/gerberx3/renderer2/svg.py</code> <pre><code>def convert_y(self, y: Offset) -&gt; Decimal:\n    \"\"\"Convert y offset to y coordinate in image space.\"\"\"\n    return self._convert_y(\n        y,\n        normalize_origin_to_0_0=self.frame.normalize_origin_to_0_0,\n        flip_y=self.frame.flip_y,\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/renderer2/svg.html#pygerber.gerberx3.renderer2.svg.SvgRenderer2Hooks.convert_size","title":"convert_size","text":"<pre><code>convert_size(diameter: Offset) -&gt; Decimal\n</code></pre> <p>Convert y offset to pixel y coordinate.</p> Source code in <code>src/pygerber/gerberx3/renderer2/svg.py</code> <pre><code>def convert_size(self, diameter: Offset) -&gt; Decimal:\n    \"\"\"Convert y offset to pixel y coordinate.\"\"\"\n    return diameter.as_millimeters() * self.scale\n</code></pre>"},{"location":"reference/pygerber/gerberx3/renderer2/svg.html#pygerber.gerberx3.renderer2.svg.SvgRenderer2Hooks.get_color","title":"get_color","text":"<pre><code>get_color(polarity: Polarity) -&gt; str\n</code></pre> <p>Get color for specified polarity.</p> Source code in <code>src/pygerber/gerberx3/renderer2/svg.py</code> <pre><code>def get_color(self, polarity: Polarity) -&gt; str:\n    \"\"\"Get color for specified polarity.\"\"\"\n    if self.frame.is_region:\n        if polarity == Polarity.Dark:\n            return self.color_scheme.solid_region_color.to_hex()\n        return \"black\"\n\n    if polarity == Polarity.Dark:\n        return self.color_scheme.solid_color.to_hex()\n    return \"black\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/renderer2/svg.html#pygerber.gerberx3.renderer2.svg.SvgRenderer2Hooks.get_aperture","title":"get_aperture","text":"<pre><code>get_aperture(\n    aperture_id: int, color: str\n) -&gt; Optional[drawsvg.Group]\n</code></pre> <p>Get SVG group representing aperture.</p> Source code in <code>src/pygerber/gerberx3/renderer2/svg.py</code> <pre><code>def get_aperture(self, aperture_id: int, color: str) -&gt; Optional[drawsvg.Group]:\n    \"\"\"Get SVG group representing aperture.\"\"\"\n    return self.apertures.get(self._get_aperture_id(aperture_id, color))\n</code></pre>"},{"location":"reference/pygerber/gerberx3/renderer2/svg.html#pygerber.gerberx3.renderer2.svg.SvgRenderer2Hooks.set_aperture","title":"set_aperture","text":"<pre><code>set_aperture(\n    aperture_id: int, color: str, aperture: drawsvg.Group\n) -&gt; None\n</code></pre> <p>Set SVG group representing aperture.</p> Source code in <code>src/pygerber/gerberx3/renderer2/svg.py</code> <pre><code>def set_aperture(\n    self,\n    aperture_id: int,\n    color: str,\n    aperture: drawsvg.Group,\n) -&gt; None:\n    \"\"\"Set SVG group representing aperture.\"\"\"\n    self.apertures[self._get_aperture_id(aperture_id, color)] = aperture\n</code></pre>"},{"location":"reference/pygerber/gerberx3/renderer2/svg.html#pygerber.gerberx3.renderer2.svg.SvgRenderer2Hooks.render_line","title":"render_line","text":"<pre><code>render_line(command: Line2) -&gt; None\n</code></pre> <p>Render line to target image.</p> Source code in <code>src/pygerber/gerberx3/renderer2/svg.py</code> <pre><code>def render_line(self, command: Line2) -&gt; None:\n    \"\"\"Render line to target image.\"\"\"\n    color = self.get_color(command.transform.polarity)\n\n    command.aperture.render_flash(\n        self.renderer,\n        Flash2(\n            transform=command.transform,\n            attributes=command.attributes,\n            aperture=command.aperture,\n            flash_point=command.start_point,\n        ),\n    )\n\n    parallel_vector = command.start_point - command.end_point\n    perpendicular_vector = parallel_vector.perpendicular()\n    normalized_perpendicular_vector = perpendicular_vector.normalize()\n    point_offset = normalized_perpendicular_vector * (\n        command.aperture.get_stroke_width() / 2.0\n    )\n\n    p0 = command.start_point - point_offset\n    p1 = command.start_point + point_offset\n    p2 = command.end_point + point_offset\n    p3 = command.end_point - point_offset\n\n    rectangle = drawsvg.Lines(\n        self.convert_x(p0.x),\n        self.convert_y(p0.y),\n        self.convert_x(p1.x),\n        self.convert_y(p1.y),\n        self.convert_x(p2.x),\n        self.convert_y(p2.y),\n        self.convert_x(p3.x),\n        self.convert_y(p3.y),\n        fill=color,\n        close=True,\n    )\n    self.get_layer(command.transform.polarity).append(rectangle)\n\n    command.aperture.render_flash(\n        self.renderer,\n        Flash2(\n            transform=command.transform,\n            attributes=command.attributes,\n            aperture=command.aperture,\n            flash_point=command.end_point,\n        ),\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/renderer2/svg.html#pygerber.gerberx3.renderer2.svg.SvgRenderer2Hooks.render_arc","title":"render_arc","text":"<pre><code>render_arc(command: Arc2) -&gt; None\n</code></pre> <p>Render arc to target image.</p> Source code in <code>src/pygerber/gerberx3/renderer2/svg.py</code> <pre><code>def render_arc(self, command: Arc2) -&gt; None:\n    \"\"\"Render arc to target image.\"\"\"\n    color = self.get_color(command.transform.polarity)\n    # Arcs which start and end point overlaps are completely invisible in SVG.\n    # Therefore we need to replace them with two half-full-arcs.\n    # THB spec recommends doing it when exporting Gerber files, to avoid problems\n    # with floating point numbers, but I guess nobody does that.\n    if command.start_point == command.end_point:\n        # This is a vector from center to start point, so we can invert it and\n        # apply it twice to get the point on the opposite side of the center point.\n        relative = command.get_relative_start_point()\n        # Now we cen recursively invoke self with two modified copies of this\n        # command.\n        self.render_arc(\n            command.model_copy(\n                update={\n                    \"start_point\": command.start_point,\n                    \"end_point\": command.start_point - (relative * 2),\n                },\n            ),\n        )\n        self.render_arc(\n            command.model_copy(\n                update={\n                    \"start_point\": command.start_point - (relative * 2),\n                    \"end_point\": command.start_point,\n                },\n            ),\n        )\n        return\n\n    command.aperture.render_flash(\n        self.renderer,\n        Flash2(\n            transform=command.transform,\n            attributes=command.attributes,\n            aperture=command.aperture,\n            flash_point=command.start_point,\n        ),\n    )\n    # First we calculate perpendicular vector. This vector is always pointing\n    # from the center, thus it is perpendicular to arc.\n    # Then we can normalize it and multiply by half of aperture diameter,\n    # effectively giving us vector pointing to inner/outer edge of line.\n    # We can ignore the fact that we don't know which point (inner/outer) we\n    # have, as long as we get the same every time, then we can pair it with\n    # corresponding vector made from end point and create single arc,\n    # Then invert both vectors and draw second arc.\n    start_perpendicular_vector = command.get_relative_start_point()\n    start_normalized_perpendicular_vector = start_perpendicular_vector.normalize()\n    start_point_offset = start_normalized_perpendicular_vector * (\n        command.aperture.get_stroke_width() / 2.0\n    )\n\n    end_perpendicular_vector = command.get_relative_end_point()\n    end_normalized_perpendicular_vector = end_perpendicular_vector.normalize()\n    end_point_offset = end_normalized_perpendicular_vector * (\n        command.aperture.get_stroke_width() / 2.0\n    )\n\n    arc_path = drawsvg.Path(fill=color)\n\n    # Determine start point of inner arc.\n    start_inner = command.start_point + start_point_offset\n    end_inner = command.end_point + end_point_offset\n    # Move path ptr to inner arc start point.\n    arc_path.M(\n        self.convert_x(start_inner.x),\n        self.convert_y(start_inner.y),\n    )\n    self.render_arc_to_path(\n        command.model_copy(\n            update={\n                \"start_point\": start_inner,\n                \"end_point\": end_inner,\n            },\n        ),\n        arc_path,\n    )\n    # Determine start point of outer arc.\n    # This arc have to be in reverse direction, so we swap start/end points.\n    start_outer = command.end_point - end_point_offset\n    end_outer = command.start_point - start_point_offset\n    # Draw line between end of inner arc and start of outer arc.\n    arc_path.L(\n        self.convert_x(start_outer.x),\n        self.convert_y(start_outer.y),\n    )\n    self.render_cc_arc_to_path(\n        CCArc2(\n            transform=command.transform,\n            attributes=command.attributes,\n            aperture=command.aperture,\n            start_point=start_outer,\n            center_point=command.center_point,\n            end_point=end_outer,\n        ),\n        arc_path,\n    )\n    # Close arc box by drawing line between end of outer arc and start of inner\n    arc_path.Z()\n    self.get_layer(command.transform.polarity).append(arc_path)\n\n    command.aperture.render_flash(\n        self.renderer,\n        Flash2(\n            transform=command.transform,\n            attributes=command.attributes,\n            aperture=command.aperture,\n            flash_point=command.end_point,\n        ),\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/renderer2/svg.html#pygerber.gerberx3.renderer2.svg.SvgRenderer2Hooks.render_cc_arc","title":"render_cc_arc","text":"<pre><code>render_cc_arc(command: Arc2) -&gt; None\n</code></pre> <p>Render arc to target image.</p> Source code in <code>src/pygerber/gerberx3/renderer2/svg.py</code> <pre><code>def render_cc_arc(self, command: Arc2) -&gt; None:\n    \"\"\"Render arc to target image.\"\"\"\n    self.render_arc(\n        command.model_copy(\n            update={\n                \"start_point\": command.end_point,\n                \"end_point\": command.start_point,\n            },\n        ),\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/renderer2/svg.html#pygerber.gerberx3.renderer2.svg.SvgRenderer2Hooks.render_flash_circle","title":"render_flash_circle","text":"<pre><code>render_flash_circle(\n    command: Flash2, aperture: Circle2\n) -&gt; None\n</code></pre> <p>Render flash circle to target image.</p> Source code in <code>src/pygerber/gerberx3/renderer2/svg.py</code> <pre><code>def render_flash_circle(self, command: Flash2, aperture: Circle2) -&gt; None:\n    \"\"\"Render flash circle to target image.\"\"\"\n    color = self.get_color(command.transform.polarity)\n    aperture_group = self.get_aperture(id(aperture), color)\n\n    if aperture_group is None:\n        mask = self._make_mask(aperture.get_bounding_box(), aperture.hole_diameter)\n        aperture_group = drawsvg.Group(mask=mask)\n        aperture_group.append(\n            drawsvg.Circle(\n                cx=0,\n                cy=0,\n                r=self.convert_size(aperture.diameter) / Decimal(\"2.0\"),\n                fill=color,\n            ),\n        )\n        self.set_aperture(id(aperture), color, aperture_group)\n\n    self.get_layer(command.transform.polarity).append(\n        drawsvg.Use(\n            aperture_group,\n            x=self.convert_x(command.flash_point.x),\n            y=self.convert_y(command.flash_point.y),\n        ),\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/renderer2/svg.html#pygerber.gerberx3.renderer2.svg.SvgRenderer2Hooks.render_flash_no_circle","title":"render_flash_no_circle","text":"<pre><code>render_flash_no_circle(\n    command: Flash2, aperture: NoCircle2\n) -&gt; None\n</code></pre> <p>Render flash no circle aperture to target image.</p> Source code in <code>src/pygerber/gerberx3/renderer2/svg.py</code> <pre><code>def render_flash_no_circle(self, command: Flash2, aperture: NoCircle2) -&gt; None:\n    \"\"\"Render flash no circle aperture to target image.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/renderer2/svg.html#pygerber.gerberx3.renderer2.svg.SvgRenderer2Hooks.render_flash_rectangle","title":"render_flash_rectangle","text":"<pre><code>render_flash_rectangle(\n    command: Flash2, aperture: Rectangle2\n) -&gt; None\n</code></pre> <p>Render flash rectangle to target image.</p> Source code in <code>src/pygerber/gerberx3/renderer2/svg.py</code> <pre><code>def render_flash_rectangle(self, command: Flash2, aperture: Rectangle2) -&gt; None:\n    \"\"\"Render flash rectangle to target image.\"\"\"\n    color = self.get_color(command.transform.polarity)\n    aperture_group = self.get_aperture(id(aperture), color)\n\n    if aperture_group is None:\n        mask = self._make_mask(aperture.get_bounding_box(), aperture.hole_diameter)\n        aperture_group = drawsvg.Group(mask=mask)\n        aperture_group.append(\n            drawsvg.Rectangle(\n                -self.convert_size(aperture.x_size) / 2,\n                -self.convert_size(aperture.y_size) / 2,\n                self.convert_size(aperture.x_size),\n                self.convert_size(aperture.y_size),\n                fill=color,\n            ),\n        )\n        self.set_aperture(id(aperture), color, aperture_group)\n\n    self.get_layer(command.transform.polarity).append(\n        drawsvg.Use(\n            aperture_group,\n            self.convert_x(command.flash_point.x),\n            self.convert_y(command.flash_point.y),\n        ),\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/renderer2/svg.html#pygerber.gerberx3.renderer2.svg.SvgRenderer2Hooks.render_flash_obround","title":"render_flash_obround","text":"<pre><code>render_flash_obround(\n    command: Flash2, aperture: Obround2\n) -&gt; None\n</code></pre> <p>Render flash obround to target image.</p> Source code in <code>src/pygerber/gerberx3/renderer2/svg.py</code> <pre><code>def render_flash_obround(self, command: Flash2, aperture: Obround2) -&gt; None:\n    \"\"\"Render flash obround to target image.\"\"\"\n    color = self.get_color(command.transform.polarity)\n    aperture_group = self.get_aperture(id(aperture), color)\n\n    if aperture_group is None:\n        mask = self._make_mask(aperture.get_bounding_box(), aperture.hole_diameter)\n        aperture_group = drawsvg.Group(mask=mask)\n        x_size = self.convert_size(aperture.x_size)\n        y_size = self.convert_size(aperture.y_size)\n        radius = x_size.min(y_size) / Decimal(\"2.0\")\n\n        aperture_group.append(\n            drawsvg.Rectangle(\n                -self.convert_size(aperture.x_size) / 2,\n                -self.convert_size(aperture.y_size) / 2,\n                x_size,\n                y_size,\n                fill=color,\n                rx=radius,\n                ry=radius,\n            ),\n        )\n        self.set_aperture(id(aperture), color, aperture_group)\n\n    self.get_layer(command.transform.polarity).append(\n        drawsvg.Use(\n            aperture_group,\n            self.convert_x(command.flash_point.x),\n            self.convert_y(command.flash_point.y),\n        ),\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/renderer2/svg.html#pygerber.gerberx3.renderer2.svg.SvgRenderer2Hooks.render_flash_polygon","title":"render_flash_polygon","text":"<pre><code>render_flash_polygon(\n    command: Flash2, aperture: Polygon2\n) -&gt; None\n</code></pre> <p>Render flash polygon to target image.</p> Source code in <code>src/pygerber/gerberx3/renderer2/svg.py</code> <pre><code>def render_flash_polygon(self, command: Flash2, aperture: Polygon2) -&gt; None:\n    \"\"\"Render flash polygon to target image.\"\"\"\n    color = self.get_color(command.transform.polarity)\n    aperture_group = self.get_aperture(id(aperture), color)\n\n    if aperture_group is None:\n        mask = self._make_mask(aperture.get_bounding_box(), aperture.hole_diameter)\n        aperture_group = drawsvg.Group(mask=mask)\n\n        number_of_vertices = aperture.number_vertices\n        initial_angle = aperture.rotation\n        inner_angle = Decimal(\"360\") / Decimal(number_of_vertices)\n\n        radius_vector = Vector2D.UNIT_X * (aperture.outer_diameter / Decimal(\"2.0\"))\n        rotated_radius_vector = radius_vector.rotate_around_origin(initial_angle)\n\n        p = drawsvg.Path(fill=color)\n        p.M(\n            self.convert_size(rotated_radius_vector.x),\n            self.convert_size(rotated_radius_vector.y),\n        )\n\n        for i in range(1, number_of_vertices):\n            rotation_angle = inner_angle * i + initial_angle\n            rotated_radius_vector = radius_vector.rotate_around_origin(\n                rotation_angle,\n            )\n            p.L(\n                self.convert_size(rotated_radius_vector.x),\n                self.convert_size(rotated_radius_vector.y),\n            )\n\n        p.Z()\n\n        aperture_group.append(p)\n        self.set_aperture(id(aperture), color, aperture_group)\n\n    self.get_layer(command.transform.polarity).append(\n        drawsvg.Use(\n            aperture_group,\n            self.convert_x(command.flash_point.x),\n            self.convert_y(command.flash_point.y),\n        ),\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/renderer2/svg.html#pygerber.gerberx3.renderer2.svg.SvgRenderer2Hooks.render_flash_macro","title":"render_flash_macro","text":"<pre><code>render_flash_macro(\n    command: Flash2, aperture: Macro2\n) -&gt; None\n</code></pre> <p>Render flash macro aperture to target image.</p> Source code in <code>src/pygerber/gerberx3/renderer2/svg.py</code> <pre><code>def render_flash_macro(self, command: Flash2, aperture: Macro2) -&gt; None:\n    \"\"\"Render flash macro aperture to target image.\"\"\"\n    color = self.get_color(command.transform.polarity)\n    aperture_group = self.get_aperture(id(aperture), color)\n\n    if aperture_group is None:\n        self.push_render_frame(\n            aperture.command_buffer,\n            normalize_origin_to_0_0=False,\n            flip_y=False,\n        )\n        for cmd in aperture.command_buffer:\n            cmd.render(self.renderer)\n\n        frame = self.pop_render_frame()\n        self.set_aperture(id(aperture), color, frame.layer)\n\n    self.get_layer(command.transform.polarity).append(\n        drawsvg.Use(\n            aperture_group,\n            x=self.convert_x(command.flash_point.x),\n            y=self.convert_y(command.flash_point.y),\n        ),\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/renderer2/svg.html#pygerber.gerberx3.renderer2.svg.SvgRenderer2Hooks.render_buffer","title":"render_buffer","text":"<pre><code>render_buffer(command: BufferCommand2) -&gt; None\n</code></pre> <p>Render buffer command, performing no writes.</p> Source code in <code>src/pygerber/gerberx3/renderer2/svg.py</code> <pre><code>def render_buffer(self, command: BufferCommand2) -&gt; None:\n    \"\"\"Render buffer command, performing no writes.\"\"\"\n    for cmd in command:\n        cmd.render(self.renderer)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/renderer2/svg.html#pygerber.gerberx3.renderer2.svg.SvgRenderer2Hooks.render_region","title":"render_region","text":"<pre><code>render_region(command: Region2) -&gt; None\n</code></pre> <p>Render region to target image.</p> Source code in <code>src/pygerber/gerberx3/renderer2/svg.py</code> <pre><code>def render_region(self, command: Region2) -&gt; None:\n    \"\"\"Render region to target image.\"\"\"\n    if len(command.command_buffer) == 0:\n        return\n\n    self.frame.is_region = True\n\n    color = self.get_color(command.transform.polarity)\n    region = drawsvg.Path(fill=color)\n\n    for cmd in command.command_buffer:\n        if isinstance(cmd, (Line2, Arc2, CCArc2)):\n            region.M(\n                self.convert_x(cmd.start_point.x),\n                self.convert_y(cmd.start_point.y),\n            )\n            break\n\n    for cmd in command.command_buffer:\n        if isinstance(cmd, Line2):\n            self.render_line_to_path(cmd, region)\n        elif isinstance(cmd, Arc2):\n            self.render_arc_to_path(cmd, region)\n        elif isinstance(cmd, CCArc2):\n            self.render_cc_arc_to_path(cmd, region)\n        else:\n            raise NotImplementedError\n\n    region.Z()\n    self.get_layer(command.transform.polarity).append(region)\n\n    self.frame.is_region = False\n</code></pre>"},{"location":"reference/pygerber/gerberx3/renderer2/svg.html#pygerber.gerberx3.renderer2.svg.SvgRenderer2Hooks.render_line_to_path","title":"render_line_to_path","text":"<pre><code>render_line_to_path(\n    command: Line2, path: drawsvg.Path\n) -&gt; None\n</code></pre> <p>Render line region boundary.</p> Source code in <code>src/pygerber/gerberx3/renderer2/svg.py</code> <pre><code>def render_line_to_path(self, command: Line2, path: drawsvg.Path) -&gt; None:\n    \"\"\"Render line region boundary.\"\"\"\n    path.L(\n        self.convert_x(command.end_point.x),\n        self.convert_y(command.end_point.y),\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/renderer2/svg.html#pygerber.gerberx3.renderer2.svg.SvgRenderer2Hooks.render_arc_to_path","title":"render_arc_to_path","text":"<pre><code>render_arc_to_path(\n    command: Arc2, path: drawsvg.Path\n) -&gt; None\n</code></pre> <p>Render line region boundary.</p> Source code in <code>src/pygerber/gerberx3/renderer2/svg.py</code> <pre><code>def render_arc_to_path(self, command: Arc2, path: drawsvg.Path) -&gt; None:\n    \"\"\"Render line region boundary.\"\"\"\n    relative_start_vector = command.get_relative_start_point()\n    relative_end_vector = command.get_relative_end_point()\n\n    angle_clockwise = relative_start_vector.angle_between(relative_end_vector)\n    angle_counter_clockwise = relative_start_vector.angle_between_cc(\n        relative_end_vector,\n    )\n    # We want to render clockwise angle, so if cc angle is bigger, we need to\n    # choose small angle.\n    large_arc = angle_clockwise &gt;= angle_counter_clockwise\n    sweep = 1\n\n    path.A(\n        rx=self.convert_size(command.get_radius()),\n        ry=self.convert_size(command.get_radius()),\n        ex=self.convert_x(command.end_point.x),\n        ey=self.convert_y(command.end_point.y),\n        rot=0,\n        large_arc=large_arc,\n        sweep=sweep,\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/renderer2/svg.html#pygerber.gerberx3.renderer2.svg.SvgRenderer2Hooks.render_cc_arc_to_path","title":"render_cc_arc_to_path","text":"<pre><code>render_cc_arc_to_path(\n    command: CCArc2, path: drawsvg.Path\n) -&gt; None\n</code></pre> <p>Render line region boundary.</p> Source code in <code>src/pygerber/gerberx3/renderer2/svg.py</code> <pre><code>def render_cc_arc_to_path(self, command: CCArc2, path: drawsvg.Path) -&gt; None:\n    \"\"\"Render line region boundary.\"\"\"\n    relative_start_vector = command.get_relative_start_point()\n    relative_end_vector = command.get_relative_end_point()\n\n    angle_clockwise = relative_start_vector.angle_between(relative_end_vector)\n    angle_counter_clockwise = relative_start_vector.angle_between_cc(\n        relative_end_vector,\n    )\n    # We want to render clockwise angle, so if cc angle is bigger, we need to\n    # choose small angle.\n    large_arc = not (angle_clockwise &gt;= angle_counter_clockwise)\n    sweep = 0\n\n    path.A(\n        rx=self.convert_size(command.get_radius()),\n        ry=self.convert_size(command.get_radius()),\n        ex=self.convert_x(command.end_point.x),\n        ey=self.convert_y(command.end_point.y),\n        rot=0,\n        large_arc=large_arc,\n        sweep=sweep,\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/renderer2/svg.html#pygerber.gerberx3.renderer2.svg.SvgRenderer2Hooks.get_image_ref","title":"get_image_ref","text":"<pre><code>get_image_ref() -&gt; ImageRef\n</code></pre> <p>Get reference to render image.</p> Source code in <code>src/pygerber/gerberx3/renderer2/svg.py</code> <pre><code>def get_image_ref(self) -&gt; ImageRef:\n    \"\"\"Get reference to render image.\"\"\"\n    return SvgImageRef(self.drawing)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/renderer2/svg.html#pygerber.gerberx3.renderer2.svg.SvgRenderer2Hooks.finalize","title":"finalize","text":"<pre><code>finalize() -&gt; None\n</code></pre> <p>Finalize rendering.</p> Source code in <code>src/pygerber/gerberx3/renderer2/svg.py</code> <pre><code>def finalize(self) -&gt; None:\n    \"\"\"Finalize rendering.\"\"\"\n    if len(self.rendering_stack) &gt; 1:\n        self.rendering_stack = [self.rendering_stack[0]]\n    elif len(self.rendering_stack) &lt; 1:\n        raise RuntimeError\n\n    width = self.convert_size(self.frame.bounding_box.width)\n    height = self.convert_size(self.frame.bounding_box.height)\n    self.drawing = drawsvg.Drawing(\n        width=width,\n        height=height,\n    )\n    self.drawing.append(self.get_layer(Polarity.Dark))\n</code></pre>"},{"location":"reference/pygerber/gerberx3/renderer2/svg.html#pygerber.gerberx3.renderer2.svg.SvgImageRef","title":"SvgImageRef","text":"<p>             Bases: <code>ImageRef</code></p> <p>Generic container for reference to rendered image.</p> Source code in <code>src/pygerber/gerberx3/renderer2/svg.py</code> <pre><code>class SvgImageRef(ImageRef):\n    \"\"\"Generic container for reference to rendered image.\"\"\"\n\n    def __init__(self, image: drawsvg.Drawing) -&gt; None:\n        self.image = image\n\n    def _save_to_io(\n        self,\n        output: BinaryIO,\n        options: Optional[FormatOptions] = None,  # noqa: ARG002\n    ) -&gt; None:\n        \"\"\"Save rendered image to bytes stream buffer.\"\"\"\n        svg = self.image.as_svg()\n        if svg is None:\n            return\n        output.write(svg.encode(\"utf-8\"))\n</code></pre>"},{"location":"reference/pygerber/gerberx3/renderer2/svg.html#pygerber.gerberx3.renderer2.svg.SvgFormatOptions","title":"SvgFormatOptions","text":"<p>Format options for SVG format.</p> Source code in <code>src/pygerber/gerberx3/renderer2/svg.py</code> <pre><code>class SvgFormatOptions:\n    \"\"\"Format options for SVG format.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/__init__.html","title":"init","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/__init__.html#pygerber.gerberx3.tokenizer","title":"tokenizer","text":"<p>Gerber X3 tokenizer.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/aperture_id.html","title":"aperture_id","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/aperture_id.html#pygerber.gerberx3.tokenizer.aperture_id","title":"aperture_id","text":"<p>Defines a class used to identify aperture objects created by parser.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/aperture_id.html#pygerber.gerberx3.tokenizer.aperture_id.ApertureID","title":"ApertureID","text":"<p>             Bases: <code>str</code>, <code>GerberCode</code></p> <p>Aperture ID wrapper.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/aperture_id.py</code> <pre><code>class ApertureID(str, GerberCode):\n    \"\"\"Aperture ID wrapper.\"\"\"\n\n    __slots__ = ()\n\n    @classmethod\n    def __get_pydantic_core_schema__(\n        cls,\n        source_type: Any,\n        handler: GetCoreSchemaHandler,\n    ) -&gt; CoreSchema:\n        \"\"\"Generate the pydantic-core schema.\"\"\"\n        return core_schema.no_info_after_validator_function(cls, handler(str))\n\n    def get_gerber_code(\n        self,\n        indent: str = \"\",  # noqa: ARG002\n        endline: str = \"\\n\",  # noqa: ARG002\n    ) -&gt; str:\n        \"\"\"Get gerber code represented by this token.\"\"\"\n        return f\"{self}\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/aperture_id.html#pygerber.gerberx3.tokenizer.aperture_id.ApertureID.__get_pydantic_core_schema__","title":"__get_pydantic_core_schema__  <code>classmethod</code>","text":"<pre><code>__get_pydantic_core_schema__(\n    source_type: Any, handler: GetCoreSchemaHandler\n) -&gt; CoreSchema\n</code></pre> <p>Generate the pydantic-core schema.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/aperture_id.py</code> <pre><code>@classmethod\ndef __get_pydantic_core_schema__(\n    cls,\n    source_type: Any,\n    handler: GetCoreSchemaHandler,\n) -&gt; CoreSchema:\n    \"\"\"Generate the pydantic-core schema.\"\"\"\n    return core_schema.no_info_after_validator_function(cls, handler(str))\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/aperture_id.html#pygerber.gerberx3.tokenizer.aperture_id.ApertureID.get_gerber_code","title":"get_gerber_code","text":"<pre><code>get_gerber_code(\n    indent: str = \"\", endline: str = \"\\n\"\n) -&gt; str\n</code></pre> <p>Get gerber code represented by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/aperture_id.py</code> <pre><code>def get_gerber_code(\n    self,\n    indent: str = \"\",  # noqa: ARG002\n    endline: str = \"\\n\",  # noqa: ARG002\n) -&gt; str:\n    \"\"\"Get gerber code represented by this token.\"\"\"\n    return f\"{self}\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/decorators.html","title":"decorators","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/decorators.html#pygerber.gerberx3.tokenizer.decorators","title":"decorators","text":"<p>Decorators for reducing boilerplate required to implement token features.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/decorators.html#pygerber.gerberx3.tokenizer.decorators.UseType","title":"UseType","text":"<p>             Bases: <code>Generic[T]</code></p> <p>Placeholder for passing type parameter specification as param.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/decorators.py</code> <pre><code>class UseType(Generic[T]):\n    \"\"\"Placeholder for passing type parameter specification as param.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/decorators.html#pygerber.gerberx3.tokenizer.decorators.AnnotateSpecSection","title":"AnnotateSpecSection","text":"<p>Add Gerber specification reference link to docstring.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/decorators.py</code> <pre><code>class AnnotateSpecSection:\n    \"\"\"Add Gerber specification reference link to docstring.\"\"\"\n\n    def __init__(self, spec_section: Revision202308) -&gt; None:\n        self.spec_section = spec_section\n\n    def __call__(self, class_: type[TokenT]) -&gt; type[TokenT]:\n        \"\"\"Update docstring with specification reference.\"\"\"\n        class_.__doc__ = (class_.__doc__ or \"\") + (\n            \"\\n\\n\"\n            f\"See section {self.spec_section.get_sec_id()} of \"\n            \"The Gerber Layer Format Specification \"\n            f\"{Revision.Revision_2023_08} - \"\n            f\"{self.spec_section.get_url()}\"\n        )\n        return class_\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/decorators.html#pygerber.gerberx3.tokenizer.decorators.AnnotateSpecSection.__call__","title":"__call__","text":"<pre><code>__call__(class_: type[TokenT]) -&gt; type[TokenT]\n</code></pre> <p>Update docstring with specification reference.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/decorators.py</code> <pre><code>def __call__(self, class_: type[TokenT]) -&gt; type[TokenT]:\n    \"\"\"Update docstring with specification reference.\"\"\"\n    class_.__doc__ = (class_.__doc__ or \"\") + (\n        \"\\n\\n\"\n        f\"See section {self.spec_section.get_sec_id()} of \"\n        \"The Gerber Layer Format Specification \"\n        f\"{Revision.Revision_2023_08} - \"\n        f\"{self.spec_section.get_url()}\"\n    )\n    return class_\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/errors.html","title":"errors","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/errors.html#pygerber.gerberx3.tokenizer.errors","title":"errors","text":"<p>Base error classes used in this module.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/errors.html#pygerber.gerberx3.tokenizer.errors.TokenizerError","title":"TokenizerError","text":"<p>             Bases: <code>ValueError</code></p> <p>Base class for tokenizer errors.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/errors.py</code> <pre><code>class TokenizerError(ValueError):\n    \"\"\"Base class for tokenizer errors.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html","title":"grammar","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar","title":"grammar","text":"<p>GerberX3 grammar.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar.TokenWrapper","title":"TokenWrapper","text":"<p>Class for wrapping ParserElements with Token classes.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/grammar.py</code> <pre><code>class TokenWrapper:\n    \"\"\"Class for wrapping ParserElements with Token classes.\"\"\"\n\n    def __init__(self, *, is_raw: bool) -&gt; None:\n        self.is_raw = is_raw\n\n    def __call__(\n        self,\n        token_cls: Type[Token],\n        parser_element: ParserElement,\n    ) -&gt; ParserElement:\n        \"\"\"Wrap ParserElement with Token class.\"\"\"\n        if self.is_raw:\n            return parser_element\n\n        return token_cls.wrap(parser_element)\n\n    @classmethod\n    def build(\n        cls,\n        wrapper: Optional[Self] = None,\n        *,\n        is_raw: bool = False,\n    ) -&gt; Self:\n        \"\"\"Build TokenWrapper instance.\"\"\"\n        if wrapper is not None:\n            return wrapper\n\n        return cls(is_raw=is_raw)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar.TokenWrapper.__call__","title":"__call__","text":"<pre><code>__call__(\n    token_cls: Type[Token], parser_element: ParserElement\n) -&gt; ParserElement\n</code></pre> <p>Wrap ParserElement with Token class.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/grammar.py</code> <pre><code>def __call__(\n    self,\n    token_cls: Type[Token],\n    parser_element: ParserElement,\n) -&gt; ParserElement:\n    \"\"\"Wrap ParserElement with Token class.\"\"\"\n    if self.is_raw:\n        return parser_element\n\n    return token_cls.wrap(parser_element)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar.TokenWrapper.build","title":"build  <code>classmethod</code>","text":"<pre><code>build(\n    wrapper: Optional[Self] = None, *, is_raw: bool = False\n) -&gt; Self\n</code></pre> <p>Build TokenWrapper instance.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/grammar.py</code> <pre><code>@classmethod\ndef build(\n    cls,\n    wrapper: Optional[Self] = None,\n    *,\n    is_raw: bool = False,\n) -&gt; Self:\n    \"\"\"Build TokenWrapper instance.\"\"\"\n    if wrapper is not None:\n        return wrapper\n\n    return cls(is_raw=is_raw)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar.GrammarBuilderOptions","title":"GrammarBuilderOptions","text":"<p>Grammar builder options.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/grammar.py</code> <pre><code>class GrammarBuilderOptions:\n    \"\"\"Grammar builder options.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar.GrammarBuilder","title":"GrammarBuilder  <code>dataclass</code>","text":"<p>Base class for all grammar builder classes.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/grammar.py</code> <pre><code>@dataclass\nclass GrammarBuilder:\n    \"\"\"Base class for all grammar builder classes.\"\"\"\n\n    def __init__(\n        self,\n        wrapper: Optional[TokenWrapper] = None,\n        *,\n        is_raw: bool = False,\n        options: Optional[GrammarBuilderOptions] = None,\n    ) -&gt; None:\n        self.wrapper = TokenWrapper.build(wrapper=wrapper, is_raw=is_raw)\n        self.options = options if options is not None else GrammarBuilderOptions()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar.GerberGrammarBuilderOptions","title":"GerberGrammarBuilderOptions  <code>dataclass</code>","text":"<p>             Bases: <code>GrammarBuilderOptions</code></p> <p>Grammar builder options.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/grammar.py</code> <pre><code>@dataclass\nclass GerberGrammarBuilderOptions(GrammarBuilderOptions):\n    \"\"\"Grammar builder options.\"\"\"\n\n    ast_token_cls: Type[Token] = AST\n    block_aperture_begin_token_cls: Type[Token] = BlockApertureBegin\n    block_aperture_end_token_cls: Type[Token] = BlockApertureEnd\n    define_circle_token_cls: Type[Token] = DefineCircle\n    define_macro_token_cls: Type[Token] = DefineMacro\n    define_obround_token_cls: Type[Token] = DefineObround\n    define_polygon_token_cls: Type[Token] = DefinePolygon\n    define_rectangle_token_cls: Type[Token] = DefineRectangle\n    axis_select_token_cls: Type[Token] = AxisSelect\n    d01_draw_token_cls: Type[Token] = D01Draw\n    d02_move_token_cls: Type[Token] = D02Move\n    d03_flash_token_cls: Type[Token] = D03Flash\n    dnn_select_aperture_token_cls: Type[Token] = DNNSelectAperture\n    end_of_expression_token_cls: Type[Token] = EndOfExpression\n    fs_coordinate_format_token_cls: Type[Token] = CoordinateFormat\n    g01_set_linear_token_cls: Type[Token] = SetLinear\n    g02_set_clockwise_circular_token_cls: Type[Token] = SetClockwiseCircular\n    g03_set_counterclockwise_circular_token_cls: Type[\n        Token\n    ] = SetCounterclockwiseCircular\n    g04_comment_token_cls: Type[Token] = Comment\n    g36_begin_region_token_cls: Type[Token] = BeginRegion\n    g37_end_region_token_cls: Type[Token] = EndRegion\n    g54_select_aperture_token_cls: Type[Token] = G54SelectAperture\n    g70_set_unit_inch_token_cls: Type[Token] = SetUnitInch\n    g71_set_unit_mm_token_cls: Type[Token] = SetUnitMillimeters\n    g74_single_quadrant_token_cls: Type[Token] = SetSingleQuadrantMode\n    g75_multi_quadrant_token_cls: Type[Token] = SetMultiQuadrantMode\n    g90_set_coordinate_absolute_token_cls: Type[Token] = SetAbsoluteNotation\n    g91_set_coordinate_incremental_token_cls: Type[Token] = SetIncrementalNotation\n    statement_token_cls: Type[Token] = Statement\n    in_image_name_token_cls: Type[Token] = ImageName\n    invalid_token_cls: Type[Token] = InvalidToken\n    ip_image_polarity_token_cls: Type[Token] = ImagePolarity\n    lm_load_mirroring_token_cls: Type[Token] = LoadMirroring\n    ln_load_name_token_cls: Type[Token] = LoadName\n    lp_load_polarity_token_cls: Type[Token] = LoadPolarity\n    lr_load_rotation_token_cls: Type[Token] = LoadRotation\n    ls_load_scaling_token_cls: Type[Token] = LoadScaling\n    of_image_offset_token_cls: Type[Token] = ImageOffset\n    as_axes_select_token_cls: Type[Token] = AxisSelect\n    m00_program_stop_token_cls: Type[Token] = M00ProgramStop\n    m01_optional_stop_token_cls: Type[Token] = M01OptionalStop\n    m02_end_of_file_token_cls: Type[Token] = M02EndOfFile\n    macro_definition_token_cls: Type[Token] = MacroDefinition\n    macro_addition_operator_token_cls: Type[Token] = AdditionOperator\n    macro_division_operator_token_cls: Type[Token] = DivisionOperator\n    macro_multiplication_operator_token_cls: Type[Token] = MultiplicationOperator\n    macro_negation_operator_token_cls: Type[Token] = NegationOperator\n    macro_positive_operator_token_cls: Type[Token] = PositiveOperator\n    macro_subtraction_operator_token_cls: Type[Token] = SubtractionOperator\n    macro_comment_token_cls: Type[Token] = MacroComment\n    macro_begin_token_cls: Type[Token] = MacroBegin\n    macro_numeric_constant_token_cls: Type[Token] = NumericConstant\n    macro_point_token_cls: Type[Token] = Point\n    macro_primitive_center_line_token_cls: Type[Token] = Code21CenterLineToken\n    macro_primitive_circle_token_cls: Type[Token] = Code1CircleToken\n    macro_primitive_outline_token_cls: Type[Token] = Code4OutlineToken\n    macro_primitive_polygon_token_cls: Type[Token] = Code5PolygonToken\n    macro_primitive_thermal_token_cls: Type[Token] = Code7ThermalToken\n    macro_primitive_vector_line_token_cls: Type[Token] = Code20VectorLineToken\n    macro_variable_definition_token_cls: Type[Token] = MacroVariableAssignment\n    macro_variable_name_token_cls: Type[Token] = MacroVariableName\n    mo_unit_mode_token_cls: Type[Token] = UnitMode\n    step_repeat_begin_token_cls: Type[Token] = StepRepeatBegin\n    step_repeat_end_token_cls: Type[Token] = StepRepeatEnd\n    ta_aperture_attribute_token_cls: Type[Token] = ApertureAttribute\n    td_delete_attribute_token_cls: Type[Token] = DeleteAttribute\n    tf_file_attribute_token_cls: Type[Token] = FileAttribute\n    to_object_attribute_token_cls: Type[Token] = ObjectAttribute\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar.GerberGrammarBuilder","title":"GerberGrammarBuilder","text":"<p>             Bases: <code>GrammarBuilder</code></p> <p>Base class for all Gerber grammar builders.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/grammar.py</code> <pre><code>class GerberGrammarBuilder(GrammarBuilder):\n    \"\"\"Base class for all Gerber grammar builders.\"\"\"\n\n    options: GerberGrammarBuilderOptions\n\n    def __init__(\n        self,\n        wrapper: Optional[TokenWrapper] = None,\n        *,\n        is_raw: bool = False,\n        options: Optional[GerberGrammarBuilderOptions] = None,\n    ) -&gt; None:\n        super().__init__(\n            wrapper=wrapper,\n            is_raw=is_raw,\n            options=options if options is not None else GerberGrammarBuilderOptions(),\n        )\n\n    def build(self) -&gt; GerberGrammar:\n        \"\"\"Build grammar object.\"\"\"\n        wrapper = self.wrapper\n        eoex = self._build_eoex()\n\n        load_commands = self._build_load_commands()\n        # Sets the polarity of the whole image.\n        ip = self._build_stmt(\n            wrapper(\n                self.options.ip_image_polarity_token_cls,\n                Literal(\"IP\") + oneOf(\"POS NEG\").set_results_name(\"image_polarity\"),\n            ),\n        )\n        # End of file.\n        m02 = wrapper(\n            self.options.m02_end_of_file_token_cls,\n            Literal(\"M02\").set_name(\"End of file\") + eoex,\n        )\n        # Optional stop.\n        m01 = wrapper(\n            self.options.m01_optional_stop_token_cls,\n            Literal(\"M01\").set_name(\"Optional stop\") + eoex,\n        )\n        # Program stop.\n        m00 = wrapper(\n            self.options.m00_program_stop_token_cls,\n            Literal(\"M00\").set_name(\"Program stop\") + eoex,\n        )\n\n        dnn = wrapper(\n            self.options.dnn_select_aperture_token_cls,\n            self._build_aperture_identifier() + eoex,\n        )\n        \"\"\"Sets the current aperture to D code nn.\"\"\"\n\n        fs = self._build_format_specifier()\n        # Sets the unit to mm or inch.\n        mo = self._build_stmt(\n            wrapper(\n                self.options.mo_unit_mode_token_cls,\n                Literal(\"MO\")\n                + oneOf(\"MM IN\").set_results_name(\"unit\").set_name(\"unit\"),\n            ),\n        )\n\n        # Open a step and repeat statement.\n        sr = self._build_step_repeat()\n\n        # Opens a block aperture statement and assigns its aperture number\n        ab_open = self._build_stmt(\n            wrapper(\n                self.options.block_aperture_begin_token_cls,\n                Literal(\"AB\") + self._build_aperture_identifier(),\n            ),\n        )\n        # Closes a block aperture statement.\n        ab_close = self._build_stmt(\n            wrapper(self.options.block_aperture_end_token_cls, Literal(\"AB\")),\n        )\n\n        g_codes = self._build_g_codes()\n        d_codes = self._build_d_codes()\n        comment = self._build_comment_token()\n\n        common = (\n            comment\n            | mo\n            | fs\n            | self._build_macro_tokens()\n            | self._build_define_aperture()\n            | dnn\n            | (d_codes + eoex)\n            | (g_codes + d_codes + eoex)\n            | (g_codes + eoex)\n            | load_commands\n            | ip\n            | ab_open\n            | ab_close\n            | sr\n            | self._build_attribute_tokens(statement=True)\n            | m01\n            | eoex\n        )\n\n        invalid_token = self.wrapper(\n            self.options.invalid_token_cls,\n            Regex(\".+\").set_results_name(\"content\"),\n        )\n\n        resilient = self.wrapper(\n            self.options.ast_token_cls,\n            (common | m02 | m00 | invalid_token)[0, ...],\n        )\n        expressions = self.wrapper(\n            self.options.ast_token_cls,\n            (common | m02 | m00)[0, ...],\n        )\n        grammar = self.wrapper(\n            self.options.ast_token_cls,\n            common[0, ...] + (m02 | m00),\n        )\n\n        return GerberGrammar(grammar, expressions, resilient)\n\n    def _build_load_commands(self) -&gt; ParserElement:\n        wrapper = self.wrapper\n\n        lm = self._build_stmt(\n            wrapper(\n                self.options.lm_load_mirroring_token_cls,\n                Literal(\"LM\") + oneOf(\"N XY Y X\").set_results_name(\"mirroring\"),\n            ),\n        )\n        lp = self._build_stmt(\n            wrapper(\n                self.options.lp_load_polarity_token_cls,\n                Literal(\"LP\") + oneOf(\"C D\").set_results_name(\"polarity\"),\n            ),\n        )\n        ls = self._build_stmt(\n            wrapper(\n                self.options.ls_load_scaling_token_cls,\n                Literal(\"LS\") + self._build_decimal(\"scaling\"),\n            ),\n        )\n        lr = self._build_stmt(\n            wrapper(\n                self.options.lr_load_rotation_token_cls,\n                Literal(\"LR\") + self._build_decimal(\"rotation\"),\n            ),\n        )\n        ln = self._build_stmt(\n            wrapper(\n                self.options.ln_load_name_token_cls,\n                Literal(\"LN\") + self._build_string(),\n            ),\n        )\n        in_ = self._build_stmt(\n            wrapper(\n                self.options.in_image_name_token_cls,\n                Literal(\"IN\") + self._build_string(),\n            ),\n        )\n        as_ = self._build_stmt(\n            wrapper(\n                self.options.as_axes_select_token_cls,\n                Literal(\"AS\") + oneOf(\"AXBY AYBX\").set_results_name(\"correspondence\"),\n            ),\n        )\n        of = self._build_stmt(\n            wrapper(\n                self.options.of_image_offset_token_cls,\n                Literal(\"OF\")\n                + Opt(Literal(\"A\") + self._build_decimal(\"a\"))\n                + Opt(Literal(\"B\") + self._build_decimal(\"b\")),\n            ),\n        )\n\n        return lm | lp | ls | lr | as_ | of | in_ | ln\n\n    def _build_format_specifier(self) -&gt; ParserElement:\n        wrapper = self.wrapper\n\n        coord_digits = Regex(r\"[1-9][1-9]\")\n\n        # Sets the coordinate format, e.g. the number of decimals.\n        return self._build_stmt(\n            wrapper(\n                self.options.fs_coordinate_format_token_cls,\n                Literal(\"FS\")\n                + oneOf(\"L T\").set_results_name(\"zeros_mode\").set_name(\"zeros mode\")\n                + oneOf(\"A I\")\n                .set_results_name(\"coordinate_mode\")\n                .set_name(\"coordinate mode\")\n                + \"X\"\n                + coord_digits.set_results_name(\"x_format\").set_name(\n                    \"X coordinate format\",\n                )\n                + \"Y\"\n                + coord_digits.set_results_name(\"y_format\").set_name(\n                    \"Y coordinate format\",\n                ),\n            ),\n        )\n\n    def _build_step_repeat(self) -&gt; ParserElement:\n        wrapper = self.wrapper\n\n        sr_open = self._build_stmt(\n            wrapper(\n                self.options.step_repeat_begin_token_cls,\n                Literal(\"SR\")\n                + \"X\"\n                + self._build_integer(\"x_repeat\")\n                + \"Y\"\n                + self._build_integer(\"y_repeat\")\n                + \"I\"\n                + self._build_decimal(\"x_step\")\n                + \"J\"\n                + self._build_decimal(\"y_step\"),\n            ),\n        )\n        # Closes a step and repeat statement.\n        sr_close = self._build_stmt(\n            wrapper(self.options.step_repeat_end_token_cls, Literal(\"SR\")),\n        )\n\n        return sr_open | sr_close\n\n    def _build_g_codes(self) -&gt; ParserElement:\n        wrapper = self.wrapper\n\n        g54dnn = wrapper(\n            self.options.g54_select_aperture_token_cls,\n            Regex(\"G0*54\") + self._build_aperture_identifier(),\n        )\n        g01 = wrapper(self.options.g01_set_linear_token_cls, Regex(\"G0*1\"))\n        g02 = wrapper(self.options.g02_set_clockwise_circular_token_cls, Regex(\"G0*2\"))\n        g03 = wrapper(\n            self.options.g03_set_counterclockwise_circular_token_cls,\n            Regex(\"G0*3\"),\n        )\n        g36 = wrapper(self.options.g36_begin_region_token_cls, Regex(\"G0*36\"))\n        g37 = wrapper(self.options.g37_end_region_token_cls, Regex(\"G0*37\"))\n        g70 = wrapper(self.options.g70_set_unit_inch_token_cls, Regex(\"G0*70\"))\n        g71 = wrapper(self.options.g71_set_unit_mm_token_cls, Regex(\"G0*71\"))\n        g74 = wrapper(self.options.g74_single_quadrant_token_cls, Regex(\"G0*74\"))\n        g75 = wrapper(self.options.g75_multi_quadrant_token_cls, Regex(\"G0*75\"))\n        g90 = wrapper(\n            self.options.g90_set_coordinate_absolute_token_cls,\n            Regex(\"G0*90\"),\n        )\n        g91 = wrapper(\n            self.options.g91_set_coordinate_incremental_token_cls,\n            Regex(\"G0*91\"),\n        )\n\n        # Order is important, as g03 would match g36 if checked before g36 regex.\n        return g54dnn | g36 | g37 | g70 | g71 | g74 | g75 | g90 | g91 | g01 | g02 | g03\n\n    def _build_d_codes(self) -&gt; ParserElement:\n        wrapper = self.wrapper\n\n        x_coordinate = Literal(\"X\") + self._build_integer(\"x\", \"X coordinate\")\n        y_coordinate = Literal(\"Y\") + self._build_integer(\"y\", \"Y coordinate\")\n\n        i_coordinate = Literal(\"I\") + self._build_integer(\"i\", \"I offset\")\n        j_coordinate = Literal(\"J\") + self._build_integer(\"j\", \"J offset\")\n\n        xy = (x_coordinate + Opt(y_coordinate)) | (Opt(x_coordinate) + y_coordinate)\n        ij = (i_coordinate + Opt(j_coordinate)) | (Opt(i_coordinate) + j_coordinate)\n\n        d01 = wrapper(\n            self.options.d01_draw_token_cls,\n            ((Opt(xy) + Opt(ij) + Regex(\"D0*1\")) | (xy + Opt(ij))),\n        )\n        d02 = wrapper(\n            self.options.d02_move_token_cls,\n            Opt(xy) + Regex(\"D0*2\"),\n        )\n        d03 = wrapper(\n            self.options.d03_flash_token_cls,\n            Opt(xy) + Regex(\"D0*3\"),\n        )\n\n        return d03 | d02 | d01\n\n    def _build_comment_token(self) -&gt; ParserElement:\n        wrapper = self.wrapper\n        eoex = self._build_eoex()\n\n        # A human readable comment, does not affect the image.\n        return wrapper(\n            self.options.g04_comment_token_cls,\n            Regex(\"G0*4\") + self._build_string() + eoex,\n        )\n\n    def _build_define_aperture(self) -&gt; ParserElement:\n        wrapper = self.wrapper\n\n        ad = Literal(\"AD\").set_name(\"AD code\")\n\n        circle = wrapper(\n            self.options.define_circle_token_cls,\n            ad\n            + self._build_aperture_identifier()\n            + Literal(\"C\").set_results_name(\"aperture_type\")\n            + \",\"\n            + self._build_decimal(\"diameter\")\n            + Opt(\"X\" + self._build_decimal(\"hole_diameter\")),\n        ).set_name(\"define aperture circle\")\n\n        rectangle = wrapper(\n            self.options.define_rectangle_token_cls,\n            ad\n            + self._build_aperture_identifier()\n            + Literal(\"R\").set_results_name(\"aperture_type\")\n            + \",\"\n            + self._build_decimal(\"x_size\")\n            + \"X\"\n            + self._build_decimal(\"y_size\")\n            + Opt(\"X\" + self._build_decimal(\"hole_diameter\")),\n        ).set_name(\"define aperture rectangle\")\n\n        obround = wrapper(\n            self.options.define_obround_token_cls,\n            ad\n            + self._build_aperture_identifier()\n            + Literal(\"O\").set_results_name(\"aperture_type\")\n            + \",\"\n            + self._build_decimal(\"x_size\")\n            + \"X\"\n            + self._build_decimal(\"y_size\")\n            + Opt(\"X\" + self._build_decimal(\"hole_diameter\")),\n        ).set_name(\"define aperture obround\")\n\n        polygon = wrapper(\n            self.options.define_polygon_token_cls,\n            ad\n            + self._build_aperture_identifier()\n            + Literal(\"P\").set_results_name(\"aperture_type\")\n            + \",\"\n            + self._build_decimal(\"outer_diameter\")\n            + \"X\"\n            + self._build_decimal(\"number_of_vertices\")\n            + Opt(\n                \"X\"\n                + self._build_decimal(\"rotation\")\n                + Opt(\"X\" + self._build_decimal(\"hole_diameter\")),\n            ),\n        ).set_name(\"define aperture polygon\")\n\n        am_param = self._build_decimal(\"am_param\", list_all_matches=True)\n        # Defines a template-based aperture, assigns a D code to it.\n\n        macro = wrapper(\n            self.options.define_macro_token_cls,\n            ad\n            + self._build_aperture_identifier()\n            + self._build_name(\"aperture_type\")\n            + Opt(\",\" + am_param + ZeroOrMore(\"X\" + am_param)),\n        ).set_name(\"define aperture macro\")\n\n        return self._build_stmt(circle | rectangle | obround | polygon | macro)\n\n    def _build_macro_tokens(self) -&gt; ParserElement:\n        wrapper = self.wrapper\n\n        primitive = self._build_macro_primitive()\n        variable_definition = self._build_macro_variable_definition()\n        comment = self._build_comment_token()\n\n        macro_body = (\n            (primitive | variable_definition | comment)\n            .set_results_name(\"macro_body\", list_all_matches=True)\n            .set_name(\"macro body expression\")\n        )[1, ...]\n\n        am_start = (\n            self._annotate_parser_element(\n                wrapper(\n                    self.options.macro_begin_token_cls,\n                    Literal(\"AM\") + self._build_name(\"macro_name\"),\n                ),\n                \"macro_begin\",\n            )\n            + self._build_eoex()\n        )\n\n        # Defines a macro aperture template.\n        return self._build_stmt(\n            wrapper(\n                self.options.macro_definition_token_cls,\n                am_start + macro_body,\n            ),\n            eoex=False,\n        ).set_name(\"macro definition\")\n\n    def _build_macro_variable_definition(self) -&gt; ParserElement:\n        return self.wrapper(\n            self.options.macro_variable_definition_token_cls,\n            self._build_macro_variable()\n            + \"=\"\n            + self._build_macro_expr(\"value\")\n            + self._build_eoex(),\n        )\n\n    def _build_macro_primitive(self) -&gt; ParserElement:\n        cs = Suppress(Literal(\",\").set_name(\"comma\"))\n        primitive_comment = self.wrapper(\n            self.options.macro_comment_token_cls,\n            \"0\" + self._build_string(),\n        )\n        primitive_circle = self.wrapper(\n            self.options.macro_primitive_circle_token_cls,\n            \"1\"  # Circle\n            + cs\n            + self._build_macro_expr(\"exposure\")  # Exposure\n            + cs\n            + self._build_macro_expr(\"diameter\")  # Diameter\n            + cs\n            + self._build_macro_expr(\"center_x\")  # Center X\n            + cs\n            + self._build_macro_expr(\"center_y\")  # Center Y\n            + Opt(cs + self._build_macro_expr(\"rotation\")),  # Rotation\n        )\n        primitive_vector_line = self.wrapper(\n            self.options.macro_primitive_vector_line_token_cls,\n            \"20\"  # Vector Line\n            + cs\n            + self._build_macro_expr(\"exposure\")  # Exposure\n            + cs\n            + self._build_macro_expr(\"width\")  # Width\n            + cs\n            + self._build_macro_expr(\"start_x\")  # Start X\n            + cs\n            + self._build_macro_expr(\"start_y\")  # Start Y\n            + cs\n            + self._build_macro_expr(\"end_x\")  # End X\n            + cs\n            + self._build_macro_expr(\"end_y\")  # End Y\n            + cs\n            + self._build_macro_expr(\"rotation\"),  # Rotation\n        )\n        primitive_center_line = self.wrapper(\n            self.options.macro_primitive_center_line_token_cls,\n            \"21\"  # Center Line\n            + cs\n            + self._build_macro_expr(\"exposure\")  # Exposure\n            + cs\n            + self._build_macro_expr(\"width\")  # Width\n            + cs\n            + self._build_macro_expr(\"height\")  # height\n            + cs\n            + self._build_macro_expr(\"center_x\")  # Center X\n            + cs\n            + self._build_macro_expr(\"center_y\")  # Center Y\n            + cs\n            + self._build_macro_expr(\"rotation\"),  # Rotation\n        )\n        primitive_outline = self.wrapper(\n            self.options.macro_primitive_outline_token_cls,\n            \"4\"  # Outline\n            + cs\n            + self._build_macro_expr(\"exposure\")  # Exposure\n            + cs\n            + self._build_macro_expr(\"number_of_vertices\")  # Number of vertices\n            + cs\n            + self._build_macro_expr(\"start_x\")  # Start X\n            + cs\n            + self._build_macro_expr(\"start_y\")  # Start Y\n            + OneOrMore(  # Subsequent points...\n                self._build_macro_point().set_results_name(\n                    \"point\",\n                    list_all_matches=True,\n                ),\n            )\n            + cs\n            + self._build_macro_expr(\"rotation\"),  # Rotation\n        )\n        primitive_polygon = self.wrapper(\n            self.options.macro_primitive_polygon_token_cls,\n            \"5\"  # Polygon\n            + cs\n            + self._build_macro_expr(\"exposure\")  # Exposure\n            + cs\n            + self._build_macro_expr(\"number_of_vertices\")  # Number of vertices\n            + cs\n            + self._build_macro_expr(\"center_x\")  # Center X\n            + cs\n            + self._build_macro_expr(\"center_y\")  # Center Y\n            + cs\n            + self._build_macro_expr(\"diameter\")  # Diameter\n            + cs\n            + self._build_macro_expr(\"rotation\"),  # Rotation\n        )\n        primitive_thermal = self.wrapper(\n            self.options.macro_primitive_thermal_token_cls,\n            \"7\"  # Thermal\n            + cs\n            + self._build_macro_expr(\"center_x\")  # Center X\n            + cs\n            + self._build_macro_expr(\"center_y\")  # Center Y\n            + cs\n            + self._build_macro_expr(\"outer_diameter\")  # Outer diameter\n            + cs\n            + self._build_macro_expr(\"inner_diameter\")  # Inner diameter\n            + cs\n            + self._build_macro_expr(\"gap\")  # Gap\n            + cs\n            + self._build_macro_expr(\"rotation\"),  # Rotation\n        )\n\n        return (\n            (primitive_comment + self._build_eoex()).set_name(\"primitive comment\")\n            | (primitive_circle + self._build_eoex()).set_name(\"primitive circle\")\n            | (primitive_vector_line + self._build_eoex()).set_name(\n                \"primitive vector line\",\n            )\n            | (primitive_center_line + self._build_eoex()).set_name(\n                \"primitive center line\",\n            )\n            | (primitive_outline + self._build_eoex()).set_name(\"primitive outline\")\n            | (primitive_polygon + self._build_eoex()).set_name(\"primitive polygon\")\n            | (primitive_thermal + self._build_eoex()).set_name(\"primitive thermal\")\n        )\n\n    def _build_macro_point(self) -&gt; ParserElement:\n        cs = Suppress(Literal(\",\").set_name(\"comma\"))\n        return self.wrapper(\n            self.options.macro_point_token_cls,\n            cs + self._build_macro_expr(\"x\") + cs + self._build_macro_expr(\"y\"),\n        )\n\n    _macro_expr: Optional[ParserElement] = None\n\n    def _build_macro_expr(self, expr_name: str = \"expr\") -&gt; ParserElement:\n        macro_variable = self._build_macro_variable()\n        numeric_constant = self.wrapper(\n            self.options.macro_numeric_constant_token_cls,\n            Regex(r\"((([0-9]+)(\\.[0-9]*)?)|(\\.[0-9]+))\").set_results_name(\n                \"numeric_constant_value\",\n            ),\n        )\n\n        arithmetic_expression = Forward()\n\n        factor = macro_variable | numeric_constant\n\n        if self.wrapper.is_raw:\n            arithmetic_expression &lt;&lt;= ungroup(\n                infix_notation(\n                    factor,\n                    [\n                        (\"-\", 1, OpAssoc.RIGHT),\n                        (\"+\", 1, OpAssoc.RIGHT),\n                        (\"/\", 2, OpAssoc.RIGHT),\n                        (oneOf(\"x X\"), 2, OpAssoc.RIGHT),\n                        (\"-\", 2, OpAssoc.RIGHT),\n                        (\"+\", 2, OpAssoc.RIGHT),\n                    ],\n                ),\n            )\n        else:\n            arithmetic_expression &lt;&lt;= ungroup(\n                infix_notation(\n                    factor,\n                    [\n                        (\n                            Suppress(\"-\"),\n                            1,\n                            OpAssoc.RIGHT,\n                            self.options.macro_negation_operator_token_cls.new,\n                        ),\n                        (\n                            Suppress(\"+\"),\n                            1,\n                            OpAssoc.RIGHT,\n                            self.options.macro_positive_operator_token_cls.new,\n                        ),\n                        (\n                            Suppress(\"/\"),\n                            2,\n                            OpAssoc.RIGHT,\n                            self.options.macro_division_operator_token_cls.new,\n                        ),\n                        (\n                            Suppress(oneOf(\"x X\")),\n                            2,\n                            OpAssoc.RIGHT,\n                            self.options.macro_multiplication_operator_token_cls.new,\n                        ),\n                        (\n                            Suppress(\"-\"),\n                            2,\n                            OpAssoc.RIGHT,\n                            self.options.macro_subtraction_operator_token_cls.new,\n                        ),\n                        (\n                            Suppress(\"+\"),\n                            2,\n                            OpAssoc.RIGHT,\n                            self.options.macro_addition_operator_token_cls.new,\n                        ),\n                    ],\n                ),\n            )\n\n        expr = arithmetic_expression | factor\n\n        return expr.set_results_name(expr_name).set_name(expr_name)\n\n    def _build_macro_variable(self) -&gt; ParserElement:\n        return self.wrapper(\n            self.options.macro_variable_name_token_cls,\n            Regex(r\"\\$[0-9]*[1-9][0-9]*\")(\"macro_variable_name\"),\n        )\n\n    def _build_attribute_tokens(self, *, statement: bool = False) -&gt; ParserElement:\n        wrapper = self.wrapper\n\n        file_attribute_name = self._build_name().set_name(\"file attribute name\")\n        aperture_attribute_name = self._build_name().set_name(\"aperture attribute name\")\n        object_attribute_name = self._build_name().set_name(\"object attribute name\")\n\n        # Set a file attribute.\n        tf = wrapper(\n            self.options.tf_file_attribute_token_cls,\n            Literal(\"TF\")\n            + file_attribute_name.set_results_name(\"attribute_name\")\n            + Literal(\",\")\n            + Opt(self._build_field()),\n        )\n        # Add an aperture attribute to the dictionary or modify it.\n        ta = wrapper(\n            self.options.ta_aperture_attribute_token_cls,\n            Literal(\"TA\")\n            + aperture_attribute_name.set_results_name(\"attribute_name\")\n            + Literal(\",\")\n            + Opt(self._build_field()),\n        )\n        # Add an object attribute to the dictionary or modify it.\n        to = wrapper(\n            self.options.to_object_attribute_token_cls,\n            Literal(\"TO\")\n            + object_attribute_name.set_results_name(\"attribute_name\")\n            + Literal(\",\")\n            + Opt(self._build_field()),\n        )\n        # Delete one or all attributes in the dictionary.\n        td = wrapper(\n            self.options.td_delete_attribute_token_cls,\n            Literal(\"TD\")\n            + Opt(\n                file_attribute_name | aperture_attribute_name | object_attribute_name,\n            ).set_results_name(\"attribute_name\"),\n        )\n        if statement:\n            return self._build_stmt(tf | ta | to | td)\n\n        return tf | ta | to | td\n\n    _build_eoex_cache: Optional[ParserElement] = None\n\n    def _build_eoex(self) -&gt; ParserElement:\n        if self._build_eoex_cache is None:\n            self._build_eoex_cache = self.wrapper(\n                self.options.end_of_expression_token_cls,\n                Literal(\"*\").set_name(\"end of expression\"),\n            )\n        return self._build_eoex_cache\n\n    def _build_stmt(\n        self,\n        expr: ParserElement,\n        *,\n        eoex: bool = True,\n    ) -&gt; ParserElement:\n        begin_stmt = Literal(\"%\")\n        end_stmt = Literal(\"%\")\n\n        return self.wrapper(\n            self.options.statement_token_cls,\n            begin_stmt + expr + ((self._build_eoex() + end_stmt) if eoex else end_stmt),\n        )\n\n    def _build_integer(\n        self,\n        result_name: str = \"integer\",\n        name: Optional[str] = None,\n        **kwargs: Any,\n    ) -&gt; ParserElement:\n        return self._annotate_parser_element(\n            Combine(Opt(oneOf(\"+ -\")) + Word(nums)),\n            result_name,\n            name,\n            **kwargs,\n        )\n\n    def _annotate_parser_element(\n        self,\n        element: ParserElement,\n        result_name: str,\n        name: Optional[str] = None,\n        **kwargs: Any,\n    ) -&gt; ParserElement:\n        if name is None:\n            name = result_name\n        return element.set_name(name).set_results_name(result_name, **kwargs)\n\n    def _build_decimal(\n        self,\n        result_name: str = \"decimal\",\n        name: Optional[str] = None,\n        **kwargs: Any,\n    ) -&gt; ParserElement:\n        return self._annotate_parser_element(\n            Regex(r\"[+-]?((([0-9]+)(\\.[0-9]*)?)|(\\.[0-9]+))\"),\n            result_name,\n            name,\n            **kwargs,\n        )\n\n    def _build_aperture_identifier(\n        self,\n        result_name: str = \"aperture_identifier\",\n        name: Optional[str] = None,\n        **kwargs: Any,\n    ) -&gt; ParserElement:\n        return self._annotate_parser_element(\n            Combine(\"D\" + Regex(r\"[1-9][0-9]+\")),\n            result_name,\n            name,\n            **kwargs,\n        )\n\n    def _build_name(\n        self,\n        result_name: str = \"name\",\n        name: Optional[str] = None,\n        **kwargs: Any,\n    ) -&gt; ParserElement:\n        return self._annotate_parser_element(\n            Regex(r\"[._a-zA-Z$][\\._a-zA-Z0-9]*\"),\n            result_name,\n            name,\n            **kwargs,\n        )\n\n    def _build_string(\n        self,\n        result_name: str = \"string\",\n        name: Optional[str] = None,\n        **kwargs: Any,\n    ) -&gt; ParserElement:\n        return self._annotate_parser_element(\n            CharsNotIn(\"%*\"),\n            result_name,\n            name,\n            **kwargs,\n        )\n\n    def _build_field(\n        self,\n        result_name: str = \"field\",\n        name: Optional[str] = None,\n        **kwargs: Any,\n    ) -&gt; ParserElement:\n        return self._annotate_parser_element(\n            CharsNotIn(\"%*\"),\n            result_name,\n            name,\n            **kwargs,\n        )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar.GerberGrammarBuilder.build","title":"build","text":"<pre><code>build() -&gt; GerberGrammar\n</code></pre> <p>Build grammar object.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/grammar.py</code> <pre><code>def build(self) -&gt; GerberGrammar:\n    \"\"\"Build grammar object.\"\"\"\n    wrapper = self.wrapper\n    eoex = self._build_eoex()\n\n    load_commands = self._build_load_commands()\n    # Sets the polarity of the whole image.\n    ip = self._build_stmt(\n        wrapper(\n            self.options.ip_image_polarity_token_cls,\n            Literal(\"IP\") + oneOf(\"POS NEG\").set_results_name(\"image_polarity\"),\n        ),\n    )\n    # End of file.\n    m02 = wrapper(\n        self.options.m02_end_of_file_token_cls,\n        Literal(\"M02\").set_name(\"End of file\") + eoex,\n    )\n    # Optional stop.\n    m01 = wrapper(\n        self.options.m01_optional_stop_token_cls,\n        Literal(\"M01\").set_name(\"Optional stop\") + eoex,\n    )\n    # Program stop.\n    m00 = wrapper(\n        self.options.m00_program_stop_token_cls,\n        Literal(\"M00\").set_name(\"Program stop\") + eoex,\n    )\n\n    dnn = wrapper(\n        self.options.dnn_select_aperture_token_cls,\n        self._build_aperture_identifier() + eoex,\n    )\n    \"\"\"Sets the current aperture to D code nn.\"\"\"\n\n    fs = self._build_format_specifier()\n    # Sets the unit to mm or inch.\n    mo = self._build_stmt(\n        wrapper(\n            self.options.mo_unit_mode_token_cls,\n            Literal(\"MO\")\n            + oneOf(\"MM IN\").set_results_name(\"unit\").set_name(\"unit\"),\n        ),\n    )\n\n    # Open a step and repeat statement.\n    sr = self._build_step_repeat()\n\n    # Opens a block aperture statement and assigns its aperture number\n    ab_open = self._build_stmt(\n        wrapper(\n            self.options.block_aperture_begin_token_cls,\n            Literal(\"AB\") + self._build_aperture_identifier(),\n        ),\n    )\n    # Closes a block aperture statement.\n    ab_close = self._build_stmt(\n        wrapper(self.options.block_aperture_end_token_cls, Literal(\"AB\")),\n    )\n\n    g_codes = self._build_g_codes()\n    d_codes = self._build_d_codes()\n    comment = self._build_comment_token()\n\n    common = (\n        comment\n        | mo\n        | fs\n        | self._build_macro_tokens()\n        | self._build_define_aperture()\n        | dnn\n        | (d_codes + eoex)\n        | (g_codes + d_codes + eoex)\n        | (g_codes + eoex)\n        | load_commands\n        | ip\n        | ab_open\n        | ab_close\n        | sr\n        | self._build_attribute_tokens(statement=True)\n        | m01\n        | eoex\n    )\n\n    invalid_token = self.wrapper(\n        self.options.invalid_token_cls,\n        Regex(\".+\").set_results_name(\"content\"),\n    )\n\n    resilient = self.wrapper(\n        self.options.ast_token_cls,\n        (common | m02 | m00 | invalid_token)[0, ...],\n    )\n    expressions = self.wrapper(\n        self.options.ast_token_cls,\n        (common | m02 | m00)[0, ...],\n    )\n    grammar = self.wrapper(\n        self.options.ast_token_cls,\n        common[0, ...] + (m02 | m00),\n    )\n\n    return GerberGrammar(grammar, expressions, resilient)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/grammar.html#pygerber.gerberx3.tokenizer.grammar.GerberGrammar","title":"GerberGrammar","text":"<p>Gerber grammar container.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/grammar.py</code> <pre><code>class GerberGrammar:\n    \"\"\"Gerber grammar container.\"\"\"\n\n    def __init__(\n        self,\n        strict_grammar: ParserElement,\n        expression_grammar: ParserElement,\n        resilient_grammar: ParserElement,\n    ) -&gt; None:\n        self.strict_grammar = strict_grammar\n        self.expression_grammar = expression_grammar\n        self.resilient_grammar = resilient_grammar\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokenizer.html","title":"tokenizer","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokenizer.html#pygerber.gerberx3.tokenizer.tokenizer","title":"tokenizer","text":"<p>GerberX3 format tokenizer.</p> <p>Parser is based on GerberX3 format described in Ucamco's <code>The Gerber Layer Format Specification</code>.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokenizer.html#pygerber.gerberx3.tokenizer.tokenizer.TokenizerOptions","title":"TokenizerOptions  <code>dataclass</code>","text":"<p>Tokenizer options.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokenizer.py</code> <pre><code>@dataclass\nclass TokenizerOptions:\n    \"\"\"Tokenizer options.\"\"\"\n\n    grammar_options: GerberGrammarBuilderOptions = field(\n        default_factory=GerberGrammarBuilderOptions,\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokenizer.html#pygerber.gerberx3.tokenizer.tokenizer.Tokenizer","title":"Tokenizer","text":"<p>GerberX3 format tokenizer.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokenizer.py</code> <pre><code>class Tokenizer:\n    \"\"\"GerberX3 format tokenizer.\"\"\"\n\n    def __init__(self, options: Optional[TokenizerOptions] = None) -&gt; None:\n        \"\"\"GerberX3 format tokenizer.\"\"\"\n        logging.debug(\"Created %s GerberX3 tokenizer.\")\n        self.options = TokenizerOptions() if options is None else options\n        self.grammar = GerberGrammarBuilder(\n            options=self.options.grammar_options,\n        ).build()\n\n    def tokenize(self, source: str) -&gt; AST:\n        \"\"\"Convert source code into token stack.\n\n        Supports only full, valid GerberX3 files.\n        \"\"\"\n        return self._tokenize_grammar(\n            source,\n            self.grammar.strict_grammar,\n            parse_all=False,\n        )\n\n    def tokenize_expressions(self, source: str) -&gt; AST:\n        \"\"\"Convert source code into token stack.\n\n        Supports arbitrary sequences of valid GerberX3 expressions.\n        \"\"\"\n        return self._tokenize_grammar(\n            source,\n            self.grammar.expression_grammar,\n            parse_all=True,\n        )\n\n    def tokenize_resilient(self, source: str) -&gt; AST:\n        \"\"\"Convert source code into token stack.\n\n        Supports arbitrary sequences of valid GerberX3 expressions.\n        \"\"\"\n        return self._tokenize_grammar(\n            source,\n            self.grammar.resilient_grammar,\n            parse_all=True,\n        )\n\n    def _tokenize_grammar(\n        self,\n        source: str,\n        grammar: ParserElement,\n        *,\n        parse_all: bool,\n    ) -&gt; AST:\n        ast = grammar.parse_string(source, parse_all=parse_all)[0]\n        if not isinstance(ast, AST):\n            raise TypeError(ast)\n        return ast\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokenizer.html#pygerber.gerberx3.tokenizer.tokenizer.Tokenizer.__init__","title":"__init__","text":"<pre><code>__init__(\n    options: Optional[TokenizerOptions] = None,\n) -&gt; None\n</code></pre> <p>GerberX3 format tokenizer.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokenizer.py</code> <pre><code>def __init__(self, options: Optional[TokenizerOptions] = None) -&gt; None:\n    \"\"\"GerberX3 format tokenizer.\"\"\"\n    logging.debug(\"Created %s GerberX3 tokenizer.\")\n    self.options = TokenizerOptions() if options is None else options\n    self.grammar = GerberGrammarBuilder(\n        options=self.options.grammar_options,\n    ).build()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokenizer.html#pygerber.gerberx3.tokenizer.tokenizer.Tokenizer.tokenize","title":"tokenize","text":"<pre><code>tokenize(source: str) -&gt; AST\n</code></pre> <p>Convert source code into token stack.</p> <p>Supports only full, valid GerberX3 files.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokenizer.py</code> <pre><code>def tokenize(self, source: str) -&gt; AST:\n    \"\"\"Convert source code into token stack.\n\n    Supports only full, valid GerberX3 files.\n    \"\"\"\n    return self._tokenize_grammar(\n        source,\n        self.grammar.strict_grammar,\n        parse_all=False,\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokenizer.html#pygerber.gerberx3.tokenizer.tokenizer.Tokenizer.tokenize_expressions","title":"tokenize_expressions","text":"<pre><code>tokenize_expressions(source: str) -&gt; AST\n</code></pre> <p>Convert source code into token stack.</p> <p>Supports arbitrary sequences of valid GerberX3 expressions.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokenizer.py</code> <pre><code>def tokenize_expressions(self, source: str) -&gt; AST:\n    \"\"\"Convert source code into token stack.\n\n    Supports arbitrary sequences of valid GerberX3 expressions.\n    \"\"\"\n    return self._tokenize_grammar(\n        source,\n        self.grammar.expression_grammar,\n        parse_all=True,\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokenizer.html#pygerber.gerberx3.tokenizer.tokenizer.Tokenizer.tokenize_resilient","title":"tokenize_resilient","text":"<pre><code>tokenize_resilient(source: str) -&gt; AST\n</code></pre> <p>Convert source code into token stack.</p> <p>Supports arbitrary sequences of valid GerberX3 expressions.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokenizer.py</code> <pre><code>def tokenize_resilient(self, source: str) -&gt; AST:\n    \"\"\"Convert source code into token stack.\n\n    Supports arbitrary sequences of valid GerberX3 expressions.\n    \"\"\"\n    return self._tokenize_grammar(\n        source,\n        self.grammar.resilient_grammar,\n        parse_all=True,\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/helpers/__init__.html","title":"init","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/helpers/__init__.html#pygerber.gerberx3.tokenizer.helpers","title":"helpers","text":"<p>Helper classes.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/helpers/gerber_code_enum.html","title":"gerber_code_enum","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/helpers/gerber_code_enum.html#pygerber.gerberx3.tokenizer.helpers.gerber_code_enum","title":"gerber_code_enum","text":"<p>Enum with GerberCode interface implementation.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/helpers/gerber_code_enum.html#pygerber.gerberx3.tokenizer.helpers.gerber_code_enum.GerberCodeEnum","title":"GerberCodeEnum","text":"<p>             Bases: <code>GerberCode</code>, <code>Enum</code></p> <p>Enum with GerberCode interface implementation.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/helpers/gerber_code_enum.py</code> <pre><code>class GerberCodeEnum(GerberCode, Enum):\n    \"\"\"Enum with GerberCode interface implementation.\"\"\"\n\n    def get_gerber_code(\n        self,\n        indent: str = \"\",\n        endline: str = \"\\n\",  # noqa: ARG002\n    ) -&gt; str:\n        \"\"\"Get gerber code represented by this token.\"\"\"\n        return f\"{indent}{self.value}\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/helpers/gerber_code_enum.html#pygerber.gerberx3.tokenizer.helpers.gerber_code_enum.GerberCodeEnum.get_gerber_code","title":"get_gerber_code","text":"<pre><code>get_gerber_code(\n    indent: str = \"\", endline: str = \"\\n\"\n) -&gt; str\n</code></pre> <p>Get gerber code represented by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/helpers/gerber_code_enum.py</code> <pre><code>def get_gerber_code(\n    self,\n    indent: str = \"\",\n    endline: str = \"\\n\",  # noqa: ARG002\n) -&gt; str:\n    \"\"\"Get gerber code represented by this token.\"\"\"\n    return f\"{indent}{self.value}\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/__init__.html","title":"init","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/__init__.html#pygerber.gerberx3.tokenizer.tokens","title":"tokens","text":"<p>Gerber X3 token wrappers.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ab_block_aperture.html","title":"ab_block_aperture","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ab_block_aperture.html#pygerber.gerberx3.tokenizer.tokens.ab_block_aperture","title":"ab_block_aperture","text":"<p>Block Aperture (AB) logic.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ab_block_aperture.html#pygerber.gerberx3.tokenizer.tokens.ab_block_aperture.BlockApertureBegin","title":"BlockApertureBegin","text":"<p>             Bases: <code>CommandToken</code></p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ab_block_aperture.html#pygerber.gerberx3.tokenizer.tokens.ab_block_aperture.BlockApertureBegin--411-block-aperture-ab","title":"4.11 Block Aperture (AB).","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ab_block_aperture.html#pygerber.gerberx3.tokenizer.tokens.ab_block_aperture.BlockApertureBegin--4111-overview-of-block-apertures","title":"4.11.1 Overview of block apertures","text":"<p>The AB command creates a block aperture. The command stream between the opening and closing AB command defines a block aperture which is stored in the aperture dictionary. Thus the AB commands add an aperture to the dictionary directly, without needing an AD command. The LM, LR, LS and LP commands affect the flashes of block apertures as any other aperture: when a block aperture is flashed, it is first transformed according to the transformation parameters in the graphics state and then added to the object stream.</p> <p>The origin of the block aperture is the (0,0) point of the file.</p> <p>A block aperture is not a single graphical object but a set of objects. While a standard or macro aperture always adds a single graphical object to the stream, a block aperture can add any number of objects, each with their own polarity. Standard and macro apertures always have a single polarity while block apertures can contain both dark and clear objects.</p> <p>If the polarity is dark (LPD) when the block is flashed then the block aperture is inserted as is. If the polarity is clear (LPC) then the polarity of all objects in the block is toggled (clear becomes dark, and dark becomes clear). This toggle propagates through all nesting levels. In the following example the polarity of objects in the flash of block D12 will be toggled.</p> <pre><code>%ABD12*%\n\u2026\n%AB*%\n\u2026\nD12*\n%LPC*%\nX-2500000Y-1000000D03*\n</code></pre> <p>A D03 of a block aperture updates the current point but otherwise leaves the graphics state unmodified, as with any other aperture.</p> <p>See section 4.11 of The Gerber Layer Format Specification</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/ab_block_aperture.py</code> <pre><code>class BlockApertureBegin(CommandToken):\n    \"\"\"## 4.11 Block Aperture (AB).\n\n    ### 4.11.1 Overview of block apertures\n\n    The AB command creates a block aperture. The command stream between the opening and\n    closing AB command defines a block aperture which is stored in the aperture dictionary. Thus\n    the AB commands add an aperture to the dictionary directly, without needing an AD command.\n    The LM, LR, LS and LP commands affect the flashes of block apertures as any other aperture:\n    when a block aperture is flashed, it is first transformed according to the transformation\n    parameters in the graphics state and then added to the object stream.\n\n    The origin of the block aperture is the (0,0) point of the file.\n\n    A block aperture is not a single graphical object but a set of objects. While a standard or macro\n    aperture always adds a single graphical object to the stream, a block aperture can add any\n    number of objects, each with their own polarity. Standard and macro apertures always have a\n    single polarity while block apertures can contain both dark and clear objects.\n\n    If the polarity is dark (LPD) when the block is flashed then the block aperture is inserted as is. If\n    the polarity is clear (LPC) then the polarity of all objects in the block is toggled (clear becomes\n    dark, and dark becomes clear). This toggle propagates through all nesting levels. In the\n    following example the polarity of objects in the flash of block D12 will be toggled.\n\n    ```gerber\n    %ABD12*%\n    \u2026\n    %AB*%\n    \u2026\n    D12*\n    %LPC*%\n    X-2500000Y-1000000D03*\n    ```\n\n    A D03 of a block aperture updates the current point but otherwise leaves the graphics state\n    unmodified, as with any other aperture.\n\n    ---\n\n    See section 4.11 of [The Gerber Layer Format Specification](https://www.ucamco.com/files/downloads/file_en/456/gerber-layer-format-specification-revision-2023-08_en.pdf#page=111)\n\n    \"\"\"  # noqa: E501\n\n    def __init__(self, string: str, location: int, identifier: ApertureID) -&gt; None:\n        super().__init__(string, location)\n        self.identifier = identifier\n\n    @classmethod\n    def new(cls, string: str, location: int, tokens: ParseResults) -&gt; Self:\n        \"\"\"Create instance of this class.\n\n        Created to be used as callback in `ParserElement.set_parse_action()`.\n        \"\"\"\n        return cls(string, location, ApertureID(tokens[\"aperture_identifier\"]))\n\n    def update_drawing_state(\n        self,\n        state: State,\n        backend: Backend,\n    ) -&gt; Tuple[State, Iterable[DrawCommand]]:\n        \"\"\"Update drawing state.\"\"\"\n        handle = backend.create_aperture_handle(self.identifier)\n        with handle:\n            # Must be included to initialize drawing target.\n            pass\n        frozen_handle = handle.get_public_handle()\n\n        new_aperture_dict = {**state.apertures}\n        new_aperture_dict[self.identifier] = frozen_handle\n\n        return (\n            state.model_copy(\n                update={\n                    \"apertures\": new_aperture_dict,\n                },\n            ),\n            (),\n        )\n\n    def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n        \"\"\"Perform actions on the context implicated by this token.\"\"\"\n        context.get_hooks().begin_block_aperture.pre_parser_visit_token(self, context)\n        context.get_hooks().begin_block_aperture.on_parser_visit_token(self, context)\n        context.get_hooks().begin_block_aperture.post_parser_visit_token(self, context)\n\n    def get_gerber_code(\n        self,\n        indent: str = \"\",\n        endline: str = \"\\n\",  # noqa: ARG002\n    ) -&gt; str:\n        \"\"\"Get gerber code represented by this token.\"\"\"\n        return f\"{indent}AB{self.identifier.get_gerber_code()}\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ab_block_aperture.html#pygerber.gerberx3.tokenizer.tokens.ab_block_aperture.BlockApertureBegin.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(\n    string: str, location: int, tokens: ParseResults\n) -&gt; Self\n</code></pre> <p>Create instance of this class.</p> <p>Created to be used as callback in <code>ParserElement.set_parse_action()</code>.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/ab_block_aperture.py</code> <pre><code>@classmethod\ndef new(cls, string: str, location: int, tokens: ParseResults) -&gt; Self:\n    \"\"\"Create instance of this class.\n\n    Created to be used as callback in `ParserElement.set_parse_action()`.\n    \"\"\"\n    return cls(string, location, ApertureID(tokens[\"aperture_identifier\"]))\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ab_block_aperture.html#pygerber.gerberx3.tokenizer.tokens.ab_block_aperture.BlockApertureBegin.update_drawing_state","title":"update_drawing_state","text":"<pre><code>update_drawing_state(\n    state: State, backend: Backend\n) -&gt; Tuple[State, Iterable[DrawCommand]]\n</code></pre> <p>Update drawing state.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/ab_block_aperture.py</code> <pre><code>def update_drawing_state(\n    self,\n    state: State,\n    backend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n    \"\"\"Update drawing state.\"\"\"\n    handle = backend.create_aperture_handle(self.identifier)\n    with handle:\n        # Must be included to initialize drawing target.\n        pass\n    frozen_handle = handle.get_public_handle()\n\n    new_aperture_dict = {**state.apertures}\n    new_aperture_dict[self.identifier] = frozen_handle\n\n    return (\n        state.model_copy(\n            update={\n                \"apertures\": new_aperture_dict,\n            },\n        ),\n        (),\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ab_block_aperture.html#pygerber.gerberx3.tokenizer.tokens.ab_block_aperture.BlockApertureBegin.parser2_visit_token","title":"parser2_visit_token","text":"<pre><code>parser2_visit_token(context: Parser2Context) -&gt; None\n</code></pre> <p>Perform actions on the context implicated by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/ab_block_aperture.py</code> <pre><code>def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n    \"\"\"Perform actions on the context implicated by this token.\"\"\"\n    context.get_hooks().begin_block_aperture.pre_parser_visit_token(self, context)\n    context.get_hooks().begin_block_aperture.on_parser_visit_token(self, context)\n    context.get_hooks().begin_block_aperture.post_parser_visit_token(self, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ab_block_aperture.html#pygerber.gerberx3.tokenizer.tokens.ab_block_aperture.BlockApertureBegin.get_gerber_code","title":"get_gerber_code","text":"<pre><code>get_gerber_code(\n    indent: str = \"\", endline: str = \"\\n\"\n) -&gt; str\n</code></pre> <p>Get gerber code represented by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/ab_block_aperture.py</code> <pre><code>def get_gerber_code(\n    self,\n    indent: str = \"\",\n    endline: str = \"\\n\",  # noqa: ARG002\n) -&gt; str:\n    \"\"\"Get gerber code represented by this token.\"\"\"\n    return f\"{indent}AB{self.identifier.get_gerber_code()}\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ab_block_aperture.html#pygerber.gerberx3.tokenizer.tokens.ab_block_aperture.BlockApertureEnd","title":"BlockApertureEnd","text":"<p>             Bases: <code>CommandToken</code></p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ab_block_aperture.html#pygerber.gerberx3.tokenizer.tokens.ab_block_aperture.BlockApertureEnd--411-block-aperture-ab","title":"4.11 Block Aperture (AB).","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ab_block_aperture.html#pygerber.gerberx3.tokenizer.tokens.ab_block_aperture.BlockApertureEnd--4111-overview-of-block-apertures","title":"4.11.1 Overview of block apertures","text":"<p>The AB command creates a block aperture. The command stream between the opening and closing AB command defines a block aperture which is stored in the aperture dictionary. Thus the AB commands add an aperture to the dictionary directly, without needing an AD command. The LM, LR, LS and LP commands affect the flashes of block apertures as any other aperture: when a block aperture is flashed, it is first transformed according to the transformation parameters in the graphics state and then added to the object stream.</p> <p>The origin of the block aperture is the (0,0) point of the file.</p> <p>A block aperture is not a single graphical object but a set of objects. While a standard or macro aperture always adds a single graphical object to the stream, a block aperture can add any number of objects, each with their own polarity. Standard and macro apertures always have a single polarity while block apertures can contain both dark and clear objects.</p> <p>If the polarity is dark (LPD) when the block is flashed then the block aperture is inserted as is. If the polarity is clear (LPC) then the polarity of all objects in the block is toggled (clear becomes dark, and dark becomes clear). This toggle propagates through all nesting levels. In the following example the polarity of objects in the flash of block D12 will be toggled.</p> <pre><code>%ABD12*%\n\u2026\n%AB*%\n\u2026\nD12*\n%LPC*%\nX-2500000Y-1000000D03*\n</code></pre> <p>A D03 of a block aperture updates the current point but otherwise leaves the graphics state unmodified, as with any other aperture.</p> <p>See section 4.11 of The Gerber Layer Format Specification</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/ab_block_aperture.py</code> <pre><code>class BlockApertureEnd(CommandToken):\n    \"\"\"## 4.11 Block Aperture (AB).\n\n    ### 4.11.1 Overview of block apertures\n\n    The AB command creates a block aperture. The command stream between the opening and\n    closing AB command defines a block aperture which is stored in the aperture dictionary. Thus\n    the AB commands add an aperture to the dictionary directly, without needing an AD command.\n    The LM, LR, LS and LP commands affect the flashes of block apertures as any other aperture:\n    when a block aperture is flashed, it is first transformed according to the transformation\n    parameters in the graphics state and then added to the object stream.\n\n    The origin of the block aperture is the (0,0) point of the file.\n\n    A block aperture is not a single graphical object but a set of objects. While a standard or macro\n    aperture always adds a single graphical object to the stream, a block aperture can add any\n    number of objects, each with their own polarity. Standard and macro apertures always have a\n    single polarity while block apertures can contain both dark and clear objects.\n\n    If the polarity is dark (LPD) when the block is flashed then the block aperture is inserted as is. If\n    the polarity is clear (LPC) then the polarity of all objects in the block is toggled (clear becomes\n    dark, and dark becomes clear). This toggle propagates through all nesting levels. In the\n    following example the polarity of objects in the flash of block D12 will be toggled.\n\n    ```gerber\n    %ABD12*%\n    \u2026\n    %AB*%\n    \u2026\n    D12*\n    %LPC*%\n    X-2500000Y-1000000D03*\n    ```\n\n    A D03 of a block aperture updates the current point but otherwise leaves the graphics state\n    unmodified, as with any other aperture.\n\n    ---\n\n    See section 4.11 of [The Gerber Layer Format Specification](https://www.ucamco.com/files/downloads/file_en/456/gerber-layer-format-specification-revision-2023-08_en.pdf#page=111)\n\n    \"\"\"  # noqa: E501\n\n    def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n        \"\"\"Perform actions on the context implicated by this token.\"\"\"\n        context.get_hooks().end_block_aperture.pre_parser_visit_token(self, context)\n        context.get_hooks().end_block_aperture.on_parser_visit_token(self, context)\n        context.get_hooks().end_block_aperture.post_parser_visit_token(self, context)\n\n    def get_gerber_code(\n        self,\n        indent: str = \"\",\n        endline: str = \"\\n\",  # noqa: ARG002\n    ) -&gt; str:\n        \"\"\"Get gerber code represented by this token.\"\"\"\n        return f\"{indent}AB\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ab_block_aperture.html#pygerber.gerberx3.tokenizer.tokens.ab_block_aperture.BlockApertureEnd.parser2_visit_token","title":"parser2_visit_token","text":"<pre><code>parser2_visit_token(context: Parser2Context) -&gt; None\n</code></pre> <p>Perform actions on the context implicated by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/ab_block_aperture.py</code> <pre><code>def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n    \"\"\"Perform actions on the context implicated by this token.\"\"\"\n    context.get_hooks().end_block_aperture.pre_parser_visit_token(self, context)\n    context.get_hooks().end_block_aperture.on_parser_visit_token(self, context)\n    context.get_hooks().end_block_aperture.post_parser_visit_token(self, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ab_block_aperture.html#pygerber.gerberx3.tokenizer.tokens.ab_block_aperture.BlockApertureEnd.get_gerber_code","title":"get_gerber_code","text":"<pre><code>get_gerber_code(\n    indent: str = \"\", endline: str = \"\\n\"\n) -&gt; str\n</code></pre> <p>Get gerber code represented by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/ab_block_aperture.py</code> <pre><code>def get_gerber_code(\n    self,\n    indent: str = \"\",\n    endline: str = \"\\n\",  # noqa: ARG002\n) -&gt; str:\n    \"\"\"Get gerber code represented by this token.\"\"\"\n    return f\"{indent}AB\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.html","title":"ad_define_aperture","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.html#pygerber.gerberx3.tokenizer.tokens.ad_define_aperture","title":"ad_define_aperture","text":"<p>AD Command logic.</p> <p>Generally, apertures with size zero are invalid, and so are objects created with them. There is one exception. The C (circular) standard aperture with zero diameter is allowed, and so are objects created with it. Attributes can be attached to them. For the avoidance of doubt, zero size is only allowed for the C aperture, not another aperture type whose shape is fortuitously circular.</p> <p>Zero-size objects do not affect the image. They can be used to provide meta-information to locations in the image plane.</p> <p>Allowed does not mean recommended, quite the contrary. If you are tempted to use a zero-size object, consider whether it is useful, and whether there is no proper way to convey the meta information. Certainly do not abuse a zero-size object to indicate the absence of an object, e.g. by flashing a zero-size aperture to indicate the absence of a pad. This is just confusing. If there is nothing, put nothing.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.html#pygerber.gerberx3.tokenizer.tokens.ad_define_aperture.DefineAperture","title":"DefineAperture","text":"<p>             Bases: <code>ExtendedCommandToken</code></p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.html#pygerber.gerberx3.tokenizer.tokens.ad_define_aperture.DefineAperture--431-ad-command","title":"4.3.1 AD Command.","text":"<p>The AD command creates an aperture, attaches the aperture attributes at that moment in the attribute dictionary to it and adds it to the apertures dictionary.</p> <pre><code>AD = '%' ('AD' aperture_ident template_call) '*%';\ntemplate_call = template_name [',' parameter {'X' parameter}*];\n</code></pre> <p>The AD command must precede the first use of the aperture. It is recommended to put all AD commands in the file header.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.html#pygerber.gerberx3.tokenizer.tokens.ad_define_aperture.DefineAperture--example","title":"Example","text":"<pre><code>%ADD10C,.025*%\n%ADD10C,0.5X0.25*%\n</code></pre> <p>See section 4.3 of The Gerber Layer Format Specification</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.py</code> <pre><code>class DefineAperture(ExtendedCommandToken):\n    \"\"\"## 4.3.1 AD Command.\n\n    The AD command creates an aperture, attaches the aperture attributes at that moment in the\n    attribute dictionary to it and adds it to the apertures dictionary.\n\n    ```ebnf\n    AD = '%' ('AD' aperture_ident template_call) '*%';\n    template_call = template_name [',' parameter {'X' parameter}*];\n    ```\n\n    The AD command must precede the first use of the aperture. It is recommended to put all AD\n    commands in the file header.\n\n    ---\n\n    ## Example\n\n    ```gerber\n    %ADD10C,.025*%\n    %ADD10C,0.5X0.25*%\n    ```\n\n    ---\n\n    See section 4.3 of [The Gerber Layer Format Specification](https://www.ucamco.com/files/downloads/file_en/456/gerber-layer-format-specification-revision-2023-08_en.pdf#page=48)\n\n    \"\"\"  # noqa: E501\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.html#pygerber.gerberx3.tokenizer.tokens.ad_define_aperture.DefineCircle","title":"DefineCircle","text":"<p>             Bases: <code>DefineAperture</code></p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.html#pygerber.gerberx3.tokenizer.tokens.ad_define_aperture.DefineCircle--431-ad-command","title":"4.3.1 AD Command.","text":"<p>The AD command creates an aperture, attaches the aperture attributes at that moment in the attribute dictionary to it and adds it to the apertures dictionary.</p> <pre><code>AD = '%' ('AD' aperture_ident template_call) '*%';\ntemplate_call = template_name [',' parameter {'X' parameter}*];\n</code></pre> <p>The AD command must precede the first use of the aperture. It is recommended to put all AD commands in the file header.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.html#pygerber.gerberx3.tokenizer.tokens.ad_define_aperture.DefineCircle--example","title":"Example","text":"<pre><code>%ADD10C,.025*%\n%ADD10C,0.5X0.25*%\n</code></pre> <p>See section 4.3 of The Gerber Layer Format Specification</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.html#pygerber.gerberx3.tokenizer.tokens.ad_define_aperture.DefineCircle--442-circle","title":"4.4.2 Circle","text":"<p>The syntax of the circle standard template call is:</p> <pre><code>template_call = 'C' ',' diameter 'X' hole_diameter\n</code></pre> <ul> <li><code>C</code> - Indicates the circle aperture template.</li> <li><code>diameter</code> - Diameter. A decimal \u22650.</li> <li><code>hole_diameter</code> - Diameter of a round hole. A decimal &gt;0. If omitted the aperture is solid. See also section 4.4.6.</li> </ul> <p>See section 4.4.2 of The Gerber Layer Format Specification</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.py</code> <pre><code>class DefineCircle(DefineAperture):\n    \"\"\"## 4.3.1 AD Command.\n\n    The AD command creates an aperture, attaches the aperture attributes at that moment in the\n    attribute dictionary to it and adds it to the apertures dictionary.\n\n    ```ebnf\n    AD = '%' ('AD' aperture_ident template_call) '*%';\n    template_call = template_name [',' parameter {'X' parameter}*];\n    ```\n\n    The AD command must precede the first use of the aperture. It is recommended to put all AD\n    commands in the file header.\n\n    ---\n\n    ## Example\n\n    ```gerber\n    %ADD10C,.025*%\n    %ADD10C,0.5X0.25*%\n    ```\n\n    ---\n\n    See section 4.3 of [The Gerber Layer Format Specification](https://www.ucamco.com/files/downloads/file_en/456/gerber-layer-format-specification-revision-2023-08_en.pdf#page=48)\n\n    ---\n\n    ## 4.4.2 Circle\n\n    The syntax of the circle standard template call is:\n\n    ```ebnf\n    template_call = 'C' ',' diameter 'X' hole_diameter\n    ```\n\n    - `C` - Indicates the circle aperture template.\n    - `diameter` - Diameter. A decimal \u22650.\n    - `hole_diameter` - Diameter of a round hole. A decimal &gt;0. If omitted the aperture is solid. See also section [4.4.6](https://www.ucamco.com/files/downloads/file_en/456/gerber-layer-format-specification-revision-2023-08_en.pdf#page=55).\n\n    ---\n\n    See section 4.4.2 of [The Gerber Layer Format Specification](https://www.ucamco.com/files/downloads/file_en/456/gerber-layer-format-specification-revision-2023-08_en.pdf#page=50)\n\n    \"\"\"  # noqa: E501\n\n    def __init__(\n        self,\n        string: str,\n        location: int,\n        aperture_id: ApertureID,\n        diameter: Decimal,\n        hole_diameter: Optional[Decimal],\n    ) -&gt; None:\n        super().__init__(string, location)\n        self.aperture_id = aperture_id\n        self.diameter = diameter\n        self.hole_diameter = hole_diameter\n\n    @classmethod\n    def new(cls, string: str, location: int, tokens: ParseResults) -&gt; Self:\n        \"\"\"Create instance of this class.\n\n        Created to be used as callback in `ParserElement.set_parse_action()`.\n        \"\"\"\n        aperture_id = ApertureID(tokens[\"aperture_identifier\"])\n        diameter: Decimal = Decimal(str(tokens[\"diameter\"]))\n        hole_diameter: Optional[Decimal] = (\n            Decimal(str(tokens[\"hole_diameter\"]))\n            if tokens.get(\"hole_diameter\") is not None\n            else None\n        )\n        return cls(\n            string=string,\n            location=location,\n            aperture_id=aperture_id,\n            diameter=diameter,\n            hole_diameter=hole_diameter,\n        )\n\n    def update_drawing_state(\n        self,\n        state: State,\n        backend: Backend,\n    ) -&gt; Tuple[State, Iterable[DrawCommand]]:\n        \"\"\"Update drawing state.\"\"\"\n        handle = backend.create_aperture_handle(self.aperture_id)\n        with handle:\n            handle.add_draw(\n                backend.get_draw_circle_cls()(\n                    backend=backend,\n                    diameter=Offset.new(self.diameter, state.get_units()),\n                    polarity=Polarity.Dark,\n                    center_position=Vector2D(x=Offset.NULL, y=Offset.NULL),\n                ),\n            )\n            if self.hole_diameter is not None:\n                handle.add_draw(\n                    backend.get_draw_circle_cls()(\n                        backend=backend,\n                        diameter=Offset.new(self.hole_diameter, state.get_units()),\n                        polarity=Polarity.Clear,\n                        center_position=Vector2D(x=Offset.NULL, y=Offset.NULL),\n                    ),\n                )\n        frozen_handle = handle.get_public_handle()\n\n        new_aperture_dict = {**state.apertures}\n        new_aperture_dict[self.aperture_id] = frozen_handle\n\n        return (\n            state.model_copy(\n                update={\n                    \"apertures\": new_aperture_dict,\n                },\n            ),\n            (),\n        )\n\n    def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n        \"\"\"Perform actions on the context implicated by this token.\"\"\"\n        context.get_hooks().define_circle_aperture.pre_parser_visit_token(self, context)\n        context.get_hooks().define_aperture.pre_parser_visit_token(self, context)\n\n        context.get_hooks().define_circle_aperture.on_parser_visit_token(self, context)\n        context.get_hooks().define_aperture.on_parser_visit_token(self, context)\n\n        context.get_hooks().define_circle_aperture.post_parser_visit_token(\n            self,\n            context,\n        )\n        context.get_hooks().define_aperture.post_parser_visit_token(self, context)\n\n    def get_gerber_code(\n        self,\n        indent: str = \"\",\n        endline: str = \"\\n\",\n    ) -&gt; str:\n        \"\"\"Get gerber code represented by this token.\"\"\"\n        suffix = \"\"\n        if self.hole_diameter is not None:\n            suffix += f\"X{self.hole_diameter}\"\n        return (\n            f\"AD{self.aperture_id.get_gerber_code(indent, endline)}C,\"\n            f\"{self.diameter}{suffix}\"\n        )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.html#pygerber.gerberx3.tokenizer.tokens.ad_define_aperture.DefineCircle.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(\n    string: str, location: int, tokens: ParseResults\n) -&gt; Self\n</code></pre> <p>Create instance of this class.</p> <p>Created to be used as callback in <code>ParserElement.set_parse_action()</code>.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.py</code> <pre><code>@classmethod\ndef new(cls, string: str, location: int, tokens: ParseResults) -&gt; Self:\n    \"\"\"Create instance of this class.\n\n    Created to be used as callback in `ParserElement.set_parse_action()`.\n    \"\"\"\n    aperture_id = ApertureID(tokens[\"aperture_identifier\"])\n    diameter: Decimal = Decimal(str(tokens[\"diameter\"]))\n    hole_diameter: Optional[Decimal] = (\n        Decimal(str(tokens[\"hole_diameter\"]))\n        if tokens.get(\"hole_diameter\") is not None\n        else None\n    )\n    return cls(\n        string=string,\n        location=location,\n        aperture_id=aperture_id,\n        diameter=diameter,\n        hole_diameter=hole_diameter,\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.html#pygerber.gerberx3.tokenizer.tokens.ad_define_aperture.DefineCircle.update_drawing_state","title":"update_drawing_state","text":"<pre><code>update_drawing_state(\n    state: State, backend: Backend\n) -&gt; Tuple[State, Iterable[DrawCommand]]\n</code></pre> <p>Update drawing state.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.py</code> <pre><code>def update_drawing_state(\n    self,\n    state: State,\n    backend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n    \"\"\"Update drawing state.\"\"\"\n    handle = backend.create_aperture_handle(self.aperture_id)\n    with handle:\n        handle.add_draw(\n            backend.get_draw_circle_cls()(\n                backend=backend,\n                diameter=Offset.new(self.diameter, state.get_units()),\n                polarity=Polarity.Dark,\n                center_position=Vector2D(x=Offset.NULL, y=Offset.NULL),\n            ),\n        )\n        if self.hole_diameter is not None:\n            handle.add_draw(\n                backend.get_draw_circle_cls()(\n                    backend=backend,\n                    diameter=Offset.new(self.hole_diameter, state.get_units()),\n                    polarity=Polarity.Clear,\n                    center_position=Vector2D(x=Offset.NULL, y=Offset.NULL),\n                ),\n            )\n    frozen_handle = handle.get_public_handle()\n\n    new_aperture_dict = {**state.apertures}\n    new_aperture_dict[self.aperture_id] = frozen_handle\n\n    return (\n        state.model_copy(\n            update={\n                \"apertures\": new_aperture_dict,\n            },\n        ),\n        (),\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.html#pygerber.gerberx3.tokenizer.tokens.ad_define_aperture.DefineCircle.parser2_visit_token","title":"parser2_visit_token","text":"<pre><code>parser2_visit_token(context: Parser2Context) -&gt; None\n</code></pre> <p>Perform actions on the context implicated by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.py</code> <pre><code>def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n    \"\"\"Perform actions on the context implicated by this token.\"\"\"\n    context.get_hooks().define_circle_aperture.pre_parser_visit_token(self, context)\n    context.get_hooks().define_aperture.pre_parser_visit_token(self, context)\n\n    context.get_hooks().define_circle_aperture.on_parser_visit_token(self, context)\n    context.get_hooks().define_aperture.on_parser_visit_token(self, context)\n\n    context.get_hooks().define_circle_aperture.post_parser_visit_token(\n        self,\n        context,\n    )\n    context.get_hooks().define_aperture.post_parser_visit_token(self, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.html#pygerber.gerberx3.tokenizer.tokens.ad_define_aperture.DefineCircle.get_gerber_code","title":"get_gerber_code","text":"<pre><code>get_gerber_code(\n    indent: str = \"\", endline: str = \"\\n\"\n) -&gt; str\n</code></pre> <p>Get gerber code represented by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.py</code> <pre><code>def get_gerber_code(\n    self,\n    indent: str = \"\",\n    endline: str = \"\\n\",\n) -&gt; str:\n    \"\"\"Get gerber code represented by this token.\"\"\"\n    suffix = \"\"\n    if self.hole_diameter is not None:\n        suffix += f\"X{self.hole_diameter}\"\n    return (\n        f\"AD{self.aperture_id.get_gerber_code(indent, endline)}C,\"\n        f\"{self.diameter}{suffix}\"\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.html#pygerber.gerberx3.tokenizer.tokens.ad_define_aperture.DefineRectangle","title":"DefineRectangle","text":"<p>             Bases: <code>DefineAperture</code></p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.html#pygerber.gerberx3.tokenizer.tokens.ad_define_aperture.DefineRectangle--431-ad-command","title":"4.3.1 AD Command.","text":"<p>The AD command creates an aperture, attaches the aperture attributes at that moment in the attribute dictionary to it and adds it to the apertures dictionary.</p> <pre><code>AD = '%' ('AD' aperture_ident template_call) '*%';\ntemplate_call = template_name [',' parameter {'X' parameter}*];\n</code></pre> <p>The AD command must precede the first use of the aperture. It is recommended to put all AD commands in the file header.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.html#pygerber.gerberx3.tokenizer.tokens.ad_define_aperture.DefineRectangle--example","title":"Example:","text":"<pre><code>%ADD22R,0.044X0.025*%\n%ADD23R,0.044X0.025X0.019*%\n</code></pre> <p>See section 4.3 of The Gerber Layer Format Specification</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.html#pygerber.gerberx3.tokenizer.tokens.ad_define_aperture.DefineRectangle--443-rectangle","title":"4.4.3 Rectangle","text":"<p>The syntax of the rectangle or square standard template call is:</p> <pre><code>template_call = 'R' ',' x_size 'X' y_size 'X' hole_diameter\n</code></pre> <ul> <li><code>T</code> - Indicates the rectangle aperture template.</li> <li><code>x_size</code>, <code>x_size</code> - X and Y sizes of the rectangle. Decimals &gt;0. If x_size = y_size the effective shape is a square</li> <li><code>hole_diameter</code> - Diameter of a round hole. A decimal &gt;0. If omitted the aperture is solid. See also section 4.4.6.</li> </ul> <p>See section 4.4.3 of The Gerber Layer Format Specification</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.py</code> <pre><code>class DefineRectangle(DefineAperture):\n    \"\"\"## 4.3.1 AD Command.\n\n    The AD command creates an aperture, attaches the aperture attributes at that moment in the\n    attribute dictionary to it and adds it to the apertures dictionary.\n\n    ```ebnf\n    AD = '%' ('AD' aperture_ident template_call) '*%';\n    template_call = template_name [',' parameter {'X' parameter}*];\n    ```\n\n    The AD command must precede the first use of the aperture. It is recommended to put all AD\n    commands in the file header.\n\n    ---\n\n    ### Example:\n\n    ```gerber\n    %ADD22R,0.044X0.025*%\n    %ADD23R,0.044X0.025X0.019*%\n    ```\n\n    ---\n\n    See section 4.3 of [The Gerber Layer Format Specification](https://www.ucamco.com/files/downloads/file_en/456/gerber-layer-format-specification-revision-2023-08_en.pdf#page=48)\n\n    ---\n\n    ## 4.4.3 Rectangle\n\n    The syntax of the rectangle or square standard template call is:\n\n    ```ebnf\n    template_call = 'R' ',' x_size 'X' y_size 'X' hole_diameter\n    ```\n\n    - `T` - Indicates the rectangle aperture template.\n    - `x_size`, `x_size` - X and Y sizes of the rectangle. Decimals &gt;0. If x_size = y_size the effective shape is a square\n    - `hole_diameter` - Diameter of a round hole. A decimal &gt;0. If omitted the aperture is solid. See also section [4.4.6](https://www.ucamco.com/files/downloads/file_en/456/gerber-layer-format-specification-revision-2023-08_en.pdf#page=55).\n\n    ---\n\n    See section 4.4.3 of [The Gerber Layer Format Specification](https://www.ucamco.com/files/downloads/file_en/456/gerber-layer-format-specification-revision-2023-08_en.pdf#page=52)\n\n    \"\"\"  # noqa: E501\n\n    def __init__(\n        self,\n        string: str,\n        location: int,\n        aperture_id: ApertureID,\n        x_size: Decimal,\n        y_size: Decimal,\n        hole_diameter: Optional[Decimal],\n    ) -&gt; None:\n        super().__init__(string, location)\n        self.aperture_id = aperture_id\n        self.x_size = x_size\n        self.y_size = y_size\n        self.hole_diameter = hole_diameter\n\n    @classmethod\n    def new(cls, string: str, location: int, tokens: ParseResults) -&gt; Self:\n        \"\"\"Create instance of this class.\n\n        Created to be used as callback in `ParserElement.set_parse_action()`.\n        \"\"\"\n        aperture_id = ApertureID(tokens[\"aperture_identifier\"])\n        x_size: Decimal = Decimal(str(tokens[\"x_size\"]))\n        y_size: Decimal = Decimal(str(tokens[\"y_size\"]))\n        hole_diameter: Optional[Decimal] = (\n            Decimal(str(tokens[\"hole_diameter\"]))\n            if tokens.get(\"hole_diameter\") is not None\n            else None\n        )\n        return cls(\n            string=string,\n            location=location,\n            aperture_id=aperture_id,\n            x_size=x_size,\n            y_size=y_size,\n            hole_diameter=hole_diameter,\n        )\n\n    def update_drawing_state(\n        self,\n        state: State,\n        backend: Backend,\n    ) -&gt; Tuple[State, Iterable[DrawCommand]]:\n        \"\"\"Update drawing state.\"\"\"\n        handle = backend.create_aperture_handle(self.aperture_id)\n        with handle:\n            handle.add_draw(\n                backend.get_draw_rectangle_cls()(\n                    backend=backend,\n                    x_size=Offset.new(self.x_size, state.get_units()),\n                    y_size=Offset.new(self.y_size, state.get_units()),\n                    polarity=Polarity.Dark,\n                    center_position=Vector2D(x=Offset.NULL, y=Offset.NULL),\n                ),\n            )\n            if self.hole_diameter is not None:\n                handle.add_draw(\n                    backend.get_draw_circle_cls()(\n                        backend=backend,\n                        diameter=Offset.new(self.hole_diameter, state.get_units()),\n                        polarity=Polarity.Clear,\n                        center_position=Vector2D(x=Offset.NULL, y=Offset.NULL),\n                    ),\n                )\n        frozen_handle = handle.get_public_handle()\n\n        new_aperture_dict = {**state.apertures}\n        new_aperture_dict[self.aperture_id] = frozen_handle\n\n        return (\n            state.model_copy(\n                update={\n                    \"apertures\": new_aperture_dict,\n                },\n            ),\n            (),\n        )\n\n    def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n        \"\"\"Perform actions on the context implicated by this token.\"\"\"\n        context.get_hooks().define_rectangle_aperture.pre_parser_visit_token(\n            self,\n            context,\n        )\n        context.get_hooks().define_aperture.pre_parser_visit_token(self, context)\n\n        context.get_hooks().define_rectangle_aperture.on_parser_visit_token(\n            self,\n            context,\n        )\n        context.get_hooks().define_aperture.on_parser_visit_token(self, context)\n\n        context.get_hooks().define_rectangle_aperture.post_parser_visit_token(\n            self,\n            context,\n        )\n        context.get_hooks().define_aperture.post_parser_visit_token(self, context)\n\n    def get_gerber_code(\n        self,\n        indent: str = \"\",\n        endline: str = \"\\n\",\n    ) -&gt; str:\n        \"\"\"Get gerber code represented by this token.\"\"\"\n        suffix = \"\"\n        if self.hole_diameter is not None:\n            suffix += f\"X{self.hole_diameter}\"\n        return (\n            f\"AD{self.aperture_id.get_gerber_code(indent, endline)}R,\"\n            f\"{self.x_size}X{self.y_size}{suffix}\"\n        )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.html#pygerber.gerberx3.tokenizer.tokens.ad_define_aperture.DefineRectangle.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(\n    string: str, location: int, tokens: ParseResults\n) -&gt; Self\n</code></pre> <p>Create instance of this class.</p> <p>Created to be used as callback in <code>ParserElement.set_parse_action()</code>.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.py</code> <pre><code>@classmethod\ndef new(cls, string: str, location: int, tokens: ParseResults) -&gt; Self:\n    \"\"\"Create instance of this class.\n\n    Created to be used as callback in `ParserElement.set_parse_action()`.\n    \"\"\"\n    aperture_id = ApertureID(tokens[\"aperture_identifier\"])\n    x_size: Decimal = Decimal(str(tokens[\"x_size\"]))\n    y_size: Decimal = Decimal(str(tokens[\"y_size\"]))\n    hole_diameter: Optional[Decimal] = (\n        Decimal(str(tokens[\"hole_diameter\"]))\n        if tokens.get(\"hole_diameter\") is not None\n        else None\n    )\n    return cls(\n        string=string,\n        location=location,\n        aperture_id=aperture_id,\n        x_size=x_size,\n        y_size=y_size,\n        hole_diameter=hole_diameter,\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.html#pygerber.gerberx3.tokenizer.tokens.ad_define_aperture.DefineRectangle.update_drawing_state","title":"update_drawing_state","text":"<pre><code>update_drawing_state(\n    state: State, backend: Backend\n) -&gt; Tuple[State, Iterable[DrawCommand]]\n</code></pre> <p>Update drawing state.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.py</code> <pre><code>def update_drawing_state(\n    self,\n    state: State,\n    backend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n    \"\"\"Update drawing state.\"\"\"\n    handle = backend.create_aperture_handle(self.aperture_id)\n    with handle:\n        handle.add_draw(\n            backend.get_draw_rectangle_cls()(\n                backend=backend,\n                x_size=Offset.new(self.x_size, state.get_units()),\n                y_size=Offset.new(self.y_size, state.get_units()),\n                polarity=Polarity.Dark,\n                center_position=Vector2D(x=Offset.NULL, y=Offset.NULL),\n            ),\n        )\n        if self.hole_diameter is not None:\n            handle.add_draw(\n                backend.get_draw_circle_cls()(\n                    backend=backend,\n                    diameter=Offset.new(self.hole_diameter, state.get_units()),\n                    polarity=Polarity.Clear,\n                    center_position=Vector2D(x=Offset.NULL, y=Offset.NULL),\n                ),\n            )\n    frozen_handle = handle.get_public_handle()\n\n    new_aperture_dict = {**state.apertures}\n    new_aperture_dict[self.aperture_id] = frozen_handle\n\n    return (\n        state.model_copy(\n            update={\n                \"apertures\": new_aperture_dict,\n            },\n        ),\n        (),\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.html#pygerber.gerberx3.tokenizer.tokens.ad_define_aperture.DefineRectangle.parser2_visit_token","title":"parser2_visit_token","text":"<pre><code>parser2_visit_token(context: Parser2Context) -&gt; None\n</code></pre> <p>Perform actions on the context implicated by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.py</code> <pre><code>def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n    \"\"\"Perform actions on the context implicated by this token.\"\"\"\n    context.get_hooks().define_rectangle_aperture.pre_parser_visit_token(\n        self,\n        context,\n    )\n    context.get_hooks().define_aperture.pre_parser_visit_token(self, context)\n\n    context.get_hooks().define_rectangle_aperture.on_parser_visit_token(\n        self,\n        context,\n    )\n    context.get_hooks().define_aperture.on_parser_visit_token(self, context)\n\n    context.get_hooks().define_rectangle_aperture.post_parser_visit_token(\n        self,\n        context,\n    )\n    context.get_hooks().define_aperture.post_parser_visit_token(self, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.html#pygerber.gerberx3.tokenizer.tokens.ad_define_aperture.DefineRectangle.get_gerber_code","title":"get_gerber_code","text":"<pre><code>get_gerber_code(\n    indent: str = \"\", endline: str = \"\\n\"\n) -&gt; str\n</code></pre> <p>Get gerber code represented by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.py</code> <pre><code>def get_gerber_code(\n    self,\n    indent: str = \"\",\n    endline: str = \"\\n\",\n) -&gt; str:\n    \"\"\"Get gerber code represented by this token.\"\"\"\n    suffix = \"\"\n    if self.hole_diameter is not None:\n        suffix += f\"X{self.hole_diameter}\"\n    return (\n        f\"AD{self.aperture_id.get_gerber_code(indent, endline)}R,\"\n        f\"{self.x_size}X{self.y_size}{suffix}\"\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.html#pygerber.gerberx3.tokenizer.tokens.ad_define_aperture.DefineObround","title":"DefineObround","text":"<p>             Bases: <code>DefineAperture</code></p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.html#pygerber.gerberx3.tokenizer.tokens.ad_define_aperture.DefineObround--431-ad-command","title":"4.3.1 AD Command.","text":"<p>The AD command creates an aperture, attaches the aperture attributes at that moment in the attribute dictionary to it and adds it to the apertures dictionary.</p> <pre><code>AD = '%' ('AD' aperture_ident template_call) '*%';\ntemplate_call = template_name [',' parameter {'X' parameter}*];\n</code></pre> <p>The AD command must precede the first use of the aperture. It is recommended to put all AD commands in the file header.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.html#pygerber.gerberx3.tokenizer.tokens.ad_define_aperture.DefineObround--example","title":"Example:","text":"<pre><code>%ADD22O,0.046X0.026*%\n%ADD22O,0.046X0.026X0.019*%\n</code></pre> <p>See section 4.3 of The Gerber Layer Format Specification</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.html#pygerber.gerberx3.tokenizer.tokens.ad_define_aperture.DefineObround--444-obround","title":"4.4.4 Obround","text":"<p>Obround (oval) is a rectangle where the smallest side is rounded to a half-circle. The syntax is:</p> <pre><code>template_call = 'O' ',' x_size 'X' y_size 'X' hole_diameter\n</code></pre> <ul> <li><code>O</code> - Indicates the obround aperture template.</li> <li><code>x_size</code>, <code>x_size</code> - X and Y sizes of enclosing box. Decimals &gt;0. If x_size = y_size the effective shape is a circle.</li> <li><code>hole_diameter</code> - Diameter of a round hole. A decimal &gt;0. If omitted the aperture is solid. See also section 4.4.6.</li> </ul> <p>See section 4.4.4 of The Gerber Layer Format Specification</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.py</code> <pre><code>class DefineObround(DefineAperture):\n    \"\"\"## 4.3.1 AD Command.\n\n    The AD command creates an aperture, attaches the aperture attributes at that moment in the\n    attribute dictionary to it and adds it to the apertures dictionary.\n\n    ```ebnf\n    AD = '%' ('AD' aperture_ident template_call) '*%';\n    template_call = template_name [',' parameter {'X' parameter}*];\n    ```\n\n    The AD command must precede the first use of the aperture. It is recommended to put all AD\n    commands in the file header.\n\n    ---\n\n    ### Example:\n\n    ```gerber\n    %ADD22O,0.046X0.026*%\n    %ADD22O,0.046X0.026X0.019*%\n    ```\n\n    ---\n\n    See section 4.3 of [The Gerber Layer Format Specification](https://www.ucamco.com/files/downloads/file_en/456/gerber-layer-format-specification-revision-2023-08_en.pdf#page=48)\n\n    ---\n\n    ## 4.4.4 Obround\n\n    Obround (oval) is a rectangle where the smallest side is rounded to a half-circle. The syntax is:\n\n    ```ebnf\n    template_call = 'O' ',' x_size 'X' y_size 'X' hole_diameter\n    ```\n\n    - `O` - Indicates the obround aperture template.\n    - `x_size`, `x_size` - X and Y sizes of enclosing box. Decimals &gt;0. If x_size = y_size the effective shape is a circle.\n    - `hole_diameter` - Diameter of a round hole. A decimal &gt;0. If omitted the aperture is solid. See also section [4.4.6](https://www.ucamco.com/files/downloads/file_en/456/gerber-layer-format-specification-revision-2023-08_en.pdf#page=55).\n\n    ---\n\n    See section 4.4.4 of [The Gerber Layer Format Specification](https://www.ucamco.com/files/downloads/file_en/456/gerber-layer-format-specification-revision-2023-08_en.pdf#page=53)\n\n    \"\"\"  # noqa: E501\n\n    def __init__(\n        self,\n        string: str,\n        location: int,\n        aperture_id: ApertureID,\n        x_size: Decimal,\n        y_size: Decimal,\n        hole_diameter: Optional[Decimal],\n    ) -&gt; None:\n        super().__init__(string, location)\n        self.aperture_id = aperture_id\n        self.x_size = x_size\n        self.y_size = y_size\n        self.hole_diameter = hole_diameter\n\n    @classmethod\n    def new(cls, string: str, location: int, tokens: ParseResults) -&gt; Self:\n        \"\"\"Create instance of this class.\n\n        Created to be used as callback in `ParserElement.set_parse_action()`.\n        \"\"\"\n        aperture_id = ApertureID(tokens[\"aperture_identifier\"])\n        x_size: Decimal = Decimal(str(tokens[\"x_size\"]))\n        y_size: Decimal = Decimal(str(tokens[\"y_size\"]))\n        hole_diameter: Optional[Decimal] = (\n            Decimal(str(tokens[\"hole_diameter\"]))\n            if tokens.get(\"hole_diameter\") is not None\n            else None\n        )\n        return cls(\n            string=string,\n            location=location,\n            aperture_id=aperture_id,\n            x_size=x_size,\n            y_size=y_size,\n            hole_diameter=hole_diameter,\n        )\n\n    def update_drawing_state(\n        self,\n        state: State,\n        backend: Backend,\n    ) -&gt; Tuple[State, Iterable[DrawCommand]]:\n        \"\"\"Update drawing state.\"\"\"\n        handle = backend.create_aperture_handle(self.aperture_id)\n\n        x_size = Offset.new(self.x_size, state.get_units())\n        y_size = Offset.new(self.y_size, state.get_units())\n\n        if self.x_size &lt; self.y_size:\n            # Obround is thin and tall.\n            circle_diameter = x_size\n\n            middle_rectangle_x = x_size\n            middle_rectangle_y = y_size - x_size\n\n            circle_positive = Vector2D(x=Offset.NULL, y=middle_rectangle_y / 2)\n            circle_negative = Vector2D(x=Offset.NULL, y=-middle_rectangle_y / 2)\n\n        else:\n            # Obround is wide and short.\n            circle_diameter = y_size\n\n            middle_rectangle_x = x_size - y_size\n            middle_rectangle_y = y_size\n\n            circle_positive = Vector2D(x=middle_rectangle_x / 2, y=Offset.NULL)\n            circle_negative = Vector2D(x=-middle_rectangle_x / 2, y=Offset.NULL)\n\n        with handle:\n            handle.add_draw(\n                backend.get_draw_rectangle_cls()(\n                    backend=backend,\n                    x_size=middle_rectangle_x,\n                    y_size=middle_rectangle_y,\n                    polarity=Polarity.Dark,\n                    center_position=Vector2D(x=Offset.NULL, y=Offset.NULL),\n                ),\n            )\n            handle.add_draw(\n                backend.get_draw_circle_cls()(\n                    backend=backend,\n                    diameter=circle_diameter,\n                    polarity=Polarity.Dark,\n                    center_position=circle_positive,\n                ),\n            )\n            handle.add_draw(\n                backend.get_draw_circle_cls()(\n                    backend=backend,\n                    diameter=circle_diameter,\n                    polarity=Polarity.Dark,\n                    center_position=circle_negative,\n                ),\n            )\n            if self.hole_diameter is not None:\n                handle.add_draw(\n                    backend.get_draw_circle_cls()(\n                        backend=backend,\n                        diameter=Offset.new(self.hole_diameter, state.get_units()),\n                        polarity=Polarity.Clear,\n                        center_position=Vector2D(x=Offset.NULL, y=Offset.NULL),\n                    ),\n                )\n        frozen_handle = handle.get_public_handle()\n\n        new_aperture_dict = {**state.apertures}\n        new_aperture_dict[self.aperture_id] = frozen_handle\n\n        return (\n            state.model_copy(\n                update={\n                    \"apertures\": new_aperture_dict,\n                },\n            ),\n            (),\n        )\n\n    def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n        \"\"\"Perform actions on the context implicated by this token.\"\"\"\n        context.get_hooks().define_obround_aperture.pre_parser_visit_token(\n            self,\n            context,\n        )\n        context.get_hooks().define_aperture.pre_parser_visit_token(self, context)\n\n        context.get_hooks().define_obround_aperture.on_parser_visit_token(self, context)\n        context.get_hooks().define_aperture.on_parser_visit_token(self, context)\n\n        context.get_hooks().define_obround_aperture.post_parser_visit_token(\n            self,\n            context,\n        )\n        context.get_hooks().define_aperture.post_parser_visit_token(self, context)\n\n    def get_gerber_code(\n        self,\n        indent: str = \"\",\n        endline: str = \"\\n\",\n    ) -&gt; str:\n        \"\"\"Get gerber code represented by this token.\"\"\"\n        suffix = \"\"\n        if self.hole_diameter is not None:\n            suffix += f\"X{self.hole_diameter}\"\n        return (\n            f\"AD{self.aperture_id.get_gerber_code(indent, endline)}O,\"\n            f\"{self.x_size}X{self.y_size}{suffix}\"\n        )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.html#pygerber.gerberx3.tokenizer.tokens.ad_define_aperture.DefineObround.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(\n    string: str, location: int, tokens: ParseResults\n) -&gt; Self\n</code></pre> <p>Create instance of this class.</p> <p>Created to be used as callback in <code>ParserElement.set_parse_action()</code>.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.py</code> <pre><code>@classmethod\ndef new(cls, string: str, location: int, tokens: ParseResults) -&gt; Self:\n    \"\"\"Create instance of this class.\n\n    Created to be used as callback in `ParserElement.set_parse_action()`.\n    \"\"\"\n    aperture_id = ApertureID(tokens[\"aperture_identifier\"])\n    x_size: Decimal = Decimal(str(tokens[\"x_size\"]))\n    y_size: Decimal = Decimal(str(tokens[\"y_size\"]))\n    hole_diameter: Optional[Decimal] = (\n        Decimal(str(tokens[\"hole_diameter\"]))\n        if tokens.get(\"hole_diameter\") is not None\n        else None\n    )\n    return cls(\n        string=string,\n        location=location,\n        aperture_id=aperture_id,\n        x_size=x_size,\n        y_size=y_size,\n        hole_diameter=hole_diameter,\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.html#pygerber.gerberx3.tokenizer.tokens.ad_define_aperture.DefineObround.update_drawing_state","title":"update_drawing_state","text":"<pre><code>update_drawing_state(\n    state: State, backend: Backend\n) -&gt; Tuple[State, Iterable[DrawCommand]]\n</code></pre> <p>Update drawing state.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.py</code> <pre><code>def update_drawing_state(\n    self,\n    state: State,\n    backend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n    \"\"\"Update drawing state.\"\"\"\n    handle = backend.create_aperture_handle(self.aperture_id)\n\n    x_size = Offset.new(self.x_size, state.get_units())\n    y_size = Offset.new(self.y_size, state.get_units())\n\n    if self.x_size &lt; self.y_size:\n        # Obround is thin and tall.\n        circle_diameter = x_size\n\n        middle_rectangle_x = x_size\n        middle_rectangle_y = y_size - x_size\n\n        circle_positive = Vector2D(x=Offset.NULL, y=middle_rectangle_y / 2)\n        circle_negative = Vector2D(x=Offset.NULL, y=-middle_rectangle_y / 2)\n\n    else:\n        # Obround is wide and short.\n        circle_diameter = y_size\n\n        middle_rectangle_x = x_size - y_size\n        middle_rectangle_y = y_size\n\n        circle_positive = Vector2D(x=middle_rectangle_x / 2, y=Offset.NULL)\n        circle_negative = Vector2D(x=-middle_rectangle_x / 2, y=Offset.NULL)\n\n    with handle:\n        handle.add_draw(\n            backend.get_draw_rectangle_cls()(\n                backend=backend,\n                x_size=middle_rectangle_x,\n                y_size=middle_rectangle_y,\n                polarity=Polarity.Dark,\n                center_position=Vector2D(x=Offset.NULL, y=Offset.NULL),\n            ),\n        )\n        handle.add_draw(\n            backend.get_draw_circle_cls()(\n                backend=backend,\n                diameter=circle_diameter,\n                polarity=Polarity.Dark,\n                center_position=circle_positive,\n            ),\n        )\n        handle.add_draw(\n            backend.get_draw_circle_cls()(\n                backend=backend,\n                diameter=circle_diameter,\n                polarity=Polarity.Dark,\n                center_position=circle_negative,\n            ),\n        )\n        if self.hole_diameter is not None:\n            handle.add_draw(\n                backend.get_draw_circle_cls()(\n                    backend=backend,\n                    diameter=Offset.new(self.hole_diameter, state.get_units()),\n                    polarity=Polarity.Clear,\n                    center_position=Vector2D(x=Offset.NULL, y=Offset.NULL),\n                ),\n            )\n    frozen_handle = handle.get_public_handle()\n\n    new_aperture_dict = {**state.apertures}\n    new_aperture_dict[self.aperture_id] = frozen_handle\n\n    return (\n        state.model_copy(\n            update={\n                \"apertures\": new_aperture_dict,\n            },\n        ),\n        (),\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.html#pygerber.gerberx3.tokenizer.tokens.ad_define_aperture.DefineObround.parser2_visit_token","title":"parser2_visit_token","text":"<pre><code>parser2_visit_token(context: Parser2Context) -&gt; None\n</code></pre> <p>Perform actions on the context implicated by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.py</code> <pre><code>def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n    \"\"\"Perform actions on the context implicated by this token.\"\"\"\n    context.get_hooks().define_obround_aperture.pre_parser_visit_token(\n        self,\n        context,\n    )\n    context.get_hooks().define_aperture.pre_parser_visit_token(self, context)\n\n    context.get_hooks().define_obround_aperture.on_parser_visit_token(self, context)\n    context.get_hooks().define_aperture.on_parser_visit_token(self, context)\n\n    context.get_hooks().define_obround_aperture.post_parser_visit_token(\n        self,\n        context,\n    )\n    context.get_hooks().define_aperture.post_parser_visit_token(self, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.html#pygerber.gerberx3.tokenizer.tokens.ad_define_aperture.DefineObround.get_gerber_code","title":"get_gerber_code","text":"<pre><code>get_gerber_code(\n    indent: str = \"\", endline: str = \"\\n\"\n) -&gt; str\n</code></pre> <p>Get gerber code represented by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.py</code> <pre><code>def get_gerber_code(\n    self,\n    indent: str = \"\",\n    endline: str = \"\\n\",\n) -&gt; str:\n    \"\"\"Get gerber code represented by this token.\"\"\"\n    suffix = \"\"\n    if self.hole_diameter is not None:\n        suffix += f\"X{self.hole_diameter}\"\n    return (\n        f\"AD{self.aperture_id.get_gerber_code(indent, endline)}O,\"\n        f\"{self.x_size}X{self.y_size}{suffix}\"\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.html#pygerber.gerberx3.tokenizer.tokens.ad_define_aperture.DefinePolygon","title":"DefinePolygon","text":"<p>             Bases: <code>DefineAperture</code></p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.html#pygerber.gerberx3.tokenizer.tokens.ad_define_aperture.DefinePolygon--431-ad-command","title":"4.3.1 AD Command.","text":"<p>The AD command creates an aperture, attaches the aperture attributes at that moment in the attribute dictionary to it and adds it to the apertures dictionary.</p> <pre><code>AD = '%' ('AD' aperture_ident template_call) '*%';\ntemplate_call = template_name [',' parameter {'X' parameter}*];\n</code></pre> <p>The AD command must precede the first use of the aperture. It is recommended to put all AD commands in the file header.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.html#pygerber.gerberx3.tokenizer.tokens.ad_define_aperture.DefinePolygon--example","title":"Example:","text":"<pre><code>%ADD17P,.040X6*%\n%ADD17P,.040X6X0.0X0.019*%\n</code></pre> <p>See section 4.3 of The Gerber Layer Format Specification</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.html#pygerber.gerberx3.tokenizer.tokens.ad_define_aperture.DefinePolygon--445-polygon","title":"4.4.5 Polygon","text":"<p>Creates a regular polygon aperture. The syntax of the polygon template is:</p> <pre><code>template_call = 'P' ',' outer_diameter 'X' vertices 'X' rotation 'X' hole_diameter\n</code></pre> <ul> <li><code>P</code> - Indicates the polygon aperture template.</li> <li><code>outer_diameter</code> - Diameter of the circle circumscribing the regular polygon, i.e. the circle through the polygon vertices. A decimal &gt; 0.</li> <li><code>vertices</code> - Number of vertices n, 3 \u2264 n \u2264 12. An integer.</li> <li><code>rotation</code> - The rotation angle, in degrees counterclockwise. A decimal. With rotation angle zero there is a vertex on the positive X-axis through the aperture center.</li> <li><code>hole_diameter</code> - Diameter of a round hole. A decimal &gt;0. If omitted the aperture is solid. See also section 4.4.6.</li> </ul> <p>See section 4.4.5 of The Gerber Layer Format Specification</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.py</code> <pre><code>class DefinePolygon(DefineAperture):\n    \"\"\"## 4.3.1 AD Command.\n\n    The AD command creates an aperture, attaches the aperture attributes at that moment in the\n    attribute dictionary to it and adds it to the apertures dictionary.\n\n    ```ebnf\n    AD = '%' ('AD' aperture_ident template_call) '*%';\n    template_call = template_name [',' parameter {'X' parameter}*];\n    ```\n\n    The AD command must precede the first use of the aperture. It is recommended to put all AD\n    commands in the file header.\n\n    ---\n\n    ### Example:\n\n    ```gerber\n    %ADD17P,.040X6*%\n    %ADD17P,.040X6X0.0X0.019*%\n    ```\n\n    ---\n\n    See section 4.3 of [The Gerber Layer Format Specification](https://www.ucamco.com/files/downloads/file_en/456/gerber-layer-format-specification-revision-2023-08_en.pdf#page=48)\n\n    ---\n\n    ## 4.4.5 Polygon\n\n    Creates a regular polygon aperture. The syntax of the polygon template is:\n\n    ```ebnf\n    template_call = 'P' ',' outer_diameter 'X' vertices 'X' rotation 'X' hole_diameter\n    ```\n\n    - `P` - Indicates the polygon aperture template.\n    - `outer_diameter` - Diameter of the circle circumscribing the regular polygon, i.e. the circle through the polygon vertices. A decimal &gt; 0.\n    - `vertices` - Number of vertices n, 3 \u2264 n \u2264 12. An integer.\n    - `rotation` - The rotation angle, in degrees counterclockwise. A decimal. With rotation angle zero there is a vertex on the positive X-axis through the aperture center.\n    - `hole_diameter` - Diameter of a round hole. A decimal &gt;0. If omitted the aperture is solid. See also section [4.4.6](https://www.ucamco.com/files/downloads/file_en/456/gerber-layer-format-specification-revision-2023-08_en.pdf#page=55).\n\n    ---\n\n    See section 4.4.5 of [The Gerber Layer Format Specification](https://www.ucamco.com/files/downloads/file_en/456/gerber-layer-format-specification-revision-2023-08_en.pdf#page=54)\n\n    \"\"\"  # noqa: E501\n\n    def __init__(\n        self,\n        string: str,\n        location: int,\n        aperture_id: ApertureID,\n        outer_diameter: Decimal,\n        number_of_vertices: int,\n        rotation: Optional[Decimal],\n        hole_diameter: Optional[Decimal],\n    ) -&gt; None:\n        super().__init__(string, location)\n        self.aperture_id = aperture_id\n        self.outer_diameter = outer_diameter\n        self.number_of_vertices = number_of_vertices\n        self.rotation = rotation\n        self.hole_diameter = hole_diameter\n\n    @classmethod\n    def new(cls, string: str, location: int, tokens: ParseResults) -&gt; Self:\n        \"\"\"Create instance of this class.\n\n        Created to be used as callback in `ParserElement.set_parse_action()`.\n        \"\"\"\n        aperture_id = ApertureID(tokens[\"aperture_identifier\"])\n        outer_diameter: Decimal = Decimal(str(tokens[\"outer_diameter\"]))\n        number_of_vertices: int = int(str(tokens[\"number_of_vertices\"]))\n        rotation: Optional[Decimal] = (\n            Decimal(str(tokens[\"rotation\"]))\n            if tokens.get(\"rotation\") is not None\n            else None\n        )\n        hole_diameter: Optional[Decimal] = (\n            Decimal(str(tokens[\"hole_diameter\"]))\n            if tokens.get(\"hole_diameter\") is not None\n            else None\n        )\n        return cls(\n            string=string,\n            location=location,\n            aperture_id=aperture_id,\n            outer_diameter=outer_diameter,\n            number_of_vertices=number_of_vertices,\n            rotation=rotation,\n            hole_diameter=hole_diameter,\n        )\n\n    def update_drawing_state(\n        self,\n        state: State,\n        backend: Backend,\n    ) -&gt; Tuple[State, Iterable[DrawCommand]]:\n        \"\"\"Update drawing state.\"\"\"\n        handle = backend.create_aperture_handle(self.aperture_id)\n        with handle:\n            handle.add_draw(\n                backend.get_draw_polygon_cls()(\n                    backend=backend,\n                    outer_diameter=Offset.new(self.outer_diameter, state.get_units()),\n                    number_of_vertices=self.number_of_vertices,\n                    rotation=Decimal(\"0.0\") if self.rotation is None else self.rotation,\n                    polarity=Polarity.Dark,\n                    center_position=Vector2D(x=Offset.NULL, y=Offset.NULL),\n                ),\n            )\n            if self.hole_diameter is not None:\n                handle.add_draw(\n                    backend.get_draw_circle_cls()(\n                        backend=backend,\n                        diameter=Offset.new(self.hole_diameter, state.get_units()),\n                        polarity=Polarity.Clear,\n                        center_position=Vector2D(x=Offset.NULL, y=Offset.NULL),\n                    ),\n                )\n        frozen_handle = handle.get_public_handle()\n\n        new_aperture_dict = {**state.apertures}\n        new_aperture_dict[self.aperture_id] = frozen_handle\n\n        return (\n            state.model_copy(\n                update={\n                    \"apertures\": new_aperture_dict,\n                },\n            ),\n            (),\n        )\n\n    def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n        \"\"\"Perform actions on the context implicated by this token.\"\"\"\n        context.get_hooks().define_polygon_aperture.pre_parser_visit_token(\n            self,\n            context,\n        )\n        context.get_hooks().define_aperture.pre_parser_visit_token(self, context)\n\n        context.get_hooks().define_polygon_aperture.on_parser_visit_token(self, context)\n        context.get_hooks().define_aperture.on_parser_visit_token(self, context)\n\n        context.get_hooks().define_polygon_aperture.post_parser_visit_token(\n            self,\n            context,\n        )\n        context.get_hooks().define_aperture.post_parser_visit_token(self, context)\n\n    def get_gerber_code(\n        self,\n        indent: str = \"\",\n        endline: str = \"\\n\",\n    ) -&gt; str:\n        \"\"\"Get gerber code represented by this token.\"\"\"\n        suffix = \"\"\n        if self.hole_diameter is not None:\n            suffix += f\"X{self.hole_diameter}\"\n        return (\n            f\"AD{self.aperture_id.get_gerber_code(indent, endline)}P,\"\n            f\"{self.outer_diameter}X{self.number_of_vertices}X{self.rotation}{suffix}\"\n        )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.html#pygerber.gerberx3.tokenizer.tokens.ad_define_aperture.DefinePolygon.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(\n    string: str, location: int, tokens: ParseResults\n) -&gt; Self\n</code></pre> <p>Create instance of this class.</p> <p>Created to be used as callback in <code>ParserElement.set_parse_action()</code>.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.py</code> <pre><code>@classmethod\ndef new(cls, string: str, location: int, tokens: ParseResults) -&gt; Self:\n    \"\"\"Create instance of this class.\n\n    Created to be used as callback in `ParserElement.set_parse_action()`.\n    \"\"\"\n    aperture_id = ApertureID(tokens[\"aperture_identifier\"])\n    outer_diameter: Decimal = Decimal(str(tokens[\"outer_diameter\"]))\n    number_of_vertices: int = int(str(tokens[\"number_of_vertices\"]))\n    rotation: Optional[Decimal] = (\n        Decimal(str(tokens[\"rotation\"]))\n        if tokens.get(\"rotation\") is not None\n        else None\n    )\n    hole_diameter: Optional[Decimal] = (\n        Decimal(str(tokens[\"hole_diameter\"]))\n        if tokens.get(\"hole_diameter\") is not None\n        else None\n    )\n    return cls(\n        string=string,\n        location=location,\n        aperture_id=aperture_id,\n        outer_diameter=outer_diameter,\n        number_of_vertices=number_of_vertices,\n        rotation=rotation,\n        hole_diameter=hole_diameter,\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.html#pygerber.gerberx3.tokenizer.tokens.ad_define_aperture.DefinePolygon.update_drawing_state","title":"update_drawing_state","text":"<pre><code>update_drawing_state(\n    state: State, backend: Backend\n) -&gt; Tuple[State, Iterable[DrawCommand]]\n</code></pre> <p>Update drawing state.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.py</code> <pre><code>def update_drawing_state(\n    self,\n    state: State,\n    backend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n    \"\"\"Update drawing state.\"\"\"\n    handle = backend.create_aperture_handle(self.aperture_id)\n    with handle:\n        handle.add_draw(\n            backend.get_draw_polygon_cls()(\n                backend=backend,\n                outer_diameter=Offset.new(self.outer_diameter, state.get_units()),\n                number_of_vertices=self.number_of_vertices,\n                rotation=Decimal(\"0.0\") if self.rotation is None else self.rotation,\n                polarity=Polarity.Dark,\n                center_position=Vector2D(x=Offset.NULL, y=Offset.NULL),\n            ),\n        )\n        if self.hole_diameter is not None:\n            handle.add_draw(\n                backend.get_draw_circle_cls()(\n                    backend=backend,\n                    diameter=Offset.new(self.hole_diameter, state.get_units()),\n                    polarity=Polarity.Clear,\n                    center_position=Vector2D(x=Offset.NULL, y=Offset.NULL),\n                ),\n            )\n    frozen_handle = handle.get_public_handle()\n\n    new_aperture_dict = {**state.apertures}\n    new_aperture_dict[self.aperture_id] = frozen_handle\n\n    return (\n        state.model_copy(\n            update={\n                \"apertures\": new_aperture_dict,\n            },\n        ),\n        (),\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.html#pygerber.gerberx3.tokenizer.tokens.ad_define_aperture.DefinePolygon.parser2_visit_token","title":"parser2_visit_token","text":"<pre><code>parser2_visit_token(context: Parser2Context) -&gt; None\n</code></pre> <p>Perform actions on the context implicated by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.py</code> <pre><code>def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n    \"\"\"Perform actions on the context implicated by this token.\"\"\"\n    context.get_hooks().define_polygon_aperture.pre_parser_visit_token(\n        self,\n        context,\n    )\n    context.get_hooks().define_aperture.pre_parser_visit_token(self, context)\n\n    context.get_hooks().define_polygon_aperture.on_parser_visit_token(self, context)\n    context.get_hooks().define_aperture.on_parser_visit_token(self, context)\n\n    context.get_hooks().define_polygon_aperture.post_parser_visit_token(\n        self,\n        context,\n    )\n    context.get_hooks().define_aperture.post_parser_visit_token(self, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.html#pygerber.gerberx3.tokenizer.tokens.ad_define_aperture.DefinePolygon.get_gerber_code","title":"get_gerber_code","text":"<pre><code>get_gerber_code(\n    indent: str = \"\", endline: str = \"\\n\"\n) -&gt; str\n</code></pre> <p>Get gerber code represented by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.py</code> <pre><code>def get_gerber_code(\n    self,\n    indent: str = \"\",\n    endline: str = \"\\n\",\n) -&gt; str:\n    \"\"\"Get gerber code represented by this token.\"\"\"\n    suffix = \"\"\n    if self.hole_diameter is not None:\n        suffix += f\"X{self.hole_diameter}\"\n    return (\n        f\"AD{self.aperture_id.get_gerber_code(indent, endline)}P,\"\n        f\"{self.outer_diameter}X{self.number_of_vertices}X{self.rotation}{suffix}\"\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.html#pygerber.gerberx3.tokenizer.tokens.ad_define_aperture.DefineMacro","title":"DefineMacro","text":"<p>             Bases: <code>DefineAperture</code></p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.html#pygerber.gerberx3.tokenizer.tokens.ad_define_aperture.DefineMacro--431-ad-command","title":"4.3.1 AD Command.","text":"<p>The AD command creates an aperture, attaches the aperture attributes at that moment in the attribute dictionary to it and adds it to the apertures dictionary.</p> <pre><code>AD = '%' ('AD' aperture_ident template_call) '*%';\ntemplate_call = template_name [',' parameter {'X' parameter}*];\n</code></pre> <p>The AD command must precede the first use of the aperture. It is recommended to put all AD commands in the file header.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.html#pygerber.gerberx3.tokenizer.tokens.ad_define_aperture.DefineMacro--example","title":"Example","text":"<pre><code>%ADD10C,.025*%\n%ADD10C,0.5X0.25*%\n</code></pre> <p>See section 4.3 of The Gerber Layer Format Specification</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.html#pygerber.gerberx3.tokenizer.tokens.ad_define_aperture.DefineMacro--45-aperture-macro-am","title":"4.5 Aperture Macro (AM)","text":"<p>The AM command creates a macro aperture template and adds it to the aperture template dictionary (see 2.2). A template is a parametrized shape. The AD command instantiates a template into an aperture by supplying values to the template parameters.</p> <p>Templates of any shape or parametrization can be created. Multiple simple shapes called primitives can be combined in a single template. An aperture macro can contain variables whose actual values are defined by:</p> <ul> <li>Values provided by the AD command,</li> <li>Arithmetic expressions with other variables.</li> </ul> <p>The template is created by positioning primitives in a coordinate space. The origin of that coordinate space will be the origin of all apertures created with the state.</p> <p>A template must be defined before the first AD that refers to it. The AM command can be used multiple times in a file.</p> <p>Attributes are not attached to templates. They are attached to the aperture at the time of its creation with the AD command.</p> <p>An AM command contains the following words:</p> <ul> <li>The AM declaration with the macro name</li> <li>Primitives with their comma-separated parameters</li> <li>Macro variables, defined by an arithmetic expression</li> </ul> <pre><code>AM = '%' ('AM' macro_name macro_body) '%';\nmacro_name = name '*';\nmacro_body = {in_macro_block}+;\nin_macro_block =\n|primitive\n|variable_definition\n;\nvariable_definition = (macro_variable '=' expression) '*';\nmacro_variable = '$' positive_integer;\nprimitive = primitive_code {',' par}*\npar = ',' (expression);\n</code></pre> <p>See section 4.5 of The Gerber Layer Format Specification</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.py</code> <pre><code>class DefineMacro(DefineAperture):\n    \"\"\"## 4.3.1 AD Command.\n\n    The AD command creates an aperture, attaches the aperture attributes at that moment in the\n    attribute dictionary to it and adds it to the apertures dictionary.\n\n    ```ebnf\n    AD = '%' ('AD' aperture_ident template_call) '*%';\n    template_call = template_name [',' parameter {'X' parameter}*];\n    ```\n\n    The AD command must precede the first use of the aperture. It is recommended to put all AD\n    commands in the file header.\n\n    ---\n\n    ## Example\n\n    ```gerber\n    %ADD10C,.025*%\n    %ADD10C,0.5X0.25*%\n    ```\n\n    ---\n\n    See section 4.3 of [The Gerber Layer Format Specification](https://www.ucamco.com/files/downloads/file_en/456/gerber-layer-format-specification-revision-2023-08_en.pdf#page=48)\n\n    ---\n\n    ## 4.5 Aperture Macro (AM)\n\n    The AM command creates a macro aperture template and adds it to the aperture template\n    dictionary (see 2.2). A template is a parametrized shape. The AD command instantiates a\n    template into an aperture by supplying values to the template parameters.\n\n    Templates of any shape or parametrization can be created. Multiple simple shapes called\n    primitives can be combined in a single template. An aperture macro can contain variables\n    whose actual values are defined by:\n\n    - Values provided by the AD command,\n    - Arithmetic expressions with other variables.\n\n    The template is created by positioning primitives in a coordinate space. The origin of that\n    coordinate space will be the origin of all apertures created with the state.\n\n    A template must be defined before the first AD that refers to it. The AM command can be used\n    multiple times in a file.\n\n    Attributes are not attached to templates. They are attached to the aperture at the time of its\n    creation with the AD command.\n\n    An AM command contains the following words:\n\n    - The AM declaration with the macro name\n    - Primitives with their comma-separated parameters\n    - Macro variables, defined by an arithmetic expression\n\n    ```ebnf\n    AM = '%' ('AM' macro_name macro_body) '%';\n    macro_name = name '*';\n    macro_body = {in_macro_block}+;\n    in_macro_block =\n    |primitive\n    |variable_definition\n    ;\n    variable_definition = (macro_variable '=' expression) '*';\n    macro_variable = '$' positive_integer;\n    primitive = primitive_code {',' par}*\n    par = ',' (expression);\n    ```\n\n    ---\n\n    See section 4.5 of [The Gerber Layer Format Specification](https://www.ucamco.com/files/downloads/file_en/456/gerber-layer-format-specification-revision-2023-08_en.pdf#page=56)\n\n    \"\"\"  # noqa: E501\n\n    def __init__(\n        self,\n        string: str,\n        location: int,\n        aperture_type: str,\n        aperture_id: ApertureID,\n        am_param: List[str],\n    ) -&gt; None:\n        super().__init__(string, location)\n        self.aperture_type = aperture_type\n        self.aperture_id = aperture_id\n        self.am_param = am_param\n\n    @classmethod\n    def new(cls, string: str, location: int, tokens: ParseResults) -&gt; Self:\n        \"\"\"Create instance of this class.\n\n        Created to be used as callback in `ParserElement.set_parse_action()`.\n        \"\"\"\n        aperture_type: str = str(tokens[\"aperture_type\"])\n        aperture_id = ApertureID(tokens[\"aperture_identifier\"])\n\n        raw_am_param = e if (e := tokens.get(\"am_param\")) is not None else []\n        am_param: List[str] = [str(p) for p in raw_am_param]\n\n        return cls(\n            string=string,\n            location=location,\n            aperture_type=aperture_type,\n            aperture_id=aperture_id,\n            am_param=am_param,\n        )\n\n    def update_drawing_state(\n        self,\n        state: State,\n        backend: Backend,\n    ) -&gt; Tuple[State, Iterable[DrawCommand]]:\n        \"\"\"Update drawing state.\"\"\"\n        handle = backend.create_aperture_handle(self.aperture_id)\n        with handle:\n            macro = state.macros[self.aperture_type]\n            parameters = {\n                f\"${i + 1}\": Offset.new(value, state.get_units())\n                for i, value in enumerate(self.am_param)\n            }\n            macro.evaluate(state, handle, parameters)\n\n        frozen_handle = handle.get_public_handle()\n\n        new_aperture_dict = {**state.apertures}\n        new_aperture_dict[self.aperture_id] = frozen_handle\n\n        return (\n            state.model_copy(\n                update={\n                    \"apertures\": new_aperture_dict,\n                },\n            ),\n            (),\n        )\n\n    def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n        \"\"\"Perform actions on the context implicated by this token.\"\"\"\n        context.get_hooks().define_macro_aperture.pre_parser_visit_token(self, context)\n        context.get_hooks().define_aperture.pre_parser_visit_token(self, context)\n\n        context.get_hooks().define_macro_aperture.on_parser_visit_token(self, context)\n        context.get_hooks().define_aperture.on_parser_visit_token(self, context)\n\n        context.get_hooks().define_macro_aperture.post_parser_visit_token(self, context)\n        context.get_hooks().define_aperture.post_parser_visit_token(self, context)\n\n    def get_gerber_code(\n        self,\n        indent: str = \"\",\n        endline: str = \"\\n\",\n    ) -&gt; str:\n        \"\"\"Get gerber code represented by this token.\"\"\"\n        return (\n            f\"AD{self.aperture_id.get_gerber_code(indent, endline)}\"\n            f\"{self.aperture_type},{'X'.join(self.am_param)}\"\n        )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.html#pygerber.gerberx3.tokenizer.tokens.ad_define_aperture.DefineMacro.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(\n    string: str, location: int, tokens: ParseResults\n) -&gt; Self\n</code></pre> <p>Create instance of this class.</p> <p>Created to be used as callback in <code>ParserElement.set_parse_action()</code>.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.py</code> <pre><code>@classmethod\ndef new(cls, string: str, location: int, tokens: ParseResults) -&gt; Self:\n    \"\"\"Create instance of this class.\n\n    Created to be used as callback in `ParserElement.set_parse_action()`.\n    \"\"\"\n    aperture_type: str = str(tokens[\"aperture_type\"])\n    aperture_id = ApertureID(tokens[\"aperture_identifier\"])\n\n    raw_am_param = e if (e := tokens.get(\"am_param\")) is not None else []\n    am_param: List[str] = [str(p) for p in raw_am_param]\n\n    return cls(\n        string=string,\n        location=location,\n        aperture_type=aperture_type,\n        aperture_id=aperture_id,\n        am_param=am_param,\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.html#pygerber.gerberx3.tokenizer.tokens.ad_define_aperture.DefineMacro.update_drawing_state","title":"update_drawing_state","text":"<pre><code>update_drawing_state(\n    state: State, backend: Backend\n) -&gt; Tuple[State, Iterable[DrawCommand]]\n</code></pre> <p>Update drawing state.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.py</code> <pre><code>def update_drawing_state(\n    self,\n    state: State,\n    backend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n    \"\"\"Update drawing state.\"\"\"\n    handle = backend.create_aperture_handle(self.aperture_id)\n    with handle:\n        macro = state.macros[self.aperture_type]\n        parameters = {\n            f\"${i + 1}\": Offset.new(value, state.get_units())\n            for i, value in enumerate(self.am_param)\n        }\n        macro.evaluate(state, handle, parameters)\n\n    frozen_handle = handle.get_public_handle()\n\n    new_aperture_dict = {**state.apertures}\n    new_aperture_dict[self.aperture_id] = frozen_handle\n\n    return (\n        state.model_copy(\n            update={\n                \"apertures\": new_aperture_dict,\n            },\n        ),\n        (),\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.html#pygerber.gerberx3.tokenizer.tokens.ad_define_aperture.DefineMacro.parser2_visit_token","title":"parser2_visit_token","text":"<pre><code>parser2_visit_token(context: Parser2Context) -&gt; None\n</code></pre> <p>Perform actions on the context implicated by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.py</code> <pre><code>def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n    \"\"\"Perform actions on the context implicated by this token.\"\"\"\n    context.get_hooks().define_macro_aperture.pre_parser_visit_token(self, context)\n    context.get_hooks().define_aperture.pre_parser_visit_token(self, context)\n\n    context.get_hooks().define_macro_aperture.on_parser_visit_token(self, context)\n    context.get_hooks().define_aperture.on_parser_visit_token(self, context)\n\n    context.get_hooks().define_macro_aperture.post_parser_visit_token(self, context)\n    context.get_hooks().define_aperture.post_parser_visit_token(self, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.html#pygerber.gerberx3.tokenizer.tokens.ad_define_aperture.DefineMacro.get_gerber_code","title":"get_gerber_code","text":"<pre><code>get_gerber_code(\n    indent: str = \"\", endline: str = \"\\n\"\n) -&gt; str\n</code></pre> <p>Get gerber code represented by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/ad_define_aperture.py</code> <pre><code>def get_gerber_code(\n    self,\n    indent: str = \"\",\n    endline: str = \"\\n\",\n) -&gt; str:\n    \"\"\"Get gerber code represented by this token.\"\"\"\n    return (\n        f\"AD{self.aperture_id.get_gerber_code(indent, endline)}\"\n        f\"{self.aperture_type},{'X'.join(self.am_param)}\"\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/as_axis_select.html","title":"as_axis_select","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/as_axis_select.html#pygerber.gerberx3.tokenizer.tokens.as_axis_select","title":"as_axis_select","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/as_axis_select.html#pygerber.gerberx3.tokenizer.tokens.as_axis_select--load-name-ln","title":"Load Name (LN).","text":"<p>Note: The LN command was deprecated in revision I4 from October 2013.</p> <p>The historic <code>LN</code> command doesn't influence the image in any manner and can safely be overlooked.</p> <p>Function of the <code>LN</code> command: - <code>LN</code> is designed to allocate a name to the following section of the file. - It was originally conceptualized to serve as a human-readable comment. - For creating human-readable comments, it's advisable to utilize the standard <code>G04</code>     command. - The <code>LN</code> command has the flexibility to be executed multiple times within a file.</p> <p>SPEC: <code>2023.03</code> SECTION: <code>8.1.6</code></p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/as_axis_select.html#pygerber.gerberx3.tokenizer.tokens.as_axis_select.AxisSelect","title":"AxisSelect","text":"<p>             Bases: <code>ExtendedCommandToken</code></p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/as_axis_select.html#pygerber.gerberx3.tokenizer.tokens.as_axis_select.AxisSelect--812-axis-select-as","title":"8.1.2 Axis Select (AS).","text":"<p>The AS command is deprecated since revision I1 from December 2012.</p> <p>The historic AS command sets the correspondence between the X, Y data axes and the A, B output device axes. It does not affect the image in computer to computer data exchange. It only has an effect how the image is positioned on an output device.</p> <p>The order of execution is always MI, SF, OF, IR and AS, independent of their order of appearance in the file.</p> <p>The AS command can only be used once, at the beginning of the file.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/as_axis_select.html#pygerber.gerberx3.tokenizer.tokens.as_axis_select.AxisSelect--8121-as-command","title":"8.1.2.1 AS Command.","text":"<p>The syntax for the AS command is:</p> <pre><code>AS = '%' (AS' ('AXBY'|'AYBX')) '*%';\n</code></pre> <ul> <li><code>AS</code> - AS for Axis Select</li> <li><code>AXBY</code> - Assign output device axis A to data axis X, output device axis B to data axis Y. This is the default.</li> <li><code>AYBX</code> - Assign output device axis A to data axis Y, output device axis B to data axis X.</li> </ul>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/as_axis_select.html#pygerber.gerberx3.tokenizer.tokens.as_axis_select.AxisSelect--example","title":"Example","text":"<p>Assign output device axis A to data axis X and output device axis B to data axis Y</p> <pre><code>%ASAXBY*%\n</code></pre> <p>Assign output device axis A to data axis Y and output device axis B to data axis X</p> <pre><code>%ASAYBX*%\n</code></pre> <p>See section 8.1.2 of The Gerber Layer Format Specification</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/as_axis_select.py</code> <pre><code>class AxisSelect(ExtendedCommandToken):\n    \"\"\"## 8.1.2 Axis Select (AS).\n\n    The AS command is deprecated since revision I1 from December 2012.\n\n    The historic AS command sets the correspondence between the X, Y data axes and the\n    A, B output device axes. It does not affect the image in computer to computer data\n    exchange. It only has an effect how the image is positioned on an output device.\n\n    The order of execution is always MI, SF, OF, IR and AS, independent of their order\n    of appearance in the file.\n\n    The AS command can only be used once, at the beginning of the file.\n\n    ### 8.1.2.1 AS Command.\n\n    The syntax for the AS command is:\n\n    ```ebnf\n    AS = '%' (AS' ('AXBY'|'AYBX')) '*%';\n    ```\n\n    - `AS` - AS for Axis Select\n    - `AXBY` - Assign output device axis A to data axis X, output device axis B to data axis Y. This is the default.\n    - `AYBX` - Assign output device axis A to data axis Y, output device axis B to data axis X.\n\n    ---\n\n    ## Example\n\n    Assign output device axis A to data axis X and output device axis B\n    to data axis Y\n\n    ```gerber\n    %ASAXBY*%\n    ```\n\n    Assign output device axis A to data axis Y and output device axis B\n    to data axis X\n\n    ```gerber\n    %ASAYBX*%\n    ```\n\n    ---\n\n    See section 8.1.2 of [The Gerber Layer Format Specification](https://www.ucamco.com/files/downloads/file_en/456/gerber-layer-format-specification-revision-2023-08_en.pdf#page=175)\n\n    \"\"\"  # noqa: E501\n\n    def __init__(\n        self,\n        string: str,\n        location: int,\n        correspondence: AxisCorrespondence,\n    ) -&gt; None:\n        super().__init__(string, location)\n        self.correspondence = correspondence\n\n    @classmethod\n    def new(cls, string: str, location: int, tokens: ParseResults) -&gt; Self:\n        \"\"\"Create instance of this class.\n\n        Created to be used as callback in `ParserElement.set_parse_action()`.\n        \"\"\"\n        correspondence = tokens[\"correspondence\"]\n        if not isinstance(correspondence, str):\n            raise TypeError(correspondence)\n        return cls(\n            string=string,\n            location=location,\n            correspondence=AxisCorrespondence(correspondence),\n        )\n\n    def update_drawing_state(\n        self,\n        state: State,\n        _backend: Backend,\n    ) -&gt; Tuple[State, Iterable[DrawCommand]]:\n        \"\"\"Update drawing state.\"\"\"\n        warn_deprecated_code(\"AS\", \"8.1\")\n        return super().update_drawing_state(state, _backend)\n\n    def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n        \"\"\"Perform actions on the context implicated by this token.\"\"\"\n        context.get_hooks().axis_select.pre_parser_visit_token(self, context)\n        context.get_hooks().axis_select.on_parser_visit_token(self, context)\n        context.get_hooks().axis_select.post_parser_visit_token(self, context)\n\n    def get_gerber_code(\n        self,\n        indent: str = \"\",  # noqa: ARG002\n        endline: str = \"\\n\",  # noqa: ARG002\n    ) -&gt; str:\n        \"\"\"Get gerber code represented by this token.\"\"\"\n        return f\"IN{self.correspondence}\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/as_axis_select.html#pygerber.gerberx3.tokenizer.tokens.as_axis_select.AxisSelect.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(\n    string: str, location: int, tokens: ParseResults\n) -&gt; Self\n</code></pre> <p>Create instance of this class.</p> <p>Created to be used as callback in <code>ParserElement.set_parse_action()</code>.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/as_axis_select.py</code> <pre><code>@classmethod\ndef new(cls, string: str, location: int, tokens: ParseResults) -&gt; Self:\n    \"\"\"Create instance of this class.\n\n    Created to be used as callback in `ParserElement.set_parse_action()`.\n    \"\"\"\n    correspondence = tokens[\"correspondence\"]\n    if not isinstance(correspondence, str):\n        raise TypeError(correspondence)\n    return cls(\n        string=string,\n        location=location,\n        correspondence=AxisCorrespondence(correspondence),\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/as_axis_select.html#pygerber.gerberx3.tokenizer.tokens.as_axis_select.AxisSelect.update_drawing_state","title":"update_drawing_state","text":"<pre><code>update_drawing_state(\n    state: State, _backend: Backend\n) -&gt; Tuple[State, Iterable[DrawCommand]]\n</code></pre> <p>Update drawing state.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/as_axis_select.py</code> <pre><code>def update_drawing_state(\n    self,\n    state: State,\n    _backend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n    \"\"\"Update drawing state.\"\"\"\n    warn_deprecated_code(\"AS\", \"8.1\")\n    return super().update_drawing_state(state, _backend)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/as_axis_select.html#pygerber.gerberx3.tokenizer.tokens.as_axis_select.AxisSelect.parser2_visit_token","title":"parser2_visit_token","text":"<pre><code>parser2_visit_token(context: Parser2Context) -&gt; None\n</code></pre> <p>Perform actions on the context implicated by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/as_axis_select.py</code> <pre><code>def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n    \"\"\"Perform actions on the context implicated by this token.\"\"\"\n    context.get_hooks().axis_select.pre_parser_visit_token(self, context)\n    context.get_hooks().axis_select.on_parser_visit_token(self, context)\n    context.get_hooks().axis_select.post_parser_visit_token(self, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/as_axis_select.html#pygerber.gerberx3.tokenizer.tokens.as_axis_select.AxisSelect.get_gerber_code","title":"get_gerber_code","text":"<pre><code>get_gerber_code(\n    indent: str = \"\", endline: str = \"\\n\"\n) -&gt; str\n</code></pre> <p>Get gerber code represented by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/as_axis_select.py</code> <pre><code>def get_gerber_code(\n    self,\n    indent: str = \"\",  # noqa: ARG002\n    endline: str = \"\\n\",  # noqa: ARG002\n) -&gt; str:\n    \"\"\"Get gerber code represented by this token.\"\"\"\n    return f\"IN{self.correspondence}\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/attribute_token.html","title":"attribute_token","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/attribute_token.html#pygerber.gerberx3.tokenizer.tokens.attribute_token","title":"attribute_token","text":"<p>Base class for attribute tokens.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/attribute_token.html#pygerber.gerberx3.tokenizer.tokens.attribute_token.AttributeToken","title":"AttributeToken","text":"<p>             Bases: <code>ExtendedCommandToken</code></p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/attribute_token.html#pygerber.gerberx3.tokenizer.tokens.attribute_token.AttributeToken--51-attributes-overview","title":"5.1 Attributes Overview,.","text":"<p>Attributes add meta-information to a Gerber file. Attributes are akin to labels providing information about the file or features within them. Examples of meta-information conveyed by attributes are:</p> <ul> <li>The function of the file in the layer structure. Is the file the top solder mask, the bottom copper layer, \u2026?</li> <li>The function of a pad. Is the pad an SMD pad, or a via pad, or a fiducial, ...?</li> </ul> <p>The attribute syntax provides a flexible and standardized way to add meta-information to a Gerber file, independent of the specific semantics or application.</p> <p>Attributes do not affect the image. A Gerber reader will generate the correct image if it simply ignores the attributes.</p> <p>Each attribute consists of an attribute name and an optional attribute value:</p> <pre><code>&lt;Attribute&gt; = &lt;AttributeName&gt;[,&lt;AttributeValue&gt;]*\n</code></pre> <p>Attribute names follow the name syntax in section 3.4.3.</p> <p>The attribute value consists of one or more comma-separated fields, see section 3.4.4.</p> <pre><code>&lt;AttributeValue&gt; = &lt;Field&gt;{,&lt;Field&gt;}\n</code></pre> <p>There are three types of attributes by the item they attach to:</p> <ul> <li><code>Attachment type</code> - The item to which they attach meta-information.</li> <li><code>File attributes</code> - Attach meta-information to the file as a whole.</li> <li><code>Aperture attributes</code> - Attach meta-information to an aperture or a region. Objects created by the aperture inherit the aperture meta-information.</li> <li><code>Object attributes</code> - Attach meta-information to on object directly.</li> </ul> <p>There are two types of attributes by the scope of their use:</p> <ul> <li> <p><code>Standard attributes</code>. Standard attribute names, values and semantics are defined in this specification and are part of it. As they are standardized, they can exchange meta information between all applications.</p> </li> <li> <p><code>User attributes</code>. User attributes can be chosen freely by users to extend the format with custom meta-information. Use custom attributes only for unequivocally defined machine-readable information, use G04 for mere human-readable comments.</p> </li> </ul> <p>In accordance with the general rule in 3.4.3 standard attribute names must begin with a dot \".\" while user attribute names cannot begin with a dot. The dot, if present, is part of the attribute name and indicates that it is a standard attribute whose syntax and semantics are defined in section 5.6.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/attribute_token.html#pygerber.gerberx3.tokenizer.tokens.attribute_token.AttributeToken--example","title":"Example","text":"<pre><code>%TFMyAttribute,Yes*%\n%TFZap*%\n%TFZonk*%\n</code></pre> <p>See section 5.1 of The Gerber Layer Format Specification</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/attribute_token.py</code> <pre><code>class AttributeToken(ExtendedCommandToken):\n    \"\"\"## 5.1 Attributes Overview,.\n\n    Attributes add meta-information to a Gerber file. Attributes are akin to labels providing\n    information about the file or features within them. Examples of meta-information conveyed by\n    attributes are:\n\n    - The function of the file in the layer structure. Is the file the top solder mask, the bottom\n    copper layer, \u2026?\n    - The function of a pad. Is the pad an SMD pad, or a via pad, or a fiducial, ...?\n\n    The attribute syntax provides a flexible and standardized way to add meta-information to a\n    Gerber file, independent of the specific semantics or application.\n\n    Attributes do not affect the image. A Gerber reader will generate the correct image if it simply\n    ignores the attributes.\n\n    Each attribute consists of an attribute name and an optional attribute value:\n\n    ```ebnf\n    &lt;Attribute&gt; = &lt;AttributeName&gt;[,&lt;AttributeValue&gt;]*\n    ```\n\n    Attribute names follow the name syntax in section 3.4.3.\n\n    The attribute value consists of one or more comma-separated fields, see section 3.4.4.\n\n    ```ebnf\n    &lt;AttributeValue&gt; = &lt;Field&gt;{,&lt;Field&gt;}\n    ```\n\n    There are three types of attributes by the item they attach to:\n\n    - `Attachment type` - The item to which they attach meta-information.\n    - `File attributes` - Attach meta-information to the file as a whole.\n    - `Aperture attributes` - Attach meta-information to an aperture or a region. Objects created by\n    the aperture inherit the aperture meta-information.\n    - `Object attributes` - Attach meta-information to on object directly.\n\n    There are two types of attributes by the scope of their use:\n\n    - `Standard attributes`. Standard attribute names, values and semantics are defined in this\n    specification and are part of it. As they are standardized, they can exchange meta information between all applications.\n\n    - `User attributes`. User attributes can be chosen freely by users to extend the format with\n    custom meta-information. Use custom attributes only for unequivocally defined\n    machine-readable information, use G04 for mere human-readable comments.\n\n    In accordance with the general rule in 3.4.3 standard attribute names must begin with a dot \".\"\n    while user attribute names cannot begin with a dot. The dot, if present, is part of the attribute\n    name and indicates that it is a standard attribute whose syntax and semantics are defined in\n    section 5.6.\n\n    ---\n\n    ## Example\n\n    ```gerber\n    %TFMyAttribute,Yes*%\n    %TFZap*%\n    %TFZonk*%\n    ```\n\n    ---\n\n    See section 5.1 of [The Gerber Layer Format Specification](https://www.ucamco.com/files/downloads/file_en/456/gerber-layer-format-specification-revision-2023-08_en.pdf#page=122)\n\n    \"\"\"  # noqa: E501\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/attribute_token.html#pygerber.gerberx3.tokenizer.tokens.attribute_token.SetAttributeToken","title":"SetAttributeToken","text":"<p>             Bases: <code>AttributeToken</code></p> <p>Base class for all classes which set some kind of attribute.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/attribute_token.py</code> <pre><code>class SetAttributeToken(AttributeToken):\n    \"\"\"Base class for all classes which set some kind of attribute.\"\"\"\n\n    def __init__(\n        self,\n        string: str,\n        location: int,\n        name: str,\n        value: Optional[str],\n    ) -&gt; None:\n        super().__init__(string, location)\n        self.name = name\n        self.value = value\n\n    @classmethod\n    def new(cls, string: str, location: int, tokens: ParseResults) -&gt; Self:\n        \"\"\"Create instance of this class.\n\n        Created to be used as callback in `ParserElement.set_parse_action()`.\n        \"\"\"\n        name: str = str(tokens[\"attribute_name\"])\n        value = tokens.get(\"field\", None)\n        if value is not None:\n            value = str(value)\n\n        return cls(\n            string=string,\n            location=location,\n            name=name,\n            value=value,\n        )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/attribute_token.html#pygerber.gerberx3.tokenizer.tokens.attribute_token.SetAttributeToken.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(\n    string: str, location: int, tokens: ParseResults\n) -&gt; Self\n</code></pre> <p>Create instance of this class.</p> <p>Created to be used as callback in <code>ParserElement.set_parse_action()</code>.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/attribute_token.py</code> <pre><code>@classmethod\ndef new(cls, string: str, location: int, tokens: ParseResults) -&gt; Self:\n    \"\"\"Create instance of this class.\n\n    Created to be used as callback in `ParserElement.set_parse_action()`.\n    \"\"\"\n    name: str = str(tokens[\"attribute_name\"])\n    value = tokens.get(\"field\", None)\n    if value is not None:\n        value = str(value)\n\n    return cls(\n        string=string,\n        location=location,\n        name=name,\n        value=value,\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/coordinate.html","title":"coordinate","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/coordinate.html#pygerber.gerberx3.tokenizer.tokens.coordinate","title":"coordinate","text":"<p>Coordinate wrapper class.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/coordinate.html#pygerber.gerberx3.tokenizer.tokens.coordinate.Coordinate","title":"Coordinate","text":"<p>             Bases: <code>GerberCode</code>, <code>FrozenGeneralModel</code></p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/coordinate.html#pygerber.gerberx3.tokenizer.tokens.coordinate.Coordinate--coordinate-data","title":"Coordinate data.","text":"<p>A number whose interpretation is determined by the FS command. It is used to specify the X and Y coordinates of a point in the image plane and a distance or offset in the X and Y direction.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/coordinate.py</code> <pre><code>class Coordinate(GerberCode, FrozenGeneralModel):\n    \"\"\"## Coordinate data.\n\n    A number whose interpretation is determined by the FS command. It is used to specify\n    the X and Y coordinates of a point in the image plane and a distance\n    or offset in the X and Y direction.\n    \"\"\"\n\n    coordinate_type: CoordinateType\n    sign: CoordinateSign\n    offset: str\n\n    @classmethod\n    def new(cls, coordinate_type: CoordinateType, offset: Optional[str]) -&gt; Self:\n        \"\"\"Create new Coordinate object.\"\"\"\n        if offset is None:\n            coordinate_type = coordinate_type.to_missing()\n            offset = \"\"\n            sign = CoordinateSign.Positive\n\n        elif len(offset) &gt; 0 and offset[0] in \"+-\":\n            sign = CoordinateSign(offset[0])\n            offset = offset[1:].ljust(1, \"0\")\n\n        else:\n            sign = CoordinateSign.Positive\n\n        return cls(coordinate_type=coordinate_type, sign=sign, offset=offset)\n\n    def get_gerber_code(\n        self,\n        indent: str = \"\",\n        endline: str = \"\\n\",  # noqa: ARG002\n    ) -&gt; str:\n        \"\"\"Get gerber code represented by this token.\"\"\"\n        return (\n            \"\"\n            if self.coordinate_type.is_missing()\n            else f\"{indent}{self.coordinate_type}{self.sign}{self.offset}\"\n        )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/coordinate.html#pygerber.gerberx3.tokenizer.tokens.coordinate.Coordinate.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(\n    coordinate_type: CoordinateType, offset: Optional[str]\n) -&gt; Self\n</code></pre> <p>Create new Coordinate object.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/coordinate.py</code> <pre><code>@classmethod\ndef new(cls, coordinate_type: CoordinateType, offset: Optional[str]) -&gt; Self:\n    \"\"\"Create new Coordinate object.\"\"\"\n    if offset is None:\n        coordinate_type = coordinate_type.to_missing()\n        offset = \"\"\n        sign = CoordinateSign.Positive\n\n    elif len(offset) &gt; 0 and offset[0] in \"+-\":\n        sign = CoordinateSign(offset[0])\n        offset = offset[1:].ljust(1, \"0\")\n\n    else:\n        sign = CoordinateSign.Positive\n\n    return cls(coordinate_type=coordinate_type, sign=sign, offset=offset)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/coordinate.html#pygerber.gerberx3.tokenizer.tokens.coordinate.Coordinate.get_gerber_code","title":"get_gerber_code","text":"<pre><code>get_gerber_code(\n    indent: str = \"\", endline: str = \"\\n\"\n) -&gt; str\n</code></pre> <p>Get gerber code represented by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/coordinate.py</code> <pre><code>def get_gerber_code(\n    self,\n    indent: str = \"\",\n    endline: str = \"\\n\",  # noqa: ARG002\n) -&gt; str:\n    \"\"\"Get gerber code represented by this token.\"\"\"\n    return (\n        \"\"\n        if self.coordinate_type.is_missing()\n        else f\"{indent}{self.coordinate_type}{self.sign}{self.offset}\"\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/coordinate.html#pygerber.gerberx3.tokenizer.tokens.coordinate.CoordinateType","title":"CoordinateType","text":"<p>             Bases: <code>Enum</code></p> <p>Type of coordinate axis/meaning.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/coordinate.py</code> <pre><code>class CoordinateType(Enum):\n    \"\"\"Type of coordinate axis/meaning.\"\"\"\n\n    X = \"X\"\n    Y = \"Y\"\n    I = \"I\"  # noqa: E741\n    J = \"J\"\n    NULL = \"\"\n    MISSING_X = \"MISSING_X\"\n    MISSING_Y = \"MISSING_Y\"\n    MISSING_I = \"MISSING_I\"\n    MISSING_J = \"MISSING_J\"\n\n    def to_missing(self) -&gt; CoordinateType:\n        \"\"\"Map &lt;coordinate&gt; to MISSING_&lt;coordinate&gt;.\"\"\"\n        return _coordinate_type_to_missing_map[self]\n\n    def is_missing(self) -&gt; bool:\n        \"\"\"Check if coordinate is one of variants of missing coordinates.\"\"\"\n        return self in (\n            CoordinateType.MISSING_X,\n            CoordinateType.MISSING_Y,\n            CoordinateType.MISSING_I,\n            CoordinateType.MISSING_J,\n        )\n\n    def __str__(self) -&gt; str:\n        return self.value\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/coordinate.html#pygerber.gerberx3.tokenizer.tokens.coordinate.CoordinateType.to_missing","title":"to_missing","text":"<pre><code>to_missing() -&gt; CoordinateType\n</code></pre> <p>Map  to MISSING_. Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/coordinate.py</code> <pre><code>def to_missing(self) -&gt; CoordinateType:\n    \"\"\"Map &lt;coordinate&gt; to MISSING_&lt;coordinate&gt;.\"\"\"\n    return _coordinate_type_to_missing_map[self]\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/coordinate.html#pygerber.gerberx3.tokenizer.tokens.coordinate.CoordinateType.is_missing","title":"is_missing","text":"<pre><code>is_missing() -&gt; bool\n</code></pre> <p>Check if coordinate is one of variants of missing coordinates.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/coordinate.py</code> <pre><code>def is_missing(self) -&gt; bool:\n    \"\"\"Check if coordinate is one of variants of missing coordinates.\"\"\"\n    return self in (\n        CoordinateType.MISSING_X,\n        CoordinateType.MISSING_Y,\n        CoordinateType.MISSING_I,\n        CoordinateType.MISSING_J,\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/coordinate.html#pygerber.gerberx3.tokenizer.tokens.coordinate.CoordinateSign","title":"CoordinateSign","text":"<p>             Bases: <code>Enum</code></p> <p>Coordinate sign.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/coordinate.py</code> <pre><code>class CoordinateSign(Enum):\n    \"\"\"Coordinate sign.\"\"\"\n\n    Positive = \"+\"\n    Negative = \"-\"\n\n    def __str__(self) -&gt; str:\n        return \"-\" if self == CoordinateSign.Negative else \"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/d01_draw.html","title":"d01_draw","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/d01_draw.html#pygerber.gerberx3.tokenizer.tokens.d01_draw","title":"d01_draw","text":"<p>Plot (D01) logic.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/d01_draw.html#pygerber.gerberx3.tokenizer.tokens.d01_draw.D01Draw","title":"D01Draw","text":"<p>             Bases: <code>CommandToken</code></p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/d01_draw.html#pygerber.gerberx3.tokenizer.tokens.d01_draw.D01Draw--482-plot-d01","title":"4.8.2 Plot (D01).","text":"<p>Performs a plotting operation, creating a draw or an arc segment. The plot state defines which type of segment is created, see 4.7. The syntax depends on the required parameters, and, hence, on the plot state.</p> <p>D01 creates a linear or circular line segment by plotting from the current point to the coordinate pair in the command. Outside a region statement (see 2.3.2) these segments are converted to draw or arc objects by stroking them with the current aperture (see 2.3.1). Within a region statement these segments form a contour defining a region (see 4.10). The effect of D01, e.g. whether a straight or circular segment is created, depends on the graphics state (see 2.3.2).</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/d01_draw.html#pygerber.gerberx3.tokenizer.tokens.d01_draw.D01Draw--syntax","title":"Syntax","text":"<p>For linear (G01):</p> <pre><code>D01 = (['X' x_coordinate] ['Y' y_coordinate] 'D01') '*';\n</code></pre> <p>For Circular (G02|G03)</p> <pre><code>D01 = (['X' x_coordinate] ['Y' y_coordinate] 'I' x_offset 'J' y-offset ) 'D01' '*';\n</code></pre> <ul> <li>x_coordinate - <code>&lt;Coordinate&gt;</code> is coordinate data - see section 0. It defines the X coordinate of the     new current point. The default is the X coordinate of the old current point.</li> </ul>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/d01_draw.html#pygerber.gerberx3.tokenizer.tokens.d01_draw.D01Draw--example","title":"Example","text":"<pre><code>X275000Y115000D02*\nG01*\nX2512000Y115000D01*\nG75*\nG03*\nX5005000Y3506000I3000J0D01*\nG01*\nX15752000D01*\nY12221000D01*\n</code></pre> <p>See section 4.8.2 of The Gerber Layer Format Specification</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/d01_draw.py</code> <pre><code>class D01Draw(CommandToken):\n    \"\"\"## 4.8.2 Plot (D01).\n\n    Performs a plotting operation, creating a draw or an arc segment. The plot state defines which\n    type of segment is created, see 4.7. The syntax depends on the required parameters, and,\n    hence, on the plot state.\n\n    D01 creates a linear or circular line segment by plotting from the current point to the\n    coordinate pair in the command. Outside a region statement (see 2.3.2) these segments\n    are converted to draw or arc objects by stroking them with the current aperture (see 2.3.1).\n    Within a region statement these segments form a contour defining a region (see 4.10). The\n    effect of D01, e.g. whether a straight or circular segment is created, depends on the\n    graphics state (see 2.3.2).\n\n    ### Syntax\n\n    For linear (G01):\n\n    ```ebnf\n    D01 = (['X' x_coordinate] ['Y' y_coordinate] 'D01') '*';\n    ```\n\n    For Circular (G02|G03)\n\n    ```ebnf\n    D01 = (['X' x_coordinate] ['Y' y_coordinate] 'I' x_offset 'J' y-offset ) 'D01' '*';\n    ```\n\n    - x_coordinate - `&lt;Coordinate&gt;` is coordinate data - see section 0. It defines the X coordinate of the\n        new current point. The default is the X coordinate of the old current point.\n\n    ---\n\n    ## Example\n\n    ```gerber\n    X275000Y115000D02*\n    G01*\n    X2512000Y115000D01*\n    G75*\n    G03*\n    X5005000Y3506000I3000J0D01*\n    G01*\n    X15752000D01*\n    Y12221000D01*\n    ```\n\n    ---\n\n    See section 4.8.2 of [The Gerber Layer Format Specification](https://www.ucamco.com/files/downloads/file_en/456/gerber-layer-format-specification-revision-2023-08_en.pdf#page=83)\n\n    \"\"\"  # noqa: E501\n\n    def __init__(\n        self,\n        string: str,\n        location: int,\n        x: Coordinate,\n        y: Coordinate,\n        i: Coordinate,\n        j: Coordinate,\n    ) -&gt; None:\n        super().__init__(string, location)\n        self.x = x\n        self.y = y\n        self.i = i\n        self.j = j\n\n    @classmethod\n    def new(cls, string: str, location: int, tokens: ParseResults) -&gt; Self:\n        \"\"\"Create instance of this class.\n\n        Created to be used as callback in `ParserElement.set_parse_action()`.\n        \"\"\"\n        x = tokens.get(\"x\")\n        x = Coordinate.new(\n            coordinate_type=CoordinateType.X,\n            offset=str(x) if x is not None else None,\n        )\n        y = tokens.get(\"y\")\n        y = Coordinate.new(\n            coordinate_type=CoordinateType.Y,\n            offset=str(y) if y is not None else None,\n        )\n        i = tokens.get(\"i\")\n        i = Coordinate.new(\n            coordinate_type=CoordinateType.I,\n            offset=str(i) if i is not None else None,\n        )\n        j = tokens.get(\"j\")\n        j = Coordinate.new(\n            coordinate_type=CoordinateType.J,\n            offset=str(j) if j is not None else None,\n        )\n\n        return cls(\n            string=string,\n            location=location,\n            x=x,\n            y=y,\n            i=i,\n            j=j,\n        )\n\n    def update_drawing_state(\n        self,\n        state: State,\n        backend: Backend,\n    ) -&gt; Tuple[State, Iterable[DrawCommand]]:\n        \"\"\"Set coordinate parser.\"\"\"\n        x = state.parse_coordinate(self.x)\n        y = state.parse_coordinate(self.y)\n\n        end_position = Vector2D(x=x, y=y)\n        start_position = state.current_position\n\n        draw_commands: list[DrawCommand] = []\n\n        if state.is_region:\n            polarity = state.polarity.to_region_variant()\n        else:\n            polarity = state.polarity\n\n        if not state.is_region or backend.options.draw_region_outlines:\n            draw_commands.extend(\n                self._create_draw_commands(\n                    state,\n                    backend,\n                    end_position,\n                    start_position,\n                    polarity,\n                ),\n            )\n\n        if state.is_region:\n            self._create_region_points(\n                state,\n                backend,\n                end_position,\n                start_position,\n                polarity,\n            )\n\n        return (\n            state.model_copy(\n                update={\n                    \"current_position\": end_position,\n                },\n            ),\n            draw_commands,\n        )\n\n    def _create_region_points(\n        self,\n        state: State,\n        backend: Backend,\n        end_position: Vector2D,\n        start_position: Vector2D,\n        polarity: Polarity,\n    ) -&gt; None:\n        if state.draw_mode == DrawMode.Linear:\n            state.region_boundary_points.append(start_position)\n            state.region_boundary_points.append(end_position)\n\n        elif state.draw_mode in (\n            DrawMode.ClockwiseCircular,\n            DrawMode.CounterclockwiseCircular,\n        ):\n            i = state.parse_coordinate(self.i)\n            j = state.parse_coordinate(self.j)\n\n            center_offset = Vector2D(x=i, y=j)\n\n            state.region_boundary_points.extend(\n                backend.get_draw_arc_cls()(\n                    backend=backend,\n                    polarity=polarity,\n                    start_position=start_position,\n                    dx_dy_center=center_offset,\n                    end_position=end_position,\n                    width=Offset.NULL,\n                    is_clockwise=(state.draw_mode == DrawMode.ClockwiseCircular),\n                    # Will require tweaking if support for single quadrant mode\n                    # will be desired.\n                    is_multi_quadrant=True,\n                ).calculate_arc_points(),\n            )\n\n        else:\n            raise NotImplementedError(state.draw_mode)\n\n    def _create_draw_commands(\n        self,\n        state: State,\n        backend: Backend,\n        end_position: Vector2D,\n        start_position: Vector2D,\n        polarity: Polarity,\n    ) -&gt; Generator[DrawCommand, None, None]:\n        current_aperture = backend.get_private_aperture_handle(\n            state.get_current_aperture(),\n        )\n        yield backend.get_draw_paste_cls()(\n            backend=backend,\n            polarity=polarity,\n            center_position=start_position,\n            other=current_aperture.drawing_target,\n        )\n\n        if state.draw_mode == DrawMode.Linear:\n            if not state.is_region or backend.options.draw_region_outlines:\n                yield backend.get_draw_vector_line_cls()(\n                    backend=backend,\n                    polarity=polarity,\n                    start_position=start_position,\n                    end_position=end_position,\n                    width=current_aperture.get_line_width(),\n                )\n\n        elif state.draw_mode in (\n            DrawMode.ClockwiseCircular,\n            DrawMode.CounterclockwiseCircular,\n        ):\n            i = state.parse_coordinate(self.i)\n            j = state.parse_coordinate(self.j)\n\n            center_offset = Vector2D(x=i, y=j)\n            if not state.is_region or backend.options.draw_region_outlines:\n                yield backend.get_draw_arc_cls()(\n                    backend=backend,\n                    polarity=polarity,\n                    start_position=start_position,\n                    dx_dy_center=center_offset,\n                    end_position=end_position,\n                    width=current_aperture.get_line_width(),\n                    is_clockwise=(state.draw_mode == DrawMode.ClockwiseCircular),\n                    # Will require tweaking if support for single quadrant mode\n                    # will be desired.\n                    is_multi_quadrant=True,\n                )\n\n        else:\n            raise NotImplementedError(state.draw_mode)\n\n        yield backend.get_draw_paste_cls()(\n            backend=backend,\n            polarity=polarity,\n            center_position=end_position,\n            other=current_aperture.drawing_target,\n        )\n\n    def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n        \"\"\"Perform actions on the context implicated by this token.\"\"\"\n        context.get_hooks().command_draw.pre_parser_visit_token(self, context)\n        context.get_hooks().command_draw.on_parser_visit_token(self, context)\n        context.get_hooks().command_draw.post_parser_visit_token(self, context)\n\n    def get_gerber_code(\n        self,\n        indent: str = \"\",\n        endline: str = \"\\n\",\n    ) -&gt; str:\n        \"\"\"Get gerber code represented by this token.\"\"\"\n        return (\n            f\"{indent}\"\n            f\"{self.x.get_gerber_code(indent, endline)}\"\n            f\"{self.y.get_gerber_code(indent, endline)}\"\n            f\"{self.i.get_gerber_code(indent, endline)}\"\n            f\"{self.j.get_gerber_code(indent, endline)}\"\n            \"D01\"\n        )\n\n    def get_state_based_hover_message(\n        self,\n        state: State,\n    ) -&gt; str:\n        \"\"\"Return operation specific extra information about token.\"\"\"\n        units = state.get_units()\n\n        x0 = state.current_position.x.as_unit(units)\n        y0 = state.current_position.x.as_unit(units)\n\n        x1 = state.parse_coordinate(self.x).as_unit(units)\n        y1 = state.parse_coordinate(self.y).as_unit(units)\n\n        draw_mode = state.draw_mode.to_human_readable()\n\n        aperture = state.get_current_aperture().aperture_id\n\n        u = units.value.lower()\n        d = state.draw_mode.value\n\n        return (\n            f\"Draw {draw_mode} (`{d}`) from (`{x0}`{u}, `{y0}`{u}) to \"\n            f\"(`{x1}`{u}, `{y1}`{u}) with aperture `{aperture}`\"\n        )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/d01_draw.html#pygerber.gerberx3.tokenizer.tokens.d01_draw.D01Draw.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(\n    string: str, location: int, tokens: ParseResults\n) -&gt; Self\n</code></pre> <p>Create instance of this class.</p> <p>Created to be used as callback in <code>ParserElement.set_parse_action()</code>.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/d01_draw.py</code> <pre><code>@classmethod\ndef new(cls, string: str, location: int, tokens: ParseResults) -&gt; Self:\n    \"\"\"Create instance of this class.\n\n    Created to be used as callback in `ParserElement.set_parse_action()`.\n    \"\"\"\n    x = tokens.get(\"x\")\n    x = Coordinate.new(\n        coordinate_type=CoordinateType.X,\n        offset=str(x) if x is not None else None,\n    )\n    y = tokens.get(\"y\")\n    y = Coordinate.new(\n        coordinate_type=CoordinateType.Y,\n        offset=str(y) if y is not None else None,\n    )\n    i = tokens.get(\"i\")\n    i = Coordinate.new(\n        coordinate_type=CoordinateType.I,\n        offset=str(i) if i is not None else None,\n    )\n    j = tokens.get(\"j\")\n    j = Coordinate.new(\n        coordinate_type=CoordinateType.J,\n        offset=str(j) if j is not None else None,\n    )\n\n    return cls(\n        string=string,\n        location=location,\n        x=x,\n        y=y,\n        i=i,\n        j=j,\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/d01_draw.html#pygerber.gerberx3.tokenizer.tokens.d01_draw.D01Draw.update_drawing_state","title":"update_drawing_state","text":"<pre><code>update_drawing_state(\n    state: State, backend: Backend\n) -&gt; Tuple[State, Iterable[DrawCommand]]\n</code></pre> <p>Set coordinate parser.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/d01_draw.py</code> <pre><code>def update_drawing_state(\n    self,\n    state: State,\n    backend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n    \"\"\"Set coordinate parser.\"\"\"\n    x = state.parse_coordinate(self.x)\n    y = state.parse_coordinate(self.y)\n\n    end_position = Vector2D(x=x, y=y)\n    start_position = state.current_position\n\n    draw_commands: list[DrawCommand] = []\n\n    if state.is_region:\n        polarity = state.polarity.to_region_variant()\n    else:\n        polarity = state.polarity\n\n    if not state.is_region or backend.options.draw_region_outlines:\n        draw_commands.extend(\n            self._create_draw_commands(\n                state,\n                backend,\n                end_position,\n                start_position,\n                polarity,\n            ),\n        )\n\n    if state.is_region:\n        self._create_region_points(\n            state,\n            backend,\n            end_position,\n            start_position,\n            polarity,\n        )\n\n    return (\n        state.model_copy(\n            update={\n                \"current_position\": end_position,\n            },\n        ),\n        draw_commands,\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/d01_draw.html#pygerber.gerberx3.tokenizer.tokens.d01_draw.D01Draw.parser2_visit_token","title":"parser2_visit_token","text":"<pre><code>parser2_visit_token(context: Parser2Context) -&gt; None\n</code></pre> <p>Perform actions on the context implicated by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/d01_draw.py</code> <pre><code>def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n    \"\"\"Perform actions on the context implicated by this token.\"\"\"\n    context.get_hooks().command_draw.pre_parser_visit_token(self, context)\n    context.get_hooks().command_draw.on_parser_visit_token(self, context)\n    context.get_hooks().command_draw.post_parser_visit_token(self, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/d01_draw.html#pygerber.gerberx3.tokenizer.tokens.d01_draw.D01Draw.get_gerber_code","title":"get_gerber_code","text":"<pre><code>get_gerber_code(\n    indent: str = \"\", endline: str = \"\\n\"\n) -&gt; str\n</code></pre> <p>Get gerber code represented by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/d01_draw.py</code> <pre><code>def get_gerber_code(\n    self,\n    indent: str = \"\",\n    endline: str = \"\\n\",\n) -&gt; str:\n    \"\"\"Get gerber code represented by this token.\"\"\"\n    return (\n        f\"{indent}\"\n        f\"{self.x.get_gerber_code(indent, endline)}\"\n        f\"{self.y.get_gerber_code(indent, endline)}\"\n        f\"{self.i.get_gerber_code(indent, endline)}\"\n        f\"{self.j.get_gerber_code(indent, endline)}\"\n        \"D01\"\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/d01_draw.html#pygerber.gerberx3.tokenizer.tokens.d01_draw.D01Draw.get_state_based_hover_message","title":"get_state_based_hover_message","text":"<pre><code>get_state_based_hover_message(state: State) -&gt; str\n</code></pre> <p>Return operation specific extra information about token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/d01_draw.py</code> <pre><code>def get_state_based_hover_message(\n    self,\n    state: State,\n) -&gt; str:\n    \"\"\"Return operation specific extra information about token.\"\"\"\n    units = state.get_units()\n\n    x0 = state.current_position.x.as_unit(units)\n    y0 = state.current_position.x.as_unit(units)\n\n    x1 = state.parse_coordinate(self.x).as_unit(units)\n    y1 = state.parse_coordinate(self.y).as_unit(units)\n\n    draw_mode = state.draw_mode.to_human_readable()\n\n    aperture = state.get_current_aperture().aperture_id\n\n    u = units.value.lower()\n    d = state.draw_mode.value\n\n    return (\n        f\"Draw {draw_mode} (`{d}`) from (`{x0}`{u}, `{y0}`{u}) to \"\n        f\"(`{x1}`{u}, `{y1}`{u}) with aperture `{aperture}`\"\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/d02_move.html","title":"d02_move","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/d02_move.html#pygerber.gerberx3.tokenizer.tokens.d02_move","title":"d02_move","text":"<p>Wrapper for move operation token.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/d02_move.html#pygerber.gerberx3.tokenizer.tokens.d02_move.D02Move","title":"D02Move","text":"<p>             Bases: <code>CommandToken</code></p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/d02_move.html#pygerber.gerberx3.tokenizer.tokens.d02_move.D02Move--483-move-d02","title":"4.8.3 Move (D02).","text":"<p>Moves the current point to the (X,Y) in the comment. The syntax is:</p> <pre><code>D02 = (['X' x_coordinate] ['Y' y_coordinate] 'D02') '*';\n</code></pre> <ul> <li>x_coordinate - <code>&lt;Coordinate&gt;</code> is coordinate data - see section 0. It defines the X     coordinate of the new current point. The default is the X coordinate of     the old current point.</li> <li>y_coordinate - As above, but for the Y coordinate.</li> <li>D02 - Move operation code</li> </ul>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/d02_move.html#pygerber.gerberx3.tokenizer.tokens.d02_move.D02Move--example","title":"Example","text":"<pre><code>X2152000Y1215000D02*\n</code></pre> <p>See section 4.8.3 of The Gerber Layer Format Specification</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/d02_move.py</code> <pre><code>class D02Move(CommandToken):\n    \"\"\"## 4.8.3 Move (D02).\n\n    Moves the current point to the (X,Y) in the comment. The syntax is:\n\n    ```ebnf\n    D02 = (['X' x_coordinate] ['Y' y_coordinate] 'D02') '*';\n    ```\n\n    - x_coordinate - `&lt;Coordinate&gt;` is coordinate data - see section 0. It defines the X\n        coordinate of the new current point. The default is the X coordinate of\n        the old current point.\n    - y_coordinate - As above, but for the Y coordinate.\n    - D02 - Move operation code\n\n    ---\n\n    ## Example\n\n    ```gerber\n    X2152000Y1215000D02*\n    ```\n\n    ---\n\n    See section 4.8.3 of [The Gerber Layer Format Specification](https://www.ucamco.com/files/downloads/file_en/456/gerber-layer-format-specification-revision-2023-08_en.pdf#page=83)\n\n    \"\"\"\n\n    def __init__(\n        self,\n        string: str,\n        location: int,\n        x: Coordinate,\n        y: Coordinate,\n    ) -&gt; None:\n        super().__init__(string, location)\n        self.x = x\n        self.y = y\n\n    @classmethod\n    def new(cls, string: str, location: int, tokens: ParseResults) -&gt; Self:\n        \"\"\"Create instance of this class.\n\n        Created to be used as callback in `ParserElement.set_parse_action()`.\n        \"\"\"\n        x = tokens.get(\"x\")\n        x = Coordinate.new(\n            coordinate_type=CoordinateType.X,\n            offset=str(x) if x is not None else None,\n        )\n        y = tokens.get(\"y\")\n        y = Coordinate.new(\n            coordinate_type=CoordinateType.Y,\n            offset=str(y) if y is not None else None,\n        )\n\n        return cls(\n            string=string,\n            location=location,\n            x=x,\n            y=y,\n        )\n\n    def update_drawing_state(\n        self,\n        state: State,\n        _backend: Backend,\n    ) -&gt; Tuple[State, Iterable[DrawCommand]]:\n        \"\"\"Set coordinate parser.\"\"\"\n        x = state.parse_coordinate(self.x)\n        y = state.parse_coordinate(self.y)\n\n        position = Vector2D(x=x, y=y)\n        return (\n            state.model_copy(\n                update={\n                    \"current_position\": position,\n                },\n            ),\n            (),\n        )\n\n    def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n        \"\"\"Perform actions on the context implicated by this token.\"\"\"\n        context.get_hooks().command_move.pre_parser_visit_token(self, context)\n        context.get_hooks().command_move.on_parser_visit_token(self, context)\n        context.get_hooks().command_move.post_parser_visit_token(self, context)\n\n    def get_gerber_code(\n        self,\n        indent: str = \"\",\n        endline: str = \"\\n\",\n    ) -&gt; str:\n        \"\"\"Get gerber code represented by this token.\"\"\"\n        return (\n            f\"{indent}\"\n            f\"{self.x.get_gerber_code(indent, endline)}\"\n            f\"{self.y.get_gerber_code(indent, endline)}\"\n            \"D02\"\n        )\n\n    def get_state_based_hover_message(\n        self,\n        state: State,\n    ) -&gt; str:\n        \"\"\"Return operation specific extra information about token.\"\"\"\n        units = state.get_units()\n\n        x0 = state.current_position.x.as_unit(units)\n        y0 = state.current_position.x.as_unit(units)\n\n        x1 = state.parse_coordinate(self.x).as_unit(units)\n        y1 = state.parse_coordinate(self.y).as_unit(units)\n\n        u = units.value.lower()\n\n        return f\"Move from (`{x0}`{u}, `{y0}`{u}) to (`{x1}`{u}, `{y1}`{u})\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/d02_move.html#pygerber.gerberx3.tokenizer.tokens.d02_move.D02Move.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(\n    string: str, location: int, tokens: ParseResults\n) -&gt; Self\n</code></pre> <p>Create instance of this class.</p> <p>Created to be used as callback in <code>ParserElement.set_parse_action()</code>.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/d02_move.py</code> <pre><code>@classmethod\ndef new(cls, string: str, location: int, tokens: ParseResults) -&gt; Self:\n    \"\"\"Create instance of this class.\n\n    Created to be used as callback in `ParserElement.set_parse_action()`.\n    \"\"\"\n    x = tokens.get(\"x\")\n    x = Coordinate.new(\n        coordinate_type=CoordinateType.X,\n        offset=str(x) if x is not None else None,\n    )\n    y = tokens.get(\"y\")\n    y = Coordinate.new(\n        coordinate_type=CoordinateType.Y,\n        offset=str(y) if y is not None else None,\n    )\n\n    return cls(\n        string=string,\n        location=location,\n        x=x,\n        y=y,\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/d02_move.html#pygerber.gerberx3.tokenizer.tokens.d02_move.D02Move.update_drawing_state","title":"update_drawing_state","text":"<pre><code>update_drawing_state(\n    state: State, _backend: Backend\n) -&gt; Tuple[State, Iterable[DrawCommand]]\n</code></pre> <p>Set coordinate parser.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/d02_move.py</code> <pre><code>def update_drawing_state(\n    self,\n    state: State,\n    _backend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n    \"\"\"Set coordinate parser.\"\"\"\n    x = state.parse_coordinate(self.x)\n    y = state.parse_coordinate(self.y)\n\n    position = Vector2D(x=x, y=y)\n    return (\n        state.model_copy(\n            update={\n                \"current_position\": position,\n            },\n        ),\n        (),\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/d02_move.html#pygerber.gerberx3.tokenizer.tokens.d02_move.D02Move.parser2_visit_token","title":"parser2_visit_token","text":"<pre><code>parser2_visit_token(context: Parser2Context) -&gt; None\n</code></pre> <p>Perform actions on the context implicated by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/d02_move.py</code> <pre><code>def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n    \"\"\"Perform actions on the context implicated by this token.\"\"\"\n    context.get_hooks().command_move.pre_parser_visit_token(self, context)\n    context.get_hooks().command_move.on_parser_visit_token(self, context)\n    context.get_hooks().command_move.post_parser_visit_token(self, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/d02_move.html#pygerber.gerberx3.tokenizer.tokens.d02_move.D02Move.get_gerber_code","title":"get_gerber_code","text":"<pre><code>get_gerber_code(\n    indent: str = \"\", endline: str = \"\\n\"\n) -&gt; str\n</code></pre> <p>Get gerber code represented by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/d02_move.py</code> <pre><code>def get_gerber_code(\n    self,\n    indent: str = \"\",\n    endline: str = \"\\n\",\n) -&gt; str:\n    \"\"\"Get gerber code represented by this token.\"\"\"\n    return (\n        f\"{indent}\"\n        f\"{self.x.get_gerber_code(indent, endline)}\"\n        f\"{self.y.get_gerber_code(indent, endline)}\"\n        \"D02\"\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/d02_move.html#pygerber.gerberx3.tokenizer.tokens.d02_move.D02Move.get_state_based_hover_message","title":"get_state_based_hover_message","text":"<pre><code>get_state_based_hover_message(state: State) -&gt; str\n</code></pre> <p>Return operation specific extra information about token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/d02_move.py</code> <pre><code>def get_state_based_hover_message(\n    self,\n    state: State,\n) -&gt; str:\n    \"\"\"Return operation specific extra information about token.\"\"\"\n    units = state.get_units()\n\n    x0 = state.current_position.x.as_unit(units)\n    y0 = state.current_position.x.as_unit(units)\n\n    x1 = state.parse_coordinate(self.x).as_unit(units)\n    y1 = state.parse_coordinate(self.y).as_unit(units)\n\n    u = units.value.lower()\n\n    return f\"Move from (`{x0}`{u}, `{y0}`{u}) to (`{x1}`{u}, `{y1}`{u})\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/d03_flash.html","title":"d03_flash","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/d03_flash.html#pygerber.gerberx3.tokenizer.tokens.d03_flash","title":"d03_flash","text":"<p>Wrapper for flash operation token.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/d03_flash.html#pygerber.gerberx3.tokenizer.tokens.d03_flash.D03Flash","title":"D03Flash","text":"<p>             Bases: <code>CommandToken</code></p> <p>Wrapper for flash operation token.</p> <p>Creates a flash object with the current aperture. The current point is moved to the flash point.</p> <p>See section 4.8.4 of The Gerber Layer Format Specification Revision 2023.03 - https://argmaster.github.io/pygerber/latest/gerber_specification/revision_2023_03.html</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/d03_flash.py</code> <pre><code>class D03Flash(CommandToken):\n    \"\"\"Wrapper for flash operation token.\n\n    Creates a flash object with the current aperture. The current point is moved to the\n    flash point.\n\n    See section 4.8.4 of The Gerber Layer Format Specification Revision 2023.03 - https://argmaster.github.io/pygerber/latest/gerber_specification/revision_2023_03.html\n    \"\"\"\n\n    def __init__(\n        self,\n        string: str,\n        location: int,\n        x: Coordinate,\n        y: Coordinate,\n    ) -&gt; None:\n        super().__init__(string, location)\n        self.x = x\n        self.y = y\n\n    @classmethod\n    def new(cls, string: str, location: int, tokens: ParseResults) -&gt; Self:\n        \"\"\"Create instance of this class.\n\n        Created to be used as callback in `ParserElement.set_parse_action()`.\n        \"\"\"\n        x = tokens.get(\"x\")\n        x = Coordinate.new(\n            coordinate_type=CoordinateType.X,\n            offset=str(x) if x is not None else None,\n        )\n        y = tokens.get(\"y\")\n        y = Coordinate.new(\n            coordinate_type=CoordinateType.Y,\n            offset=str(y) if y is not None else None,\n        )\n\n        return cls(\n            string=string,\n            location=location,\n            x=x,\n            y=y,\n        )\n\n    def update_drawing_state(\n        self,\n        state: State,\n        backend: Backend,\n    ) -&gt; Tuple[State, Iterable[DrawCommand]]:\n        \"\"\"Set coordinate parser.\"\"\"\n        x = state.parse_coordinate(self.x)\n        y = state.parse_coordinate(self.y)\n\n        position = Vector2D(x=x, y=y)\n        draw_commands: list[DrawCommand] = []\n        current_aperture = backend.get_private_aperture_handle(\n            state.get_current_aperture(),\n        )\n        if state.is_region:\n            polarity = state.polarity.to_region_variant()\n        else:\n            polarity = state.polarity\n\n        draw_commands.append(\n            backend.get_draw_paste_cls()(\n                backend=backend,\n                polarity=polarity,\n                center_position=position,\n                other=current_aperture.drawing_target,\n            ),\n        )\n\n        return (\n            state.model_copy(\n                update={\n                    \"current_position\": position,\n                },\n            ),\n            draw_commands,\n        )\n\n    def get_gerber_code(\n        self,\n        indent: str = \"\",\n        endline: str = \"\\n\",\n    ) -&gt; str:\n        \"\"\"Get gerber code represented by this token.\"\"\"\n        return (\n            f\"{indent}\"\n            f\"{self.x.get_gerber_code(indent, endline)}\"\n            f\"{self.y.get_gerber_code(indent, endline)}\"\n            \"D03\"\n        )\n\n    def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n        \"\"\"Perform actions on the context implicated by this token.\"\"\"\n        context.get_hooks().command_flash.pre_parser_visit_token(self, context)\n        context.get_hooks().command_flash.on_parser_visit_token(self, context)\n        context.get_hooks().command_flash.post_parser_visit_token(self, context)\n\n    def get_state_based_hover_message(\n        self,\n        state: State,\n    ) -&gt; str:\n        \"\"\"Return operation specific extra information about token.\"\"\"\n        units = state.get_units()\n\n        x1 = state.parse_coordinate(self.x).as_unit(units)\n        y1 = state.parse_coordinate(self.y).as_unit(units)\n\n        aperture = state.get_current_aperture().aperture_id\n\n        u = units.value.lower()\n\n        return f\"Flash `{aperture}` on (`{x1}`{u}, `{y1}`{u})\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/d03_flash.html#pygerber.gerberx3.tokenizer.tokens.d03_flash.D03Flash.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(\n    string: str, location: int, tokens: ParseResults\n) -&gt; Self\n</code></pre> <p>Create instance of this class.</p> <p>Created to be used as callback in <code>ParserElement.set_parse_action()</code>.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/d03_flash.py</code> <pre><code>@classmethod\ndef new(cls, string: str, location: int, tokens: ParseResults) -&gt; Self:\n    \"\"\"Create instance of this class.\n\n    Created to be used as callback in `ParserElement.set_parse_action()`.\n    \"\"\"\n    x = tokens.get(\"x\")\n    x = Coordinate.new(\n        coordinate_type=CoordinateType.X,\n        offset=str(x) if x is not None else None,\n    )\n    y = tokens.get(\"y\")\n    y = Coordinate.new(\n        coordinate_type=CoordinateType.Y,\n        offset=str(y) if y is not None else None,\n    )\n\n    return cls(\n        string=string,\n        location=location,\n        x=x,\n        y=y,\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/d03_flash.html#pygerber.gerberx3.tokenizer.tokens.d03_flash.D03Flash.update_drawing_state","title":"update_drawing_state","text":"<pre><code>update_drawing_state(\n    state: State, backend: Backend\n) -&gt; Tuple[State, Iterable[DrawCommand]]\n</code></pre> <p>Set coordinate parser.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/d03_flash.py</code> <pre><code>def update_drawing_state(\n    self,\n    state: State,\n    backend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n    \"\"\"Set coordinate parser.\"\"\"\n    x = state.parse_coordinate(self.x)\n    y = state.parse_coordinate(self.y)\n\n    position = Vector2D(x=x, y=y)\n    draw_commands: list[DrawCommand] = []\n    current_aperture = backend.get_private_aperture_handle(\n        state.get_current_aperture(),\n    )\n    if state.is_region:\n        polarity = state.polarity.to_region_variant()\n    else:\n        polarity = state.polarity\n\n    draw_commands.append(\n        backend.get_draw_paste_cls()(\n            backend=backend,\n            polarity=polarity,\n            center_position=position,\n            other=current_aperture.drawing_target,\n        ),\n    )\n\n    return (\n        state.model_copy(\n            update={\n                \"current_position\": position,\n            },\n        ),\n        draw_commands,\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/d03_flash.html#pygerber.gerberx3.tokenizer.tokens.d03_flash.D03Flash.get_gerber_code","title":"get_gerber_code","text":"<pre><code>get_gerber_code(\n    indent: str = \"\", endline: str = \"\\n\"\n) -&gt; str\n</code></pre> <p>Get gerber code represented by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/d03_flash.py</code> <pre><code>def get_gerber_code(\n    self,\n    indent: str = \"\",\n    endline: str = \"\\n\",\n) -&gt; str:\n    \"\"\"Get gerber code represented by this token.\"\"\"\n    return (\n        f\"{indent}\"\n        f\"{self.x.get_gerber_code(indent, endline)}\"\n        f\"{self.y.get_gerber_code(indent, endline)}\"\n        \"D03\"\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/d03_flash.html#pygerber.gerberx3.tokenizer.tokens.d03_flash.D03Flash.parser2_visit_token","title":"parser2_visit_token","text":"<pre><code>parser2_visit_token(context: Parser2Context) -&gt; None\n</code></pre> <p>Perform actions on the context implicated by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/d03_flash.py</code> <pre><code>def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n    \"\"\"Perform actions on the context implicated by this token.\"\"\"\n    context.get_hooks().command_flash.pre_parser_visit_token(self, context)\n    context.get_hooks().command_flash.on_parser_visit_token(self, context)\n    context.get_hooks().command_flash.post_parser_visit_token(self, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/d03_flash.html#pygerber.gerberx3.tokenizer.tokens.d03_flash.D03Flash.get_state_based_hover_message","title":"get_state_based_hover_message","text":"<pre><code>get_state_based_hover_message(state: State) -&gt; str\n</code></pre> <p>Return operation specific extra information about token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/d03_flash.py</code> <pre><code>def get_state_based_hover_message(\n    self,\n    state: State,\n) -&gt; str:\n    \"\"\"Return operation specific extra information about token.\"\"\"\n    units = state.get_units()\n\n    x1 = state.parse_coordinate(self.x).as_unit(units)\n    y1 = state.parse_coordinate(self.y).as_unit(units)\n\n    aperture = state.get_current_aperture().aperture_id\n\n    u = units.value.lower()\n\n    return f\"Flash `{aperture}` on (`{x1}`{u}, `{y1}`{u})\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/dnn_select_aperture.html","title":"dnn_select_aperture","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/dnn_select_aperture.html#pygerber.gerberx3.tokenizer.tokens.dnn_select_aperture","title":"dnn_select_aperture","text":"<p>Wrapper for aperture select token.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/dnn_select_aperture.html#pygerber.gerberx3.tokenizer.tokens.dnn_select_aperture.DNNSelectAperture","title":"DNNSelectAperture","text":"<p>             Bases: <code>CommandToken</code></p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/dnn_select_aperture.html#pygerber.gerberx3.tokenizer.tokens.dnn_select_aperture.DNNSelectAperture--46-current-aperture-dnn","title":"4.6 Current Aperture (Dnn).","text":"<p>The command Dnn (nn\u226510) sets the current aperture graphics state parameter. The syntax is:</p> <pre><code>Dnn = 'D unsigned_integer '*';\n</code></pre> <ul> <li><code>D</code> - Command code.</li> <li><code>&lt;aperture number&gt;</code> - The aperture number (integer \u226510). An aperture with that number must be in the apertures dictionary.</li> </ul> <p>D-commands 0 to 9 are reserved and cannot be used for apertures. The D01 and D03 commands use the current aperture to create track and flash graphical objects.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/dnn_select_aperture.html#pygerber.gerberx3.tokenizer.tokens.dnn_select_aperture.DNNSelectAperture--example","title":"Example","text":"<pre><code>D10*\n</code></pre> <p>See section 4.6 of The Gerber Layer Format Specification</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/dnn_select_aperture.py</code> <pre><code>class DNNSelectAperture(CommandToken):\n    \"\"\"## 4.6 Current Aperture (Dnn).\n\n    The command Dnn (nn\u226510) sets the current aperture graphics state parameter. The syntax is:\n\n    ```ebnf\n    Dnn = 'D unsigned_integer '*';\n    ```\n\n    - `D` - Command code.\n    - `&lt;aperture number&gt;` - The aperture number (integer \u226510). An aperture with that number must be in the apertures dictionary.\n\n    D-commands 0 to 9 are reserved and cannot be used for apertures. The D01 and D03\n    commands use the current aperture to create track and flash graphical objects.\n\n    ---\n\n    ## Example\n\n    ```gerber\n    D10*\n    ```\n\n    ---\n\n    See section 4.6 of [The Gerber Layer Format Specification](https://www.ucamco.com/files/downloads/file_en/456/gerber-layer-format-specification-revision-2023-08_en.pdf#page=75)\n\n    \"\"\"  # noqa: E501\n\n    def __init__(self, string: str, location: int, aperture_id: ApertureID) -&gt; None:\n        super().__init__(string, location)\n        self.aperture_id = aperture_id\n\n    @classmethod\n    def new(cls, string: str, location: int, tokens: ParseResults) -&gt; Self:\n        \"\"\"Create instance of this class.\n\n        Created to be used as callback in `ParserElement.set_parse_action()`.\n        \"\"\"\n        return cls(\n            string=string,\n            location=location,\n            aperture_id=ApertureID(tokens[\"aperture_identifier\"]),\n        )\n\n    def update_drawing_state(\n        self,\n        state: State,\n        _backend: Backend,\n    ) -&gt; Tuple[State, Iterable[DrawCommand]]:\n        \"\"\"Set current aperture.\"\"\"\n        if self.aperture_id not in state.apertures:\n            raise ApertureNotDefinedError(self.aperture_id)\n        return (\n            state.model_copy(\n                update={\n                    \"current_aperture\": state.apertures[self.aperture_id],\n                },\n            ),\n            (),\n        )\n\n    def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n        \"\"\"Perform actions on the context implicated by this token.\"\"\"\n        context.get_hooks().select_aperture.pre_parser_visit_token(self, context)\n        context.get_hooks().select_aperture.on_parser_visit_token(self, context)\n        context.get_hooks().select_aperture.post_parser_visit_token(self, context)\n\n    def get_gerber_code(\n        self,\n        indent: str = \"\",\n        endline: str = \"\\n\",\n    ) -&gt; str:\n        \"\"\"Get gerber code represented by this token.\"\"\"\n        return f\"{indent}{self.aperture_id.get_gerber_code(indent, endline)}\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/dnn_select_aperture.html#pygerber.gerberx3.tokenizer.tokens.dnn_select_aperture.DNNSelectAperture.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(\n    string: str, location: int, tokens: ParseResults\n) -&gt; Self\n</code></pre> <p>Create instance of this class.</p> <p>Created to be used as callback in <code>ParserElement.set_parse_action()</code>.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/dnn_select_aperture.py</code> <pre><code>@classmethod\ndef new(cls, string: str, location: int, tokens: ParseResults) -&gt; Self:\n    \"\"\"Create instance of this class.\n\n    Created to be used as callback in `ParserElement.set_parse_action()`.\n    \"\"\"\n    return cls(\n        string=string,\n        location=location,\n        aperture_id=ApertureID(tokens[\"aperture_identifier\"]),\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/dnn_select_aperture.html#pygerber.gerberx3.tokenizer.tokens.dnn_select_aperture.DNNSelectAperture.update_drawing_state","title":"update_drawing_state","text":"<pre><code>update_drawing_state(\n    state: State, _backend: Backend\n) -&gt; Tuple[State, Iterable[DrawCommand]]\n</code></pre> <p>Set current aperture.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/dnn_select_aperture.py</code> <pre><code>def update_drawing_state(\n    self,\n    state: State,\n    _backend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n    \"\"\"Set current aperture.\"\"\"\n    if self.aperture_id not in state.apertures:\n        raise ApertureNotDefinedError(self.aperture_id)\n    return (\n        state.model_copy(\n            update={\n                \"current_aperture\": state.apertures[self.aperture_id],\n            },\n        ),\n        (),\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/dnn_select_aperture.html#pygerber.gerberx3.tokenizer.tokens.dnn_select_aperture.DNNSelectAperture.parser2_visit_token","title":"parser2_visit_token","text":"<pre><code>parser2_visit_token(context: Parser2Context) -&gt; None\n</code></pre> <p>Perform actions on the context implicated by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/dnn_select_aperture.py</code> <pre><code>def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n    \"\"\"Perform actions on the context implicated by this token.\"\"\"\n    context.get_hooks().select_aperture.pre_parser_visit_token(self, context)\n    context.get_hooks().select_aperture.on_parser_visit_token(self, context)\n    context.get_hooks().select_aperture.post_parser_visit_token(self, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/dnn_select_aperture.html#pygerber.gerberx3.tokenizer.tokens.dnn_select_aperture.DNNSelectAperture.get_gerber_code","title":"get_gerber_code","text":"<pre><code>get_gerber_code(\n    indent: str = \"\", endline: str = \"\\n\"\n) -&gt; str\n</code></pre> <p>Get gerber code represented by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/dnn_select_aperture.py</code> <pre><code>def get_gerber_code(\n    self,\n    indent: str = \"\",\n    endline: str = \"\\n\",\n) -&gt; str:\n    \"\"\"Get gerber code represented by this token.\"\"\"\n    return f\"{indent}{self.aperture_id.get_gerber_code(indent, endline)}\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/end_of_expression.html","title":"end_of_expression","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/end_of_expression.html#pygerber.gerberx3.tokenizer.tokens.end_of_expression","title":"end_of_expression","text":"<p>Wrapper for G74 token.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/end_of_expression.html#pygerber.gerberx3.tokenizer.tokens.end_of_expression.EndOfExpression","title":"EndOfExpression","text":"<p>             Bases: <code>Token</code></p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/end_of_expression.html#pygerber.gerberx3.tokenizer.tokens.end_of_expression.EndOfExpression--33-commands-end-of-command","title":"3.3 Commands (<code>'*' - end of command</code>).","text":"<p>Commands are the core syntactic element of the Gerber format. A Gerber file is a stream of commands. Commands define the graphics state, create graphical objects, defines apertures, manage attributes and so on.</p> <p>Commands are built with words, the basic syntactic building block of a Gerber file. A word is a non-empty character string, excluding the reserved characters '' and '%', terminated with an ''</p> <pre><code>word = {free_character}+ '*';\n</code></pre> <p>For historic reasons, there are two command syntax styles: word commands and extended commands.</p> <p>(...)</p> <p>The example below shows a stream of Gerber commands.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/end_of_expression.html#pygerber.gerberx3.tokenizer.tokens.end_of_expression.EndOfExpression--example","title":"Example","text":"<pre><code>G04 Different command styles*\nG75*\nG02*\nD10*\nX0Y0D02*\nX2000000Y0I1000000J0D01*\nD11*\nX0Y2000000D03*\nM02*\n</code></pre> <p>See section 3.3 of The Gerber Layer Format Specification</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/end_of_expression.py</code> <pre><code>class EndOfExpression(Token):\n    \"\"\"## 3.3 Commands (`'*' - end of command`).\n\n    Commands are the core syntactic element of the Gerber format. A Gerber file is a stream of\n    commands. Commands define the graphics state, create graphical objects, defines apertures,\n    manage attributes and so on.\n\n    Commands are built with words, the basic syntactic building block of a Gerber file. A word is a\n    non-empty character string, excluding the reserved characters '*' and '%', terminated with an '*'\n\n    ```ebnf\n    word = {free_character}+ '*';\n    ```\n\n    For historic reasons, there are two command syntax styles: word commands and extended\n    commands.\n\n    (...)\n\n    The example below shows a stream of Gerber commands.\n\n    ---\n\n    ## Example\n\n    ```gerber\n    G04 Different command styles*\n    G75*\n    G02*\n    D10*\n    X0Y0D02*\n    X2000000Y0I1000000J0D01*\n    D11*\n    X0Y2000000D03*\n    M02*\n    ```\n\n    ---\n\n    See section 3.3 of [The Gerber Layer Format Specification](https://www.ucamco.com/files/downloads/file_en/456/gerber-layer-format-specification-revision-2023-08_en.pdf#page=33)\n\n    \"\"\"  # noqa: E501\n\n    def get_gerber_code(\n        self,\n        indent: str = \"\",  # noqa: ARG002\n        endline: str = \"\\n\",  # noqa: ARG002\n    ) -&gt; str:\n        \"\"\"Get gerber code represented by this token.\"\"\"\n        return \"*\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/end_of_expression.html#pygerber.gerberx3.tokenizer.tokens.end_of_expression.EndOfExpression.get_gerber_code","title":"get_gerber_code","text":"<pre><code>get_gerber_code(\n    indent: str = \"\", endline: str = \"\\n\"\n) -&gt; str\n</code></pre> <p>Get gerber code represented by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/end_of_expression.py</code> <pre><code>def get_gerber_code(\n    self,\n    indent: str = \"\",  # noqa: ARG002\n    endline: str = \"\\n\",  # noqa: ARG002\n) -&gt; str:\n    \"\"\"Get gerber code represented by this token.\"\"\"\n    return \"*\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/fs_coordinate_format.html","title":"fs_coordinate_format","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/fs_coordinate_format.html#pygerber.gerberx3.tokenizer.tokens.fs_coordinate_format","title":"fs_coordinate_format","text":"<p>Coordinate format token.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/fs_coordinate_format.html#pygerber.gerberx3.tokenizer.tokens.fs_coordinate_format.CoordinateFormat","title":"CoordinateFormat","text":"<p>             Bases: <code>ExtendedCommandToken</code></p> <p>Description of coordinate format token.</p> <p>See: -   section 4.1.1 of The Gerber Layer Format Specification Revision 2023.03 - https://argmaster.github.io/pygerber/latest/gerber_specification/revision_2023_03.html -   section 4.2.2 of The Gerber Layer Format Specification Revision 2023.03 - https://argmaster.github.io/pygerber/latest/gerber_specification/revision_2023_03.html</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/fs_coordinate_format.py</code> <pre><code>class CoordinateFormat(ExtendedCommandToken):\n    \"\"\"Description of coordinate format token.\n\n    See:\n    -   section 4.1.1 of The Gerber Layer Format Specification Revision 2023.03 - https://argmaster.github.io/pygerber/latest/gerber_specification/revision_2023_03.html\n    -   section 4.2.2 of The Gerber Layer Format Specification Revision 2023.03 - https://argmaster.github.io/pygerber/latest/gerber_specification/revision_2023_03.html\n    \"\"\"\n\n    def __init__(\n        self,\n        string: str,\n        location: int,\n        zeros_mode: TrailingZerosMode,\n        coordinate_mode: CoordinateMode,\n        x_format: AxisFormat,\n        y_format: AxisFormat,\n    ) -&gt; None:\n        super().__init__(string, location)\n        self.zeros_mode = zeros_mode\n        self.coordinate_mode = coordinate_mode\n        self.x_format = x_format\n        self.y_format = y_format\n\n    @classmethod\n    def new(cls, string: str, location: int, tokens: ParseResults) -&gt; Self:\n        \"\"\"Create instance of this class.\n\n        Created to be used as callback in `ParserElement.set_parse_action()`.\n        \"\"\"\n        zeros_mode = TrailingZerosMode(tokens[\"zeros_mode\"])\n        coordinate_mode = CoordinateMode(tokens[\"coordinate_mode\"])\n        x_format = AxisFormat(\n            integer=int(str(tokens[\"x_format\"][0])),\n            decimal=int(str(tokens[\"x_format\"][1])),\n        )\n        y_format = AxisFormat(\n            integer=int(str(tokens[\"y_format\"][0])),\n            decimal=int(str(tokens[\"y_format\"][1])),\n        )\n        return cls(\n            string=string,\n            location=location,\n            zeros_mode=zeros_mode,\n            coordinate_mode=coordinate_mode,\n            x_format=x_format,\n            y_format=y_format,\n        )\n\n    def update_drawing_state(\n        self,\n        state: State,\n        _backend: Backend,\n    ) -&gt; Tuple[State, Iterable[DrawCommand]]:\n        \"\"\"Set coordinate parser.\"\"\"\n        if state.coordinate_parser is not None:\n            logging.warning(\n                \"Overriding coordinate format is illegal.\"\n                \"(See 4.2.2 in Gerber Layer Format Specification)\",\n            )\n        return (\n            state.model_copy(\n                update={\n                    \"coordinate_parser\": CoordinateParser.new(\n                        x_format=self.x_format,\n                        y_format=self.y_format,\n                    ),\n                },\n            ),\n            (),\n        )\n\n    def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n        \"\"\"Perform actions on the context implicated by this token.\"\"\"\n        context.get_hooks().coordinate_format.pre_parser_visit_token(self, context)\n        context.get_hooks().coordinate_format.on_parser_visit_token(self, context)\n        context.get_hooks().coordinate_format.post_parser_visit_token(self, context)\n\n    def get_gerber_code(\n        self,\n        indent: str = \"\",\n        endline: str = \"\\n\",\n    ) -&gt; str:\n        \"\"\"Get gerber code represented by this token.\"\"\"\n        return (\n            f\"FS\"\n            f\"{self.zeros_mode.get_gerber_code(indent, endline)}\"\n            f\"{self.coordinate_mode.get_gerber_code(indent, endline)}\"\n            f\"X{self.x_format.get_gerber_code(indent, endline)}\"\n            f\"Y{self.y_format.get_gerber_code(indent, endline)}\"\n        )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/fs_coordinate_format.html#pygerber.gerberx3.tokenizer.tokens.fs_coordinate_format.CoordinateFormat.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(\n    string: str, location: int, tokens: ParseResults\n) -&gt; Self\n</code></pre> <p>Create instance of this class.</p> <p>Created to be used as callback in <code>ParserElement.set_parse_action()</code>.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/fs_coordinate_format.py</code> <pre><code>@classmethod\ndef new(cls, string: str, location: int, tokens: ParseResults) -&gt; Self:\n    \"\"\"Create instance of this class.\n\n    Created to be used as callback in `ParserElement.set_parse_action()`.\n    \"\"\"\n    zeros_mode = TrailingZerosMode(tokens[\"zeros_mode\"])\n    coordinate_mode = CoordinateMode(tokens[\"coordinate_mode\"])\n    x_format = AxisFormat(\n        integer=int(str(tokens[\"x_format\"][0])),\n        decimal=int(str(tokens[\"x_format\"][1])),\n    )\n    y_format = AxisFormat(\n        integer=int(str(tokens[\"y_format\"][0])),\n        decimal=int(str(tokens[\"y_format\"][1])),\n    )\n    return cls(\n        string=string,\n        location=location,\n        zeros_mode=zeros_mode,\n        coordinate_mode=coordinate_mode,\n        x_format=x_format,\n        y_format=y_format,\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/fs_coordinate_format.html#pygerber.gerberx3.tokenizer.tokens.fs_coordinate_format.CoordinateFormat.update_drawing_state","title":"update_drawing_state","text":"<pre><code>update_drawing_state(\n    state: State, _backend: Backend\n) -&gt; Tuple[State, Iterable[DrawCommand]]\n</code></pre> <p>Set coordinate parser.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/fs_coordinate_format.py</code> <pre><code>def update_drawing_state(\n    self,\n    state: State,\n    _backend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n    \"\"\"Set coordinate parser.\"\"\"\n    if state.coordinate_parser is not None:\n        logging.warning(\n            \"Overriding coordinate format is illegal.\"\n            \"(See 4.2.2 in Gerber Layer Format Specification)\",\n        )\n    return (\n        state.model_copy(\n            update={\n                \"coordinate_parser\": CoordinateParser.new(\n                    x_format=self.x_format,\n                    y_format=self.y_format,\n                ),\n            },\n        ),\n        (),\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/fs_coordinate_format.html#pygerber.gerberx3.tokenizer.tokens.fs_coordinate_format.CoordinateFormat.parser2_visit_token","title":"parser2_visit_token","text":"<pre><code>parser2_visit_token(context: Parser2Context) -&gt; None\n</code></pre> <p>Perform actions on the context implicated by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/fs_coordinate_format.py</code> <pre><code>def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n    \"\"\"Perform actions on the context implicated by this token.\"\"\"\n    context.get_hooks().coordinate_format.pre_parser_visit_token(self, context)\n    context.get_hooks().coordinate_format.on_parser_visit_token(self, context)\n    context.get_hooks().coordinate_format.post_parser_visit_token(self, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/fs_coordinate_format.html#pygerber.gerberx3.tokenizer.tokens.fs_coordinate_format.CoordinateFormat.get_gerber_code","title":"get_gerber_code","text":"<pre><code>get_gerber_code(\n    indent: str = \"\", endline: str = \"\\n\"\n) -&gt; str\n</code></pre> <p>Get gerber code represented by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/fs_coordinate_format.py</code> <pre><code>def get_gerber_code(\n    self,\n    indent: str = \"\",\n    endline: str = \"\\n\",\n) -&gt; str:\n    \"\"\"Get gerber code represented by this token.\"\"\"\n    return (\n        f\"FS\"\n        f\"{self.zeros_mode.get_gerber_code(indent, endline)}\"\n        f\"{self.coordinate_mode.get_gerber_code(indent, endline)}\"\n        f\"X{self.x_format.get_gerber_code(indent, endline)}\"\n        f\"Y{self.y_format.get_gerber_code(indent, endline)}\"\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/fs_coordinate_format.html#pygerber.gerberx3.tokenizer.tokens.fs_coordinate_format.TrailingZerosMode","title":"TrailingZerosMode","text":"<p>             Bases: <code>GerberCodeEnum</code></p> <p>Coordinate format mode.</p> <p>GerberX3 supports only one, L, the other is required for backwards compatibility.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/fs_coordinate_format.py</code> <pre><code>class TrailingZerosMode(GerberCodeEnum):\n    \"\"\"Coordinate format mode.\n\n    GerberX3 supports only one, L, the other is required for backwards compatibility.\n    \"\"\"\n\n    OmitLeading = \"L\"\n    OmitTrailing = \"T\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/fs_coordinate_format.html#pygerber.gerberx3.tokenizer.tokens.fs_coordinate_format.CoordinateMode","title":"CoordinateMode","text":"<p>             Bases: <code>GerberCodeEnum</code></p> <p>Coordinate format mode.</p> <p>GerberX3 supports only one, A, the other required for backwards compatibility.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/fs_coordinate_format.py</code> <pre><code>class CoordinateMode(GerberCodeEnum):\n    \"\"\"Coordinate format mode.\n\n    GerberX3 supports only one, A, the other required for backwards compatibility.\n    \"\"\"\n\n    Absolute = \"A\"\n    Incremental = \"I\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/fs_coordinate_format.html#pygerber.gerberx3.tokenizer.tokens.fs_coordinate_format.AxisFormat","title":"AxisFormat","text":"<p>             Bases: <code>FrozenGeneralModel</code>, <code>GerberCode</code></p> <p>Wrapper for single axis format.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/fs_coordinate_format.py</code> <pre><code>class AxisFormat(FrozenGeneralModel, GerberCode):\n    \"\"\"Wrapper for single axis format.\"\"\"\n\n    integer: int\n    decimal: int\n\n    @property\n    def total_length(self) -&gt; int:\n        \"\"\"Total format length.\"\"\"\n        return self.integer + self.decimal\n\n    def __str__(self) -&gt; str:\n        return f\"{self.integer}{self.decimal}\"\n\n    def get_gerber_code(\n        self,\n        indent: str = \"\",\n        endline: str = \"\\n\",  # noqa: ARG002\n    ) -&gt; str:\n        \"\"\"Get gerber code represented by this token.\"\"\"\n        return f\"{indent}{self.integer}{self.decimal}\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/fs_coordinate_format.html#pygerber.gerberx3.tokenizer.tokens.fs_coordinate_format.AxisFormat.total_length","title":"total_length  <code>property</code>","text":"<pre><code>total_length: int\n</code></pre> <p>Total format length.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/fs_coordinate_format.html#pygerber.gerberx3.tokenizer.tokens.fs_coordinate_format.AxisFormat.get_gerber_code","title":"get_gerber_code","text":"<pre><code>get_gerber_code(\n    indent: str = \"\", endline: str = \"\\n\"\n) -&gt; str\n</code></pre> <p>Get gerber code represented by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/fs_coordinate_format.py</code> <pre><code>def get_gerber_code(\n    self,\n    indent: str = \"\",\n    endline: str = \"\\n\",  # noqa: ARG002\n) -&gt; str:\n    \"\"\"Get gerber code represented by this token.\"\"\"\n    return f\"{indent}{self.integer}{self.decimal}\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/fs_coordinate_format.html#pygerber.gerberx3.tokenizer.tokens.fs_coordinate_format.CoordinateParser","title":"CoordinateParser","text":"<p>             Bases: <code>FrozenGeneralModel</code></p> <p>Coordinate Parser class.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/fs_coordinate_format.py</code> <pre><code>class CoordinateParser(FrozenGeneralModel):\n    \"\"\"Coordinate Parser class.\"\"\"\n\n    x_format: AxisFormat\n    y_format: AxisFormat\n\n    @classmethod\n    def new(\n        cls,\n        x_format: AxisFormat,\n        y_format: AxisFormat,\n        coordinate_mode: CoordinateMode = CoordinateMode.Absolute,\n        zeros_mode: TrailingZerosMode = TrailingZerosMode.OmitLeading,\n    ) -&gt; Self:\n        \"\"\"Update coordinate parser format configuration.\"\"\"\n        if coordinate_mode != CoordinateMode.Absolute:\n            raise IncrementalCoordinatesNotSupportedError\n\n        if zeros_mode != TrailingZerosMode.OmitLeading:\n            raise ZeroOmissionNotSupportedError\n\n        for axis, axis_format in ((\"X\", x_format), (\"Y\", y_format)):\n            if axis_format.decimal &lt; RECOMMENDED_MINIMAL_DECIMAL_PLACES:\n                logging.warning(\n                    \"It is recommended to use at least 5 decimal places for coordinate \"\n                    \"data when using metric units and 6 decimal places for imperial \"\n                    \"units. (Detected for %s)\"\n                    \"(See 4.2.2 in Gerber Layer Format Specification)\",\n                    axis,\n                )\n\n        return cls(x_format=x_format, y_format=y_format)\n\n    def parse(self, coordinate: Coordinate) -&gt; Decimal:\n        \"\"\"Parse raw coordinate data.\"\"\"\n        if coordinate.coordinate_type in (CoordinateType.X, CoordinateType.I):\n            return self._parse(self.x_format, coordinate.offset, coordinate.sign)\n\n        if coordinate.coordinate_type in (CoordinateType.Y, CoordinateType.J):\n            return self._parse(self.y_format, coordinate.offset, coordinate.sign)\n\n        raise UnsupportedCoordinateTypeError(coordinate.coordinate_type)\n\n    def _parse(\n        self,\n        axis_format: AxisFormat,\n        offset: str,\n        sign: CoordinateSign,\n    ) -&gt; Decimal:\n        total_length = axis_format.total_length\n\n        if len(offset) &gt; total_length:\n            msg = f\"Got {offset!r} with length {len(offset)} expected {total_length}.\"\n            raise InvalidCoordinateLengthError(msg)\n\n        offset = offset.rjust(axis_format.total_length, \"0\")\n        integer, decimal = offset[: axis_format.integer], offset[axis_format.integer :]\n\n        return Decimal(f\"{sign.value}{integer}.{decimal}\")\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/fs_coordinate_format.html#pygerber.gerberx3.tokenizer.tokens.fs_coordinate_format.CoordinateParser.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(\n    x_format: AxisFormat,\n    y_format: AxisFormat,\n    coordinate_mode: CoordinateMode = CoordinateMode.Absolute,\n    zeros_mode: TrailingZerosMode = TrailingZerosMode.OmitLeading,\n) -&gt; Self\n</code></pre> <p>Update coordinate parser format configuration.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/fs_coordinate_format.py</code> <pre><code>@classmethod\ndef new(\n    cls,\n    x_format: AxisFormat,\n    y_format: AxisFormat,\n    coordinate_mode: CoordinateMode = CoordinateMode.Absolute,\n    zeros_mode: TrailingZerosMode = TrailingZerosMode.OmitLeading,\n) -&gt; Self:\n    \"\"\"Update coordinate parser format configuration.\"\"\"\n    if coordinate_mode != CoordinateMode.Absolute:\n        raise IncrementalCoordinatesNotSupportedError\n\n    if zeros_mode != TrailingZerosMode.OmitLeading:\n        raise ZeroOmissionNotSupportedError\n\n    for axis, axis_format in ((\"X\", x_format), (\"Y\", y_format)):\n        if axis_format.decimal &lt; RECOMMENDED_MINIMAL_DECIMAL_PLACES:\n            logging.warning(\n                \"It is recommended to use at least 5 decimal places for coordinate \"\n                \"data when using metric units and 6 decimal places for imperial \"\n                \"units. (Detected for %s)\"\n                \"(See 4.2.2 in Gerber Layer Format Specification)\",\n                axis,\n            )\n\n    return cls(x_format=x_format, y_format=y_format)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/fs_coordinate_format.html#pygerber.gerberx3.tokenizer.tokens.fs_coordinate_format.CoordinateParser.parse","title":"parse","text":"<pre><code>parse(coordinate: Coordinate) -&gt; Decimal\n</code></pre> <p>Parse raw coordinate data.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/fs_coordinate_format.py</code> <pre><code>def parse(self, coordinate: Coordinate) -&gt; Decimal:\n    \"\"\"Parse raw coordinate data.\"\"\"\n    if coordinate.coordinate_type in (CoordinateType.X, CoordinateType.I):\n        return self._parse(self.x_format, coordinate.offset, coordinate.sign)\n\n    if coordinate.coordinate_type in (CoordinateType.Y, CoordinateType.J):\n        return self._parse(self.y_format, coordinate.offset, coordinate.sign)\n\n    raise UnsupportedCoordinateTypeError(coordinate.coordinate_type)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g01_set_linear.html","title":"g01_set_linear","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g01_set_linear.html#pygerber.gerberx3.tokenizer.tokens.g01_set_linear","title":"g01_set_linear","text":"<p>Wrapper for G01 mode set token.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g01_set_linear.html#pygerber.gerberx3.tokenizer.tokens.g01_set_linear.SetLinear","title":"SetLinear","text":"<p>             Bases: <code>CommandToken</code></p> <p>Wrapper for G01 mode set token.</p> <p>Sets linear/circular mode to linear. See: -   section 4.8 of The Gerber Layer Format Specification Revision 2020.09 - https://argmaster.github.io/pygerber/latest/gerber_specification/revision_2020_09.html -   section 4.7 of The Gerber Layer Format Specification Revision 2023.03 - https://argmaster.github.io/pygerber/latest/gerber_specification/revision_2023_03.html</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/g01_set_linear.py</code> <pre><code>class SetLinear(CommandToken):\n    \"\"\"Wrapper for G01 mode set token.\n\n    Sets linear/circular mode to linear.\n    See:\n    -   section 4.8 of The Gerber Layer Format Specification Revision 2020.09 - https://argmaster.github.io/pygerber/latest/gerber_specification/revision_2020_09.html\n    -   section 4.7 of The Gerber Layer Format Specification Revision 2023.03 - https://argmaster.github.io/pygerber/latest/gerber_specification/revision_2023_03.html\n    \"\"\"\n\n    def update_drawing_state(\n        self,\n        state: State,\n        _backend: Backend,\n    ) -&gt; Tuple[State, Iterable[DrawCommand]]:\n        \"\"\"Set drawing mode.\"\"\"\n        return (\n            state.model_copy(\n                update={\n                    \"draw_mode\": DrawMode.Linear,\n                },\n            ),\n            (),\n        )\n\n    def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n        \"\"\"Perform actions on the context implicated by this token.\"\"\"\n        context.get_hooks().set_linear.pre_parser_visit_token(self, context)\n        context.get_hooks().set_linear.on_parser_visit_token(self, context)\n        context.get_hooks().set_linear.post_parser_visit_token(self, context)\n\n    def get_gerber_code(\n        self,\n        indent: str = \"\",\n        endline: str = \"\\n\",  # noqa: ARG002\n    ) -&gt; str:\n        \"\"\"Get gerber code represented by this token.\"\"\"\n        return f\"{indent}G01\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g01_set_linear.html#pygerber.gerberx3.tokenizer.tokens.g01_set_linear.SetLinear.update_drawing_state","title":"update_drawing_state","text":"<pre><code>update_drawing_state(\n    state: State, _backend: Backend\n) -&gt; Tuple[State, Iterable[DrawCommand]]\n</code></pre> <p>Set drawing mode.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/g01_set_linear.py</code> <pre><code>def update_drawing_state(\n    self,\n    state: State,\n    _backend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n    \"\"\"Set drawing mode.\"\"\"\n    return (\n        state.model_copy(\n            update={\n                \"draw_mode\": DrawMode.Linear,\n            },\n        ),\n        (),\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g01_set_linear.html#pygerber.gerberx3.tokenizer.tokens.g01_set_linear.SetLinear.parser2_visit_token","title":"parser2_visit_token","text":"<pre><code>parser2_visit_token(context: Parser2Context) -&gt; None\n</code></pre> <p>Perform actions on the context implicated by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/g01_set_linear.py</code> <pre><code>def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n    \"\"\"Perform actions on the context implicated by this token.\"\"\"\n    context.get_hooks().set_linear.pre_parser_visit_token(self, context)\n    context.get_hooks().set_linear.on_parser_visit_token(self, context)\n    context.get_hooks().set_linear.post_parser_visit_token(self, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g01_set_linear.html#pygerber.gerberx3.tokenizer.tokens.g01_set_linear.SetLinear.get_gerber_code","title":"get_gerber_code","text":"<pre><code>get_gerber_code(\n    indent: str = \"\", endline: str = \"\\n\"\n) -&gt; str\n</code></pre> <p>Get gerber code represented by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/g01_set_linear.py</code> <pre><code>def get_gerber_code(\n    self,\n    indent: str = \"\",\n    endline: str = \"\\n\",  # noqa: ARG002\n) -&gt; str:\n    \"\"\"Get gerber code represented by this token.\"\"\"\n    return f\"{indent}G01\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g02_set_clockwise_circular.html","title":"g02_set_clockwise_circular","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g02_set_clockwise_circular.html#pygerber.gerberx3.tokenizer.tokens.g02_set_clockwise_circular","title":"g02_set_clockwise_circular","text":"<p>Wrapper for G01 mode set token.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g02_set_clockwise_circular.html#pygerber.gerberx3.tokenizer.tokens.g02_set_clockwise_circular.SetClockwiseCircular","title":"SetClockwiseCircular","text":"<p>             Bases: <code>CommandToken</code></p> <p>Wrapper for G02 mode set token.</p> <p>Sets linear/circular mode to clockwise circular.</p> <p>See: -   section 4.8 of The Gerber Layer Format Specification Revision 2020.09 - https://argmaster.github.io/pygerber/latest/gerber_specification/revision_2020_09.html -   section 4.7 of The Gerber Layer Format Specification Revision 2023.03 - https://argmaster.github.io/pygerber/latest/gerber_specification/revision_2023_03.html</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/g02_set_clockwise_circular.py</code> <pre><code>class SetClockwiseCircular(CommandToken):\n    \"\"\"Wrapper for G02 mode set token.\n\n    Sets linear/circular mode to clockwise circular.\n\n    See:\n    -   section 4.8 of The Gerber Layer Format Specification Revision 2020.09 - https://argmaster.github.io/pygerber/latest/gerber_specification/revision_2020_09.html\n    -   section 4.7 of The Gerber Layer Format Specification Revision 2023.03 - https://argmaster.github.io/pygerber/latest/gerber_specification/revision_2023_03.html\n    \"\"\"\n\n    def update_drawing_state(\n        self,\n        state: State,\n        _backend: Backend,\n    ) -&gt; Tuple[State, Iterable[DrawCommand]]:\n        \"\"\"Set drawing mode.\"\"\"\n        return (\n            state.model_copy(\n                update={\n                    \"draw_mode\": DrawMode.ClockwiseCircular,\n                },\n            ),\n            (),\n        )\n\n    def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n        \"\"\"Perform actions on the context implicated by this token.\"\"\"\n        context.get_hooks().set_clockwise_circular.pre_parser_visit_token(self, context)\n        context.get_hooks().set_clockwise_circular.on_parser_visit_token(self, context)\n        context.get_hooks().set_clockwise_circular.post_parser_visit_token(\n            self,\n            context,\n        )\n\n    def get_gerber_code(\n        self,\n        indent: str = \"\",\n        endline: str = \"\\n\",  # noqa: ARG002\n    ) -&gt; str:\n        \"\"\"Get gerber code represented by this token.\"\"\"\n        return f\"{indent}G02\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g02_set_clockwise_circular.html#pygerber.gerberx3.tokenizer.tokens.g02_set_clockwise_circular.SetClockwiseCircular.update_drawing_state","title":"update_drawing_state","text":"<pre><code>update_drawing_state(\n    state: State, _backend: Backend\n) -&gt; Tuple[State, Iterable[DrawCommand]]\n</code></pre> <p>Set drawing mode.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/g02_set_clockwise_circular.py</code> <pre><code>def update_drawing_state(\n    self,\n    state: State,\n    _backend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n    \"\"\"Set drawing mode.\"\"\"\n    return (\n        state.model_copy(\n            update={\n                \"draw_mode\": DrawMode.ClockwiseCircular,\n            },\n        ),\n        (),\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g02_set_clockwise_circular.html#pygerber.gerberx3.tokenizer.tokens.g02_set_clockwise_circular.SetClockwiseCircular.parser2_visit_token","title":"parser2_visit_token","text":"<pre><code>parser2_visit_token(context: Parser2Context) -&gt; None\n</code></pre> <p>Perform actions on the context implicated by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/g02_set_clockwise_circular.py</code> <pre><code>def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n    \"\"\"Perform actions on the context implicated by this token.\"\"\"\n    context.get_hooks().set_clockwise_circular.pre_parser_visit_token(self, context)\n    context.get_hooks().set_clockwise_circular.on_parser_visit_token(self, context)\n    context.get_hooks().set_clockwise_circular.post_parser_visit_token(\n        self,\n        context,\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g02_set_clockwise_circular.html#pygerber.gerberx3.tokenizer.tokens.g02_set_clockwise_circular.SetClockwiseCircular.get_gerber_code","title":"get_gerber_code","text":"<pre><code>get_gerber_code(\n    indent: str = \"\", endline: str = \"\\n\"\n) -&gt; str\n</code></pre> <p>Get gerber code represented by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/g02_set_clockwise_circular.py</code> <pre><code>def get_gerber_code(\n    self,\n    indent: str = \"\",\n    endline: str = \"\\n\",  # noqa: ARG002\n) -&gt; str:\n    \"\"\"Get gerber code represented by this token.\"\"\"\n    return f\"{indent}G02\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g03_set_counterclockwise_circular.html","title":"g03_set_counterclockwise_circular","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g03_set_counterclockwise_circular.html#pygerber.gerberx3.tokenizer.tokens.g03_set_counterclockwise_circular","title":"g03_set_counterclockwise_circular","text":"<p>Wrapper for G01 mode set token.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g03_set_counterclockwise_circular.html#pygerber.gerberx3.tokenizer.tokens.g03_set_counterclockwise_circular.SetCounterclockwiseCircular","title":"SetCounterclockwiseCircular","text":"<p>             Bases: <code>CommandToken</code></p> <p>Wrapper for G03 mode set token.</p> <p>Sets linear/circular mode to counterclockwise circular.</p> <p>See: -   section 4.8 of The Gerber Layer Format Specification Revision 2020.09 - https://argmaster.github.io/pygerber/latest/gerber_specification/revision_2020_09.html -   section 4.7 of The Gerber Layer Format Specification Revision 2023.03 - https://argmaster.github.io/pygerber/latest/gerber_specification/revision_2023_03.html</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/g03_set_counterclockwise_circular.py</code> <pre><code>class SetCounterclockwiseCircular(CommandToken):\n    \"\"\"Wrapper for G03 mode set token.\n\n    Sets linear/circular mode to counterclockwise circular.\n\n    See:\n    -   section 4.8 of The Gerber Layer Format Specification Revision 2020.09 - https://argmaster.github.io/pygerber/latest/gerber_specification/revision_2020_09.html\n    -   section 4.7 of The Gerber Layer Format Specification Revision 2023.03 - https://argmaster.github.io/pygerber/latest/gerber_specification/revision_2023_03.html\n    \"\"\"\n\n    def update_drawing_state(\n        self,\n        state: State,\n        _backend: Backend,\n    ) -&gt; Tuple[State, Iterable[DrawCommand]]:\n        \"\"\"Set drawing mode.\"\"\"\n        return (\n            state.model_copy(\n                update={\n                    \"draw_mode\": DrawMode.CounterclockwiseCircular,\n                },\n            ),\n            (),\n        )\n\n    def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n        \"\"\"Perform actions on the context implicated by this token.\"\"\"\n        context.get_hooks().set_counter_clockwise_circular.pre_parser_visit_token(\n            self,\n            context,\n        )\n        context.get_hooks().set_counter_clockwise_circular.on_parser_visit_token(\n            self,\n            context,\n        )\n        context.get_hooks().set_counter_clockwise_circular.post_parser_visit_token(\n            self,\n            context,\n        )\n\n    def get_gerber_code(\n        self,\n        indent: str = \"\",\n        endline: str = \"\\n\",  # noqa: ARG002\n    ) -&gt; str:\n        \"\"\"Get gerber code represented by this token.\"\"\"\n        return f\"{indent}G03\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g03_set_counterclockwise_circular.html#pygerber.gerberx3.tokenizer.tokens.g03_set_counterclockwise_circular.SetCounterclockwiseCircular.update_drawing_state","title":"update_drawing_state","text":"<pre><code>update_drawing_state(\n    state: State, _backend: Backend\n) -&gt; Tuple[State, Iterable[DrawCommand]]\n</code></pre> <p>Set drawing mode.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/g03_set_counterclockwise_circular.py</code> <pre><code>def update_drawing_state(\n    self,\n    state: State,\n    _backend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n    \"\"\"Set drawing mode.\"\"\"\n    return (\n        state.model_copy(\n            update={\n                \"draw_mode\": DrawMode.CounterclockwiseCircular,\n            },\n        ),\n        (),\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g03_set_counterclockwise_circular.html#pygerber.gerberx3.tokenizer.tokens.g03_set_counterclockwise_circular.SetCounterclockwiseCircular.parser2_visit_token","title":"parser2_visit_token","text":"<pre><code>parser2_visit_token(context: Parser2Context) -&gt; None\n</code></pre> <p>Perform actions on the context implicated by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/g03_set_counterclockwise_circular.py</code> <pre><code>def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n    \"\"\"Perform actions on the context implicated by this token.\"\"\"\n    context.get_hooks().set_counter_clockwise_circular.pre_parser_visit_token(\n        self,\n        context,\n    )\n    context.get_hooks().set_counter_clockwise_circular.on_parser_visit_token(\n        self,\n        context,\n    )\n    context.get_hooks().set_counter_clockwise_circular.post_parser_visit_token(\n        self,\n        context,\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g03_set_counterclockwise_circular.html#pygerber.gerberx3.tokenizer.tokens.g03_set_counterclockwise_circular.SetCounterclockwiseCircular.get_gerber_code","title":"get_gerber_code","text":"<pre><code>get_gerber_code(\n    indent: str = \"\", endline: str = \"\\n\"\n) -&gt; str\n</code></pre> <p>Get gerber code represented by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/g03_set_counterclockwise_circular.py</code> <pre><code>def get_gerber_code(\n    self,\n    indent: str = \"\",\n    endline: str = \"\\n\",  # noqa: ARG002\n) -&gt; str:\n    \"\"\"Get gerber code represented by this token.\"\"\"\n    return f\"{indent}G03\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g04_comment.html","title":"g04_comment","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g04_comment.html#pygerber.gerberx3.tokenizer.tokens.g04_comment","title":"g04_comment","text":"<p>Comment token.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g04_comment.html#pygerber.gerberx3.tokenizer.tokens.g04_comment.Comment","title":"Comment","text":"<p>             Bases: <code>CommandToken</code></p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g04_comment.html#pygerber.gerberx3.tokenizer.tokens.g04_comment.Comment--41-comment-g04","title":"4.1 Comment (G04).","text":"<p>The G04 command is used for human readable comments. It does not affect the image. The syntax for G04 is as follows.</p> <pre><code>G04 = ('G04' string) '*';\n</code></pre> <p>The string must follow the string syntax in 3.4.3.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g04_comment.html#pygerber.gerberx3.tokenizer.tokens.g04_comment.Comment--example","title":"Example","text":"<pre><code>G04 This is a comment*\nG04 The space characters as well as \",\" and \";\" are allowed here.*\n</code></pre> <p>See section 4.1 of The Gerber Layer Format Specification</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/g04_comment.py</code> <pre><code>class Comment(CommandToken):\n    \"\"\"## 4.1 Comment (G04).\n\n    The G04 command is used for human readable comments. It does not affect the image.\n    The syntax for G04 is as follows.\n\n    ```ebnf\n    G04 = ('G04' string) '*';\n    ```\n\n    The string must follow the string syntax in [3.4.3](https://www.ucamco.com/files/downloads/file_en/456/gerber-layer-format-specification-revision-2023-08_en.pdf#page=35).\n\n    ---\n\n    ## Example\n\n    ```gerber\n    G04 This is a comment*\n    G04 The space characters as well as \",\" and \";\" are allowed here.*\n    ```\n\n    ---\n\n    See section 4.1 of [The Gerber Layer Format Specification](https://www.ucamco.com/files/downloads/file_en/456/gerber-layer-format-specification-revision-2023-08_en.pdf#page=44)\n\n    \"\"\"\n\n    def __init__(self, string: str, location: int, content: str) -&gt; None:\n        super().__init__(string, location)\n        self.content = content\n\n    @classmethod\n    def new(cls, string: str, location: int, tokens: ParseResults) -&gt; Self:\n        \"\"\"Create instance of this class.\n\n        Created to be used as callback in `ParserElement.set_parse_action()`.\n        \"\"\"\n        content: str = str(tokens[\"string\"])\n        return cls(string=string, location=location, content=content)\n\n    def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n        \"\"\"Perform actions on the context implicated by this token.\"\"\"\n        context.get_hooks().comment.pre_parser_visit_token(self, context)\n        context.get_hooks().comment.on_parser_visit_token(self, context)\n        context.get_hooks().comment.post_parser_visit_token(self, context)\n\n    def get_gerber_code(\n        self,\n        indent: str = \"\",\n        endline: str = \"\\n\",  # noqa: ARG002\n    ) -&gt; str:\n        \"\"\"Get gerber code represented by this token.\"\"\"\n        return f\"{indent}G04 {self.content}\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g04_comment.html#pygerber.gerberx3.tokenizer.tokens.g04_comment.Comment.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(\n    string: str, location: int, tokens: ParseResults\n) -&gt; Self\n</code></pre> <p>Create instance of this class.</p> <p>Created to be used as callback in <code>ParserElement.set_parse_action()</code>.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/g04_comment.py</code> <pre><code>@classmethod\ndef new(cls, string: str, location: int, tokens: ParseResults) -&gt; Self:\n    \"\"\"Create instance of this class.\n\n    Created to be used as callback in `ParserElement.set_parse_action()`.\n    \"\"\"\n    content: str = str(tokens[\"string\"])\n    return cls(string=string, location=location, content=content)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g04_comment.html#pygerber.gerberx3.tokenizer.tokens.g04_comment.Comment.parser2_visit_token","title":"parser2_visit_token","text":"<pre><code>parser2_visit_token(context: Parser2Context) -&gt; None\n</code></pre> <p>Perform actions on the context implicated by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/g04_comment.py</code> <pre><code>def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n    \"\"\"Perform actions on the context implicated by this token.\"\"\"\n    context.get_hooks().comment.pre_parser_visit_token(self, context)\n    context.get_hooks().comment.on_parser_visit_token(self, context)\n    context.get_hooks().comment.post_parser_visit_token(self, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g04_comment.html#pygerber.gerberx3.tokenizer.tokens.g04_comment.Comment.get_gerber_code","title":"get_gerber_code","text":"<pre><code>get_gerber_code(\n    indent: str = \"\", endline: str = \"\\n\"\n) -&gt; str\n</code></pre> <p>Get gerber code represented by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/g04_comment.py</code> <pre><code>def get_gerber_code(\n    self,\n    indent: str = \"\",\n    endline: str = \"\\n\",  # noqa: ARG002\n) -&gt; str:\n    \"\"\"Get gerber code represented by this token.\"\"\"\n    return f\"{indent}G04 {self.content}\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g36_begin_region.html","title":"g36_begin_region","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g36_begin_region.html#pygerber.gerberx3.tokenizer.tokens.g36_begin_region","title":"g36_begin_region","text":"<p>Wrapper for aperture select token.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g36_begin_region.html#pygerber.gerberx3.tokenizer.tokens.g36_begin_region.BeginRegion","title":"BeginRegion","text":"<p>             Bases: <code>CommandToken</code></p> <p>Wrapper for G36 token.</p> <p>Starts a region statement which creates a region by defining its contours.</p> <p>See section 4.10 of The Gerber Layer Format Specification Revision 2023.03 - https://argmaster.github.io/pygerber/latest/gerber_specification/revision_2023_03.html</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/g36_begin_region.py</code> <pre><code>class BeginRegion(CommandToken):\n    \"\"\"Wrapper for G36 token.\n\n    Starts a region statement which creates a region by defining its contours.\n\n    See section 4.10 of The Gerber Layer Format Specification Revision 2023.03 - https://argmaster.github.io/pygerber/latest/gerber_specification/revision_2023_03.html\n    \"\"\"\n\n    def update_drawing_state(\n        self,\n        state: State,\n        _backend: Backend,\n    ) -&gt; Tuple[State, Iterable[DrawCommand]]:\n        \"\"\"Set drawing polarity.\"\"\"\n        if state.is_region:\n            logging.warning(\"Starting region within a region is not allowed.\")\n\n        return (\n            state.model_copy(\n                update={\n                    \"is_region\": True,\n                    \"region_boundary_points\": [],\n                },\n            ),\n            (),\n        )\n\n    def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n        \"\"\"Perform actions on the context implicated by this token.\"\"\"\n        context.get_hooks().begin_region.pre_parser_visit_token(self, context)\n        context.get_hooks().begin_region.on_parser_visit_token(self, context)\n        context.get_hooks().begin_region.post_parser_visit_token(self, context)\n\n    def get_gerber_code(\n        self,\n        indent: str = \"\",\n        endline: str = \"\\n\",  # noqa: ARG002\n    ) -&gt; str:\n        \"\"\"Get gerber code represented by this token.\"\"\"\n        return f\"{indent}G36\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g36_begin_region.html#pygerber.gerberx3.tokenizer.tokens.g36_begin_region.BeginRegion.update_drawing_state","title":"update_drawing_state","text":"<pre><code>update_drawing_state(\n    state: State, _backend: Backend\n) -&gt; Tuple[State, Iterable[DrawCommand]]\n</code></pre> <p>Set drawing polarity.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/g36_begin_region.py</code> <pre><code>def update_drawing_state(\n    self,\n    state: State,\n    _backend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n    \"\"\"Set drawing polarity.\"\"\"\n    if state.is_region:\n        logging.warning(\"Starting region within a region is not allowed.\")\n\n    return (\n        state.model_copy(\n            update={\n                \"is_region\": True,\n                \"region_boundary_points\": [],\n            },\n        ),\n        (),\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g36_begin_region.html#pygerber.gerberx3.tokenizer.tokens.g36_begin_region.BeginRegion.parser2_visit_token","title":"parser2_visit_token","text":"<pre><code>parser2_visit_token(context: Parser2Context) -&gt; None\n</code></pre> <p>Perform actions on the context implicated by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/g36_begin_region.py</code> <pre><code>def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n    \"\"\"Perform actions on the context implicated by this token.\"\"\"\n    context.get_hooks().begin_region.pre_parser_visit_token(self, context)\n    context.get_hooks().begin_region.on_parser_visit_token(self, context)\n    context.get_hooks().begin_region.post_parser_visit_token(self, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g36_begin_region.html#pygerber.gerberx3.tokenizer.tokens.g36_begin_region.BeginRegion.get_gerber_code","title":"get_gerber_code","text":"<pre><code>get_gerber_code(\n    indent: str = \"\", endline: str = \"\\n\"\n) -&gt; str\n</code></pre> <p>Get gerber code represented by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/g36_begin_region.py</code> <pre><code>def get_gerber_code(\n    self,\n    indent: str = \"\",\n    endline: str = \"\\n\",  # noqa: ARG002\n) -&gt; str:\n    \"\"\"Get gerber code represented by this token.\"\"\"\n    return f\"{indent}G36\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g37_end_region.html","title":"g37_end_region","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g37_end_region.html#pygerber.gerberx3.tokenizer.tokens.g37_end_region","title":"g37_end_region","text":"<p>Wrapper for aperture select token.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g37_end_region.html#pygerber.gerberx3.tokenizer.tokens.g37_end_region.EndRegion","title":"EndRegion","text":"<p>             Bases: <code>CommandToken</code></p> <p>Wrapper for G37 token.</p> <p>Ends the region statement.</p> <p>See section 4.10 of The Gerber Layer Format Specification Revision 2023.03 - https://argmaster.github.io/pygerber/latest/gerber_specification/revision_2023_03.html</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/g37_end_region.py</code> <pre><code>class EndRegion(CommandToken):\n    \"\"\"Wrapper for G37 token.\n\n    Ends the region statement.\n\n    See section 4.10 of The Gerber Layer Format Specification Revision 2023.03 - https://argmaster.github.io/pygerber/latest/gerber_specification/revision_2023_03.html\n    \"\"\"\n\n    def update_drawing_state(\n        self,\n        state: State,\n        backend: Backend,\n    ) -&gt; Tuple[State, Iterable[DrawCommand]]:\n        \"\"\"Set drawing polarity.\"\"\"\n        if not state.is_region:\n            logging.warning(\"Ending region which was not started.\")\n\n        if len(state.region_boundary_points) == 0:\n            logging.warning(\"Created region with no boundaries.\")\n\n        draw_command = backend.get_draw_region_cls()(\n            backend,\n            state.polarity.to_region_variant(),\n            state.region_boundary_points,\n        )\n\n        return (\n            state.model_copy(\n                update={\n                    \"is_region\": False,\n                    \"region_boundary_points\": [],\n                },\n            ),\n            (draw_command,),\n        )\n\n    def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n        \"\"\"Perform actions on the context implicated by this token.\"\"\"\n        context.get_hooks().end_region.pre_parser_visit_token(self, context)\n        context.get_hooks().end_region.on_parser_visit_token(self, context)\n        context.get_hooks().end_region.post_parser_visit_token(self, context)\n\n    def get_gerber_code(\n        self,\n        indent: str = \"\",\n        endline: str = \"\\n\",  # noqa: ARG002\n    ) -&gt; str:\n        \"\"\"Get gerber code represented by this token.\"\"\"\n        return f\"{indent}G37\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g37_end_region.html#pygerber.gerberx3.tokenizer.tokens.g37_end_region.EndRegion.update_drawing_state","title":"update_drawing_state","text":"<pre><code>update_drawing_state(\n    state: State, backend: Backend\n) -&gt; Tuple[State, Iterable[DrawCommand]]\n</code></pre> <p>Set drawing polarity.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/g37_end_region.py</code> <pre><code>def update_drawing_state(\n    self,\n    state: State,\n    backend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n    \"\"\"Set drawing polarity.\"\"\"\n    if not state.is_region:\n        logging.warning(\"Ending region which was not started.\")\n\n    if len(state.region_boundary_points) == 0:\n        logging.warning(\"Created region with no boundaries.\")\n\n    draw_command = backend.get_draw_region_cls()(\n        backend,\n        state.polarity.to_region_variant(),\n        state.region_boundary_points,\n    )\n\n    return (\n        state.model_copy(\n            update={\n                \"is_region\": False,\n                \"region_boundary_points\": [],\n            },\n        ),\n        (draw_command,),\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g37_end_region.html#pygerber.gerberx3.tokenizer.tokens.g37_end_region.EndRegion.parser2_visit_token","title":"parser2_visit_token","text":"<pre><code>parser2_visit_token(context: Parser2Context) -&gt; None\n</code></pre> <p>Perform actions on the context implicated by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/g37_end_region.py</code> <pre><code>def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n    \"\"\"Perform actions on the context implicated by this token.\"\"\"\n    context.get_hooks().end_region.pre_parser_visit_token(self, context)\n    context.get_hooks().end_region.on_parser_visit_token(self, context)\n    context.get_hooks().end_region.post_parser_visit_token(self, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g37_end_region.html#pygerber.gerberx3.tokenizer.tokens.g37_end_region.EndRegion.get_gerber_code","title":"get_gerber_code","text":"<pre><code>get_gerber_code(\n    indent: str = \"\", endline: str = \"\\n\"\n) -&gt; str\n</code></pre> <p>Get gerber code represented by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/g37_end_region.py</code> <pre><code>def get_gerber_code(\n    self,\n    indent: str = \"\",\n    endline: str = \"\\n\",  # noqa: ARG002\n) -&gt; str:\n    \"\"\"Get gerber code represented by this token.\"\"\"\n    return f\"{indent}G37\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g54_select_aperture.html","title":"g54_select_aperture","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g54_select_aperture.html#pygerber.gerberx3.tokenizer.tokens.g54_select_aperture","title":"g54_select_aperture","text":"<p>Wrapper for G70 token.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g54_select_aperture.html#pygerber.gerberx3.tokenizer.tokens.g54_select_aperture.G54SelectAperture","title":"G54SelectAperture","text":"<p>             Bases: <code>DNNSelectAperture</code></p> <p>Wrapper for G54DNN token.</p> <p>Select aperture.</p> <p>This historic code optionally precedes an aperture selection Dnn command. It has no effect. Sometimes used. Deprecated in 2012.</p> <p>See section 8.1.1 of The Gerber Layer Format Specification Revision 2023.03 - https://argmaster.github.io/pygerber/latest/gerber_specification/revision_2023_03.html</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/g54_select_aperture.py</code> <pre><code>class G54SelectAperture(DNNSelectAperture):\n    \"\"\"Wrapper for G54DNN token.\n\n    Select aperture.\n\n    This historic code optionally precedes an aperture selection Dnn command. It has no\n    effect. Sometimes used. Deprecated in 2012.\n\n    See section 8.1.1 of The Gerber Layer Format Specification Revision 2023.03 - https://argmaster.github.io/pygerber/latest/gerber_specification/revision_2023_03.html\n    \"\"\"\n\n    def update_drawing_state(\n        self,\n        state: State,\n        _backend: Backend,\n    ) -&gt; Tuple[State, Iterable[DrawCommand]]:\n        \"\"\"Update drawing state.\"\"\"\n        warn_deprecated_code(\"G54\", \"8.1\")\n        return super().update_drawing_state(state, _backend)\n\n    def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n        \"\"\"Perform actions on the context implicated by this token.\"\"\"\n        context.get_hooks().prepare_select_aperture.pre_parser_visit_token(\n            self,\n            context,\n        )\n        context.get_hooks().prepare_select_aperture.on_parser_visit_token(self, context)\n        context.get_hooks().prepare_select_aperture.post_parser_visit_token(\n            self,\n            context,\n        )\n\n    def get_gerber_code(\n        self,\n        indent: str = \"\",\n        endline: str = \"\\n\",  # noqa: ARG002\n    ) -&gt; str:\n        \"\"\"Get gerber code represented by this token.\"\"\"\n        return f\"{indent}G54{self.aperture_id}\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g54_select_aperture.html#pygerber.gerberx3.tokenizer.tokens.g54_select_aperture.G54SelectAperture.update_drawing_state","title":"update_drawing_state","text":"<pre><code>update_drawing_state(\n    state: State, _backend: Backend\n) -&gt; Tuple[State, Iterable[DrawCommand]]\n</code></pre> <p>Update drawing state.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/g54_select_aperture.py</code> <pre><code>def update_drawing_state(\n    self,\n    state: State,\n    _backend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n    \"\"\"Update drawing state.\"\"\"\n    warn_deprecated_code(\"G54\", \"8.1\")\n    return super().update_drawing_state(state, _backend)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g54_select_aperture.html#pygerber.gerberx3.tokenizer.tokens.g54_select_aperture.G54SelectAperture.parser2_visit_token","title":"parser2_visit_token","text":"<pre><code>parser2_visit_token(context: Parser2Context) -&gt; None\n</code></pre> <p>Perform actions on the context implicated by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/g54_select_aperture.py</code> <pre><code>def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n    \"\"\"Perform actions on the context implicated by this token.\"\"\"\n    context.get_hooks().prepare_select_aperture.pre_parser_visit_token(\n        self,\n        context,\n    )\n    context.get_hooks().prepare_select_aperture.on_parser_visit_token(self, context)\n    context.get_hooks().prepare_select_aperture.post_parser_visit_token(\n        self,\n        context,\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g54_select_aperture.html#pygerber.gerberx3.tokenizer.tokens.g54_select_aperture.G54SelectAperture.get_gerber_code","title":"get_gerber_code","text":"<pre><code>get_gerber_code(\n    indent: str = \"\", endline: str = \"\\n\"\n) -&gt; str\n</code></pre> <p>Get gerber code represented by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/g54_select_aperture.py</code> <pre><code>def get_gerber_code(\n    self,\n    indent: str = \"\",\n    endline: str = \"\\n\",  # noqa: ARG002\n) -&gt; str:\n    \"\"\"Get gerber code represented by this token.\"\"\"\n    return f\"{indent}G54{self.aperture_id}\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g70_set_unit_inch.html","title":"g70_set_unit_inch","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g70_set_unit_inch.html#pygerber.gerberx3.tokenizer.tokens.g70_set_unit_inch","title":"g70_set_unit_inch","text":"<p>Wrapper for G70 token.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g70_set_unit_inch.html#pygerber.gerberx3.tokenizer.tokens.g70_set_unit_inch.SetUnitInch","title":"SetUnitInch","text":"<p>             Bases: <code>CommandToken</code></p> <p>Wrapper for G70 token.</p> <p>Set the <code>Unit</code> to inch.</p> <p>This historic codes perform a function handled by the MO command. See 4.2.1. Sometimes used. Deprecated in 2012</p> <p>See section 8.1 of The Gerber Layer Format Specification Revision 2023.03 - https://argmaster.github.io/pygerber/latest/gerber_specification/revision_2023_03.html</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/g70_set_unit_inch.py</code> <pre><code>class SetUnitInch(CommandToken):\n    \"\"\"Wrapper for G70 token.\n\n    Set the `Unit` to inch.\n\n    This historic codes perform a function handled by the MO command. See 4.2.1.\n    Sometimes used. Deprecated in 2012\n\n    See section 8.1 of The Gerber Layer Format Specification Revision 2023.03 - https://argmaster.github.io/pygerber/latest/gerber_specification/revision_2023_03.html\n    \"\"\"\n\n    def update_drawing_state(\n        self,\n        state: State,\n        _backend: Backend,\n    ) -&gt; Tuple[State, Iterable[DrawCommand]]:\n        \"\"\"Set drawing polarity.\"\"\"\n        warn_deprecated_code(\"G70\", \"8.1\")\n        logging.warning(\n            \"Detected use of imperial units. Using metric units is recommended. \"\n            \"Imperial units will be deprecated in future. \"\n            \"(See 4.2.1 in Gerber Layer Format Specification)\",\n        )\n        if state.draw_units is not None:\n            logging.warning(\n                \"Overriding coordinate units is illegal. \"\n                \"(See section 4.2.2 of The Gerber Layer Format Specification \"\n                \"Revision 2023.03 - https://argmaster.github.io/pygerber/latest/gerber_specification/revision_2023_03.html)\",\n            )\n        return (\n            state.model_copy(\n                update={\n                    \"draw_units\": Unit.Inches,\n                },\n            ),\n            (),\n        )\n\n    def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n        \"\"\"Perform actions on the context implicated by this token.\"\"\"\n        context.get_hooks().set_unit_inch.pre_parser_visit_token(self, context)\n        context.get_hooks().set_unit_inch.on_parser_visit_token(self, context)\n        context.get_hooks().set_unit_inch.post_parser_visit_token(self, context)\n\n    def get_gerber_code(\n        self,\n        indent: str = \"\",\n        endline: str = \"\\n\",  # noqa: ARG002\n    ) -&gt; str:\n        \"\"\"Get gerber code represented by this token.\"\"\"\n        return f\"{indent}G70\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g70_set_unit_inch.html#pygerber.gerberx3.tokenizer.tokens.g70_set_unit_inch.SetUnitInch.update_drawing_state","title":"update_drawing_state","text":"<pre><code>update_drawing_state(\n    state: State, _backend: Backend\n) -&gt; Tuple[State, Iterable[DrawCommand]]\n</code></pre> <p>Set drawing polarity.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/g70_set_unit_inch.py</code> <pre><code>def update_drawing_state(\n    self,\n    state: State,\n    _backend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n    \"\"\"Set drawing polarity.\"\"\"\n    warn_deprecated_code(\"G70\", \"8.1\")\n    logging.warning(\n        \"Detected use of imperial units. Using metric units is recommended. \"\n        \"Imperial units will be deprecated in future. \"\n        \"(See 4.2.1 in Gerber Layer Format Specification)\",\n    )\n    if state.draw_units is not None:\n        logging.warning(\n            \"Overriding coordinate units is illegal. \"\n            \"(See section 4.2.2 of The Gerber Layer Format Specification \"\n            \"Revision 2023.03 - https://argmaster.github.io/pygerber/latest/gerber_specification/revision_2023_03.html)\",\n        )\n    return (\n        state.model_copy(\n            update={\n                \"draw_units\": Unit.Inches,\n            },\n        ),\n        (),\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g70_set_unit_inch.html#pygerber.gerberx3.tokenizer.tokens.g70_set_unit_inch.SetUnitInch.parser2_visit_token","title":"parser2_visit_token","text":"<pre><code>parser2_visit_token(context: Parser2Context) -&gt; None\n</code></pre> <p>Perform actions on the context implicated by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/g70_set_unit_inch.py</code> <pre><code>def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n    \"\"\"Perform actions on the context implicated by this token.\"\"\"\n    context.get_hooks().set_unit_inch.pre_parser_visit_token(self, context)\n    context.get_hooks().set_unit_inch.on_parser_visit_token(self, context)\n    context.get_hooks().set_unit_inch.post_parser_visit_token(self, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g70_set_unit_inch.html#pygerber.gerberx3.tokenizer.tokens.g70_set_unit_inch.SetUnitInch.get_gerber_code","title":"get_gerber_code","text":"<pre><code>get_gerber_code(\n    indent: str = \"\", endline: str = \"\\n\"\n) -&gt; str\n</code></pre> <p>Get gerber code represented by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/g70_set_unit_inch.py</code> <pre><code>def get_gerber_code(\n    self,\n    indent: str = \"\",\n    endline: str = \"\\n\",  # noqa: ARG002\n) -&gt; str:\n    \"\"\"Get gerber code represented by this token.\"\"\"\n    return f\"{indent}G70\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g71_set_unit_mm.html","title":"g71_set_unit_mm","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g71_set_unit_mm.html#pygerber.gerberx3.tokenizer.tokens.g71_set_unit_mm","title":"g71_set_unit_mm","text":"<p>Wrapper for G71 token.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g71_set_unit_mm.html#pygerber.gerberx3.tokenizer.tokens.g71_set_unit_mm.SetUnitMillimeters","title":"SetUnitMillimeters","text":"<p>             Bases: <code>CommandToken</code></p> <p>Wrapper for G71 token.</p> <p>Set the <code>Unit</code> to millimeter.</p> <p>This historic codes perform a function handled by the MO command. Sometimes used. Deprecated in 2012</p> <p>See section 4.2.1 of The Gerber Layer Format Specification Revision 2023.03 - https://argmaster.github.io/pygerber/latest/gerber_specification/revision_2023_03.html</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/g71_set_unit_mm.py</code> <pre><code>class SetUnitMillimeters(CommandToken):\n    \"\"\"Wrapper for G71 token.\n\n    Set the `Unit` to millimeter.\n\n    This historic codes perform a function handled by the MO command.\n    Sometimes used. Deprecated in 2012\n\n    See section 4.2.1 of The Gerber Layer Format Specification Revision 2023.03 - https://argmaster.github.io/pygerber/latest/gerber_specification/revision_2023_03.html\n    \"\"\"\n\n    def update_drawing_state(\n        self,\n        state: State,\n        _backend: Backend,\n    ) -&gt; Tuple[State, Iterable[DrawCommand]]:\n        \"\"\"Set drawing polarity.\"\"\"\n        warn_deprecated_code(\"G71\", \"8.1\")\n        if state.draw_units is not None:\n            logging.warning(\n                \"Overriding coordinate units is illegal. \"\n                \"(See section 4.2.2 of The Gerber Layer Format Specification \"\n                \"Revision 2023.03 - https://argmaster.github.io/pygerber/latest/gerber_specification/revision_2023_03.html)\",\n            )\n        return (\n            state.model_copy(\n                update={\n                    \"draw_units\": Unit.Millimeters,\n                },\n            ),\n            (),\n        )\n\n    def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n        \"\"\"Perform actions on the context implicated by this token.\"\"\"\n        context.get_hooks().set_unit_millimeters.pre_parser_visit_token(self, context)\n        context.get_hooks().set_unit_millimeters.on_parser_visit_token(self, context)\n        context.get_hooks().set_unit_millimeters.post_parser_visit_token(self, context)\n\n    def get_gerber_code(\n        self,\n        indent: str = \"\",\n        endline: str = \"\\n\",  # noqa: ARG002\n    ) -&gt; str:\n        \"\"\"Get gerber code represented by this token.\"\"\"\n        return f\"{indent}G71\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g71_set_unit_mm.html#pygerber.gerberx3.tokenizer.tokens.g71_set_unit_mm.SetUnitMillimeters.update_drawing_state","title":"update_drawing_state","text":"<pre><code>update_drawing_state(\n    state: State, _backend: Backend\n) -&gt; Tuple[State, Iterable[DrawCommand]]\n</code></pre> <p>Set drawing polarity.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/g71_set_unit_mm.py</code> <pre><code>def update_drawing_state(\n    self,\n    state: State,\n    _backend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n    \"\"\"Set drawing polarity.\"\"\"\n    warn_deprecated_code(\"G71\", \"8.1\")\n    if state.draw_units is not None:\n        logging.warning(\n            \"Overriding coordinate units is illegal. \"\n            \"(See section 4.2.2 of The Gerber Layer Format Specification \"\n            \"Revision 2023.03 - https://argmaster.github.io/pygerber/latest/gerber_specification/revision_2023_03.html)\",\n        )\n    return (\n        state.model_copy(\n            update={\n                \"draw_units\": Unit.Millimeters,\n            },\n        ),\n        (),\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g71_set_unit_mm.html#pygerber.gerberx3.tokenizer.tokens.g71_set_unit_mm.SetUnitMillimeters.parser2_visit_token","title":"parser2_visit_token","text":"<pre><code>parser2_visit_token(context: Parser2Context) -&gt; None\n</code></pre> <p>Perform actions on the context implicated by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/g71_set_unit_mm.py</code> <pre><code>def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n    \"\"\"Perform actions on the context implicated by this token.\"\"\"\n    context.get_hooks().set_unit_millimeters.pre_parser_visit_token(self, context)\n    context.get_hooks().set_unit_millimeters.on_parser_visit_token(self, context)\n    context.get_hooks().set_unit_millimeters.post_parser_visit_token(self, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g71_set_unit_mm.html#pygerber.gerberx3.tokenizer.tokens.g71_set_unit_mm.SetUnitMillimeters.get_gerber_code","title":"get_gerber_code","text":"<pre><code>get_gerber_code(\n    indent: str = \"\", endline: str = \"\\n\"\n) -&gt; str\n</code></pre> <p>Get gerber code represented by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/g71_set_unit_mm.py</code> <pre><code>def get_gerber_code(\n    self,\n    indent: str = \"\",\n    endline: str = \"\\n\",  # noqa: ARG002\n) -&gt; str:\n    \"\"\"Get gerber code represented by this token.\"\"\"\n    return f\"{indent}G71\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g74_single_quadrant.html","title":"g74_single_quadrant","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g74_single_quadrant.html#pygerber.gerberx3.tokenizer.tokens.g74_single_quadrant","title":"g74_single_quadrant","text":"<p>Wrapper for G74 token.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g74_single_quadrant.html#pygerber.gerberx3.tokenizer.tokens.g74_single_quadrant.SetSingleQuadrantMode","title":"SetSingleQuadrantMode","text":"<p>             Bases: <code>CommandToken</code></p> <p>Wrapper for G74 token.</p> <p>Sets single quadrant mode - Rarely used, and then typically without effect. Deprecated in 2020.</p> <p>In single quadrant mode the arc is not allowed to extend over more than 90\u00b0.</p> <p>See: -   section 4.7 of The Gerber Layer Format Specification Revision 2023.03 - https://argmaster.github.io/pygerber/latest/gerber_specification/revision_2023_03.html -   section 8.1.10 of The Gerber Layer Format Specification Revision 2023.03 - https://argmaster.github.io/pygerber/latest/gerber_specification/revision_2023_03.html</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/g74_single_quadrant.py</code> <pre><code>class SetSingleQuadrantMode(CommandToken):\n    \"\"\"Wrapper for G74 token.\n\n    Sets single quadrant mode - Rarely used, and then typically without effect.\n    Deprecated in 2020.\n\n    In single quadrant mode the arc is not allowed to extend over more than 90\u00b0.\n\n    See:\n    -   section 4.7 of The Gerber Layer Format Specification Revision 2023.03 - https://argmaster.github.io/pygerber/latest/gerber_specification/revision_2023_03.html\n    -   section 8.1.10 of The Gerber Layer Format Specification Revision 2023.03 - https://argmaster.github.io/pygerber/latest/gerber_specification/revision_2023_03.html\n    \"\"\"\n\n    def update_drawing_state(\n        self,\n        state: State,\n        _backend: Backend,\n    ) -&gt; Tuple[State, Iterable[DrawCommand]]:\n        \"\"\"Set drawing polarity.\"\"\"\n        warn_deprecated_code(\"G74\", \"8.1.10\")\n        return (\n            state.model_copy(\n                update={\n                    \"is_multi_quadrant\": False,\n                },\n            ),\n            (),\n        )\n\n    def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n        \"\"\"Perform actions on the context implicated by this token.\"\"\"\n        context.get_hooks().set_single_quadrant_mode.pre_parser_visit_token(\n            self,\n            context,\n        )\n        context.get_hooks().set_single_quadrant_mode.on_parser_visit_token(\n            self,\n            context,\n        )\n        context.get_hooks().set_single_quadrant_mode.post_parser_visit_token(\n            self,\n            context,\n        )\n\n    def get_gerber_code(\n        self,\n        indent: str = \"\",\n        endline: str = \"\\n\",  # noqa: ARG002\n    ) -&gt; str:\n        \"\"\"Get gerber code represented by this token.\"\"\"\n        return f\"{indent}G74\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g74_single_quadrant.html#pygerber.gerberx3.tokenizer.tokens.g74_single_quadrant.SetSingleQuadrantMode.update_drawing_state","title":"update_drawing_state","text":"<pre><code>update_drawing_state(\n    state: State, _backend: Backend\n) -&gt; Tuple[State, Iterable[DrawCommand]]\n</code></pre> <p>Set drawing polarity.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/g74_single_quadrant.py</code> <pre><code>def update_drawing_state(\n    self,\n    state: State,\n    _backend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n    \"\"\"Set drawing polarity.\"\"\"\n    warn_deprecated_code(\"G74\", \"8.1.10\")\n    return (\n        state.model_copy(\n            update={\n                \"is_multi_quadrant\": False,\n            },\n        ),\n        (),\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g74_single_quadrant.html#pygerber.gerberx3.tokenizer.tokens.g74_single_quadrant.SetSingleQuadrantMode.parser2_visit_token","title":"parser2_visit_token","text":"<pre><code>parser2_visit_token(context: Parser2Context) -&gt; None\n</code></pre> <p>Perform actions on the context implicated by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/g74_single_quadrant.py</code> <pre><code>def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n    \"\"\"Perform actions on the context implicated by this token.\"\"\"\n    context.get_hooks().set_single_quadrant_mode.pre_parser_visit_token(\n        self,\n        context,\n    )\n    context.get_hooks().set_single_quadrant_mode.on_parser_visit_token(\n        self,\n        context,\n    )\n    context.get_hooks().set_single_quadrant_mode.post_parser_visit_token(\n        self,\n        context,\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g74_single_quadrant.html#pygerber.gerberx3.tokenizer.tokens.g74_single_quadrant.SetSingleQuadrantMode.get_gerber_code","title":"get_gerber_code","text":"<pre><code>get_gerber_code(\n    indent: str = \"\", endline: str = \"\\n\"\n) -&gt; str\n</code></pre> <p>Get gerber code represented by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/g74_single_quadrant.py</code> <pre><code>def get_gerber_code(\n    self,\n    indent: str = \"\",\n    endline: str = \"\\n\",  # noqa: ARG002\n) -&gt; str:\n    \"\"\"Get gerber code represented by this token.\"\"\"\n    return f\"{indent}G74\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g75_multi_quadrant.html","title":"g75_multi_quadrant","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g75_multi_quadrant.html#pygerber.gerberx3.tokenizer.tokens.g75_multi_quadrant","title":"g75_multi_quadrant","text":"<p>Wrapper for G74 token.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g75_multi_quadrant.html#pygerber.gerberx3.tokenizer.tokens.g75_multi_quadrant.SetMultiQuadrantMode","title":"SetMultiQuadrantMode","text":"<p>             Bases: <code>CommandToken</code></p> <p>Wrapper for G75 token.</p> <p>In multi quadrant mode the arc is allowed to extend over more than 90\u00b0. To avoid ambiguity between 0\u00b0 and 360\u00b0 arcs the following relation must hold:</p> <p>0\u00b0 &lt; A \u2264360\u00b0, where A is the arc angle</p> <p>If the start point of the arc is equal to the end point, the arc is a full circle of 360\u00b0.</p> <p>0\u00b0 \u2264A \u226490\u00b0, where A is the arc angle</p> <p>angleIf the start point of the arc is equal to the end point, the arc has length zero, i.e. it covers 0\u00b0. A separate operation is required for each quadrant. A minimum of four operations is required for a full circle.</p> <p>See: -   section 4.8 of The Gerber Layer Format Specification Revision 2020.09 - https://argmaster.github.io/pygerber/latest/gerber_specification/revision_2020_09.html -   section 4.7 of The Gerber Layer Format Specification Revision 2023.03 - https://argmaster.github.io/pygerber/latest/gerber_specification/revision_2023_03.html -   section 8.1.10 of The Gerber Layer Format Specification Revision 2023.03 - https://argmaster.github.io/pygerber/latest/gerber_specification/revision_2023_03.html</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/g75_multi_quadrant.py</code> <pre><code>class SetMultiQuadrantMode(CommandToken):\n    \"\"\"Wrapper for G75 token.\n\n    In multi quadrant mode the arc is allowed to extend over more than 90\u00b0.\n    To avoid ambiguity between 0\u00b0 and 360\u00b0 arcs the following relation must hold:\n\n    0\u00b0 &lt; A \u2264360\u00b0, where A is the arc angle\n\n    If the start point of the arc is equal to the\n    end point, the arc is a full circle of 360\u00b0.\n\n    0\u00b0 \u2264A \u226490\u00b0, where A is the arc angle\n\n    angleIf the start point of the arc is equal to the end point, the arc has length\n    zero, i.e. it covers 0\u00b0. A separate operation is required for each quadrant. A\n    minimum of four operations is required for a full circle.\n\n    See:\n    -   section 4.8 of The Gerber Layer Format Specification Revision 2020.09 - https://argmaster.github.io/pygerber/latest/gerber_specification/revision_2020_09.html\n    -   section 4.7 of The Gerber Layer Format Specification Revision 2023.03 - https://argmaster.github.io/pygerber/latest/gerber_specification/revision_2023_03.html\n    -   section 8.1.10 of The Gerber Layer Format Specification Revision 2023.03 - https://argmaster.github.io/pygerber/latest/gerber_specification/revision_2023_03.html\n    \"\"\"\n\n    def update_drawing_state(\n        self,\n        state: State,\n        _backend: Backend,\n    ) -&gt; Tuple[State, Iterable[DrawCommand]]:\n        \"\"\"Set drawing polarity.\"\"\"\n        return (\n            state.model_copy(\n                update={\n                    \"is_multi_quadrant\": True,\n                },\n            ),\n            (),\n        )\n\n    def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n        \"\"\"Perform actions on the context implicated by this token.\"\"\"\n        context.get_hooks().set_multi_quadrant_mode.pre_parser_visit_token(\n            self,\n            context,\n        )\n        context.get_hooks().set_multi_quadrant_mode.on_parser_visit_token(self, context)\n        context.get_hooks().set_multi_quadrant_mode.post_parser_visit_token(\n            self,\n            context,\n        )\n\n    def get_gerber_code(\n        self,\n        indent: str = \"\",\n        endline: str = \"\\n\",  # noqa: ARG002\n    ) -&gt; str:\n        \"\"\"Get gerber code represented by this token.\"\"\"\n        return f\"{indent}G75\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g75_multi_quadrant.html#pygerber.gerberx3.tokenizer.tokens.g75_multi_quadrant.SetMultiQuadrantMode.update_drawing_state","title":"update_drawing_state","text":"<pre><code>update_drawing_state(\n    state: State, _backend: Backend\n) -&gt; Tuple[State, Iterable[DrawCommand]]\n</code></pre> <p>Set drawing polarity.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/g75_multi_quadrant.py</code> <pre><code>def update_drawing_state(\n    self,\n    state: State,\n    _backend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n    \"\"\"Set drawing polarity.\"\"\"\n    return (\n        state.model_copy(\n            update={\n                \"is_multi_quadrant\": True,\n            },\n        ),\n        (),\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g75_multi_quadrant.html#pygerber.gerberx3.tokenizer.tokens.g75_multi_quadrant.SetMultiQuadrantMode.parser2_visit_token","title":"parser2_visit_token","text":"<pre><code>parser2_visit_token(context: Parser2Context) -&gt; None\n</code></pre> <p>Perform actions on the context implicated by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/g75_multi_quadrant.py</code> <pre><code>def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n    \"\"\"Perform actions on the context implicated by this token.\"\"\"\n    context.get_hooks().set_multi_quadrant_mode.pre_parser_visit_token(\n        self,\n        context,\n    )\n    context.get_hooks().set_multi_quadrant_mode.on_parser_visit_token(self, context)\n    context.get_hooks().set_multi_quadrant_mode.post_parser_visit_token(\n        self,\n        context,\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g75_multi_quadrant.html#pygerber.gerberx3.tokenizer.tokens.g75_multi_quadrant.SetMultiQuadrantMode.get_gerber_code","title":"get_gerber_code","text":"<pre><code>get_gerber_code(\n    indent: str = \"\", endline: str = \"\\n\"\n) -&gt; str\n</code></pre> <p>Get gerber code represented by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/g75_multi_quadrant.py</code> <pre><code>def get_gerber_code(\n    self,\n    indent: str = \"\",\n    endline: str = \"\\n\",  # noqa: ARG002\n) -&gt; str:\n    \"\"\"Get gerber code represented by this token.\"\"\"\n    return f\"{indent}G75\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g90_set_coordinate_absolute.html","title":"g90_set_coordinate_absolute","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g90_set_coordinate_absolute.html#pygerber.gerberx3.tokenizer.tokens.g90_set_coordinate_absolute","title":"g90_set_coordinate_absolute","text":"<p>Wrapper for G90 token.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g90_set_coordinate_absolute.html#pygerber.gerberx3.tokenizer.tokens.g90_set_coordinate_absolute.SetAbsoluteNotation","title":"SetAbsoluteNotation","text":"<p>             Bases: <code>CommandToken</code></p> <p>Wrapper for G90 token.</p> <p>Set the <code>Coordinate format</code> to <code>Absolute notation</code>.</p> <p>This historic code performs a function handled by the FS command. See 4.1. Very rarely used nowadays. Deprecated in 2012.</p> <p>See section 8.1 of The Gerber Layer Format Specification Revision 2023.03 - https://argmaster.github.io/pygerber/latest/gerber_specification/revision_2023_03.html</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/g90_set_coordinate_absolute.py</code> <pre><code>class SetAbsoluteNotation(CommandToken):\n    \"\"\"Wrapper for G90 token.\n\n    Set the `Coordinate format` to `Absolute notation`.\n\n    This historic code performs a function handled by the FS command. See 4.1. Very\n    rarely used nowadays. Deprecated in 2012.\n\n    See section 8.1 of The Gerber Layer Format Specification Revision 2023.03 - https://argmaster.github.io/pygerber/latest/gerber_specification/revision_2023_03.html\n    \"\"\"\n\n    def update_drawing_state(\n        self,\n        state: State,\n        _backend: Backend,\n    ) -&gt; Tuple[State, Iterable[DrawCommand]]:\n        \"\"\"Set drawing polarity.\"\"\"\n        warn_deprecated_code(\"G90\", \"8.1\")\n        if state.coordinate_parser is not None:\n            logging.warning(\n                \"Overriding coordinate format is illegal. \"\n                \"(See section 4.2.2 of The Gerber Layer Format Specification \"\n                \"Revision 2023.03 - https://argmaster.github.io/pygerber/latest/gerber_specification/revision_2023_03.html)\",\n            )\n        return (\n            state.model_copy(deep=True),\n            (),\n        )\n\n    def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n        \"\"\"Perform actions on the context implicated by this token.\"\"\"\n        context.get_hooks().set_coordinate_absolute.pre_parser_visit_token(\n            self,\n            context,\n        )\n        context.get_hooks().set_coordinate_absolute.on_parser_visit_token(self, context)\n        context.get_hooks().set_coordinate_absolute.post_parser_visit_token(\n            self,\n            context,\n        )\n\n    def get_gerber_code(\n        self,\n        indent: str = \"\",\n        endline: str = \"\\n\",  # noqa: ARG002\n    ) -&gt; str:\n        \"\"\"Get gerber code represented by this token.\"\"\"\n        return f\"{indent}G90\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g90_set_coordinate_absolute.html#pygerber.gerberx3.tokenizer.tokens.g90_set_coordinate_absolute.SetAbsoluteNotation.update_drawing_state","title":"update_drawing_state","text":"<pre><code>update_drawing_state(\n    state: State, _backend: Backend\n) -&gt; Tuple[State, Iterable[DrawCommand]]\n</code></pre> <p>Set drawing polarity.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/g90_set_coordinate_absolute.py</code> <pre><code>def update_drawing_state(\n    self,\n    state: State,\n    _backend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n    \"\"\"Set drawing polarity.\"\"\"\n    warn_deprecated_code(\"G90\", \"8.1\")\n    if state.coordinate_parser is not None:\n        logging.warning(\n            \"Overriding coordinate format is illegal. \"\n            \"(See section 4.2.2 of The Gerber Layer Format Specification \"\n            \"Revision 2023.03 - https://argmaster.github.io/pygerber/latest/gerber_specification/revision_2023_03.html)\",\n        )\n    return (\n        state.model_copy(deep=True),\n        (),\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g90_set_coordinate_absolute.html#pygerber.gerberx3.tokenizer.tokens.g90_set_coordinate_absolute.SetAbsoluteNotation.parser2_visit_token","title":"parser2_visit_token","text":"<pre><code>parser2_visit_token(context: Parser2Context) -&gt; None\n</code></pre> <p>Perform actions on the context implicated by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/g90_set_coordinate_absolute.py</code> <pre><code>def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n    \"\"\"Perform actions on the context implicated by this token.\"\"\"\n    context.get_hooks().set_coordinate_absolute.pre_parser_visit_token(\n        self,\n        context,\n    )\n    context.get_hooks().set_coordinate_absolute.on_parser_visit_token(self, context)\n    context.get_hooks().set_coordinate_absolute.post_parser_visit_token(\n        self,\n        context,\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g90_set_coordinate_absolute.html#pygerber.gerberx3.tokenizer.tokens.g90_set_coordinate_absolute.SetAbsoluteNotation.get_gerber_code","title":"get_gerber_code","text":"<pre><code>get_gerber_code(\n    indent: str = \"\", endline: str = \"\\n\"\n) -&gt; str\n</code></pre> <p>Get gerber code represented by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/g90_set_coordinate_absolute.py</code> <pre><code>def get_gerber_code(\n    self,\n    indent: str = \"\",\n    endline: str = \"\\n\",  # noqa: ARG002\n) -&gt; str:\n    \"\"\"Get gerber code represented by this token.\"\"\"\n    return f\"{indent}G90\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g91_set_coordinate_incremental.html","title":"g91_set_coordinate_incremental","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g91_set_coordinate_incremental.html#pygerber.gerberx3.tokenizer.tokens.g91_set_coordinate_incremental","title":"g91_set_coordinate_incremental","text":"<p>Wrapper for G91 token.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g91_set_coordinate_incremental.html#pygerber.gerberx3.tokenizer.tokens.g91_set_coordinate_incremental.SetIncrementalNotation","title":"SetIncrementalNotation","text":"<p>             Bases: <code>CommandToken</code></p> <p>Wrapper for G91 token.</p> <p>Set the <code>Coordinate format</code> to <code>Incremental notation</code>.</p> <p>This historic code performs a function handled by the FS command. See 4.1. Very rarely used nowadays. Deprecated in 2012.</p> <p>See section 8.1 of The Gerber Layer Format Specification Revision 2023.03 - https://argmaster.github.io/pygerber/latest/gerber_specification/revision_2023_03.html</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/g91_set_coordinate_incremental.py</code> <pre><code>class SetIncrementalNotation(CommandToken):\n    \"\"\"Wrapper for G91 token.\n\n    Set the `Coordinate format` to `Incremental notation`.\n\n    This historic code performs a function handled by the FS command. See 4.1. Very\n    rarely used nowadays. Deprecated in 2012.\n\n    See section 8.1 of The Gerber Layer Format Specification Revision 2023.03 - https://argmaster.github.io/pygerber/latest/gerber_specification/revision_2023_03.html\n    \"\"\"\n\n    def update_drawing_state(\n        self,\n        state: State,\n        _backend: Backend,\n    ) -&gt; Tuple[State, Iterable[DrawCommand]]:\n        \"\"\"Set drawing polarity.\"\"\"\n        warn_deprecated_code(\"G91\", \"8.1\")\n        if state.coordinate_parser is not None:\n            logging.warning(\n                \"Overriding coordinate format is illegal. \"\n                \"(See section 4.2.2 of The Gerber Layer Format Specification \"\n                \"Revision 2023.03 - https://argmaster.github.io/pygerber/latest/gerber_specification/revision_2023_03.html)\",\n            )\n\n        msg = \"Incremental notation not supported.\"\n        raise NotImplementedError(msg)\n\n    def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n        \"\"\"Perform actions on the context implicated by this token.\"\"\"\n        context.get_hooks().set_coordinate_incremental.pre_parser_visit_token(\n            self,\n            context,\n        )\n        context.get_hooks().set_coordinate_incremental.on_parser_visit_token(\n            self,\n            context,\n        )\n        context.get_hooks().set_coordinate_incremental.post_parser_visit_token(\n            self,\n            context,\n        )\n\n    def get_gerber_code(\n        self,\n        indent: str = \"\",\n        endline: str = \"\\n\",  # noqa: ARG002\n    ) -&gt; str:\n        \"\"\"Get gerber code represented by this token.\"\"\"\n        return f\"{indent}G91\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g91_set_coordinate_incremental.html#pygerber.gerberx3.tokenizer.tokens.g91_set_coordinate_incremental.SetIncrementalNotation.update_drawing_state","title":"update_drawing_state","text":"<pre><code>update_drawing_state(\n    state: State, _backend: Backend\n) -&gt; Tuple[State, Iterable[DrawCommand]]\n</code></pre> <p>Set drawing polarity.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/g91_set_coordinate_incremental.py</code> <pre><code>def update_drawing_state(\n    self,\n    state: State,\n    _backend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n    \"\"\"Set drawing polarity.\"\"\"\n    warn_deprecated_code(\"G91\", \"8.1\")\n    if state.coordinate_parser is not None:\n        logging.warning(\n            \"Overriding coordinate format is illegal. \"\n            \"(See section 4.2.2 of The Gerber Layer Format Specification \"\n            \"Revision 2023.03 - https://argmaster.github.io/pygerber/latest/gerber_specification/revision_2023_03.html)\",\n        )\n\n    msg = \"Incremental notation not supported.\"\n    raise NotImplementedError(msg)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g91_set_coordinate_incremental.html#pygerber.gerberx3.tokenizer.tokens.g91_set_coordinate_incremental.SetIncrementalNotation.parser2_visit_token","title":"parser2_visit_token","text":"<pre><code>parser2_visit_token(context: Parser2Context) -&gt; None\n</code></pre> <p>Perform actions on the context implicated by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/g91_set_coordinate_incremental.py</code> <pre><code>def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n    \"\"\"Perform actions on the context implicated by this token.\"\"\"\n    context.get_hooks().set_coordinate_incremental.pre_parser_visit_token(\n        self,\n        context,\n    )\n    context.get_hooks().set_coordinate_incremental.on_parser_visit_token(\n        self,\n        context,\n    )\n    context.get_hooks().set_coordinate_incremental.post_parser_visit_token(\n        self,\n        context,\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/g91_set_coordinate_incremental.html#pygerber.gerberx3.tokenizer.tokens.g91_set_coordinate_incremental.SetIncrementalNotation.get_gerber_code","title":"get_gerber_code","text":"<pre><code>get_gerber_code(\n    indent: str = \"\", endline: str = \"\\n\"\n) -&gt; str\n</code></pre> <p>Get gerber code represented by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/g91_set_coordinate_incremental.py</code> <pre><code>def get_gerber_code(\n    self,\n    indent: str = \"\",\n    endline: str = \"\\n\",  # noqa: ARG002\n) -&gt; str:\n    \"\"\"Get gerber code represented by this token.\"\"\"\n    return f\"{indent}G91\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/in_image_name.html","title":"in_image_name","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/in_image_name.html#pygerber.gerberx3.tokenizer.tokens.in_image_name","title":"in_image_name","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/in_image_name.html#pygerber.gerberx3.tokenizer.tokens.in_image_name--load-name-ln","title":"Load Name (LN).","text":"<p>Note: The LN command was deprecated in revision I4 from October 2013.</p> <p>The historic <code>LN</code> command doesn't influence the image in any manner and can safely be overlooked.</p> <p>Function of the <code>LN</code> command: - <code>LN</code> is designed to allocate a name to the following section of the file. - It was originally conceptualized to serve as a human-readable comment. - For creating human-readable comments, it's advisable to utilize the standard <code>G04</code>     command. - The <code>LN</code> command has the flexibility to be executed multiple times within a file.</p> <p>SPEC: <code>2023.03</code> SECTION: <code>8.1.6</code></p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/in_image_name.html#pygerber.gerberx3.tokenizer.tokens.in_image_name.ImageName","title":"ImageName","text":"<p>             Bases: <code>ExtendedCommandToken</code></p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/in_image_name.html#pygerber.gerberx3.tokenizer.tokens.in_image_name.ImageName--image-name-in","title":"Image Name (IN).","text":"<p>The IN command is deprecated since revision I4 from October 2013.</p> <p>The historic IN command gives a name to the image contained in the Gerber file. The name must comply with the syntax rules for a string as described in section 3.4.3. This command can only be used once, at the beginning of the file.</p> <p>IN has no effect on the image. A reader can ignore this command. The informal information provide by IN can also be put a G04 comment.</p> <p>See section 8.1.3 of The Gerber Layer Format Specification Revision 2023.03 - https://argmaster.github.io/pygerber/latest/gerber_specification/revision_2023_03.html</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/in_image_name.py</code> <pre><code>class ImageName(ExtendedCommandToken):\n    \"\"\"### Image Name (IN).\n\n    The IN command is deprecated since revision I4 from October 2013.\n\n    The historic IN command gives a name to the image contained in the Gerber file.\n    The name must comply with the syntax rules for a string as described in section\n    3.4.3. This command can only be used once, at the beginning of the file.\n\n    IN has no effect on the image. A reader can ignore this command. The informal\n    information provide by IN can also be put a G04 comment.\n\n    See section 8.1.3 of The Gerber Layer Format Specification Revision 2023.03 - https://argmaster.github.io/pygerber/latest/gerber_specification/revision_2023_03.html\n    \"\"\"\n\n    def __init__(self, string: str, location: int, content: str) -&gt; None:\n        super().__init__(string, location)\n        self.content = content\n\n    @classmethod\n    def new(cls, string: str, location: int, tokens: ParseResults) -&gt; Self:\n        \"\"\"Create instance of this class.\n\n        Created to be used as callback in `ParserElement.set_parse_action()`.\n        \"\"\"\n        content: str = str(tokens[\"string\"])\n        return cls(string=string, location=location, content=content)\n\n    def update_drawing_state(\n        self,\n        state: State,\n        _backend: Backend,\n    ) -&gt; Tuple[State, Iterable[DrawCommand]]:\n        \"\"\"Update drawing state.\"\"\"\n        warn_deprecated_code(\"IN\", \"8.1\")\n        return super().update_drawing_state(state, _backend)\n\n    def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n        \"\"\"Perform actions on the context implicated by this token.\"\"\"\n        context.get_hooks().image_name.pre_parser_visit_token(self, context)\n        context.get_hooks().image_name.on_parser_visit_token(self, context)\n        context.get_hooks().image_name.post_parser_visit_token(self, context)\n\n    def get_gerber_code(\n        self,\n        indent: str = \"\",  # noqa: ARG002\n        endline: str = \"\\n\",  # noqa: ARG002\n    ) -&gt; str:\n        \"\"\"Get gerber code represented by this token.\"\"\"\n        return f\"IN{self.content}\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/in_image_name.html#pygerber.gerberx3.tokenizer.tokens.in_image_name.ImageName.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(\n    string: str, location: int, tokens: ParseResults\n) -&gt; Self\n</code></pre> <p>Create instance of this class.</p> <p>Created to be used as callback in <code>ParserElement.set_parse_action()</code>.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/in_image_name.py</code> <pre><code>@classmethod\ndef new(cls, string: str, location: int, tokens: ParseResults) -&gt; Self:\n    \"\"\"Create instance of this class.\n\n    Created to be used as callback in `ParserElement.set_parse_action()`.\n    \"\"\"\n    content: str = str(tokens[\"string\"])\n    return cls(string=string, location=location, content=content)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/in_image_name.html#pygerber.gerberx3.tokenizer.tokens.in_image_name.ImageName.update_drawing_state","title":"update_drawing_state","text":"<pre><code>update_drawing_state(\n    state: State, _backend: Backend\n) -&gt; Tuple[State, Iterable[DrawCommand]]\n</code></pre> <p>Update drawing state.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/in_image_name.py</code> <pre><code>def update_drawing_state(\n    self,\n    state: State,\n    _backend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n    \"\"\"Update drawing state.\"\"\"\n    warn_deprecated_code(\"IN\", \"8.1\")\n    return super().update_drawing_state(state, _backend)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/in_image_name.html#pygerber.gerberx3.tokenizer.tokens.in_image_name.ImageName.parser2_visit_token","title":"parser2_visit_token","text":"<pre><code>parser2_visit_token(context: Parser2Context) -&gt; None\n</code></pre> <p>Perform actions on the context implicated by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/in_image_name.py</code> <pre><code>def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n    \"\"\"Perform actions on the context implicated by this token.\"\"\"\n    context.get_hooks().image_name.pre_parser_visit_token(self, context)\n    context.get_hooks().image_name.on_parser_visit_token(self, context)\n    context.get_hooks().image_name.post_parser_visit_token(self, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/in_image_name.html#pygerber.gerberx3.tokenizer.tokens.in_image_name.ImageName.get_gerber_code","title":"get_gerber_code","text":"<pre><code>get_gerber_code(\n    indent: str = \"\", endline: str = \"\\n\"\n) -&gt; str\n</code></pre> <p>Get gerber code represented by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/in_image_name.py</code> <pre><code>def get_gerber_code(\n    self,\n    indent: str = \"\",  # noqa: ARG002\n    endline: str = \"\\n\",  # noqa: ARG002\n) -&gt; str:\n    \"\"\"Get gerber code represented by this token.\"\"\"\n    return f\"IN{self.content}\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/invalid_token.html","title":"invalid_token","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/invalid_token.html#pygerber.gerberx3.tokenizer.tokens.invalid_token","title":"invalid_token","text":"<p>Wrapper for G74 token.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/invalid_token.html#pygerber.gerberx3.tokenizer.tokens.invalid_token.InvalidToken","title":"InvalidToken","text":"<p>             Bases: <code>Token</code></p> <p>Invalid syntax.</p> <p>This is not a valid Gerber X3/X2 expression.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/invalid_token.py</code> <pre><code>class InvalidToken(Token):\n    \"\"\"Invalid syntax.\n\n    This is not a valid Gerber X3/X2 expression.\n    \"\"\"\n\n    def __init__(self, string: str, location: int, content: str) -&gt; None:\n        super().__init__(string, location)\n        self.content = content\n\n    @classmethod\n    def new(cls, string: str, location: int, tokens: ParseResults) -&gt; Self:\n        \"\"\"Create instance of this class.\n\n        Created to be used as callback in `ParserElement.set_parse_action()`.\n        \"\"\"\n        content: str = str(tokens[\"content\"])\n        return cls(string=string, location=location, content=content)\n\n    def get_token_diagnostics(self) -&gt; Iterable[diagnostic.Diagnostic]:\n        \"\"\"Get diagnostics for this token.\"\"\"\n        yield diagnostic.Diagnostic(\n            range=(\n                diagnostic.Range(\n                    start=self.get_token_position(),\n                    end=self.get_token_end_position(),\n                )\n            ),\n            message=\"Invalid syntax.\",\n            severity=diagnostic.DiagnosticSeverity.Error,\n        )\n\n    def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n        \"\"\"Perform actions on the context implicated by this token.\"\"\"\n        context.get_hooks().invalid_token.pre_parser_visit_token(self, context)\n        context.get_hooks().invalid_token.on_parser_visit_token(self, context)\n        context.get_hooks().invalid_token.post_parser_visit_token(self, context)\n\n    def get_gerber_code(\n        self,\n        indent: str = \"\",  # noqa: ARG002\n        endline: str = \"\\n\",  # noqa: ARG002\n    ) -&gt; str:\n        \"\"\"Get gerber code represented by this token.\"\"\"\n        return self.content\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/invalid_token.html#pygerber.gerberx3.tokenizer.tokens.invalid_token.InvalidToken.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(\n    string: str, location: int, tokens: ParseResults\n) -&gt; Self\n</code></pre> <p>Create instance of this class.</p> <p>Created to be used as callback in <code>ParserElement.set_parse_action()</code>.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/invalid_token.py</code> <pre><code>@classmethod\ndef new(cls, string: str, location: int, tokens: ParseResults) -&gt; Self:\n    \"\"\"Create instance of this class.\n\n    Created to be used as callback in `ParserElement.set_parse_action()`.\n    \"\"\"\n    content: str = str(tokens[\"content\"])\n    return cls(string=string, location=location, content=content)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/invalid_token.html#pygerber.gerberx3.tokenizer.tokens.invalid_token.InvalidToken.get_token_diagnostics","title":"get_token_diagnostics","text":"<pre><code>get_token_diagnostics() -&gt; Iterable[diagnostic.Diagnostic]\n</code></pre> <p>Get diagnostics for this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/invalid_token.py</code> <pre><code>def get_token_diagnostics(self) -&gt; Iterable[diagnostic.Diagnostic]:\n    \"\"\"Get diagnostics for this token.\"\"\"\n    yield diagnostic.Diagnostic(\n        range=(\n            diagnostic.Range(\n                start=self.get_token_position(),\n                end=self.get_token_end_position(),\n            )\n        ),\n        message=\"Invalid syntax.\",\n        severity=diagnostic.DiagnosticSeverity.Error,\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/invalid_token.html#pygerber.gerberx3.tokenizer.tokens.invalid_token.InvalidToken.parser2_visit_token","title":"parser2_visit_token","text":"<pre><code>parser2_visit_token(context: Parser2Context) -&gt; None\n</code></pre> <p>Perform actions on the context implicated by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/invalid_token.py</code> <pre><code>def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n    \"\"\"Perform actions on the context implicated by this token.\"\"\"\n    context.get_hooks().invalid_token.pre_parser_visit_token(self, context)\n    context.get_hooks().invalid_token.on_parser_visit_token(self, context)\n    context.get_hooks().invalid_token.post_parser_visit_token(self, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/invalid_token.html#pygerber.gerberx3.tokenizer.tokens.invalid_token.InvalidToken.get_gerber_code","title":"get_gerber_code","text":"<pre><code>get_gerber_code(\n    indent: str = \"\", endline: str = \"\\n\"\n) -&gt; str\n</code></pre> <p>Get gerber code represented by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/invalid_token.py</code> <pre><code>def get_gerber_code(\n    self,\n    indent: str = \"\",  # noqa: ARG002\n    endline: str = \"\\n\",  # noqa: ARG002\n) -&gt; str:\n    \"\"\"Get gerber code represented by this token.\"\"\"\n    return self.content\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ip_image_polarity.html","title":"ip_image_polarity","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ip_image_polarity.html#pygerber.gerberx3.tokenizer.tokens.ip_image_polarity","title":"ip_image_polarity","text":"<p>Wrapper for image polarity token.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ip_image_polarity.html#pygerber.gerberx3.tokenizer.tokens.ip_image_polarity.ImagePolarity","title":"ImagePolarity","text":"<p>             Bases: <code>ExtendedCommandToken</code></p> <p>Wrapper for image polarity token.</p> <p>The IP command is deprecated.</p> <p>IP sets positive or negative polarity for the entire image. It can only be used once, at the beginning of the file.</p> <p>See section 8.1.4 of The Gerber Layer Format Specification Revision 2023.03 - https://argmaster.github.io/pygerber/latest/gerber_specification/revision_2023_03.html</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/ip_image_polarity.py</code> <pre><code>class ImagePolarity(ExtendedCommandToken):\n    \"\"\"Wrapper for image polarity token.\n\n    The IP command is deprecated.\n\n    IP sets positive or negative polarity for the entire image. It can only be used\n    once, at the beginning of the file.\n\n    See section 8.1.4 of The Gerber Layer Format Specification Revision 2023.03 - https://argmaster.github.io/pygerber/latest/gerber_specification/revision_2023_03.html\n    \"\"\"\n\n    def __init__(\n        self,\n        string: str,\n        location: int,\n        image_polarity: ImagePolarityEnum,\n    ) -&gt; None:\n        super().__init__(string, location)\n        self.image_polarity = image_polarity\n\n    @classmethod\n    def new(cls, string: str, location: int, tokens: ParseResults) -&gt; Self:\n        \"\"\"Create instance of this class.\n\n        Created to be used as callback in `ParserElement.set_parse_action()`.\n        \"\"\"\n        image_polarity = ImagePolarityEnum(tokens[\"image_polarity\"])\n        return cls(\n            string=string,\n            location=location,\n            image_polarity=image_polarity,\n        )\n\n    def update_drawing_state(\n        self,\n        state: State,\n        _backend: Backend,\n    ) -&gt; Tuple[State, Iterable[DrawCommand]]:\n        \"\"\"Set drawing polarity.\"\"\"\n        warn_deprecated_code(\"IP\", \"8.1.4\")\n        return (\n            state.model_copy(\n                update={\n                    \"is_output_image_negation_required\": (\n                        self.image_polarity == ImagePolarityEnum.NEGATIVE\n                    ),\n                },\n            ),\n            (),\n        )\n\n    def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n        \"\"\"Perform actions on the context implicated by this token.\"\"\"\n        context.get_hooks().image_polarity.pre_parser_visit_token(self, context)\n        context.get_hooks().image_polarity.on_parser_visit_token(self, context)\n        context.get_hooks().image_polarity.post_parser_visit_token(self, context)\n\n    def get_gerber_code(\n        self,\n        indent: str = \"\",\n        endline: str = \"\\n\",\n    ) -&gt; str:\n        \"\"\"Get gerber code represented by this token.\"\"\"\n        return f\"IP{self.image_polarity.get_gerber_code(indent, endline)}\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ip_image_polarity.html#pygerber.gerberx3.tokenizer.tokens.ip_image_polarity.ImagePolarity.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(\n    string: str, location: int, tokens: ParseResults\n) -&gt; Self\n</code></pre> <p>Create instance of this class.</p> <p>Created to be used as callback in <code>ParserElement.set_parse_action()</code>.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/ip_image_polarity.py</code> <pre><code>@classmethod\ndef new(cls, string: str, location: int, tokens: ParseResults) -&gt; Self:\n    \"\"\"Create instance of this class.\n\n    Created to be used as callback in `ParserElement.set_parse_action()`.\n    \"\"\"\n    image_polarity = ImagePolarityEnum(tokens[\"image_polarity\"])\n    return cls(\n        string=string,\n        location=location,\n        image_polarity=image_polarity,\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ip_image_polarity.html#pygerber.gerberx3.tokenizer.tokens.ip_image_polarity.ImagePolarity.update_drawing_state","title":"update_drawing_state","text":"<pre><code>update_drawing_state(\n    state: State, _backend: Backend\n) -&gt; Tuple[State, Iterable[DrawCommand]]\n</code></pre> <p>Set drawing polarity.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/ip_image_polarity.py</code> <pre><code>def update_drawing_state(\n    self,\n    state: State,\n    _backend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n    \"\"\"Set drawing polarity.\"\"\"\n    warn_deprecated_code(\"IP\", \"8.1.4\")\n    return (\n        state.model_copy(\n            update={\n                \"is_output_image_negation_required\": (\n                    self.image_polarity == ImagePolarityEnum.NEGATIVE\n                ),\n            },\n        ),\n        (),\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ip_image_polarity.html#pygerber.gerberx3.tokenizer.tokens.ip_image_polarity.ImagePolarity.parser2_visit_token","title":"parser2_visit_token","text":"<pre><code>parser2_visit_token(context: Parser2Context) -&gt; None\n</code></pre> <p>Perform actions on the context implicated by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/ip_image_polarity.py</code> <pre><code>def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n    \"\"\"Perform actions on the context implicated by this token.\"\"\"\n    context.get_hooks().image_polarity.pre_parser_visit_token(self, context)\n    context.get_hooks().image_polarity.on_parser_visit_token(self, context)\n    context.get_hooks().image_polarity.post_parser_visit_token(self, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ip_image_polarity.html#pygerber.gerberx3.tokenizer.tokens.ip_image_polarity.ImagePolarity.get_gerber_code","title":"get_gerber_code","text":"<pre><code>get_gerber_code(\n    indent: str = \"\", endline: str = \"\\n\"\n) -&gt; str\n</code></pre> <p>Get gerber code represented by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/ip_image_polarity.py</code> <pre><code>def get_gerber_code(\n    self,\n    indent: str = \"\",\n    endline: str = \"\\n\",\n) -&gt; str:\n    \"\"\"Get gerber code represented by this token.\"\"\"\n    return f\"IP{self.image_polarity.get_gerber_code(indent, endline)}\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/lm_load_mirroring.html","title":"lm_load_mirroring","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/lm_load_mirroring.html#pygerber.gerberx3.tokenizer.tokens.lm_load_mirroring","title":"lm_load_mirroring","text":"<p>Wrapper for load mirroring token.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/lm_load_mirroring.html#pygerber.gerberx3.tokenizer.tokens.lm_load_mirroring.LoadMirroring","title":"LoadMirroring","text":"<p>             Bases: <code>ExtendedCommandToken</code></p> <p>Wrapper for load mirroring token.</p> <p>Loads the mirror object transformation parameter.</p> <p>See section 4.9.3 of The Gerber Layer Format Specification Revision 2023.03 - https://argmaster.github.io/pygerber/latest/gerber_specification/revision_2023_03.html</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/lm_load_mirroring.py</code> <pre><code>class LoadMirroring(ExtendedCommandToken):\n    \"\"\"Wrapper for load mirroring token.\n\n    Loads the mirror object transformation parameter.\n\n    See section 4.9.3 of The Gerber Layer Format Specification Revision 2023.03 - https://argmaster.github.io/pygerber/latest/gerber_specification/revision_2023_03.html\n    \"\"\"\n\n    def __init__(\n        self,\n        string: str,\n        location: int,\n        mirroring: Mirroring,\n    ) -&gt; None:\n        super().__init__(string, location)\n        self.mirroring = mirroring\n\n    @classmethod\n    def new(cls, string: str, location: int, tokens: ParseResults) -&gt; Self:\n        \"\"\"Create instance of this class.\n\n        Created to be used as callback in `ParserElement.set_parse_action()`.\n        \"\"\"\n        mirroring = Mirroring(tokens[\"mirroring\"])\n        return cls(string=string, location=location, mirroring=mirroring)\n\n    def update_drawing_state(\n        self,\n        state: State,\n        _backend: Backend,\n    ) -&gt; Tuple[State, Iterable[DrawCommand]]:\n        \"\"\"Set drawing polarity.\"\"\"\n        return (\n            state.model_copy(\n                update={\n                    \"mirroring\": self.mirroring,\n                },\n            ),\n            (),\n        )\n\n    def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n        \"\"\"Perform actions on the context implicated by this token.\"\"\"\n        context.get_hooks().load_mirroring.pre_parser_visit_token(self, context)\n        context.get_hooks().load_mirroring.on_parser_visit_token(self, context)\n        context.get_hooks().load_mirroring.post_parser_visit_token(self, context)\n\n    def get_gerber_code(\n        self,\n        indent: str = \"\",  # noqa: ARG002\n        endline: str = \"\\n\",  # noqa: ARG002\n    ) -&gt; str:\n        \"\"\"Get gerber code represented by this token.\"\"\"\n        return f\"LM{self.mirroring.value}\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/lm_load_mirroring.html#pygerber.gerberx3.tokenizer.tokens.lm_load_mirroring.LoadMirroring.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(\n    string: str, location: int, tokens: ParseResults\n) -&gt; Self\n</code></pre> <p>Create instance of this class.</p> <p>Created to be used as callback in <code>ParserElement.set_parse_action()</code>.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/lm_load_mirroring.py</code> <pre><code>@classmethod\ndef new(cls, string: str, location: int, tokens: ParseResults) -&gt; Self:\n    \"\"\"Create instance of this class.\n\n    Created to be used as callback in `ParserElement.set_parse_action()`.\n    \"\"\"\n    mirroring = Mirroring(tokens[\"mirroring\"])\n    return cls(string=string, location=location, mirroring=mirroring)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/lm_load_mirroring.html#pygerber.gerberx3.tokenizer.tokens.lm_load_mirroring.LoadMirroring.update_drawing_state","title":"update_drawing_state","text":"<pre><code>update_drawing_state(\n    state: State, _backend: Backend\n) -&gt; Tuple[State, Iterable[DrawCommand]]\n</code></pre> <p>Set drawing polarity.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/lm_load_mirroring.py</code> <pre><code>def update_drawing_state(\n    self,\n    state: State,\n    _backend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n    \"\"\"Set drawing polarity.\"\"\"\n    return (\n        state.model_copy(\n            update={\n                \"mirroring\": self.mirroring,\n            },\n        ),\n        (),\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/lm_load_mirroring.html#pygerber.gerberx3.tokenizer.tokens.lm_load_mirroring.LoadMirroring.parser2_visit_token","title":"parser2_visit_token","text":"<pre><code>parser2_visit_token(context: Parser2Context) -&gt; None\n</code></pre> <p>Perform actions on the context implicated by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/lm_load_mirroring.py</code> <pre><code>def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n    \"\"\"Perform actions on the context implicated by this token.\"\"\"\n    context.get_hooks().load_mirroring.pre_parser_visit_token(self, context)\n    context.get_hooks().load_mirroring.on_parser_visit_token(self, context)\n    context.get_hooks().load_mirroring.post_parser_visit_token(self, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/lm_load_mirroring.html#pygerber.gerberx3.tokenizer.tokens.lm_load_mirroring.LoadMirroring.get_gerber_code","title":"get_gerber_code","text":"<pre><code>get_gerber_code(\n    indent: str = \"\", endline: str = \"\\n\"\n) -&gt; str\n</code></pre> <p>Get gerber code represented by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/lm_load_mirroring.py</code> <pre><code>def get_gerber_code(\n    self,\n    indent: str = \"\",  # noqa: ARG002\n    endline: str = \"\\n\",  # noqa: ARG002\n) -&gt; str:\n    \"\"\"Get gerber code represented by this token.\"\"\"\n    return f\"LM{self.mirroring.value}\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ln_load_name.html","title":"ln_load_name","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ln_load_name.html#pygerber.gerberx3.tokenizer.tokens.ln_load_name","title":"ln_load_name","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ln_load_name.html#pygerber.gerberx3.tokenizer.tokens.ln_load_name--load-name-ln","title":"Load Name (LN).","text":"<p>Note: The LN command was deprecated in revision I4 from October 2013.</p> <p>The historic <code>LN</code> command doesn't influence the image in any manner and can safely be overlooked.</p> <p>Function of the <code>LN</code> command: - <code>LN</code> is designed to allocate a name to the following section of the file. - It was originally conceptualized to serve as a human-readable comment. - For creating human-readable comments, it's advisable to utilize the standard <code>G04</code>     command. - The <code>LN</code> command has the flexibility to be executed multiple times within a file.</p> <p>SPEC: <code>2023.03</code> SECTION: <code>8.1.6</code></p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ln_load_name.html#pygerber.gerberx3.tokenizer.tokens.ln_load_name.LoadName","title":"LoadName","text":"<p>             Bases: <code>ExtendedCommandToken</code></p> <p>Comment token.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ln_load_name.html#pygerber.gerberx3.tokenizer.tokens.ln_load_name.LoadName--load-name-ln","title":"Load Name (LN)","text":"<p>Note: The LN command was deprecated in revision I4 from October 2013.</p> <p>The historic <code>LN</code> command doesn't influence the image in any manner and can safely be overlooked.</p> <p>Function of the <code>LN</code> command: - <code>LN</code> is designed to allocate a name to the following section of the file. - It was originally conceptualized to serve as a human-readable comment. - For creating human-readable comments, it's advisable to utilize the standard <code>G04</code>     command. - The <code>LN</code> command has the flexibility to be executed multiple times within a file.</p> <p>See section 8.1.6 of The Gerber Layer Format Specification Revision 2023.03 - https://argmaster.github.io/pygerber/latest/gerber_specification/revision_2023_03.html</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/ln_load_name.py</code> <pre><code>class LoadName(ExtendedCommandToken):\n    \"\"\"Comment token.\n\n    ### Load Name (LN)\n\n    Note: The LN command was deprecated in revision I4 from October 2013.\n\n    The historic `LN` command doesn't influence the image in any manner and can safely\n    be overlooked.\n\n    Function of the `LN` command:\n    - `LN` is designed to allocate a name to the following section of the file.\n    - It was originally conceptualized to serve as a human-readable comment.\n    - For creating human-readable comments, it's advisable to utilize the standard `G04`\n        command.\n    - The `LN` command has the flexibility to be executed multiple times within a file.\n\n    See section 8.1.6 of The Gerber Layer Format Specification Revision 2023.03 - https://argmaster.github.io/pygerber/latest/gerber_specification/revision_2023_03.html\n    \"\"\"\n\n    def __init__(self, string: str, location: int, content: str) -&gt; None:\n        super().__init__(string, location)\n        self.content = content\n\n    @classmethod\n    def new(cls, string: str, location: int, tokens: ParseResults) -&gt; Self:\n        \"\"\"Create instance of this class.\n\n        Created to be used as callback in `ParserElement.set_parse_action()`.\n        \"\"\"\n        content: str = str(tokens[\"string\"])\n        return cls(string=string, location=location, content=content)\n\n    def update_drawing_state(\n        self,\n        state: State,\n        _backend: Backend,\n    ) -&gt; Tuple[State, Iterable[DrawCommand]]:\n        \"\"\"Update drawing state.\"\"\"\n        warn_deprecated_code(\"LN\", \"8.1\")\n        return super().update_drawing_state(state, _backend)\n\n    def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n        \"\"\"Perform actions on the context implicated by this token.\"\"\"\n        context.get_hooks().load_name.pre_parser_visit_token(self, context)\n        context.get_hooks().load_name.on_parser_visit_token(self, context)\n        context.get_hooks().load_name.post_parser_visit_token(self, context)\n\n    def get_gerber_code(\n        self,\n        indent: str = \"\",  # noqa: ARG002\n        endline: str = \"\\n\",  # noqa: ARG002\n    ) -&gt; str:\n        \"\"\"Get gerber code represented by this token.\"\"\"\n        return f\"LN{self.content}\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ln_load_name.html#pygerber.gerberx3.tokenizer.tokens.ln_load_name.LoadName.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(\n    string: str, location: int, tokens: ParseResults\n) -&gt; Self\n</code></pre> <p>Create instance of this class.</p> <p>Created to be used as callback in <code>ParserElement.set_parse_action()</code>.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/ln_load_name.py</code> <pre><code>@classmethod\ndef new(cls, string: str, location: int, tokens: ParseResults) -&gt; Self:\n    \"\"\"Create instance of this class.\n\n    Created to be used as callback in `ParserElement.set_parse_action()`.\n    \"\"\"\n    content: str = str(tokens[\"string\"])\n    return cls(string=string, location=location, content=content)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ln_load_name.html#pygerber.gerberx3.tokenizer.tokens.ln_load_name.LoadName.update_drawing_state","title":"update_drawing_state","text":"<pre><code>update_drawing_state(\n    state: State, _backend: Backend\n) -&gt; Tuple[State, Iterable[DrawCommand]]\n</code></pre> <p>Update drawing state.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/ln_load_name.py</code> <pre><code>def update_drawing_state(\n    self,\n    state: State,\n    _backend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n    \"\"\"Update drawing state.\"\"\"\n    warn_deprecated_code(\"LN\", \"8.1\")\n    return super().update_drawing_state(state, _backend)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ln_load_name.html#pygerber.gerberx3.tokenizer.tokens.ln_load_name.LoadName.parser2_visit_token","title":"parser2_visit_token","text":"<pre><code>parser2_visit_token(context: Parser2Context) -&gt; None\n</code></pre> <p>Perform actions on the context implicated by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/ln_load_name.py</code> <pre><code>def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n    \"\"\"Perform actions on the context implicated by this token.\"\"\"\n    context.get_hooks().load_name.pre_parser_visit_token(self, context)\n    context.get_hooks().load_name.on_parser_visit_token(self, context)\n    context.get_hooks().load_name.post_parser_visit_token(self, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ln_load_name.html#pygerber.gerberx3.tokenizer.tokens.ln_load_name.LoadName.get_gerber_code","title":"get_gerber_code","text":"<pre><code>get_gerber_code(\n    indent: str = \"\", endline: str = \"\\n\"\n) -&gt; str\n</code></pre> <p>Get gerber code represented by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/ln_load_name.py</code> <pre><code>def get_gerber_code(\n    self,\n    indent: str = \"\",  # noqa: ARG002\n    endline: str = \"\\n\",  # noqa: ARG002\n) -&gt; str:\n    \"\"\"Get gerber code represented by this token.\"\"\"\n    return f\"LN{self.content}\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/lp_load_polarity.html","title":"lp_load_polarity","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/lp_load_polarity.html#pygerber.gerberx3.tokenizer.tokens.lp_load_polarity","title":"lp_load_polarity","text":"<p>Wrapper for load polarity token.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/lp_load_polarity.html#pygerber.gerberx3.tokenizer.tokens.lp_load_polarity.LoadPolarity","title":"LoadPolarity","text":"<p>             Bases: <code>ExtendedCommandToken</code></p> <p>Wrapper for load polarity token.</p> <p>Loads the scale object transformation parameter.</p> <p>See section 4.9.2 of The Gerber Layer Format Specification Revision 2023.03 - https://argmaster.github.io/pygerber/latest/gerber_specification/revision_2023_03.html</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/lp_load_polarity.py</code> <pre><code>class LoadPolarity(ExtendedCommandToken):\n    \"\"\"Wrapper for load polarity token.\n\n    Loads the scale object transformation parameter.\n\n    See section 4.9.2 of The Gerber Layer Format Specification Revision 2023.03 - https://argmaster.github.io/pygerber/latest/gerber_specification/revision_2023_03.html\n    \"\"\"\n\n    def __init__(\n        self,\n        string: str,\n        location: int,\n        polarity: Polarity,\n    ) -&gt; None:\n        super().__init__(string, location)\n        self.polarity = polarity\n\n    @classmethod\n    def new(cls, string: str, location: int, tokens: ParseResults) -&gt; Self:\n        \"\"\"Create instance of this class.\n\n        Created to be used as callback in `ParserElement.set_parse_action()`.\n        \"\"\"\n        polarity = Polarity(tokens[\"polarity\"])\n        return cls(string=string, location=location, polarity=polarity)\n\n    def update_drawing_state(\n        self,\n        state: State,\n        _backend: Backend,\n    ) -&gt; Tuple[State, Iterable[DrawCommand]]:\n        \"\"\"Set drawing polarity.\"\"\"\n        return (\n            state.model_copy(\n                update={\n                    \"polarity\": self.polarity,\n                },\n            ),\n            (),\n        )\n\n    def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n        \"\"\"Perform actions on the context implicated by this token.\"\"\"\n        context.get_hooks().load_polarity.pre_parser_visit_token(self, context)\n        context.get_hooks().load_polarity.on_parser_visit_token(self, context)\n        context.get_hooks().load_polarity.post_parser_visit_token(self, context)\n\n    def get_gerber_code(\n        self,\n        indent: str = \"\",  # noqa: ARG002\n        endline: str = \"\\n\",  # noqa: ARG002\n    ) -&gt; str:\n        \"\"\"Get gerber code represented by this token.\"\"\"\n        return f\"LP{self.polarity.value}\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/lp_load_polarity.html#pygerber.gerberx3.tokenizer.tokens.lp_load_polarity.LoadPolarity.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(\n    string: str, location: int, tokens: ParseResults\n) -&gt; Self\n</code></pre> <p>Create instance of this class.</p> <p>Created to be used as callback in <code>ParserElement.set_parse_action()</code>.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/lp_load_polarity.py</code> <pre><code>@classmethod\ndef new(cls, string: str, location: int, tokens: ParseResults) -&gt; Self:\n    \"\"\"Create instance of this class.\n\n    Created to be used as callback in `ParserElement.set_parse_action()`.\n    \"\"\"\n    polarity = Polarity(tokens[\"polarity\"])\n    return cls(string=string, location=location, polarity=polarity)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/lp_load_polarity.html#pygerber.gerberx3.tokenizer.tokens.lp_load_polarity.LoadPolarity.update_drawing_state","title":"update_drawing_state","text":"<pre><code>update_drawing_state(\n    state: State, _backend: Backend\n) -&gt; Tuple[State, Iterable[DrawCommand]]\n</code></pre> <p>Set drawing polarity.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/lp_load_polarity.py</code> <pre><code>def update_drawing_state(\n    self,\n    state: State,\n    _backend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n    \"\"\"Set drawing polarity.\"\"\"\n    return (\n        state.model_copy(\n            update={\n                \"polarity\": self.polarity,\n            },\n        ),\n        (),\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/lp_load_polarity.html#pygerber.gerberx3.tokenizer.tokens.lp_load_polarity.LoadPolarity.parser2_visit_token","title":"parser2_visit_token","text":"<pre><code>parser2_visit_token(context: Parser2Context) -&gt; None\n</code></pre> <p>Perform actions on the context implicated by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/lp_load_polarity.py</code> <pre><code>def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n    \"\"\"Perform actions on the context implicated by this token.\"\"\"\n    context.get_hooks().load_polarity.pre_parser_visit_token(self, context)\n    context.get_hooks().load_polarity.on_parser_visit_token(self, context)\n    context.get_hooks().load_polarity.post_parser_visit_token(self, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/lp_load_polarity.html#pygerber.gerberx3.tokenizer.tokens.lp_load_polarity.LoadPolarity.get_gerber_code","title":"get_gerber_code","text":"<pre><code>get_gerber_code(\n    indent: str = \"\", endline: str = \"\\n\"\n) -&gt; str\n</code></pre> <p>Get gerber code represented by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/lp_load_polarity.py</code> <pre><code>def get_gerber_code(\n    self,\n    indent: str = \"\",  # noqa: ARG002\n    endline: str = \"\\n\",  # noqa: ARG002\n) -&gt; str:\n    \"\"\"Get gerber code represented by this token.\"\"\"\n    return f\"LP{self.polarity.value}\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/lr_load_rotation.html","title":"lr_load_rotation","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/lr_load_rotation.html#pygerber.gerberx3.tokenizer.tokens.lr_load_rotation","title":"lr_load_rotation","text":"<p>Wrapper for load rotation token.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/lr_load_rotation.html#pygerber.gerberx3.tokenizer.tokens.lr_load_rotation.LoadRotation","title":"LoadRotation","text":"<p>             Bases: <code>ExtendedCommandToken</code></p> <p>Wrapper for load rotation token.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/lr_load_rotation.html#pygerber.gerberx3.tokenizer.tokens.lr_load_rotation.LoadRotation--lr-command-rotation-graphics-state-parameter","title":"LR Command: Rotation Graphics State Parameter","text":"<p>The <code>LR</code> command is utilized to configure the rotation graphics state parameter.</p> <p>Functionality: - This command specifies the rotation angle to be applied when crafting objects. - The aperture is rotated centered on its origin, which might either coincide with     or differ from its geometric center.</p> <p>Usage and Persistence: - The <code>LR</code> command can be invoked numerous times throughout a file. - Once defined, the object rotation retains its configuration unless overridden by     an ensuing <code>LR</code> command. - Rotation is strictly determined by the exact value mentioned in the command and     doesn't integrate with any prior rotation values.</p> <p>The LR command was introduced in revision 2016.12.</p> <p>See section 4.9.4 of The Gerber Layer Format Specification Revision 2023.03 - https://argmaster.github.io/pygerber/latest/gerber_specification/revision_2023_03.html</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/lr_load_rotation.py</code> <pre><code>class LoadRotation(ExtendedCommandToken):\n    \"\"\"Wrapper for load rotation token.\n\n    ### LR Command: Rotation Graphics State Parameter\n\n    The `LR` command is utilized to configure the rotation graphics state parameter.\n\n    Functionality:\n    - This command specifies the rotation angle to be applied when crafting objects.\n    - The aperture is rotated centered on its origin, which might either coincide with\n        or differ from its geometric center.\n\n    Usage and Persistence:\n    - The `LR` command can be invoked numerous times throughout a file.\n    - Once defined, the object rotation retains its configuration unless overridden by\n        an ensuing `LR` command.\n    - Rotation is strictly determined by the exact value mentioned in the command and\n        doesn't integrate with any prior rotation values.\n\n    The LR command was introduced in revision 2016.12.\n\n    See section 4.9.4 of The Gerber Layer Format Specification Revision 2023.03 - https://argmaster.github.io/pygerber/latest/gerber_specification/revision_2023_03.html\n    \"\"\"\n\n    def __init__(\n        self,\n        string: str,\n        location: int,\n        rotation: Decimal,\n    ) -&gt; None:\n        super().__init__(string, location)\n        self.rotation = rotation\n\n    @classmethod\n    def new(cls, string: str, location: int, tokens: ParseResults) -&gt; Self:\n        \"\"\"Create instance of this class.\n\n        Created to be used as callback in `ParserElement.set_parse_action()`.\n        \"\"\"\n        rotation = Decimal(str(tokens[\"rotation\"]))\n        return cls(string=string, location=location, rotation=rotation)\n\n    def update_drawing_state(\n        self,\n        state: State,\n        _backend: Backend,\n    ) -&gt; Tuple[State, Iterable[DrawCommand]]:\n        \"\"\"Set drawing polarity.\"\"\"\n        return (\n            state.model_copy(\n                update={\n                    \"rotation\": self.rotation,\n                },\n            ),\n            (),\n        )\n\n    def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n        \"\"\"Perform actions on the context implicated by this token.\"\"\"\n        context.get_hooks().load_rotation.pre_parser_visit_token(self, context)\n        context.get_hooks().load_rotation.on_parser_visit_token(self, context)\n        context.get_hooks().load_rotation.post_parser_visit_token(self, context)\n\n    def get_gerber_code(\n        self,\n        indent: str = \"\",  # noqa: ARG002\n        endline: str = \"\\n\",  # noqa: ARG002\n    ) -&gt; str:\n        \"\"\"Get gerber code represented by this token.\"\"\"\n        return f\"LR{self.rotation}\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/lr_load_rotation.html#pygerber.gerberx3.tokenizer.tokens.lr_load_rotation.LoadRotation.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(\n    string: str, location: int, tokens: ParseResults\n) -&gt; Self\n</code></pre> <p>Create instance of this class.</p> <p>Created to be used as callback in <code>ParserElement.set_parse_action()</code>.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/lr_load_rotation.py</code> <pre><code>@classmethod\ndef new(cls, string: str, location: int, tokens: ParseResults) -&gt; Self:\n    \"\"\"Create instance of this class.\n\n    Created to be used as callback in `ParserElement.set_parse_action()`.\n    \"\"\"\n    rotation = Decimal(str(tokens[\"rotation\"]))\n    return cls(string=string, location=location, rotation=rotation)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/lr_load_rotation.html#pygerber.gerberx3.tokenizer.tokens.lr_load_rotation.LoadRotation.update_drawing_state","title":"update_drawing_state","text":"<pre><code>update_drawing_state(\n    state: State, _backend: Backend\n) -&gt; Tuple[State, Iterable[DrawCommand]]\n</code></pre> <p>Set drawing polarity.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/lr_load_rotation.py</code> <pre><code>def update_drawing_state(\n    self,\n    state: State,\n    _backend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n    \"\"\"Set drawing polarity.\"\"\"\n    return (\n        state.model_copy(\n            update={\n                \"rotation\": self.rotation,\n            },\n        ),\n        (),\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/lr_load_rotation.html#pygerber.gerberx3.tokenizer.tokens.lr_load_rotation.LoadRotation.parser2_visit_token","title":"parser2_visit_token","text":"<pre><code>parser2_visit_token(context: Parser2Context) -&gt; None\n</code></pre> <p>Perform actions on the context implicated by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/lr_load_rotation.py</code> <pre><code>def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n    \"\"\"Perform actions on the context implicated by this token.\"\"\"\n    context.get_hooks().load_rotation.pre_parser_visit_token(self, context)\n    context.get_hooks().load_rotation.on_parser_visit_token(self, context)\n    context.get_hooks().load_rotation.post_parser_visit_token(self, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/lr_load_rotation.html#pygerber.gerberx3.tokenizer.tokens.lr_load_rotation.LoadRotation.get_gerber_code","title":"get_gerber_code","text":"<pre><code>get_gerber_code(\n    indent: str = \"\", endline: str = \"\\n\"\n) -&gt; str\n</code></pre> <p>Get gerber code represented by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/lr_load_rotation.py</code> <pre><code>def get_gerber_code(\n    self,\n    indent: str = \"\",  # noqa: ARG002\n    endline: str = \"\\n\",  # noqa: ARG002\n) -&gt; str:\n    \"\"\"Get gerber code represented by this token.\"\"\"\n    return f\"LR{self.rotation}\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ls_load_scaling.html","title":"ls_load_scaling","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ls_load_scaling.html#pygerber.gerberx3.tokenizer.tokens.ls_load_scaling","title":"ls_load_scaling","text":"<p>Wrapper for load scaling token.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ls_load_scaling.html#pygerber.gerberx3.tokenizer.tokens.ls_load_scaling.LoadScaling","title":"LoadScaling","text":"<p>             Bases: <code>ExtendedCommandToken</code></p> <p>Wrapper for load scaling token.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ls_load_scaling.html#pygerber.gerberx3.tokenizer.tokens.ls_load_scaling.LoadScaling--ls-command-scaling-graphics-state-parameter","title":"LS Command: Scaling Graphics State Parameter","text":"<p>The <code>LS</code> command is employed to establish the scaling graphics state parameter.</p> <p>Functionality: - The command dictates the scale factor utilized during object creation. - The aperture undergoes scaling, anchored at its origin. It's crucial to note that     this origin might not always align with its geometric center.</p> <p>Usage and Persistence: - The <code>LS</code> command can be invoked multiple times within a single file. - Once set, the object scaling retains its value unless a subsequent <code>LS</code> command     modifies it. - The scaling gets adjusted based on the specific value mentioned in the command and     doesn't accumulate with the preceding scale factor.</p> <p>The LS command was introduced in revision 2016.12.</p> <p>See section 4.9.5 of The Gerber Layer Format Specification Revision 2023.03 - https://argmaster.github.io/pygerber/latest/gerber_specification/revision_2023_03.html</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/ls_load_scaling.py</code> <pre><code>class LoadScaling(ExtendedCommandToken):\n    \"\"\"Wrapper for load scaling token.\n\n    ### LS Command: Scaling Graphics State Parameter\n\n    The `LS` command is employed to establish the scaling graphics state parameter.\n\n    Functionality:\n    - The command dictates the scale factor utilized during object creation.\n    - The aperture undergoes scaling, anchored at its origin. It's crucial to note that\n        this origin might not always align with its geometric center.\n\n    Usage and Persistence:\n    - The `LS` command can be invoked multiple times within a single file.\n    - Once set, the object scaling retains its value unless a subsequent `LS` command\n        modifies it.\n    - The scaling gets adjusted based on the specific value mentioned in the command and\n        doesn't accumulate with the preceding scale factor.\n\n    The LS command was introduced in revision 2016.12.\n\n    See section 4.9.5 of The Gerber Layer Format Specification Revision 2023.03 - https://argmaster.github.io/pygerber/latest/gerber_specification/revision_2023_03.html\n    \"\"\"\n\n    def __init__(\n        self,\n        string: str,\n        location: int,\n        scaling: Decimal,\n    ) -&gt; None:\n        super().__init__(string, location)\n        self.scaling = scaling\n\n    @classmethod\n    def new(cls, string: str, location: int, tokens: ParseResults) -&gt; Self:\n        \"\"\"Create instance of this class.\n\n        Created to be used as callback in `ParserElement.set_parse_action()`.\n        \"\"\"\n        scaling = Decimal(str(tokens[\"scaling\"]))\n        return cls(string=string, location=location, scaling=scaling)\n\n    def update_drawing_state(\n        self,\n        state: State,\n        _backend: Backend,\n    ) -&gt; Tuple[State, Iterable[DrawCommand]]:\n        \"\"\"Set drawing polarity.\"\"\"\n        return (\n            state.model_copy(\n                update={\n                    \"scaling\": self.scaling,\n                },\n            ),\n            (),\n        )\n\n    def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n        \"\"\"Perform actions on the context implicated by this token.\"\"\"\n        context.get_hooks().load_scaling.pre_parser_visit_token(self, context)\n        context.get_hooks().load_scaling.on_parser_visit_token(self, context)\n        context.get_hooks().load_scaling.post_parser_visit_token(self, context)\n\n    def get_gerber_code(\n        self,\n        indent: str = \"\",  # noqa: ARG002\n        endline: str = \"\\n\",  # noqa: ARG002\n    ) -&gt; str:\n        \"\"\"Get gerber code represented by this token.\"\"\"\n        return f\"LS{self.scaling}\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ls_load_scaling.html#pygerber.gerberx3.tokenizer.tokens.ls_load_scaling.LoadScaling.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(\n    string: str, location: int, tokens: ParseResults\n) -&gt; Self\n</code></pre> <p>Create instance of this class.</p> <p>Created to be used as callback in <code>ParserElement.set_parse_action()</code>.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/ls_load_scaling.py</code> <pre><code>@classmethod\ndef new(cls, string: str, location: int, tokens: ParseResults) -&gt; Self:\n    \"\"\"Create instance of this class.\n\n    Created to be used as callback in `ParserElement.set_parse_action()`.\n    \"\"\"\n    scaling = Decimal(str(tokens[\"scaling\"]))\n    return cls(string=string, location=location, scaling=scaling)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ls_load_scaling.html#pygerber.gerberx3.tokenizer.tokens.ls_load_scaling.LoadScaling.update_drawing_state","title":"update_drawing_state","text":"<pre><code>update_drawing_state(\n    state: State, _backend: Backend\n) -&gt; Tuple[State, Iterable[DrawCommand]]\n</code></pre> <p>Set drawing polarity.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/ls_load_scaling.py</code> <pre><code>def update_drawing_state(\n    self,\n    state: State,\n    _backend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n    \"\"\"Set drawing polarity.\"\"\"\n    return (\n        state.model_copy(\n            update={\n                \"scaling\": self.scaling,\n            },\n        ),\n        (),\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ls_load_scaling.html#pygerber.gerberx3.tokenizer.tokens.ls_load_scaling.LoadScaling.parser2_visit_token","title":"parser2_visit_token","text":"<pre><code>parser2_visit_token(context: Parser2Context) -&gt; None\n</code></pre> <p>Perform actions on the context implicated by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/ls_load_scaling.py</code> <pre><code>def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n    \"\"\"Perform actions on the context implicated by this token.\"\"\"\n    context.get_hooks().load_scaling.pre_parser_visit_token(self, context)\n    context.get_hooks().load_scaling.on_parser_visit_token(self, context)\n    context.get_hooks().load_scaling.post_parser_visit_token(self, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ls_load_scaling.html#pygerber.gerberx3.tokenizer.tokens.ls_load_scaling.LoadScaling.get_gerber_code","title":"get_gerber_code","text":"<pre><code>get_gerber_code(\n    indent: str = \"\", endline: str = \"\\n\"\n) -&gt; str\n</code></pre> <p>Get gerber code represented by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/ls_load_scaling.py</code> <pre><code>def get_gerber_code(\n    self,\n    indent: str = \"\",  # noqa: ARG002\n    endline: str = \"\\n\",  # noqa: ARG002\n) -&gt; str:\n    \"\"\"Get gerber code represented by this token.\"\"\"\n    return f\"LS{self.scaling}\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/m00_program_stop.html","title":"m00_program_stop","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/m00_program_stop.html#pygerber.gerberx3.tokenizer.tokens.m00_program_stop","title":"m00_program_stop","text":"<p>Wrapper for program stop token.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/m00_program_stop.html#pygerber.gerberx3.tokenizer.tokens.m00_program_stop.M00ProgramStop","title":"M00ProgramStop","text":"<p>             Bases: <code>CommandToken</code></p> <p>Wrapper for program stop token.</p> <p>See section 8.1.1 of The Gerber Layer Format Specification Revision 2023.03 - https://argmaster.github.io/pygerber/latest/gerber_specification/revision_2023_03.html</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/m00_program_stop.py</code> <pre><code>class M00ProgramStop(CommandToken):\n    \"\"\"Wrapper for program stop token.\n\n    See section 8.1.1 of The Gerber Layer Format Specification Revision 2023.03 - https://argmaster.github.io/pygerber/latest/gerber_specification/revision_2023_03.html\n    \"\"\"\n\n    def update_drawing_state(\n        self,\n        _state: State,\n        _backend: Backend,\n    ) -&gt; Tuple[State, Iterable[DrawCommand]]:\n        \"\"\"Exit drawing process.\"\"\"\n        raise ExitParsingProcessInterrupt\n\n    def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n        \"\"\"Perform actions on the context implicated by this token.\"\"\"\n        context.get_hooks().program_stop.pre_parser_visit_token(self, context)\n        context.get_hooks().program_stop.on_parser_visit_token(self, context)\n        context.get_hooks().program_stop.post_parser_visit_token(self, context)\n\n    def get_gerber_code(\n        self,\n        indent: str = \"\",\n        endline: str = \"\\n\",  # noqa: ARG002\n    ) -&gt; str:\n        \"\"\"Get gerber code represented by this token.\"\"\"\n        return f\"{indent}M00\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/m00_program_stop.html#pygerber.gerberx3.tokenizer.tokens.m00_program_stop.M00ProgramStop.update_drawing_state","title":"update_drawing_state","text":"<pre><code>update_drawing_state(\n    _state: State, _backend: Backend\n) -&gt; Tuple[State, Iterable[DrawCommand]]\n</code></pre> <p>Exit drawing process.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/m00_program_stop.py</code> <pre><code>def update_drawing_state(\n    self,\n    _state: State,\n    _backend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n    \"\"\"Exit drawing process.\"\"\"\n    raise ExitParsingProcessInterrupt\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/m00_program_stop.html#pygerber.gerberx3.tokenizer.tokens.m00_program_stop.M00ProgramStop.parser2_visit_token","title":"parser2_visit_token","text":"<pre><code>parser2_visit_token(context: Parser2Context) -&gt; None\n</code></pre> <p>Perform actions on the context implicated by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/m00_program_stop.py</code> <pre><code>def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n    \"\"\"Perform actions on the context implicated by this token.\"\"\"\n    context.get_hooks().program_stop.pre_parser_visit_token(self, context)\n    context.get_hooks().program_stop.on_parser_visit_token(self, context)\n    context.get_hooks().program_stop.post_parser_visit_token(self, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/m00_program_stop.html#pygerber.gerberx3.tokenizer.tokens.m00_program_stop.M00ProgramStop.get_gerber_code","title":"get_gerber_code","text":"<pre><code>get_gerber_code(\n    indent: str = \"\", endline: str = \"\\n\"\n) -&gt; str\n</code></pre> <p>Get gerber code represented by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/m00_program_stop.py</code> <pre><code>def get_gerber_code(\n    self,\n    indent: str = \"\",\n    endline: str = \"\\n\",  # noqa: ARG002\n) -&gt; str:\n    \"\"\"Get gerber code represented by this token.\"\"\"\n    return f\"{indent}M00\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/m01_optional_stop.html","title":"m01_optional_stop","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/m01_optional_stop.html#pygerber.gerberx3.tokenizer.tokens.m01_optional_stop","title":"m01_optional_stop","text":"<p>Wrapper for optional stop token.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/m01_optional_stop.html#pygerber.gerberx3.tokenizer.tokens.m01_optional_stop.M01OptionalStop","title":"M01OptionalStop","text":"<p>             Bases: <code>CommandToken</code></p> <p>Wrapper for optional stop token.</p> <p>See section 8.1.1 of The Gerber Layer Format Specification Revision 2023.03 - https://argmaster.github.io/pygerber/latest/gerber_specification/revision_2023_03.html</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/m01_optional_stop.py</code> <pre><code>class M01OptionalStop(CommandToken):\n    \"\"\"Wrapper for optional stop token.\n\n    See section 8.1.1 of The Gerber Layer Format Specification Revision 2023.03 - https://argmaster.github.io/pygerber/latest/gerber_specification/revision_2023_03.html\n    \"\"\"\n\n    def update_drawing_state(\n        self,\n        _state: State,\n        _backend: Backend,\n    ) -&gt; Tuple[State, Iterable[DrawCommand]]:\n        \"\"\"Exit drawing process.\"\"\"\n        raise ExitParsingProcessInterrupt\n\n    def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n        \"\"\"Perform actions on the context implicated by this token.\"\"\"\n        context.get_hooks().optional_stop.pre_parser_visit_token(self, context)\n        context.get_hooks().optional_stop.on_parser_visit_token(self, context)\n        context.get_hooks().optional_stop.post_parser_visit_token(self, context)\n\n    def get_gerber_code(\n        self,\n        indent: str = \"\",\n        endline: str = \"\\n\",  # noqa: ARG002\n    ) -&gt; str:\n        \"\"\"Get gerber code represented by this token.\"\"\"\n        return f\"{indent}M01\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/m01_optional_stop.html#pygerber.gerberx3.tokenizer.tokens.m01_optional_stop.M01OptionalStop.update_drawing_state","title":"update_drawing_state","text":"<pre><code>update_drawing_state(\n    _state: State, _backend: Backend\n) -&gt; Tuple[State, Iterable[DrawCommand]]\n</code></pre> <p>Exit drawing process.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/m01_optional_stop.py</code> <pre><code>def update_drawing_state(\n    self,\n    _state: State,\n    _backend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n    \"\"\"Exit drawing process.\"\"\"\n    raise ExitParsingProcessInterrupt\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/m01_optional_stop.html#pygerber.gerberx3.tokenizer.tokens.m01_optional_stop.M01OptionalStop.parser2_visit_token","title":"parser2_visit_token","text":"<pre><code>parser2_visit_token(context: Parser2Context) -&gt; None\n</code></pre> <p>Perform actions on the context implicated by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/m01_optional_stop.py</code> <pre><code>def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n    \"\"\"Perform actions on the context implicated by this token.\"\"\"\n    context.get_hooks().optional_stop.pre_parser_visit_token(self, context)\n    context.get_hooks().optional_stop.on_parser_visit_token(self, context)\n    context.get_hooks().optional_stop.post_parser_visit_token(self, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/m01_optional_stop.html#pygerber.gerberx3.tokenizer.tokens.m01_optional_stop.M01OptionalStop.get_gerber_code","title":"get_gerber_code","text":"<pre><code>get_gerber_code(\n    indent: str = \"\", endline: str = \"\\n\"\n) -&gt; str\n</code></pre> <p>Get gerber code represented by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/m01_optional_stop.py</code> <pre><code>def get_gerber_code(\n    self,\n    indent: str = \"\",\n    endline: str = \"\\n\",  # noqa: ARG002\n) -&gt; str:\n    \"\"\"Get gerber code represented by this token.\"\"\"\n    return f\"{indent}M01\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/m02_end_of_file.html","title":"m02_end_of_file","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/m02_end_of_file.html#pygerber.gerberx3.tokenizer.tokens.m02_end_of_file","title":"m02_end_of_file","text":"<p>Wrapper for end of file token.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/m02_end_of_file.html#pygerber.gerberx3.tokenizer.tokens.m02_end_of_file.M02EndOfFile","title":"M02EndOfFile","text":"<p>             Bases: <code>CommandToken</code></p> <p>Wrapper for end of file token.</p> <p>See section 4.10 of The Gerber Layer Format Specification Revision 2023.03 - https://argmaster.github.io/pygerber/latest/gerber_specification/revision_2023_03.html</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/m02_end_of_file.py</code> <pre><code>class M02EndOfFile(CommandToken):\n    \"\"\"Wrapper for end of file token.\n\n    See section 4.10 of The Gerber Layer Format Specification Revision 2023.03 - https://argmaster.github.io/pygerber/latest/gerber_specification/revision_2023_03.html\n    \"\"\"\n\n    def update_drawing_state(\n        self,\n        _state: State,\n        _backend: Backend,\n    ) -&gt; Tuple[State, Iterable[DrawCommand]]:\n        \"\"\"Exit drawing process.\"\"\"\n        raise ExitParsingProcessInterrupt\n\n    def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n        \"\"\"Perform actions on the context implicated by this token.\"\"\"\n        context.get_hooks().end_of_file.pre_parser_visit_token(self, context)\n        context.get_hooks().end_of_file.on_parser_visit_token(self, context)\n        context.get_hooks().end_of_file.post_parser_visit_token(self, context)\n\n    def get_gerber_code(\n        self,\n        indent: str = \"\",\n        endline: str = \"\\n\",  # noqa: ARG002\n    ) -&gt; str:\n        \"\"\"Get gerber code represented by this token.\"\"\"\n        return f\"{indent}M02\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/m02_end_of_file.html#pygerber.gerberx3.tokenizer.tokens.m02_end_of_file.M02EndOfFile.update_drawing_state","title":"update_drawing_state","text":"<pre><code>update_drawing_state(\n    _state: State, _backend: Backend\n) -&gt; Tuple[State, Iterable[DrawCommand]]\n</code></pre> <p>Exit drawing process.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/m02_end_of_file.py</code> <pre><code>def update_drawing_state(\n    self,\n    _state: State,\n    _backend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n    \"\"\"Exit drawing process.\"\"\"\n    raise ExitParsingProcessInterrupt\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/m02_end_of_file.html#pygerber.gerberx3.tokenizer.tokens.m02_end_of_file.M02EndOfFile.parser2_visit_token","title":"parser2_visit_token","text":"<pre><code>parser2_visit_token(context: Parser2Context) -&gt; None\n</code></pre> <p>Perform actions on the context implicated by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/m02_end_of_file.py</code> <pre><code>def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n    \"\"\"Perform actions on the context implicated by this token.\"\"\"\n    context.get_hooks().end_of_file.pre_parser_visit_token(self, context)\n    context.get_hooks().end_of_file.on_parser_visit_token(self, context)\n    context.get_hooks().end_of_file.post_parser_visit_token(self, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/m02_end_of_file.html#pygerber.gerberx3.tokenizer.tokens.m02_end_of_file.M02EndOfFile.get_gerber_code","title":"get_gerber_code","text":"<pre><code>get_gerber_code(\n    indent: str = \"\", endline: str = \"\\n\"\n) -&gt; str\n</code></pre> <p>Get gerber code represented by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/m02_end_of_file.py</code> <pre><code>def get_gerber_code(\n    self,\n    indent: str = \"\",\n    endline: str = \"\\n\",  # noqa: ARG002\n) -&gt; str:\n    \"\"\"Get gerber code represented by this token.\"\"\"\n    return f\"{indent}M02\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/mo_unit_mode.html","title":"mo_unit_mode","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/mo_unit_mode.html#pygerber.gerberx3.tokenizer.tokens.mo_unit_mode","title":"mo_unit_mode","text":"<p>Wrapper for set unit mode token.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/mo_unit_mode.html#pygerber.gerberx3.tokenizer.tokens.mo_unit_mode.UnitMode","title":"UnitMode","text":"<p>             Bases: <code>ExtendedCommandToken</code></p> <p>Wrapper for set unit mode token.</p> <p>Sets the unit to mm or inch.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/mo_unit_mode.py</code> <pre><code>class UnitMode(ExtendedCommandToken):\n    \"\"\"Wrapper for set unit mode token.\n\n    Sets the unit to mm or inch.\n    \"\"\"\n\n    def __init__(self, string: str, location: int, unit: Unit) -&gt; None:\n        super().__init__(string, location)\n        self.unit = unit\n\n    @classmethod\n    def new(cls, string: str, location: int, tokens: ParseResults) -&gt; Self:\n        \"\"\"Create instance of this class.\n\n        Created to be used as callback in `ParserElement.set_parse_action()`.\n        \"\"\"\n        unit: Unit = Unit(tokens[\"unit\"])\n        return cls(string=string, location=location, unit=unit)\n\n    def update_drawing_state(\n        self,\n        state: State,\n        _backend: Backend,\n    ) -&gt; Tuple[State, Iterable[DrawCommand]]:\n        \"\"\"Update drawing state.\"\"\"\n        if self.unit == Unit.Inches:\n            logging.warning(\n                \"Detected use of imperial units. Using metric units is recommended. \"\n                \"Imperial units will be deprecated in future. \"\n                \"(See 4.2.1 in Gerber Layer Format Specification)\",\n            )\n        if state.draw_units is not None:\n            logging.warning(\n                \"Overriding coordinate format is illegal. \"\n                \"(See 4.2.1 in Gerber Layer Format Specification)\",\n            )\n        return (\n            state.model_copy(\n                update={\n                    \"draw_units\": self.unit,\n                },\n            ),\n            (),\n        )\n\n    def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n        \"\"\"Perform actions on the context implicated by this token.\"\"\"\n        context.get_hooks().unit_mode.pre_parser_visit_token(self, context)\n        context.get_hooks().unit_mode.on_parser_visit_token(self, context)\n        context.get_hooks().unit_mode.post_parser_visit_token(self, context)\n\n    def get_gerber_code(\n        self,\n        indent: str = \"\",  # noqa: ARG002\n        endline: str = \"\\n\",  # noqa: ARG002\n    ) -&gt; str:\n        \"\"\"Get gerber code represented by this token.\"\"\"\n        return f\"MO{self.unit.value}\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/mo_unit_mode.html#pygerber.gerberx3.tokenizer.tokens.mo_unit_mode.UnitMode.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(\n    string: str, location: int, tokens: ParseResults\n) -&gt; Self\n</code></pre> <p>Create instance of this class.</p> <p>Created to be used as callback in <code>ParserElement.set_parse_action()</code>.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/mo_unit_mode.py</code> <pre><code>@classmethod\ndef new(cls, string: str, location: int, tokens: ParseResults) -&gt; Self:\n    \"\"\"Create instance of this class.\n\n    Created to be used as callback in `ParserElement.set_parse_action()`.\n    \"\"\"\n    unit: Unit = Unit(tokens[\"unit\"])\n    return cls(string=string, location=location, unit=unit)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/mo_unit_mode.html#pygerber.gerberx3.tokenizer.tokens.mo_unit_mode.UnitMode.update_drawing_state","title":"update_drawing_state","text":"<pre><code>update_drawing_state(\n    state: State, _backend: Backend\n) -&gt; Tuple[State, Iterable[DrawCommand]]\n</code></pre> <p>Update drawing state.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/mo_unit_mode.py</code> <pre><code>def update_drawing_state(\n    self,\n    state: State,\n    _backend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n    \"\"\"Update drawing state.\"\"\"\n    if self.unit == Unit.Inches:\n        logging.warning(\n            \"Detected use of imperial units. Using metric units is recommended. \"\n            \"Imperial units will be deprecated in future. \"\n            \"(See 4.2.1 in Gerber Layer Format Specification)\",\n        )\n    if state.draw_units is not None:\n        logging.warning(\n            \"Overriding coordinate format is illegal. \"\n            \"(See 4.2.1 in Gerber Layer Format Specification)\",\n        )\n    return (\n        state.model_copy(\n            update={\n                \"draw_units\": self.unit,\n            },\n        ),\n        (),\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/mo_unit_mode.html#pygerber.gerberx3.tokenizer.tokens.mo_unit_mode.UnitMode.parser2_visit_token","title":"parser2_visit_token","text":"<pre><code>parser2_visit_token(context: Parser2Context) -&gt; None\n</code></pre> <p>Perform actions on the context implicated by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/mo_unit_mode.py</code> <pre><code>def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n    \"\"\"Perform actions on the context implicated by this token.\"\"\"\n    context.get_hooks().unit_mode.pre_parser_visit_token(self, context)\n    context.get_hooks().unit_mode.on_parser_visit_token(self, context)\n    context.get_hooks().unit_mode.post_parser_visit_token(self, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/mo_unit_mode.html#pygerber.gerberx3.tokenizer.tokens.mo_unit_mode.UnitMode.get_gerber_code","title":"get_gerber_code","text":"<pre><code>get_gerber_code(\n    indent: str = \"\", endline: str = \"\\n\"\n) -&gt; str\n</code></pre> <p>Get gerber code represented by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/mo_unit_mode.py</code> <pre><code>def get_gerber_code(\n    self,\n    indent: str = \"\",  # noqa: ARG002\n    endline: str = \"\\n\",  # noqa: ARG002\n) -&gt; str:\n    \"\"\"Get gerber code represented by this token.\"\"\"\n    return f\"MO{self.unit.value}\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/of_image_offset.html","title":"of_image_offset","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/of_image_offset.html#pygerber.gerberx3.tokenizer.tokens.of_image_offset","title":"of_image_offset","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/of_image_offset.html#pygerber.gerberx3.tokenizer.tokens.of_image_offset--load-name-ln","title":"Load Name (LN).","text":"<p>Note: The LN command was deprecated in revision I4 from October 2013.</p> <p>The historic <code>LN</code> command doesn't influence the image in any manner and can safely be overlooked.</p> <p>Function of the <code>LN</code> command: - <code>LN</code> is designed to allocate a name to the following section of the file. - It was originally conceptualized to serve as a human-readable comment. - For creating human-readable comments, it's advisable to utilize the standard <code>G04</code>     command. - The <code>LN</code> command has the flexibility to be executed multiple times within a file.</p> <p>SPEC: <code>2023.03</code> SECTION: <code>8.1.6</code></p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/of_image_offset.html#pygerber.gerberx3.tokenizer.tokens.of_image_offset.ImageOffset","title":"ImageOffset","text":"<p>             Bases: <code>ExtendedCommandToken</code></p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/of_image_offset.html#pygerber.gerberx3.tokenizer.tokens.of_image_offset.ImageOffset--image-offset-of","title":"Image Offset (OF).","text":"<p>The OF command is deprecated since revision I1 from December 2012.</p> <p>OF moves the final image up to plus or minus 99999.99999 units from the imaging device (0, 0) point. The image can be moved along the imaging device A or B axis, or both. The offset values used by OF command are absolute. If the A or B part is missing, the corresponding offset is 0. The offset values are expressed in units specified by MO command.  This command affects the entire image. It can only be used once, at the beginning of the file. The order of execution is always MI, SF, OF, IR and AS, independent of their order of appearance in the file.</p> <p>See section 8.1.8 of The Gerber Layer Format Specification Revision 2023.03 - https://argmaster.github.io/pygerber/latest/gerber_specification/revision_2023_03.html</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/of_image_offset.py</code> <pre><code>class ImageOffset(ExtendedCommandToken):\n    \"\"\"### Image Offset (OF).\n\n    The OF command is deprecated since revision I1 from December 2012.\n\n    OF moves the final image up to plus or minus 99999.99999 units from the imaging\n    device (0, 0) point. The image can be moved along the imaging device A or B axis,\n    or both. The offset values used by OF command are absolute. If the A or B part is\n    missing, the corresponding offset is 0. The offset values are expressed in units\n    specified by MO command.  This command affects the entire image. It can only be\n    used once, at the beginning of the file. The order of execution is always MI, SF,\n    OF, IR and AS, independent of their order of appearance in the file.\n\n    See section 8.1.8 of The Gerber Layer Format Specification Revision 2023.03 - https://argmaster.github.io/pygerber/latest/gerber_specification/revision_2023_03.html\n    \"\"\"\n\n    def __init__(\n        self,\n        string: str,\n        location: int,\n        a: Optional[Decimal],\n        b: Optional[Decimal],\n    ) -&gt; None:\n        super().__init__(string, location)\n        self.a = a\n        self.b = b\n\n    @classmethod\n    def new(cls, string: str, location: int, tokens: ParseResults) -&gt; Self:\n        \"\"\"Create instance of this class.\n\n        Created to be used as callback in `ParserElement.set_parse_action()`.\n        \"\"\"\n        a = Decimal(str(tmp)) if (tmp := tokens.get(\"a\")) is not None else None\n        b = Decimal(str(tmp)) if (tmp := tokens.get(\"b\")) is not None else None\n        return cls(string=string, location=location, a=a, b=b)\n\n    def update_drawing_state(\n        self,\n        state: State,\n        _backend: Backend,\n    ) -&gt; Tuple[State, Iterable[DrawCommand]]:\n        \"\"\"Update drawing state.\"\"\"\n        warn_deprecated_code(\"IN\", \"8.1\")\n        return super().update_drawing_state(state, _backend)\n\n    def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n        \"\"\"Perform actions on the context implicated by this token.\"\"\"\n        context.get_hooks().image_offset.pre_parser_visit_token(self, context)\n        context.get_hooks().image_offset.on_parser_visit_token(self, context)\n        context.get_hooks().image_offset.post_parser_visit_token(self, context)\n\n    def get_gerber_code(\n        self,\n        indent: str = \"\",  # noqa: ARG002\n        endline: str = \"\\n\",  # noqa: ARG002\n    ) -&gt; str:\n        \"\"\"Get gerber code represented by this token.\"\"\"\n        a = f\"A{self.a}\" if self.a is not None else \"\"\n        b = f\"B{self.b}\" if self.b is not None else \"\"\n        return f\"OF{a}{b}\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/of_image_offset.html#pygerber.gerberx3.tokenizer.tokens.of_image_offset.ImageOffset.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(\n    string: str, location: int, tokens: ParseResults\n) -&gt; Self\n</code></pre> <p>Create instance of this class.</p> <p>Created to be used as callback in <code>ParserElement.set_parse_action()</code>.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/of_image_offset.py</code> <pre><code>@classmethod\ndef new(cls, string: str, location: int, tokens: ParseResults) -&gt; Self:\n    \"\"\"Create instance of this class.\n\n    Created to be used as callback in `ParserElement.set_parse_action()`.\n    \"\"\"\n    a = Decimal(str(tmp)) if (tmp := tokens.get(\"a\")) is not None else None\n    b = Decimal(str(tmp)) if (tmp := tokens.get(\"b\")) is not None else None\n    return cls(string=string, location=location, a=a, b=b)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/of_image_offset.html#pygerber.gerberx3.tokenizer.tokens.of_image_offset.ImageOffset.update_drawing_state","title":"update_drawing_state","text":"<pre><code>update_drawing_state(\n    state: State, _backend: Backend\n) -&gt; Tuple[State, Iterable[DrawCommand]]\n</code></pre> <p>Update drawing state.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/of_image_offset.py</code> <pre><code>def update_drawing_state(\n    self,\n    state: State,\n    _backend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n    \"\"\"Update drawing state.\"\"\"\n    warn_deprecated_code(\"IN\", \"8.1\")\n    return super().update_drawing_state(state, _backend)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/of_image_offset.html#pygerber.gerberx3.tokenizer.tokens.of_image_offset.ImageOffset.parser2_visit_token","title":"parser2_visit_token","text":"<pre><code>parser2_visit_token(context: Parser2Context) -&gt; None\n</code></pre> <p>Perform actions on the context implicated by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/of_image_offset.py</code> <pre><code>def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n    \"\"\"Perform actions on the context implicated by this token.\"\"\"\n    context.get_hooks().image_offset.pre_parser_visit_token(self, context)\n    context.get_hooks().image_offset.on_parser_visit_token(self, context)\n    context.get_hooks().image_offset.post_parser_visit_token(self, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/of_image_offset.html#pygerber.gerberx3.tokenizer.tokens.of_image_offset.ImageOffset.get_gerber_code","title":"get_gerber_code","text":"<pre><code>get_gerber_code(\n    indent: str = \"\", endline: str = \"\\n\"\n) -&gt; str\n</code></pre> <p>Get gerber code represented by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/of_image_offset.py</code> <pre><code>def get_gerber_code(\n    self,\n    indent: str = \"\",  # noqa: ARG002\n    endline: str = \"\\n\",  # noqa: ARG002\n) -&gt; str:\n    \"\"\"Get gerber code represented by this token.\"\"\"\n    a = f\"A{self.a}\" if self.a is not None else \"\"\n    b = f\"B{self.b}\" if self.b is not None else \"\"\n    return f\"OF{a}{b}\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/sr_step_repeat.html","title":"sr_step_repeat","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/sr_step_repeat.html#pygerber.gerberx3.tokenizer.tokens.sr_step_repeat","title":"sr_step_repeat","text":"<p>Wrapper for aperture select token.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/sr_step_repeat.html#pygerber.gerberx3.tokenizer.tokens.sr_step_repeat.StepRepeatBegin","title":"StepRepeatBegin","text":"<p>             Bases: <code>CommandToken</code></p> <p>Wrapper for SR begin token.</p> <p>Opens an SR statement and starts block accumulation.</p> <p>See section 4.10 of The Gerber Layer Format Specification Revision 2023.03 - https://argmaster.github.io/pygerber/latest/gerber_specification/revision_2023_03.html</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/sr_step_repeat.py</code> <pre><code>class StepRepeatBegin(CommandToken):\n    \"\"\"Wrapper for SR begin token.\n\n    Opens an SR statement and starts block accumulation.\n\n    See section 4.10 of The Gerber Layer Format Specification Revision 2023.03 - https://argmaster.github.io/pygerber/latest/gerber_specification/revision_2023_03.html\n    \"\"\"\n\n    def __init__(\n        self,\n        string: str,\n        location: int,\n        x_repeat: int,\n        y_repeat: int,\n        x_step: Decimal,\n        y_step: Decimal,\n    ) -&gt; None:\n        super().__init__(string, location)\n        self.x_repeat = x_repeat\n        self.y_repeat = y_repeat\n        self.x_step = x_step\n        self.y_step = y_step\n\n    @classmethod\n    def new(cls, string: str, location: int, tokens: ParseResults) -&gt; Self:\n        \"\"\"Create instance of this class.\n\n        Created to be used as callback in `ParserElement.set_parse_action()`.\n        \"\"\"\n        x_repeat = int(str(tokens.get(\"x_repeat\", \"0\")))\n        y_repeat = int(str(tokens.get(\"y_repeat\", \"0\")))\n        x_step = Decimal(str(tokens.get(\"x_step\", \"0\")))\n        y_step = Decimal(str(tokens.get(\"y_step\", \"0\")))\n        return cls(\n            string=string,\n            location=location,\n            x_repeat=x_repeat,\n            y_repeat=y_repeat,\n            x_step=x_step,\n            y_step=y_step,\n        )\n\n    def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n        \"\"\"Perform actions on the context implicated by this token.\"\"\"\n        context.get_hooks().step_repeat_begin.pre_parser_visit_token(self, context)\n        context.get_hooks().step_repeat_begin.on_parser_visit_token(self, context)\n        context.get_hooks().step_repeat_begin.post_parser_visit_token(self, context)\n\n    def get_gerber_code(\n        self,\n        indent: str = \"\",  # noqa: ARG002\n        endline: str = \"\\n\",  # noqa: ARG002\n    ) -&gt; str:\n        \"\"\"Get gerber code represented by this token.\"\"\"\n        return f\"SRX{self.x_repeat}Y{self.y_repeat}I{self.x_step}J{self.y_step}\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/sr_step_repeat.html#pygerber.gerberx3.tokenizer.tokens.sr_step_repeat.StepRepeatBegin.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(\n    string: str, location: int, tokens: ParseResults\n) -&gt; Self\n</code></pre> <p>Create instance of this class.</p> <p>Created to be used as callback in <code>ParserElement.set_parse_action()</code>.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/sr_step_repeat.py</code> <pre><code>@classmethod\ndef new(cls, string: str, location: int, tokens: ParseResults) -&gt; Self:\n    \"\"\"Create instance of this class.\n\n    Created to be used as callback in `ParserElement.set_parse_action()`.\n    \"\"\"\n    x_repeat = int(str(tokens.get(\"x_repeat\", \"0\")))\n    y_repeat = int(str(tokens.get(\"y_repeat\", \"0\")))\n    x_step = Decimal(str(tokens.get(\"x_step\", \"0\")))\n    y_step = Decimal(str(tokens.get(\"y_step\", \"0\")))\n    return cls(\n        string=string,\n        location=location,\n        x_repeat=x_repeat,\n        y_repeat=y_repeat,\n        x_step=x_step,\n        y_step=y_step,\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/sr_step_repeat.html#pygerber.gerberx3.tokenizer.tokens.sr_step_repeat.StepRepeatBegin.parser2_visit_token","title":"parser2_visit_token","text":"<pre><code>parser2_visit_token(context: Parser2Context) -&gt; None\n</code></pre> <p>Perform actions on the context implicated by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/sr_step_repeat.py</code> <pre><code>def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n    \"\"\"Perform actions on the context implicated by this token.\"\"\"\n    context.get_hooks().step_repeat_begin.pre_parser_visit_token(self, context)\n    context.get_hooks().step_repeat_begin.on_parser_visit_token(self, context)\n    context.get_hooks().step_repeat_begin.post_parser_visit_token(self, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/sr_step_repeat.html#pygerber.gerberx3.tokenizer.tokens.sr_step_repeat.StepRepeatBegin.get_gerber_code","title":"get_gerber_code","text":"<pre><code>get_gerber_code(\n    indent: str = \"\", endline: str = \"\\n\"\n) -&gt; str\n</code></pre> <p>Get gerber code represented by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/sr_step_repeat.py</code> <pre><code>def get_gerber_code(\n    self,\n    indent: str = \"\",  # noqa: ARG002\n    endline: str = \"\\n\",  # noqa: ARG002\n) -&gt; str:\n    \"\"\"Get gerber code represented by this token.\"\"\"\n    return f\"SRX{self.x_repeat}Y{self.y_repeat}I{self.x_step}J{self.y_step}\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/sr_step_repeat.html#pygerber.gerberx3.tokenizer.tokens.sr_step_repeat.StepRepeatEnd","title":"StepRepeatEnd","text":"<p>             Bases: <code>CommandToken</code></p> <p>Wrapper for SR end token.</p> <p>Ends step and repeat statement.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/sr_step_repeat.py</code> <pre><code>class StepRepeatEnd(CommandToken):\n    \"\"\"Wrapper for SR end token.\n\n    Ends step and repeat statement.\n    \"\"\"\n\n    def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n        \"\"\"Perform actions on the context implicated by this token.\"\"\"\n        context.get_hooks().step_repeat_end.pre_parser_visit_token(self, context)\n        context.get_hooks().step_repeat_end.on_parser_visit_token(self, context)\n        context.get_hooks().step_repeat_end.post_parser_visit_token(self, context)\n\n    def get_gerber_code(\n        self,\n        indent: str = \"\",  # noqa: ARG002\n        endline: str = \"\\n\",  # noqa: ARG002\n    ) -&gt; str:\n        \"\"\"Get gerber code represented by this token.\"\"\"\n        return \"SR\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/sr_step_repeat.html#pygerber.gerberx3.tokenizer.tokens.sr_step_repeat.StepRepeatEnd.parser2_visit_token","title":"parser2_visit_token","text":"<pre><code>parser2_visit_token(context: Parser2Context) -&gt; None\n</code></pre> <p>Perform actions on the context implicated by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/sr_step_repeat.py</code> <pre><code>def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n    \"\"\"Perform actions on the context implicated by this token.\"\"\"\n    context.get_hooks().step_repeat_end.pre_parser_visit_token(self, context)\n    context.get_hooks().step_repeat_end.on_parser_visit_token(self, context)\n    context.get_hooks().step_repeat_end.post_parser_visit_token(self, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/sr_step_repeat.html#pygerber.gerberx3.tokenizer.tokens.sr_step_repeat.StepRepeatEnd.get_gerber_code","title":"get_gerber_code","text":"<pre><code>get_gerber_code(\n    indent: str = \"\", endline: str = \"\\n\"\n) -&gt; str\n</code></pre> <p>Get gerber code represented by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/sr_step_repeat.py</code> <pre><code>def get_gerber_code(\n    self,\n    indent: str = \"\",  # noqa: ARG002\n    endline: str = \"\\n\",  # noqa: ARG002\n) -&gt; str:\n    \"\"\"Get gerber code represented by this token.\"\"\"\n    return \"SR\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ta_aperture_attribute.html","title":"ta_aperture_attribute","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ta_aperture_attribute.html#pygerber.gerberx3.tokenizer.tokens.ta_aperture_attribute","title":"ta_aperture_attribute","text":"<p>Comment token.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ta_aperture_attribute.html#pygerber.gerberx3.tokenizer.tokens.ta_aperture_attribute.ApertureAttribute","title":"ApertureAttribute","text":"<p>             Bases: <code>SetAttributeToken</code></p> <p>Add an aperture attribute to the dictionary or modify it.</p> <p>An aperture attribute is attached to an aperture or a region. They are a method to assign attributes to graphical objects in bulk: all objects that are created with an aperture inherit its attributes; for example, a via attribute on an aperture means that all pads flashed with this aperture are via pads. Providing information about graphical objects via their apertures is elegant, compact and efficient. As region objects are created without intermediary aperture, aperture objects can be assigned to regions directly.</p> <p>See section 5.3 of The Gerber Layer Format Specification Revision 2023.03 - https://argmaster.github.io/pygerber/latest/gerber_specification/revision_2023_03.html</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/ta_aperture_attribute.py</code> <pre><code>class ApertureAttribute(SetAttributeToken):\n    \"\"\"Add an aperture attribute to the dictionary or modify it.\n\n    An aperture attribute is attached to an aperture or a region. They are a method to\n    assign attributes to graphical objects in bulk: all objects that are created with\n    an aperture inherit its attributes; for example, a via attribute on an aperture\n    means that all pads flashed with this aperture are via pads. Providing information\n    about graphical objects via their apertures is elegant, compact and efficient. As\n    region objects are created without intermediary aperture, aperture objects can be\n    assigned to regions directly.\n\n    See section 5.3 of The Gerber Layer Format Specification Revision 2023.03 - https://argmaster.github.io/pygerber/latest/gerber_specification/revision_2023_03.html\n    \"\"\"\n\n    def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n        \"\"\"Perform actions on the context implicated by this token.\"\"\"\n        context.get_hooks().aperture_attribute.pre_parser_visit_token(self, context)\n        context.get_hooks().aperture_attribute.on_parser_visit_token(self, context)\n        context.get_hooks().aperture_attribute.post_parser_visit_token(self, context)\n\n    def get_gerber_code(\n        self,\n        indent: str = \"\",  # noqa: ARG002\n        endline: str = \"\\n\",  # noqa: ARG002\n    ) -&gt; str:\n        \"\"\"Get gerber code represented by this token.\"\"\"\n        return f\"TA{self.name},{self.value}\"\n\n    def __str__(self) -&gt; str:\n        return f\"{super().__str__()}::[{self.name} -&gt; {self.value}]\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ta_aperture_attribute.html#pygerber.gerberx3.tokenizer.tokens.ta_aperture_attribute.ApertureAttribute.parser2_visit_token","title":"parser2_visit_token","text":"<pre><code>parser2_visit_token(context: Parser2Context) -&gt; None\n</code></pre> <p>Perform actions on the context implicated by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/ta_aperture_attribute.py</code> <pre><code>def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n    \"\"\"Perform actions on the context implicated by this token.\"\"\"\n    context.get_hooks().aperture_attribute.pre_parser_visit_token(self, context)\n    context.get_hooks().aperture_attribute.on_parser_visit_token(self, context)\n    context.get_hooks().aperture_attribute.post_parser_visit_token(self, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/ta_aperture_attribute.html#pygerber.gerberx3.tokenizer.tokens.ta_aperture_attribute.ApertureAttribute.get_gerber_code","title":"get_gerber_code","text":"<pre><code>get_gerber_code(\n    indent: str = \"\", endline: str = \"\\n\"\n) -&gt; str\n</code></pre> <p>Get gerber code represented by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/ta_aperture_attribute.py</code> <pre><code>def get_gerber_code(\n    self,\n    indent: str = \"\",  # noqa: ARG002\n    endline: str = \"\\n\",  # noqa: ARG002\n) -&gt; str:\n    \"\"\"Get gerber code represented by this token.\"\"\"\n    return f\"TA{self.name},{self.value}\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/td_delete_attribute.html","title":"td_delete_attribute","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/td_delete_attribute.html#pygerber.gerberx3.tokenizer.tokens.td_delete_attribute","title":"td_delete_attribute","text":"<p>Comment token.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/td_delete_attribute.html#pygerber.gerberx3.tokenizer.tokens.td_delete_attribute.DeleteAttribute","title":"DeleteAttribute","text":"<p>             Bases: <code>AttributeToken</code></p> <p>Delete one or all attributes in the dictionary.</p> <p>The TD command deletes an aperture attribute or object attribute from the attributes dictionary. (File attributes are immutable and are not deleted.)</p> <p>See section 5.5 of The Gerber Layer Format Specification Revision 2023.03 - https://argmaster.github.io/pygerber/latest/gerber_specification/revision_2023_03.html</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/td_delete_attribute.py</code> <pre><code>class DeleteAttribute(AttributeToken):\n    \"\"\"Delete one or all attributes in the dictionary.\n\n    The TD command deletes an aperture attribute or object attribute from the attributes\n    dictionary. (File attributes are immutable and are not deleted.)\n\n    See section 5.5 of The Gerber Layer Format Specification Revision 2023.03 - https://argmaster.github.io/pygerber/latest/gerber_specification/revision_2023_03.html\n    \"\"\"\n\n    def __init__(self, string: str, location: int, name: Optional[str]) -&gt; None:\n        super().__init__(string, location)\n        self.name = name\n\n    @classmethod\n    def new(cls, string: str, location: int, tokens: ParseResults) -&gt; Self:\n        \"\"\"Create instance of this class.\n\n        Created to be used as callback in `ParserElement.set_parse_action()`.\n        \"\"\"\n        name = tokens.get(\"attribute_name\")\n        if name is not None:\n            name = str(name)\n\n        return cls(\n            string=string,\n            location=location,\n            name=name,\n        )\n\n    def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n        \"\"\"Perform actions on the context implicated by this token.\"\"\"\n        context.get_hooks().delete_attribute.pre_parser_visit_token(self, context)\n        context.get_hooks().delete_attribute.on_parser_visit_token(self, context)\n        context.get_hooks().delete_attribute.post_parser_visit_token(self, context)\n\n    def get_gerber_code(\n        self,\n        indent: str = \"\",  # noqa: ARG002\n        endline: str = \"\\n\",  # noqa: ARG002\n    ) -&gt; str:\n        \"\"\"Get gerber code represented by this token.\"\"\"\n        return f\"TD{self.name if self.name is not None else ''}\"\n\n    def __str__(self) -&gt; str:\n        return f\"{super().__str__()}::[{self.name}]\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/td_delete_attribute.html#pygerber.gerberx3.tokenizer.tokens.td_delete_attribute.DeleteAttribute.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(\n    string: str, location: int, tokens: ParseResults\n) -&gt; Self\n</code></pre> <p>Create instance of this class.</p> <p>Created to be used as callback in <code>ParserElement.set_parse_action()</code>.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/td_delete_attribute.py</code> <pre><code>@classmethod\ndef new(cls, string: str, location: int, tokens: ParseResults) -&gt; Self:\n    \"\"\"Create instance of this class.\n\n    Created to be used as callback in `ParserElement.set_parse_action()`.\n    \"\"\"\n    name = tokens.get(\"attribute_name\")\n    if name is not None:\n        name = str(name)\n\n    return cls(\n        string=string,\n        location=location,\n        name=name,\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/td_delete_attribute.html#pygerber.gerberx3.tokenizer.tokens.td_delete_attribute.DeleteAttribute.parser2_visit_token","title":"parser2_visit_token","text":"<pre><code>parser2_visit_token(context: Parser2Context) -&gt; None\n</code></pre> <p>Perform actions on the context implicated by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/td_delete_attribute.py</code> <pre><code>def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n    \"\"\"Perform actions on the context implicated by this token.\"\"\"\n    context.get_hooks().delete_attribute.pre_parser_visit_token(self, context)\n    context.get_hooks().delete_attribute.on_parser_visit_token(self, context)\n    context.get_hooks().delete_attribute.post_parser_visit_token(self, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/td_delete_attribute.html#pygerber.gerberx3.tokenizer.tokens.td_delete_attribute.DeleteAttribute.get_gerber_code","title":"get_gerber_code","text":"<pre><code>get_gerber_code(\n    indent: str = \"\", endline: str = \"\\n\"\n) -&gt; str\n</code></pre> <p>Get gerber code represented by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/td_delete_attribute.py</code> <pre><code>def get_gerber_code(\n    self,\n    indent: str = \"\",  # noqa: ARG002\n    endline: str = \"\\n\",  # noqa: ARG002\n) -&gt; str:\n    \"\"\"Get gerber code represented by this token.\"\"\"\n    return f\"TD{self.name if self.name is not None else ''}\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/tf_file_attribute.html","title":"tf_file_attribute","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/tf_file_attribute.html#pygerber.gerberx3.tokenizer.tokens.tf_file_attribute","title":"tf_file_attribute","text":"<p>Comment token.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/tf_file_attribute.html#pygerber.gerberx3.tokenizer.tokens.tf_file_attribute.FileAttribute","title":"FileAttribute","text":"<p>             Bases: <code>SetAttributeToken</code></p> <p>File attribute token.</p> <p>The semantics of a file attribute specifies where it must be defined, typically in the header of the file. File attributes are immutable. They cannot be redefined or deleted.</p> <p>See section 5.2 of The Gerber Layer Format Specification Revision 2023.03 - https://argmaster.github.io/pygerber/latest/gerber_specification/revision_2023_03.html</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/tf_file_attribute.py</code> <pre><code>class FileAttribute(SetAttributeToken):\n    \"\"\"File attribute token.\n\n    The semantics of a file attribute specifies where it must be defined, typically in\n    the header of the file. File attributes are immutable. They cannot be redefined or\n    deleted.\n\n    See section 5.2 of The Gerber Layer Format Specification Revision 2023.03 - https://argmaster.github.io/pygerber/latest/gerber_specification/revision_2023_03.html\n    \"\"\"\n\n    def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n        \"\"\"Perform actions on the context implicated by this token.\"\"\"\n        context.get_hooks().file_attribute.pre_parser_visit_token(self, context)\n        context.get_hooks().file_attribute.on_parser_visit_token(self, context)\n        context.get_hooks().file_attribute.post_parser_visit_token(self, context)\n\n    def get_gerber_code(\n        self,\n        indent: str = \"\",  # noqa: ARG002\n        endline: str = \"\\n\",  # noqa: ARG002\n    ) -&gt; str:\n        \"\"\"Get gerber code represented by this token.\"\"\"\n        return f\"TF{self.name},{self.value}\"\n\n    def __str__(self) -&gt; str:\n        return f\"{super().__str__()}::[{self.name} -&gt; {self.value}]\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/tf_file_attribute.html#pygerber.gerberx3.tokenizer.tokens.tf_file_attribute.FileAttribute.parser2_visit_token","title":"parser2_visit_token","text":"<pre><code>parser2_visit_token(context: Parser2Context) -&gt; None\n</code></pre> <p>Perform actions on the context implicated by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/tf_file_attribute.py</code> <pre><code>def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n    \"\"\"Perform actions on the context implicated by this token.\"\"\"\n    context.get_hooks().file_attribute.pre_parser_visit_token(self, context)\n    context.get_hooks().file_attribute.on_parser_visit_token(self, context)\n    context.get_hooks().file_attribute.post_parser_visit_token(self, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/tf_file_attribute.html#pygerber.gerberx3.tokenizer.tokens.tf_file_attribute.FileAttribute.get_gerber_code","title":"get_gerber_code","text":"<pre><code>get_gerber_code(\n    indent: str = \"\", endline: str = \"\\n\"\n) -&gt; str\n</code></pre> <p>Get gerber code represented by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/tf_file_attribute.py</code> <pre><code>def get_gerber_code(\n    self,\n    indent: str = \"\",  # noqa: ARG002\n    endline: str = \"\\n\",  # noqa: ARG002\n) -&gt; str:\n    \"\"\"Get gerber code represented by this token.\"\"\"\n    return f\"TF{self.name},{self.value}\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/to_object_attribute.html","title":"to_object_attribute","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/to_object_attribute.html#pygerber.gerberx3.tokenizer.tokens.to_object_attribute","title":"to_object_attribute","text":"<p>Comment token.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/to_object_attribute.html#pygerber.gerberx3.tokenizer.tokens.to_object_attribute.ObjectAttribute","title":"ObjectAttribute","text":"<p>             Bases: <code>SetAttributeToken</code></p> <p>Add an object attribute to the dictionary or modify it.</p> <p>An object attribute is attached to graphical objects. When a D01, D03 or region statement (G36/G37) creates an object all object attributes in the attribute dictionary are attached to it. As attribute commands are not allowed inside a region statement, all regions created by that statement have the same object attributes. Once attached to an object they cannot be chan</p> <p>See section 5.4 of The Gerber Layer Format Specification Revision 2023.03 - https://argmaster.github.io/pygerber/latest/gerber_specification/revision_2023_03.html</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/to_object_attribute.py</code> <pre><code>class ObjectAttribute(SetAttributeToken):\n    \"\"\"Add an object attribute to the dictionary or modify it.\n\n    An object attribute is attached to graphical objects. When a D01, D03 or region\n    statement (G36/G37) creates an object all object attributes in the attribute\n    dictionary are attached to it. As attribute commands are not allowed inside a region\n    statement, all regions created by that statement have the same object attributes.\n    Once attached to an object they cannot be chan\n\n    See section 5.4 of The Gerber Layer Format Specification Revision 2023.03 - https://argmaster.github.io/pygerber/latest/gerber_specification/revision_2023_03.html\n    \"\"\"\n\n    def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n        \"\"\"Perform actions on the context implicated by this token.\"\"\"\n        context.get_hooks().object_attribute.pre_parser_visit_token(self, context)\n        context.get_hooks().object_attribute.on_parser_visit_token(self, context)\n        context.get_hooks().object_attribute.post_parser_visit_token(self, context)\n\n    def get_gerber_code(\n        self,\n        indent: str = \"\",  # noqa: ARG002\n        endline: str = \"\\n\",  # noqa: ARG002\n    ) -&gt; str:\n        \"\"\"Get gerber code represented by this token.\"\"\"\n        return f\"TO{self.name},{self.value}\"\n\n    def __str__(self) -&gt; str:\n        return f\"{super().__str__()}::[{self.name} -&gt; {self.value}]\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/to_object_attribute.html#pygerber.gerberx3.tokenizer.tokens.to_object_attribute.ObjectAttribute.parser2_visit_token","title":"parser2_visit_token","text":"<pre><code>parser2_visit_token(context: Parser2Context) -&gt; None\n</code></pre> <p>Perform actions on the context implicated by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/to_object_attribute.py</code> <pre><code>def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n    \"\"\"Perform actions on the context implicated by this token.\"\"\"\n    context.get_hooks().object_attribute.pre_parser_visit_token(self, context)\n    context.get_hooks().object_attribute.on_parser_visit_token(self, context)\n    context.get_hooks().object_attribute.post_parser_visit_token(self, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/to_object_attribute.html#pygerber.gerberx3.tokenizer.tokens.to_object_attribute.ObjectAttribute.get_gerber_code","title":"get_gerber_code","text":"<pre><code>get_gerber_code(\n    indent: str = \"\", endline: str = \"\\n\"\n) -&gt; str\n</code></pre> <p>Get gerber code represented by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/to_object_attribute.py</code> <pre><code>def get_gerber_code(\n    self,\n    indent: str = \"\",  # noqa: ARG002\n    endline: str = \"\\n\",  # noqa: ARG002\n) -&gt; str:\n    \"\"\"Get gerber code represented by this token.\"\"\"\n    return f\"TO{self.name},{self.value}\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/bases/__init__.html","title":"init","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/bases/__init__.html#pygerber.gerberx3.tokenizer.tokens.bases","title":"bases","text":"<p>All generic base classes for tokens.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/bases/command.html","title":"command","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/bases/command.html#pygerber.gerberx3.tokenizer.tokens.bases.command","title":"command","text":"<p>Base class for all commands.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/bases/command.html#pygerber.gerberx3.tokenizer.tokens.bases.command.CommandToken","title":"CommandToken","text":"<p>             Bases: <code>Token</code></p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/bases/command.html#pygerber.gerberx3.tokenizer.tokens.bases.command.CommandToken--33-commands","title":"3.3 Commands.","text":"<p>Commands are the core syntactic element of the Gerber format. A Gerber file is a stream of commands. Commands define the graphics state, create graphical objects, defines apertures, manage attributes and so on.</p> <p>Commands are built with words, the basic syntactic building block of a Gerber file. A word is a non-empty character string, excluding the reserved characters '' and '%', terminated with an ''</p> <pre><code>free_character = /[^%*]/; # All characters but * and %\nword = {free_character}+ '*';\n</code></pre> <p>For historic reasons, there are two command syntax styles: word commands and extended commands.</p> <pre><code>command =\n| extended_command\n| word_command\n;\nword_command = word;\nextended_command = '%' {word}+ '%';\n</code></pre> <p>Word commands are identified by a command code, the letter G, D or M followed by a positive integer, e.g. <code>G02</code>. Most word commands only consist of the command code, some also contain coordinates.</p> <p>Extended commands are identified by a two-character command code that is followed by parameters specific to the code. An extended command is enclosed by a pair of \"%\" delimiters</p> <p>An overview of all commands is in section 2.8, a full description in chapters 3.5 and 5.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/bases/command.html#pygerber.gerberx3.tokenizer.tokens.bases.command.CommandToken--example-1","title":"Example 1","text":"<p>The example below shows a stream of Gerber commands.</p> <pre><code>G04 Different command styles*\nG75*\nG02*\nD10*\nX0Y0D02*\nX2000000Y0I1000000J0D01*\nD11*\nX0Y2000000D03*\nM02*\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/bases/command.html#pygerber.gerberx3.tokenizer.tokens.bases.command.CommandToken--example-2","title":"Example 2","text":"<p>The example below shows a stream of Gerber extended commands.</p> <pre><code>%FSLAX26Y26*%\n%MOMM*%\n%AMDonut*\n1,1,$1,$2,$3*\n$4=$1x0.75*\n1,0,$4,$2,$3*\n%\n%ADD11Donut,0.30X0X0*%\n%ADD10C,0.1*%\n</code></pre> <p>See section 3.3 of The Gerber Layer Format Specification</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/bases/command.py</code> <pre><code>class CommandToken(Token):\n    \"\"\"## 3.3 Commands.\n\n    Commands are the core syntactic element of the Gerber format. A Gerber file is a stream of\n    commands. Commands define the graphics state, create graphical objects, defines apertures,\n    manage attributes and so on.\n\n    Commands are built with words, the basic syntactic building block of a Gerber file. A word is a\n    non-empty character string, excluding the reserved characters '*' and '%', terminated with an '*'\n\n    ```ebnf\n    free_character = /[^%*]/; # All characters but * and %\n    word = {free_character}+ '*';\n    ```\n\n    For historic reasons, there are two command syntax styles: word commands and extended\n    commands.\n\n    ```ebnf\n    command =\n    | extended_command\n    | word_command\n    ;\n    word_command = word;\n    extended_command = '%' {word}+ '%';\n    ```\n\n\n    Word commands are identified by a command code, the letter G, D or M followed by a positive\n    integer, e.g. `G02`. Most word commands only consist of the command code, some also contain\n    coordinates.\n\n    Extended commands are identified by a two-character command code that is followed by\n    parameters specific to the code. An extended command is enclosed by a pair of \"%\" delimiters\n\n    An overview of all commands is in section 2.8, a full description in chapters 3.5 and 5.\n\n\n    ---\n\n    ## Example 1\n\n    The example below shows a stream of Gerber commands.\n\n    ```gerber\n    G04 Different command styles*\n    G75*\n    G02*\n    D10*\n    X0Y0D02*\n    X2000000Y0I1000000J0D01*\n    D11*\n    X0Y2000000D03*\n    M02*\n    ```\n\n\n    ---\n\n    ## Example 2\n\n    The example below shows a stream of Gerber extended commands.\n\n    ```gerber\n    %FSLAX26Y26*%\n    %MOMM*%\n    %AMDonut*\n    1,1,$1,$2,$3*\n    $4=$1x0.75*\n    1,0,$4,$2,$3*\n    %\n    %ADD11Donut,0.30X0X0*%\n    %ADD10C,0.1*%\n    ```\n\n    ---\n\n    See section 3.3 of [The Gerber Layer Format Specification](https://www.ucamco.com/files/downloads/file_en/456/gerber-layer-format-specification-revision-2023-08_en.pdf#page=33)\n\n    \"\"\"  # noqa: E501\n\n    def get_gerber_code_one_line_pretty_display(self) -&gt; str:\n        \"\"\"Get gerber code represented by this token.\"\"\"\n        return f\"{self.get_gerber_code()}*\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/bases/command.html#pygerber.gerberx3.tokenizer.tokens.bases.command.CommandToken.get_gerber_code_one_line_pretty_display","title":"get_gerber_code_one_line_pretty_display","text":"<pre><code>get_gerber_code_one_line_pretty_display() -&gt; str\n</code></pre> <p>Get gerber code represented by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/bases/command.py</code> <pre><code>def get_gerber_code_one_line_pretty_display(self) -&gt; str:\n    \"\"\"Get gerber code represented by this token.\"\"\"\n    return f\"{self.get_gerber_code()}*\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/bases/extended_command.html","title":"extended_command","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/bases/extended_command.html#pygerber.gerberx3.tokenizer.tokens.bases.extended_command","title":"extended_command","text":"<p>Base class for all extended commands.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/bases/extended_command.html#pygerber.gerberx3.tokenizer.tokens.bases.extended_command.ExtendedCommandToken","title":"ExtendedCommandToken","text":"<p>             Bases: <code>Token</code></p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/bases/extended_command.html#pygerber.gerberx3.tokenizer.tokens.bases.extended_command.ExtendedCommandToken--33-commands","title":"3.3 Commands.","text":"<p>Commands are the core syntactic element of the Gerber format. A Gerber file is a stream of commands. Commands define the graphics state, create graphical objects, defines apertures, manage attributes and so on.</p> <p>Commands are built with words, the basic syntactic building block of a Gerber file. A word is a non-empty character string, excluding the reserved characters '' and '%', terminated with an ''</p> <pre><code>free_character = /[^%*]/; # All characters but * and %\nword = {free_character}+ '*';\n</code></pre> <p>For historic reasons, there are two command syntax styles: word commands and extended commands.</p> <pre><code>command =\n| extended_command\n| word_command\n;\nword_command = word;\nextended_command = '%' {word}+ '%';\n</code></pre> <p>Word commands are identified by a command code, the letter G, D or M followed by a positive integer, e.g. <code>G02</code>. Most word commands only consist of the command code, some also contain coordinates.</p> <p>Extended commands are identified by a two-character command code that is followed by parameters specific to the code. An extended command is enclosed by a pair of \"%\" delimiters</p> <p>An overview of all commands is in section 2.8, a full description in chapters 3.5 and 5.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/bases/extended_command.html#pygerber.gerberx3.tokenizer.tokens.bases.extended_command.ExtendedCommandToken--example-1","title":"Example 1","text":"<p>The example below shows a stream of Gerber commands.</p> <pre><code>G04 Different command styles*\nG75*\nG02*\nD10*\nX0Y0D02*\nX2000000Y0I1000000J0D01*\nD11*\nX0Y2000000D03*\nM02*\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/bases/extended_command.html#pygerber.gerberx3.tokenizer.tokens.bases.extended_command.ExtendedCommandToken--example-2","title":"Example 2","text":"<p>The example below shows a stream of Gerber extended commands.</p> <pre><code>%FSLAX26Y26*%\n%MOMM*%\n%AMDonut*\n1,1,$1,$2,$3*\n$4=$1x0.75*\n1,0,$4,$2,$3*\n%\n%ADD11Donut,0.30X0X0*%\n%ADD10C,0.1*%\n</code></pre> <p>See section 3.3 of The Gerber Layer Format Specification</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/bases/extended_command.py</code> <pre><code>class ExtendedCommandToken(Token):\n    \"\"\"## 3.3 Commands.\n\n    Commands are the core syntactic element of the Gerber format. A Gerber file is a stream of\n    commands. Commands define the graphics state, create graphical objects, defines apertures,\n    manage attributes and so on.\n\n    Commands are built with words, the basic syntactic building block of a Gerber file. A word is a\n    non-empty character string, excluding the reserved characters '*' and '%', terminated with an '*'\n\n    ```ebnf\n    free_character = /[^%*]/; # All characters but * and %\n    word = {free_character}+ '*';\n    ```\n\n    For historic reasons, there are two command syntax styles: word commands and extended\n    commands.\n\n    ```ebnf\n    command =\n    | extended_command\n    | word_command\n    ;\n    word_command = word;\n    extended_command = '%' {word}+ '%';\n    ```\n\n\n    Word commands are identified by a command code, the letter G, D or M followed by a positive\n    integer, e.g. `G02`. Most word commands only consist of the command code, some also contain\n    coordinates.\n\n    Extended commands are identified by a two-character command code that is followed by\n    parameters specific to the code. An extended command is enclosed by a pair of \"%\" delimiters\n\n    An overview of all commands is in section 2.8, a full description in chapters 3.5 and 5.\n\n\n    ---\n\n    ## Example 1\n\n    The example below shows a stream of Gerber commands.\n\n    ```gerber\n    G04 Different command styles*\n    G75*\n    G02*\n    D10*\n    X0Y0D02*\n    X2000000Y0I1000000J0D01*\n    D11*\n    X0Y2000000D03*\n    M02*\n    ```\n\n\n    ---\n\n    ## Example 2\n\n    The example below shows a stream of Gerber extended commands.\n\n    ```gerber\n    %FSLAX26Y26*%\n    %MOMM*%\n    %AMDonut*\n    1,1,$1,$2,$3*\n    $4=$1x0.75*\n    1,0,$4,$2,$3*\n    %\n    %ADD11Donut,0.30X0X0*%\n    %ADD10C,0.1*%\n    ```\n\n    ---\n\n    See section 3.3 of [The Gerber Layer Format Specification](https://www.ucamco.com/files/downloads/file_en/456/gerber-layer-format-specification-revision-2023-08_en.pdf#page=33)\n\n    \"\"\"  # noqa: E501\n\n    def get_gerber_code_one_line_pretty_display(self) -&gt; str:\n        \"\"\"Get gerber code represented by this token.\"\"\"\n        return f\"%{self.get_gerber_code()}*%\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/bases/extended_command.html#pygerber.gerberx3.tokenizer.tokens.bases.extended_command.ExtendedCommandToken.get_gerber_code_one_line_pretty_display","title":"get_gerber_code_one_line_pretty_display","text":"<pre><code>get_gerber_code_one_line_pretty_display() -&gt; str\n</code></pre> <p>Get gerber code represented by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/bases/extended_command.py</code> <pre><code>def get_gerber_code_one_line_pretty_display(self) -&gt; str:\n    \"\"\"Get gerber code represented by this token.\"\"\"\n    return f\"%{self.get_gerber_code()}*%\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/bases/gerber_code.html","title":"gerber_code","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/bases/gerber_code.html#pygerber.gerberx3.tokenizer.tokens.bases.gerber_code","title":"gerber_code","text":"<p>Base class providing GerberCode interface.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/bases/gerber_code.html#pygerber.gerberx3.tokenizer.tokens.bases.gerber_code.GerberCode","title":"GerberCode","text":"<p>Interface of object which can be converted to gerber code.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/bases/gerber_code.py</code> <pre><code>class GerberCode:\n    \"\"\"Interface of object which can be converted to gerber code.\"\"\"\n\n    def get_gerber_code(\n        self,\n        indent: str = \"\",\n        endline: str = \"\\n\",  # noqa: ARG002\n    ) -&gt; str:\n        \"\"\"Get gerber code represented by this token.\"\"\"\n        return f\"{indent}G04 {self.__class__.__qualname__} no formatting available*\"\n\n    def get_gerber_code_one_line_pretty_display(self) -&gt; str:\n        \"\"\"Get gerber code represented by this token.\"\"\"\n        return f\"G04 {self.__class__.__qualname__} no formatting available*\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/bases/gerber_code.html#pygerber.gerberx3.tokenizer.tokens.bases.gerber_code.GerberCode.get_gerber_code","title":"get_gerber_code","text":"<pre><code>get_gerber_code(\n    indent: str = \"\", endline: str = \"\\n\"\n) -&gt; str\n</code></pre> <p>Get gerber code represented by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/bases/gerber_code.py</code> <pre><code>def get_gerber_code(\n    self,\n    indent: str = \"\",\n    endline: str = \"\\n\",  # noqa: ARG002\n) -&gt; str:\n    \"\"\"Get gerber code represented by this token.\"\"\"\n    return f\"{indent}G04 {self.__class__.__qualname__} no formatting available*\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/bases/gerber_code.html#pygerber.gerberx3.tokenizer.tokens.bases.gerber_code.GerberCode.get_gerber_code_one_line_pretty_display","title":"get_gerber_code_one_line_pretty_display","text":"<pre><code>get_gerber_code_one_line_pretty_display() -&gt; str\n</code></pre> <p>Get gerber code represented by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/bases/gerber_code.py</code> <pre><code>def get_gerber_code_one_line_pretty_display(self) -&gt; str:\n    \"\"\"Get gerber code represented by this token.\"\"\"\n    return f\"G04 {self.__class__.__qualname__} no formatting available*\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/bases/gerber_code.html#pygerber.gerberx3.tokenizer.tokens.bases.gerber_code.get_gerber_code","title":"get_gerber_code","text":"<pre><code>get_gerber_code(\n    tokens: Iterable[GerberCode],\n    indent: str = \"\",\n    endline: str = \"\\n\",\n) -&gt; str\n</code></pre> <p>Get gerber code from iterable of tokens.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/bases/gerber_code.py</code> <pre><code>def get_gerber_code(\n    tokens: Iterable[GerberCode],\n    indent: str = \"\",\n    endline: str = \"\\n\",\n) -&gt; str:\n    \"\"\"Get gerber code from iterable of tokens.\"\"\"\n    return endline.join(t.get_gerber_code(indent, endline) for t in tokens)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/bases/group.html","title":"group","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/bases/group.html#pygerber.gerberx3.tokenizer.tokens.bases.group","title":"group","text":"<p>Wrapper for flash operation token.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/bases/group.html#pygerber.gerberx3.tokenizer.tokens.bases.group.TokenGroup","title":"TokenGroup","text":"<p>             Bases: <code>Token</code></p> <p>Token consisting of multiple nested tokens.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/bases/group.py</code> <pre><code>class TokenGroup(Token):\n    \"\"\"Token consisting of multiple nested tokens.\"\"\"\n\n    def __init__(\n        self,\n        string: str,\n        location: int,\n        tokens: Sequence[Token],\n    ) -&gt; None:\n        super().__init__(string, location)\n        self.tokens = tokens\n\n    @classmethod\n    def new(cls, string: str, location: int, tokens: ParseResults) -&gt; Self:\n        \"\"\"Create instance of this class.\n\n        Created to be used as callback in `ParserElement.set_parse_action()`.\n        \"\"\"\n\n        def _() -&gt; Iterable[Token]:\n            for token in tokens.as_list():\n                if isinstance(token, Token):\n                    yield token\n\n        return cls(\n            string=string,\n            location=location,\n            tokens=list(_()),\n        )\n\n    def get_gerber_code(\n        self,\n        indent: str = \"\",\n        endline: str = \"\\n\",\n    ) -&gt; str:\n        \"\"\"Get gerber code represented by this token.\"\"\"\n        return endline.join(t.get_gerber_code(indent) for t in self.tokens)\n\n    def __str__(self) -&gt; str:\n        prefix = super().__str__()\n        tokens = \", \".join(str(t) for t in self.tokens)\n        return f\"{prefix}[{tokens}]\"\n\n    def find_closest_token(\n        self,\n        pos: Position,\n        parent: Optional[TokenAccessor] = None,\n    ) -&gt; TokenAccessor:\n        \"\"\"Find token closest to specified position.\"\"\"\n        if parent is None:\n            parent = TokenAccessor(self)\n\n        token_accessor = self._find_closest_token(pos, parent)\n        token = token_accessor.token\n\n        if token and isinstance(token, TokenGroup):\n            token_accessor = token.find_closest_token(pos, token_accessor)\n\n        return token_accessor\n\n    def _find_closest_token(\n        self,\n        pos: Position,\n        parent: TokenAccessor,\n    ) -&gt; TokenAccessor:\n        threshold = 10\n        if len(self.tokens) &gt; threshold:\n            return self._find_closest_token_binary(pos, parent)\n\n        return self._find_closest_token_linear(pos, parent)\n\n    def _find_closest_token_binary(\n        self,\n        pos: Position,\n        parent: TokenAccessor,\n    ) -&gt; TokenAccessor:\n        left = 0\n        right = len(self.tokens) - 1\n        center = (left + right) // 2\n\n        while left &lt;= right:\n            center = (left + right) // 2\n            token = self.tokens[center]\n            token_pos = token.get_token_position()\n\n            if token_pos &lt; pos:\n                left = center + 1\n            elif token_pos &gt; pos:\n                right = center - 1\n            else:\n                break\n\n        while ((token := self.tokens[center]).get_token_position()) &gt; pos:\n            center -= 1\n\n        return TokenAccessor(\n            self.tokens[center],\n            parent,\n            self.tokens,\n            center,\n        )\n\n    def _find_closest_token_linear(\n        self,\n        pos: Position,\n        parent: TokenAccessor,\n    ) -&gt; TokenAccessor:\n        i = 0\n        search_pos = pos\n        token = prev_token = self.tokens[i]\n\n        for i, token in enumerate(self.tokens):\n            token_pos = token.get_token_position()\n            if token_pos &gt; search_pos:\n                return TokenAccessor(\n                    prev_token,\n                    parent,\n                    self.tokens,\n                    i,\n                )\n\n            prev_token = token\n\n        return TokenAccessor(prev_token, parent, self.tokens, i)\n\n    def __iter__(self) -&gt; Iterator[Token]:\n        for token in self.tokens:\n            yield from token\n\n    def __len__(self) -&gt; int:\n        return self.tokens.__len__()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/bases/group.html#pygerber.gerberx3.tokenizer.tokens.bases.group.TokenGroup.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(\n    string: str, location: int, tokens: ParseResults\n) -&gt; Self\n</code></pre> <p>Create instance of this class.</p> <p>Created to be used as callback in <code>ParserElement.set_parse_action()</code>.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/bases/group.py</code> <pre><code>@classmethod\ndef new(cls, string: str, location: int, tokens: ParseResults) -&gt; Self:\n    \"\"\"Create instance of this class.\n\n    Created to be used as callback in `ParserElement.set_parse_action()`.\n    \"\"\"\n\n    def _() -&gt; Iterable[Token]:\n        for token in tokens.as_list():\n            if isinstance(token, Token):\n                yield token\n\n    return cls(\n        string=string,\n        location=location,\n        tokens=list(_()),\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/bases/group.html#pygerber.gerberx3.tokenizer.tokens.bases.group.TokenGroup.get_gerber_code","title":"get_gerber_code","text":"<pre><code>get_gerber_code(\n    indent: str = \"\", endline: str = \"\\n\"\n) -&gt; str\n</code></pre> <p>Get gerber code represented by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/bases/group.py</code> <pre><code>def get_gerber_code(\n    self,\n    indent: str = \"\",\n    endline: str = \"\\n\",\n) -&gt; str:\n    \"\"\"Get gerber code represented by this token.\"\"\"\n    return endline.join(t.get_gerber_code(indent) for t in self.tokens)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/bases/group.html#pygerber.gerberx3.tokenizer.tokens.bases.group.TokenGroup.find_closest_token","title":"find_closest_token","text":"<pre><code>find_closest_token(\n    pos: Position, parent: Optional[TokenAccessor] = None\n) -&gt; TokenAccessor\n</code></pre> <p>Find token closest to specified position.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/bases/group.py</code> <pre><code>def find_closest_token(\n    self,\n    pos: Position,\n    parent: Optional[TokenAccessor] = None,\n) -&gt; TokenAccessor:\n    \"\"\"Find token closest to specified position.\"\"\"\n    if parent is None:\n        parent = TokenAccessor(self)\n\n    token_accessor = self._find_closest_token(pos, parent)\n    token = token_accessor.token\n\n    if token and isinstance(token, TokenGroup):\n        token_accessor = token.find_closest_token(pos, token_accessor)\n\n    return token_accessor\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/bases/token.html","title":"token","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/bases/token.html#pygerber.gerberx3.tokenizer.tokens.bases.token","title":"token","text":"<p>Base class for creating token classes.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/bases/token.html#pygerber.gerberx3.tokenizer.tokens.bases.token.Token","title":"Token","text":"<p>             Bases: <code>GerberCode</code></p> <p>Base class for creating Gerber token classes.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/bases/token.py</code> <pre><code>class Token(GerberCode):\n    \"\"\"Base class for creating Gerber token classes.\"\"\"\n\n    @classmethod\n    def wrap(cls, expr: ParserElement) -&gt; ParserElement:\n        \"\"\"Set parse result to be instance of this class.\"\"\"\n        return expr.set_parse_action(cls.new)\n\n    @classmethod\n    def new(cls, string: str, location: int, _tokens: ParseResults) -&gt; Self:\n        \"\"\"Create instance of this class.\n\n        Created to be used as callback in `ParserElement.set_parse_action()`.\n        \"\"\"\n        return cls(string, location)\n\n    def __init__(self, string: str, location: int) -&gt; None:\n        \"\"\"Initialize token instance.\"\"\"\n        self.string = string\n        self.location = location\n\n    def __str__(self) -&gt; str:\n        return f\"GerberCode::Token::{self.__class__.__qualname__}\"\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return pretty representation of comment token.\"\"\"\n        return self.__str__()\n\n    def get_debug_format(self) -&gt; str:\n        \"\"\"Return debug formatted token object.\"\"\"\n        return super().__repr__()\n\n    @classmethod\n    def ensure_type(cls, thing: Any) -&gt; Self:\n        \"\"\"Ensure that &lt;thing&gt; is a instance of this class.\n\n        Raise TypeError otherwise.\n        \"\"\"\n        if not isinstance(thing, cls):\n            raise TypeError(thing)\n\n        return thing\n\n    def parser2_visit_token(\n        self,\n        context: Parser2Context,\n    ) -&gt; None:\n        \"\"\"Update drawing state for Gerber AST parser, version 2.\"\"\"\n\n    def update_drawing_state(\n        self,\n        state: State,\n        _backend: Backend,\n    ) -&gt; Tuple[State, Iterable[DrawCommand]]:\n        \"\"\"Update drawing state.\"\"\"\n        return state, ()\n\n    def get_token_position(self) -&gt; Position:\n        \"\"\"Get position of token.\"\"\"\n        return self._token_position\n\n    @cached_property\n    def _token_position(self) -&gt; Position:\n        return Position(\n            lineno(self.location, self.string),\n            col(self.location, self.string),\n        )\n\n    def get_hover_message(self, state: State) -&gt; str:\n        \"\"\"Return language server hover message.\"\"\"\n        ref_doc = \"\\n\".join(s.strip() for s in str(self.__doc__).split(\"\\n\"))\n        op_specific_extra = self.get_state_based_hover_message(state)\n        return (\n            \"```gerber\\n\"\n            f\"{self.get_gerber_code_one_line_pretty_display()}\"\n            \"\\n\"\n            \"```\"\n            \"\\n\"\n            \"---\"\n            \"\\n\"\n            f\"{op_specific_extra}\\n\"\n            \"\\n\"\n            \"---\"\n            \"\\n\"\n            f\"{ref_doc}\"\n        )\n\n    def get_state_based_hover_message(\n        self,\n        state: State,  # noqa: ARG002\n    ) -&gt; str:\n        \"\"\"Return operation specific extra information about token.\"\"\"\n        return \"\"\n\n    def find_closest_token(\n        self,\n        pos: Position,  # noqa: ARG002\n        parent: Optional[TokenAccessor] = None,\n    ) -&gt; TokenAccessor:\n        \"\"\"Find token closest to specified position.\"\"\"\n        return TokenAccessor(self, parent)\n\n    def get_gerber_code_one_line_pretty_display(self) -&gt; str:\n        \"\"\"Get gerber code represented by this token.\"\"\"\n        return self.get_gerber_code()\n\n    def get_token_diagnostics(self) -&gt; Iterable[diagnostic.Diagnostic]:\n        \"\"\"Get diagnostics for this token.\"\"\"\n        return\n        yield  # type: ignore[unreachable]\n\n    def get_token_end_position(self) -&gt; Position:\n        \"\"\"Get position of the end of the token.\"\"\"\n        s = str(self)\n        first, *_ = s.split(\"\\n\")\n        lines_offset = 0\n        column_offset = len(first)\n        return self.get_token_position().offset(lines_offset, column_offset)\n\n    def __iter__(self) -&gt; Iterator[Token]:\n        yield self\n\n    def __hash__(self) -&gt; int:\n        return id(self)\n\n    def __eq__(self, __value: object) -&gt; bool:\n        if not isinstance(__value, Token):\n            return NotImplemented\n        return id(__value) == id(self)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/bases/token.html#pygerber.gerberx3.tokenizer.tokens.bases.token.Token.wrap","title":"wrap  <code>classmethod</code>","text":"<pre><code>wrap(expr: ParserElement) -&gt; ParserElement\n</code></pre> <p>Set parse result to be instance of this class.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/bases/token.py</code> <pre><code>@classmethod\ndef wrap(cls, expr: ParserElement) -&gt; ParserElement:\n    \"\"\"Set parse result to be instance of this class.\"\"\"\n    return expr.set_parse_action(cls.new)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/bases/token.html#pygerber.gerberx3.tokenizer.tokens.bases.token.Token.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(\n    string: str, location: int, _tokens: ParseResults\n) -&gt; Self\n</code></pre> <p>Create instance of this class.</p> <p>Created to be used as callback in <code>ParserElement.set_parse_action()</code>.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/bases/token.py</code> <pre><code>@classmethod\ndef new(cls, string: str, location: int, _tokens: ParseResults) -&gt; Self:\n    \"\"\"Create instance of this class.\n\n    Created to be used as callback in `ParserElement.set_parse_action()`.\n    \"\"\"\n    return cls(string, location)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/bases/token.html#pygerber.gerberx3.tokenizer.tokens.bases.token.Token.__init__","title":"__init__","text":"<pre><code>__init__(string: str, location: int) -&gt; None\n</code></pre> <p>Initialize token instance.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/bases/token.py</code> <pre><code>def __init__(self, string: str, location: int) -&gt; None:\n    \"\"\"Initialize token instance.\"\"\"\n    self.string = string\n    self.location = location\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/bases/token.html#pygerber.gerberx3.tokenizer.tokens.bases.token.Token.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return pretty representation of comment token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/bases/token.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return pretty representation of comment token.\"\"\"\n    return self.__str__()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/bases/token.html#pygerber.gerberx3.tokenizer.tokens.bases.token.Token.get_debug_format","title":"get_debug_format","text":"<pre><code>get_debug_format() -&gt; str\n</code></pre> <p>Return debug formatted token object.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/bases/token.py</code> <pre><code>def get_debug_format(self) -&gt; str:\n    \"\"\"Return debug formatted token object.\"\"\"\n    return super().__repr__()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/bases/token.html#pygerber.gerberx3.tokenizer.tokens.bases.token.Token.ensure_type","title":"ensure_type  <code>classmethod</code>","text":"<pre><code>ensure_type(thing: Any) -&gt; Self\n</code></pre> <p>Ensure that  is a instance of this class. <p>Raise TypeError otherwise.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/bases/token.py</code> <pre><code>@classmethod\ndef ensure_type(cls, thing: Any) -&gt; Self:\n    \"\"\"Ensure that &lt;thing&gt; is a instance of this class.\n\n    Raise TypeError otherwise.\n    \"\"\"\n    if not isinstance(thing, cls):\n        raise TypeError(thing)\n\n    return thing\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/bases/token.html#pygerber.gerberx3.tokenizer.tokens.bases.token.Token.parser2_visit_token","title":"parser2_visit_token","text":"<pre><code>parser2_visit_token(context: Parser2Context) -&gt; None\n</code></pre> <p>Update drawing state for Gerber AST parser, version 2.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/bases/token.py</code> <pre><code>def parser2_visit_token(\n    self,\n    context: Parser2Context,\n) -&gt; None:\n    \"\"\"Update drawing state for Gerber AST parser, version 2.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/bases/token.html#pygerber.gerberx3.tokenizer.tokens.bases.token.Token.update_drawing_state","title":"update_drawing_state","text":"<pre><code>update_drawing_state(\n    state: State, _backend: Backend\n) -&gt; Tuple[State, Iterable[DrawCommand]]\n</code></pre> <p>Update drawing state.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/bases/token.py</code> <pre><code>def update_drawing_state(\n    self,\n    state: State,\n    _backend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n    \"\"\"Update drawing state.\"\"\"\n    return state, ()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/bases/token.html#pygerber.gerberx3.tokenizer.tokens.bases.token.Token.get_token_position","title":"get_token_position","text":"<pre><code>get_token_position() -&gt; Position\n</code></pre> <p>Get position of token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/bases/token.py</code> <pre><code>def get_token_position(self) -&gt; Position:\n    \"\"\"Get position of token.\"\"\"\n    return self._token_position\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/bases/token.html#pygerber.gerberx3.tokenizer.tokens.bases.token.Token.get_hover_message","title":"get_hover_message","text":"<pre><code>get_hover_message(state: State) -&gt; str\n</code></pre> <p>Return language server hover message.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/bases/token.py</code> <pre><code>def get_hover_message(self, state: State) -&gt; str:\n    \"\"\"Return language server hover message.\"\"\"\n    ref_doc = \"\\n\".join(s.strip() for s in str(self.__doc__).split(\"\\n\"))\n    op_specific_extra = self.get_state_based_hover_message(state)\n    return (\n        \"```gerber\\n\"\n        f\"{self.get_gerber_code_one_line_pretty_display()}\"\n        \"\\n\"\n        \"```\"\n        \"\\n\"\n        \"---\"\n        \"\\n\"\n        f\"{op_specific_extra}\\n\"\n        \"\\n\"\n        \"---\"\n        \"\\n\"\n        f\"{ref_doc}\"\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/bases/token.html#pygerber.gerberx3.tokenizer.tokens.bases.token.Token.get_state_based_hover_message","title":"get_state_based_hover_message","text":"<pre><code>get_state_based_hover_message(state: State) -&gt; str\n</code></pre> <p>Return operation specific extra information about token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/bases/token.py</code> <pre><code>def get_state_based_hover_message(\n    self,\n    state: State,  # noqa: ARG002\n) -&gt; str:\n    \"\"\"Return operation specific extra information about token.\"\"\"\n    return \"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/bases/token.html#pygerber.gerberx3.tokenizer.tokens.bases.token.Token.find_closest_token","title":"find_closest_token","text":"<pre><code>find_closest_token(\n    pos: Position, parent: Optional[TokenAccessor] = None\n) -&gt; TokenAccessor\n</code></pre> <p>Find token closest to specified position.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/bases/token.py</code> <pre><code>def find_closest_token(\n    self,\n    pos: Position,  # noqa: ARG002\n    parent: Optional[TokenAccessor] = None,\n) -&gt; TokenAccessor:\n    \"\"\"Find token closest to specified position.\"\"\"\n    return TokenAccessor(self, parent)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/bases/token.html#pygerber.gerberx3.tokenizer.tokens.bases.token.Token.get_gerber_code_one_line_pretty_display","title":"get_gerber_code_one_line_pretty_display","text":"<pre><code>get_gerber_code_one_line_pretty_display() -&gt; str\n</code></pre> <p>Get gerber code represented by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/bases/token.py</code> <pre><code>def get_gerber_code_one_line_pretty_display(self) -&gt; str:\n    \"\"\"Get gerber code represented by this token.\"\"\"\n    return self.get_gerber_code()\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/bases/token.html#pygerber.gerberx3.tokenizer.tokens.bases.token.Token.get_token_diagnostics","title":"get_token_diagnostics","text":"<pre><code>get_token_diagnostics() -&gt; Iterable[diagnostic.Diagnostic]\n</code></pre> <p>Get diagnostics for this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/bases/token.py</code> <pre><code>def get_token_diagnostics(self) -&gt; Iterable[diagnostic.Diagnostic]:\n    \"\"\"Get diagnostics for this token.\"\"\"\n    return\n    yield  # type: ignore[unreachable]\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/bases/token.html#pygerber.gerberx3.tokenizer.tokens.bases.token.Token.get_token_end_position","title":"get_token_end_position","text":"<pre><code>get_token_end_position() -&gt; Position\n</code></pre> <p>Get position of the end of the token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/bases/token.py</code> <pre><code>def get_token_end_position(self) -&gt; Position:\n    \"\"\"Get position of the end of the token.\"\"\"\n    s = str(self)\n    first, *_ = s.split(\"\\n\")\n    lines_offset = 0\n    column_offset = len(first)\n    return self.get_token_position().offset(lines_offset, column_offset)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/bases/token_accessor.html","title":"token_accessor","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/bases/token_accessor.html#pygerber.gerberx3.tokenizer.tokens.bases.token_accessor","title":"token_accessor","text":"<p>Accessor for token objects in AST.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/bases/token_accessor.html#pygerber.gerberx3.tokenizer.tokens.bases.token_accessor.TokenAccessor","title":"TokenAccessor","text":"<p>Accessor containing reference to token and its parent group.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/bases/token_accessor.py</code> <pre><code>class TokenAccessor:\n    \"\"\"Accessor containing reference to token and its parent group.\"\"\"\n\n    def __init__(\n        self,\n        token: Optional[Token],\n        parent: Optional[TokenAccessor] = None,\n        tokens: Sequence[Token] = (),\n        token_index: int = 0,\n    ) -&gt; None:\n        self.token = token\n        self.parent = parent\n        self.tokens = tokens\n        self.token_index = token_index\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/groups/__init__.html","title":"init","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/groups/__init__.html#pygerber.gerberx3.tokenizer.tokens.groups","title":"groups","text":"<p>Group tokens.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/groups/ast.html","title":"ast","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/groups/ast.html#pygerber.gerberx3.tokenizer.tokens.groups.ast","title":"ast","text":"<p>Wrapper for G74 token.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/groups/ast.html#pygerber.gerberx3.tokenizer.tokens.groups.ast.AST","title":"AST","text":"<p>             Bases: <code>TokenGroup</code></p> <p>Gerber format abstract syntax tree.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/groups/ast.py</code> <pre><code>class AST(TokenGroup):\n    \"\"\"Gerber format abstract syntax tree.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/groups/statement.html","title":"statement","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/groups/statement.html#pygerber.gerberx3.tokenizer.tokens.groups.statement","title":"statement","text":"<p>Wrapper for G74 token.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/groups/statement.html#pygerber.gerberx3.tokenizer.tokens.groups.statement.Statement","title":"Statement","text":"<p>             Bases: <code>TokenGroup</code></p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/groups/statement.html#pygerber.gerberx3.tokenizer.tokens.groups.statement.Statement--33-commands-something-extended-command","title":"3.3 Commands (<code>'%&lt;something&gt;%' - extended command</code>).","text":"<p>Commands are the core syntactic element of the Gerber format. A Gerber file is a stream of commands. Commands define the graphics state, create graphical objects, defines apertures, manage attributes and so on.</p> <p>Commands are built with words, the basic syntactic building block of a Gerber file. A word is a non-empty character string, excluding the reserved characters '' and '%', terminated with an ''</p> <pre><code>free_character = /[^%*]/; # All characters but * and %\nword = {free_character}+ '*';\n</code></pre> <p>For historic reasons, there are two command syntax styles: word commands and extended commands.</p> <pre><code>command =\n| extended_command\n| word_command\n;\nword_command = word;\nextended_command = '%' {word}+ '%';\n</code></pre> <p>(...)</p> <p>Extended commands are identified by a two-character command code that is followed by parameters specific to the code. An extended command is enclosed by a pair of \"%\" delimiters.</p> <p>An overview of all commands is in section 2.8, a full description in chapters 3.5 and 5.</p> <p>The example below shows a stream of Gerber extended commands.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/groups/statement.html#pygerber.gerberx3.tokenizer.tokens.groups.statement.Statement--example","title":"Example","text":"<pre><code>%FSLAX26Y26*%\n%MOMM*%\n%AMDonut*\n1,1,$1,$2,$3*\n$4=$1x0.75*\n1,0,$4,$2,$3*\n%\n%ADD11Donut,0.30X0X0*%\n%ADD10C,0.1*%\n</code></pre> <p>See section 3.3 of The Gerber Layer Format Specification</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/groups/statement.py</code> <pre><code>class Statement(TokenGroup):\n    \"\"\"## 3.3 Commands (`'%&lt;something&gt;%' - extended command`).\n\n    Commands are the core syntactic element of the Gerber format. A Gerber file is a stream of\n    commands. Commands define the graphics state, create graphical objects, defines apertures,\n    manage attributes and so on.\n\n    Commands are built with words, the basic syntactic building block of a Gerber file. A word is a\n    non-empty character string, excluding the reserved characters '*' and '%', terminated with an '*'\n\n    ```ebnf\n    free_character = /[^%*]/; # All characters but * and %\n    word = {free_character}+ '*';\n    ```\n\n    For historic reasons, there are two command syntax styles: word commands and extended\n    commands.\n\n    ```ebnf\n    command =\n    | extended_command\n    | word_command\n    ;\n    word_command = word;\n    extended_command = '%' {word}+ '%';\n    ```\n\n    (...)\n\n    Extended commands are identified by a two-character command code that is followed by\n    parameters specific to the code. An extended command is enclosed by a pair of \"%\" delimiters.\n\n    An overview of all commands is in section 2.8, a full description in chapters 3.5 and 5.\n\n    The example below shows a stream of Gerber extended commands.\n\n    ---\n\n    ## Example\n\n    ```gerber\n    %FSLAX26Y26*%\n    %MOMM*%\n    %AMDonut*\n    1,1,$1,$2,$3*\n    $4=$1x0.75*\n    1,0,$4,$2,$3*\n    %\n    %ADD11Donut,0.30X0X0*%\n    %ADD10C,0.1*%\n    ```\n\n    ---\n\n    See section 3.3 of [The Gerber Layer Format Specification](https://www.ucamco.com/files/downloads/file_en/456/gerber-layer-format-specification-revision-2023-08_en.pdf#page=33)\n\n    \"\"\"  # noqa: E501\n\n    def get_gerber_code(\n        self,\n        indent: str = \"\",\n        endline: str = \"\\n\",  # noqa: ARG002\n    ) -&gt; str:\n        \"\"\"Get gerber code represented by this token.\"\"\"\n        return \"%\" + \"\".join(t.get_gerber_code(indent) for t in self.tokens) + \"%\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/groups/statement.html#pygerber.gerberx3.tokenizer.tokens.groups.statement.Statement.get_gerber_code","title":"get_gerber_code","text":"<pre><code>get_gerber_code(\n    indent: str = \"\", endline: str = \"\\n\"\n) -&gt; str\n</code></pre> <p>Get gerber code represented by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/groups/statement.py</code> <pre><code>def get_gerber_code(\n    self,\n    indent: str = \"\",\n    endline: str = \"\\n\",  # noqa: ARG002\n) -&gt; str:\n    \"\"\"Get gerber code represented by this token.\"\"\"\n    return \"%\" + \"\".join(t.get_gerber_code(indent) for t in self.tokens) + \"%\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/__init__.html","title":"init","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/__init__.html#pygerber.gerberx3.tokenizer.tokens.macro","title":"macro","text":"<p>The AM command creates a macro aperture template and adds it to the aperture template dictionary (see 2.2). A template is a parametrized shape. The AD command instantiates a template into an aperture by supplying values to the template parameters.</p> <p>Templates of any shape or parametrization can be created. Multiple simple shapes called primitives can be combined in a single template. An aperture macro can contain variables whose actual values are defined by:</p> <ul> <li> <p>Values provided by the AD command</p> </li> <li> <p>Arithmetic expressions with other variables</p> </li> </ul> <p>The template is created by positioning primitives in a coordinate space. The origin of that coordinate space will be the origin of all apertures created with the state.</p> <p>A template must be defined before the first AD that refers to it. The AM command can be used multiple times in a file.</p> <p>Attributes are not attached to templates. They are attached to the aperture at the time of its creation with the AD command.</p> <p>An AM command contains the following words:</p> <ul> <li> <p>The AM declaration with the macro name</p> </li> <li> <p>Primitives with their comma-separated parameters</p> </li> <li> <p>Macro variables, defined by an arithmetic expression</p> </li> </ul>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/am_macro.html","title":"am_macro","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/am_macro.html#pygerber.gerberx3.tokenizer.tokens.macro.am_macro","title":"am_macro","text":"<p>Container token for macro definition.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/am_macro.html#pygerber.gerberx3.tokenizer.tokens.macro.am_macro.MacroDefinition","title":"MacroDefinition","text":"<p>             Bases: <code>TokenGroup</code></p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/am_macro.html#pygerber.gerberx3.tokenizer.tokens.macro.am_macro.MacroDefinition--45-aperture-macro-am","title":"4.5 Aperture Macro (AM).","text":"<p>The AM command creates a macro aperture template and adds it to the aperture template dictionary (see 2.2). A template is a parametrized shape. The AD command instantiates a template into an aperture by supplying values to the template parameters.</p> <p>Templates of any shape or parametrization can be created. Multiple simple shapes called primitives can be combined in a single template. An aperture macro can contain variables whose actual values are defined by:</p> <ul> <li>Values provided by the AD command,</li> <li>Arithmetic expressions with other variables.</li> </ul> <p>The template is created by positioning primitives in a coordinate space. The origin of that coordinate space will be the origin of all apertures created with the state.</p> <p>A template must be defined before the first AD that refers to it. The AM command can be used multiple times in a file.</p> <p>Attributes are not attached to templates. They are attached to the aperture at the time of its creation with the AD command.</p> <p>An AM command contains the following words:</p> <ul> <li>The AM declaration with the macro name</li> <li>Primitives with their comma-separated parameters</li> <li>Macro variables, defined by an arithmetic expression</li> </ul>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/am_macro.html#pygerber.gerberx3.tokenizer.tokens.macro.am_macro.MacroDefinition--syntax","title":"Syntax","text":"<pre><code>AM = '%' ('AM' macro_name macro_body) '%';\nmacro_name = name '*';\nmacro_body = {in_macro_block}+;\nin_macro_block =\n|primitive\n|variable_definition\n;\nvariable_definition = (macro_variable '=' expression) '*';\nmacro_variable = '$' positive_integer;\nprimitive = primitive_code {',' par}*\npar = ',' (expression);\n</code></pre> <ul> <li><code>AM</code> - AM for Aperture Macro</li> <li><code>&lt;Macro name&gt;</code> - Name of the aperture macro. The name must be unique, it     cannot be reused for another macro. See 3.4.5     for the syntax rules.</li> <li><code>&lt;Macro body&gt;</code> - The macro body contains the primitives generating the image     and the calculation of their parameters.</li> <li><code>&lt;Variable definition&gt;</code> - <code>$n=&lt;Arithmetic expression&gt;</code>. An arithmetic expression may     use arithmetic operators (described later), constants and     variables $m defined previously.</li> <li><code>&lt;Primitive&gt;</code> - A primitive is a basic shape to create the macro. It includes     primitive code identifying the primitive and primitive-specific     parameters (e.g. center of a circle). See 4.5.1.     The primitives are positioned in a coordinates system whose origin is the     origin of the resulting apertures.</li> <li><code>&lt;Primitive code&gt;</code> - A code specifying the primitive (e.g. polygon).</li> <li><code>&lt;Parameter&gt;</code> - Parameter can be a decimal number (e.g. <code>0.050</code>), a variable     (e.g. <code>$1</code>) or an arithmetic expression based on numbers and     variables. The actual value is calculated as explained in     4.5.4.3.</li> </ul> <p>Coordinates and sizes are expressed in the unit set by the MO command.</p> <p>A parameter can be either:</p> <ul> <li>A decimal number</li> <li>A macro variable</li> <li>An arithmetic expression</li> </ul> <p>A macro variable name must be a <code>$</code> character followed by an integer &gt;0, for example <code>$12</code>. (This is a subset of names allowed in 3.4.3.)</p> <p>Note: New lines can be added between words of a single command to enhance readability. They do not affect the macro definition.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/am_macro.html#pygerber.gerberx3.tokenizer.tokens.macro.am_macro.MacroDefinition--example","title":"Example","text":"<p>The following AM command defines an aperture macro named 'Triangle_30'.</p> <pre><code>%AMTriangle_30*\n4,1,3,\n1,-1,\n1,1,\n2,1,\n1,-1,\n30*\n%\n</code></pre> <p>See section 4.5 of The Gerber Layer Format Specification</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/am_macro.py</code> <pre><code>class MacroDefinition(TokenGroup):\n    \"\"\"## 4.5 Aperture Macro (AM).\n\n    The AM command creates a macro aperture template and adds it to the aperture template\n    dictionary (see 2.2). A template is a parametrized shape. The AD command instantiates a\n    template into an aperture by supplying values to the template parameters.\n\n    Templates of any shape or parametrization can be created. Multiple simple shapes called\n    primitives can be combined in a single template. An aperture macro can contain variables\n    whose actual values are defined by:\n\n    - Values provided by the AD command,\n    - Arithmetic expressions with other variables.\n\n    The template is created by positioning primitives in a coordinate space. The origin of that\n    coordinate space will be the origin of all apertures created with the state.\n\n    A template must be defined before the first AD that refers to it. The AM command can be used\n    multiple times in a file.\n\n    Attributes are not attached to templates. They are attached to the aperture at the time of its\n    creation with the AD command.\n\n    An AM command contains the following words:\n\n    - The AM declaration with the macro name\n    - Primitives with their comma-separated parameters\n    - Macro variables, defined by an arithmetic expression\n\n    ---\n\n    ### Syntax\n\n    ```ebnf\n    AM = '%' ('AM' macro_name macro_body) '%';\n    macro_name = name '*';\n    macro_body = {in_macro_block}+;\n    in_macro_block =\n    |primitive\n    |variable_definition\n    ;\n    variable_definition = (macro_variable '=' expression) '*';\n    macro_variable = '$' positive_integer;\n    primitive = primitive_code {',' par}*\n    par = ',' (expression);\n    ```\n\n    - `AM` - AM for Aperture Macro\n    - `&lt;Macro name&gt;` - Name of the aperture macro. The name must be unique, it\n        cannot be reused for another macro. See [3.4.5](https://www.ucamco.com/files/downloads/file_en/456/gerber-layer-format-specification-revision-2023-08_en.pdf#page=36)\n        for the syntax rules.\n    - `&lt;Macro body&gt;` - The macro body contains the primitives generating the image\n        and the calculation of their parameters.\n    - `&lt;Variable definition&gt;` - `$n=&lt;Arithmetic expression&gt;`. An arithmetic expression may\n        use arithmetic operators (described later), constants and\n        variables $m defined previously.\n    - `&lt;Primitive&gt;` - A primitive is a basic shape to create the macro. It includes\n        primitive code identifying the primitive and primitive-specific\n        parameters (e.g. center of a circle). See [4.5.1](https://www.ucamco.com/files/downloads/file_en/456/gerber-layer-format-specification-revision-2023-08_en.pdf#page=58).\n        The primitives are positioned in a coordinates system whose origin is the\n        origin of the resulting apertures.\n    - `&lt;Primitive code&gt;` - A code specifying the primitive (e.g. polygon).\n    - `&lt;Parameter&gt;` - Parameter can be a decimal number (e.g. `0.050`), a variable\n        (e.g. `$1`) or an arithmetic expression based on numbers and\n        variables. The actual value is calculated as explained in\n        [4.5.4.3](https://www.ucamco.com/files/downloads/file_en/456/gerber-layer-format-specification-revision-2023-08_en.pdf#page=71).\n\n    Coordinates and sizes are expressed in the unit set by the MO command.\n\n    A parameter can be either:\n\n    - A decimal number\n    - A macro variable\n    - An arithmetic expression\n\n    A macro variable name must be a `$` character followed by an integer &gt;0, for example `$12`.\n    (This is a subset of names allowed in [3.4.3](https://www.ucamco.com/files/downloads/file_en/456/gerber-layer-format-specification-revision-2023-08_en.pdf#page=35).)\n\n    **Note:** New lines can be added between words of a single command to enhance\n    readability. They do not affect the macro definition.\n\n    ### Example\n\n    The following AM command defines an aperture macro named 'Triangle_30'.\n\n    ```gerber\n    %AMTriangle_30*\n    4,1,3,\n    1,-1,\n    1,1,\n    2,1,\n    1,-1,\n    30*\n    %\n    ```\n\n    ---\n\n    See section 4.5 of [The Gerber Layer Format Specification](https://www.ucamco.com/files/downloads/file_en/456/gerber-layer-format-specification-revision-2023-08_en.pdf#page=56)\n\n    \"\"\"  # noqa: E501\n\n    begin: MacroBegin\n    tokens: List[Token]\n\n    def __init__(\n        self,\n        string: str,\n        location: int,\n        macro_begin: MacroBegin,\n        tokens: List[Token],\n    ) -&gt; None:\n        super().__init__(string, location, tokens)\n        self.macro_begin = macro_begin\n\n    @property\n    def macro_name(self) -&gt; str:\n        \"\"\"Name of macro item.\"\"\"\n        return self.macro_begin.name\n\n    @classmethod\n    def new(cls, string: str, location: int, tokens: ParseResults) -&gt; Self:\n        \"\"\"Create instance of this class.\n\n        Created to be used as callback in `ParserElement.set_parse_action()`.\n        \"\"\"\n        macro_begin = tokens[\"macro_begin\"]\n        if not isinstance(macro_begin, MacroBegin):\n            raise TypeError(macro_begin)\n\n        macro_body_raw = tokens[\"macro_body\"]\n        macro_body_tokens: list[Token] = []\n\n        for e in macro_body_raw:\n            token = e[0]\n            if not isinstance(token, Token):\n                raise TypeError(token)\n            macro_body_tokens.append(token)\n\n        return cls(\n            string=string,\n            location=location,\n            macro_begin=macro_begin,\n            tokens=macro_body_tokens,\n        )\n\n    def update_drawing_state(\n        self,\n        state: State,\n        _backend: Backend,\n    ) -&gt; Tuple[State, Iterable[DrawCommand]]:\n        \"\"\"Exit drawing process.\"\"\"\n        new_macros_dict = {**state.macros}\n        new_macros_dict[self.macro_name] = self\n\n        return (\n            state.model_copy(\n                update={\n                    \"macros\": new_macros_dict,\n                },\n            ),\n            (),\n        )\n\n    def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n        \"\"\"Perform actions on the context implicated by this token.\"\"\"\n        context.get_hooks().macro_definition.pre_parser_visit_token(self, context)\n        context.get_hooks().macro_definition.on_parser_visit_token(self, context)\n        context.get_hooks().macro_definition.post_parser_visit_token(self, context)\n\n    def __iter__(self) -&gt; Iterator[Token]:\n        yield self.macro_begin\n        for token in self.tokens:\n            yield from token\n        yield self\n\n    def evaluate(\n        self,\n        state: State,\n        handle: PrivateApertureHandle,\n        parameters: dict[str, Offset],\n    ) -&gt; None:\n        \"\"\"Evaluate macro into series of DrawCommands.\"\"\"\n        context = MacroContext()\n        context.variables.update(parameters)\n\n        for expression in self.tokens:\n            if isinstance(expression, MacroStatementToken):\n                expression.evaluate(context, state, handle)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/am_macro.html#pygerber.gerberx3.tokenizer.tokens.macro.am_macro.MacroDefinition.macro_name","title":"macro_name  <code>property</code>","text":"<pre><code>macro_name: str\n</code></pre> <p>Name of macro item.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/am_macro.html#pygerber.gerberx3.tokenizer.tokens.macro.am_macro.MacroDefinition.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(\n    string: str, location: int, tokens: ParseResults\n) -&gt; Self\n</code></pre> <p>Create instance of this class.</p> <p>Created to be used as callback in <code>ParserElement.set_parse_action()</code>.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/am_macro.py</code> <pre><code>@classmethod\ndef new(cls, string: str, location: int, tokens: ParseResults) -&gt; Self:\n    \"\"\"Create instance of this class.\n\n    Created to be used as callback in `ParserElement.set_parse_action()`.\n    \"\"\"\n    macro_begin = tokens[\"macro_begin\"]\n    if not isinstance(macro_begin, MacroBegin):\n        raise TypeError(macro_begin)\n\n    macro_body_raw = tokens[\"macro_body\"]\n    macro_body_tokens: list[Token] = []\n\n    for e in macro_body_raw:\n        token = e[0]\n        if not isinstance(token, Token):\n            raise TypeError(token)\n        macro_body_tokens.append(token)\n\n    return cls(\n        string=string,\n        location=location,\n        macro_begin=macro_begin,\n        tokens=macro_body_tokens,\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/am_macro.html#pygerber.gerberx3.tokenizer.tokens.macro.am_macro.MacroDefinition.update_drawing_state","title":"update_drawing_state","text":"<pre><code>update_drawing_state(\n    state: State, _backend: Backend\n) -&gt; Tuple[State, Iterable[DrawCommand]]\n</code></pre> <p>Exit drawing process.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/am_macro.py</code> <pre><code>def update_drawing_state(\n    self,\n    state: State,\n    _backend: Backend,\n) -&gt; Tuple[State, Iterable[DrawCommand]]:\n    \"\"\"Exit drawing process.\"\"\"\n    new_macros_dict = {**state.macros}\n    new_macros_dict[self.macro_name] = self\n\n    return (\n        state.model_copy(\n            update={\n                \"macros\": new_macros_dict,\n            },\n        ),\n        (),\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/am_macro.html#pygerber.gerberx3.tokenizer.tokens.macro.am_macro.MacroDefinition.parser2_visit_token","title":"parser2_visit_token","text":"<pre><code>parser2_visit_token(context: Parser2Context) -&gt; None\n</code></pre> <p>Perform actions on the context implicated by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/am_macro.py</code> <pre><code>def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n    \"\"\"Perform actions on the context implicated by this token.\"\"\"\n    context.get_hooks().macro_definition.pre_parser_visit_token(self, context)\n    context.get_hooks().macro_definition.on_parser_visit_token(self, context)\n    context.get_hooks().macro_definition.post_parser_visit_token(self, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/am_macro.html#pygerber.gerberx3.tokenizer.tokens.macro.am_macro.MacroDefinition.evaluate","title":"evaluate","text":"<pre><code>evaluate(\n    state: State,\n    handle: PrivateApertureHandle,\n    parameters: dict[str, Offset],\n) -&gt; None\n</code></pre> <p>Evaluate macro into series of DrawCommands.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/am_macro.py</code> <pre><code>def evaluate(\n    self,\n    state: State,\n    handle: PrivateApertureHandle,\n    parameters: dict[str, Offset],\n) -&gt; None:\n    \"\"\"Evaluate macro into series of DrawCommands.\"\"\"\n    context = MacroContext()\n    context.variables.update(parameters)\n\n    for expression in self.tokens:\n        if isinstance(expression, MacroStatementToken):\n            expression.evaluate(context, state, handle)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/macro_begin.html","title":"macro_begin","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/macro_begin.html#pygerber.gerberx3.tokenizer.tokens.macro.macro_begin","title":"macro_begin","text":"<p>Comment token.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/macro_begin.html#pygerber.gerberx3.tokenizer.tokens.macro.macro_begin.MacroBegin","title":"MacroBegin","text":"<p>             Bases: <code>Token</code></p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/macro_begin.html#pygerber.gerberx3.tokenizer.tokens.macro.macro_begin.MacroBegin--45-aperture-macro-am","title":"4.5 Aperture Macro (AM).","text":"<p>The AM command creates a macro aperture <code>template</code> and adds it to the aperture <code>template</code> dictionary (see 2.2). A <code>template</code> is a parametrized shape. The AD command instantiates a <code>template</code> into an aperture by supplying values to the template <code>parameters</code>.</p> <p>Templates of any shape or parametrization can be created. Multiple simple shapes called <code>primitives</code> can be combined in a single <code>template</code>. An aperture macro can contain <code>variables</code> whose actual values are defined by:</p> <ul> <li>Values provided by the AD command</li> <li><code>Arithmetic expressions</code> with other <code>variables</code></li> </ul> <p>The template is created by positioning <code>primitives</code> in a coordinate space. The origin of that coordinate space will be the origin of all apertures created with the state.</p> <p>A <code>template</code> must be defined before the first AD that refers to it. The AM command can be used multiple times in a file.</p> <p><code>Attributes</code> are not attached to templates. They are attached to the aperture at the time of its creation with the AD command.</p> <p>An AM command contains the following words:</p> <ul> <li>The AM declaration with the macro name</li> <li><code>Primitives</code> with their comma-separated <code>parameters</code></li> <li><code>Macro variables</code>, defined by an <code>arithmetic expression</code></li> </ul> <p>Coordinates and sizes are expressed in the unit set by the MO command.</p> <p>A parameter can be either:</p> <ul> <li>A <code>decimal</code> number</li> <li>A <code>macro variable</code></li> <li>An <code>arithmetic expression</code></li> </ul> <p>A <code>macro variable</code> name must be a \"$\" character followed by an integer &gt;0, for example <code>$12</code>. (This is a subset of names allowed in 3.4.3.)</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/macro_begin.html#pygerber.gerberx3.tokenizer.tokens.macro.macro_begin.MacroBegin--example","title":"Example","text":"<p>The following AM command defines an aperture macro named \"Triangle_30\".</p> <pre><code>%AMTriangle_30*\n4,1,3,\n1,-1,\n1,1,\n2,1,\n1,-1,\n30*\n%\n</code></pre> <p>See section 4.5 of The Gerber Layer Format Specification</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/macro_begin.py</code> <pre><code>class MacroBegin(Token):\n    \"\"\"## 4.5 Aperture Macro (AM).\n\n    The AM command creates a macro aperture `template` and adds it to the aperture `template`\n    dictionary (see 2.2). A `template` is a parametrized shape. The AD command instantiates a\n    `template` into an aperture by supplying values to the template `parameters`.\n\n    Templates of any shape or parametrization can be created. Multiple simple shapes called\n    `primitives` can be combined in a single `template`. An aperture macro can contain `variables`\n    whose actual values are defined by:\n\n    - Values provided by the AD command\n    - `Arithmetic expressions` with other `variables`\n\n    The template is created by positioning `primitives` in a coordinate space. The origin of that\n    coordinate space will be the origin of all apertures created with the state.\n\n    A `template` must be defined before the first AD that refers to it. The AM command can be used\n    multiple times in a file.\n\n    `Attributes` are not attached to templates. They are attached to the aperture at the time of its\n    creation with the AD command.\n\n    An AM command contains the following words:\n\n    - The AM declaration with the macro name\n    - `Primitives` with their comma-separated `parameters`\n    - `Macro variables`, defined by an `arithmetic expression`\n\n    Coordinates and sizes are expressed in the unit set by the MO command.\n\n    A parameter can be either:\n\n    - A `decimal` number\n    - A `macro variable`\n    - An `arithmetic expression`\n\n    A `macro variable` name must be a \"$\" character followed by an integer &gt;0, for example `$12`.\n    (This is a subset of names allowed in 3.4.3.)\n\n    ---\n\n    ## Example\n\n    The following AM command defines an aperture macro named \"Triangle_30\".\n\n    ```gerber\n    %AMTriangle_30*\n    4,1,3,\n    1,-1,\n    1,1,\n    2,1,\n    1,-1,\n    30*\n    %\n    ```\n\n    ---\n\n    See section 4.5 of [The Gerber Layer Format Specification](https://www.ucamco.com/files/downloads/file_en/456/gerber-layer-format-specification-revision-2023-08_en.pdf#page=56)\n\n    \"\"\"  # noqa: E501\n\n    def __init__(self, string: str, location: int, name: str) -&gt; None:\n        super().__init__(string, location)\n        self.name = name\n\n    @classmethod\n    def new(cls, string: str, location: int, tokens: ParseResults) -&gt; Self:\n        \"\"\"Create instance of this class.\n\n        Created to be used as callback in `ParserElement.set_parse_action()`.\n        \"\"\"\n        content: str = str(tokens[\"macro_name\"])\n        return cls(string=string, location=location, name=content)\n\n    def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n        \"\"\"Perform actions on the context implicated by this token.\"\"\"\n        context.get_hooks().macro_begin.pre_parser_visit_token(self, context)\n        context.get_hooks().macro_begin.on_parser_visit_token(self, context)\n        context.get_hooks().macro_begin.post_parser_visit_token(self, context)\n\n    def get_gerber_code(\n        self,\n        indent: str = \"\",  # noqa: ARG002\n        endline: str = \"\\n\",  # noqa: ARG002\n    ) -&gt; str:\n        \"\"\"Get gerber code represented by this token.\"\"\"\n        return f\"AM{self.name}\"\n\n    def get_gerber_code_one_line_pretty_display(self) -&gt; str:\n        \"\"\"Get gerber code represented by this token.\"\"\"\n        return f\"%{self.get_gerber_code()}*\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/macro_begin.html#pygerber.gerberx3.tokenizer.tokens.macro.macro_begin.MacroBegin.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(\n    string: str, location: int, tokens: ParseResults\n) -&gt; Self\n</code></pre> <p>Create instance of this class.</p> <p>Created to be used as callback in <code>ParserElement.set_parse_action()</code>.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/macro_begin.py</code> <pre><code>@classmethod\ndef new(cls, string: str, location: int, tokens: ParseResults) -&gt; Self:\n    \"\"\"Create instance of this class.\n\n    Created to be used as callback in `ParserElement.set_parse_action()`.\n    \"\"\"\n    content: str = str(tokens[\"macro_name\"])\n    return cls(string=string, location=location, name=content)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/macro_begin.html#pygerber.gerberx3.tokenizer.tokens.macro.macro_begin.MacroBegin.parser2_visit_token","title":"parser2_visit_token","text":"<pre><code>parser2_visit_token(context: Parser2Context) -&gt; None\n</code></pre> <p>Perform actions on the context implicated by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/macro_begin.py</code> <pre><code>def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n    \"\"\"Perform actions on the context implicated by this token.\"\"\"\n    context.get_hooks().macro_begin.pre_parser_visit_token(self, context)\n    context.get_hooks().macro_begin.on_parser_visit_token(self, context)\n    context.get_hooks().macro_begin.post_parser_visit_token(self, context)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/macro_begin.html#pygerber.gerberx3.tokenizer.tokens.macro.macro_begin.MacroBegin.get_gerber_code","title":"get_gerber_code","text":"<pre><code>get_gerber_code(\n    indent: str = \"\", endline: str = \"\\n\"\n) -&gt; str\n</code></pre> <p>Get gerber code represented by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/macro_begin.py</code> <pre><code>def get_gerber_code(\n    self,\n    indent: str = \"\",  # noqa: ARG002\n    endline: str = \"\\n\",  # noqa: ARG002\n) -&gt; str:\n    \"\"\"Get gerber code represented by this token.\"\"\"\n    return f\"AM{self.name}\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/macro_begin.html#pygerber.gerberx3.tokenizer.tokens.macro.macro_begin.MacroBegin.get_gerber_code_one_line_pretty_display","title":"get_gerber_code_one_line_pretty_display","text":"<pre><code>get_gerber_code_one_line_pretty_display() -&gt; str\n</code></pre> <p>Get gerber code represented by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/macro_begin.py</code> <pre><code>def get_gerber_code_one_line_pretty_display(self) -&gt; str:\n    \"\"\"Get gerber code represented by this token.\"\"\"\n    return f\"%{self.get_gerber_code()}*\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/macro_context.html","title":"macro_context","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/macro_context.html#pygerber.gerberx3.tokenizer.tokens.macro.macro_context","title":"macro_context","text":"<p>Module contains MacroContext class definition.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/macro_context.html#pygerber.gerberx3.tokenizer.tokens.macro.macro_context.MacroContext","title":"MacroContext","text":"<p>             Bases: <code>BaseModel</code></p> <p>Macro context object used during macro evaluation.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/macro_context.py</code> <pre><code>class MacroContext(BaseModel):\n    \"\"\"Macro context object used during macro evaluation.\"\"\"\n\n    variables: Dict[str, Offset] = Field(default_factory=dict)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/point.html","title":"point","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/point.html#pygerber.gerberx3.tokenizer.tokens.macro.point","title":"point","text":"<p>Point wrapper token.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/point.html#pygerber.gerberx3.tokenizer.tokens.macro.point.Point","title":"Point","text":"<p>             Bases: <code>Token</code></p> <p>Point wrapper token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/point.py</code> <pre><code>class Point(Token):\n    \"\"\"Point wrapper token.\"\"\"\n\n    def __init__(\n        self,\n        string: str,\n        location: int,\n        x: MacroExpressionToken,\n        y: MacroExpressionToken,\n    ) -&gt; None:\n        super().__init__(string, location)\n        self.x = x\n        self.y = y\n\n    @classmethod\n    def new(cls, string: str, location: int, tokens: ParseResults) -&gt; Self:\n        \"\"\"Create instance of this class.\n\n        Created to be used as callback in `ParserElement.set_parse_action()`.\n        \"\"\"\n        x = MacroExpressionToken.ensure_type(tokens[\"x\"])\n        y = MacroExpressionToken.ensure_type(tokens[\"y\"])\n\n        return cls(\n            string=string,\n            location=location,\n            x=x,\n            y=y,\n        )\n\n    def to_parser2_point2(self, context: Parser2Context) -&gt; Point2:\n        \"\"\"Convert to `Expression2` descendant class.\"\"\"\n        return Point2(\n            x=self.x.to_parser2_expression(context=context),\n            y=self.y.to_parser2_expression(context=context),\n        )\n\n    def get_gerber_code(\n        self,\n        indent: str = \"\",\n        endline: str = \"\\n\",\n    ) -&gt; str:\n        \"\"\"Get gerber code from iterable of tokens.\"\"\"\n        return (\n            f\"{self.x.get_gerber_code(indent, endline)},\"\n            f\"{self.y.get_gerber_code(indent, endline)}\"\n        )\n\n    def __str__(self) -&gt; str:\n        return f\"{super().__str__()}::[{self.x}, {self.y}]\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/point.html#pygerber.gerberx3.tokenizer.tokens.macro.point.Point.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(\n    string: str, location: int, tokens: ParseResults\n) -&gt; Self\n</code></pre> <p>Create instance of this class.</p> <p>Created to be used as callback in <code>ParserElement.set_parse_action()</code>.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/point.py</code> <pre><code>@classmethod\ndef new(cls, string: str, location: int, tokens: ParseResults) -&gt; Self:\n    \"\"\"Create instance of this class.\n\n    Created to be used as callback in `ParserElement.set_parse_action()`.\n    \"\"\"\n    x = MacroExpressionToken.ensure_type(tokens[\"x\"])\n    y = MacroExpressionToken.ensure_type(tokens[\"y\"])\n\n    return cls(\n        string=string,\n        location=location,\n        x=x,\n        y=y,\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/point.html#pygerber.gerberx3.tokenizer.tokens.macro.point.Point.to_parser2_point2","title":"to_parser2_point2","text":"<pre><code>to_parser2_point2(context: Parser2Context) -&gt; Point2\n</code></pre> <p>Convert to <code>Expression2</code> descendant class.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/point.py</code> <pre><code>def to_parser2_point2(self, context: Parser2Context) -&gt; Point2:\n    \"\"\"Convert to `Expression2` descendant class.\"\"\"\n    return Point2(\n        x=self.x.to_parser2_expression(context=context),\n        y=self.y.to_parser2_expression(context=context),\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/point.html#pygerber.gerberx3.tokenizer.tokens.macro.point.Point.get_gerber_code","title":"get_gerber_code","text":"<pre><code>get_gerber_code(\n    indent: str = \"\", endline: str = \"\\n\"\n) -&gt; str\n</code></pre> <p>Get gerber code from iterable of tokens.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/point.py</code> <pre><code>def get_gerber_code(\n    self,\n    indent: str = \"\",\n    endline: str = \"\\n\",\n) -&gt; str:\n    \"\"\"Get gerber code from iterable of tokens.\"\"\"\n    return (\n        f\"{self.x.get_gerber_code(indent, endline)},\"\n        f\"{self.y.get_gerber_code(indent, endline)}\"\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/expressions/__init__.html","title":"init","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/expressions/__init__.html#pygerber.gerberx3.tokenizer.tokens.macro.expressions","title":"expressions","text":"<p><code>expressions</code> package contains macro expression tokens.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/expressions/binary.html","title":"binary","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/expressions/binary.html#pygerber.gerberx3.tokenizer.tokens.macro.expressions.binary","title":"binary","text":"<p>Arithmetic expression token.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/expressions/binary.html#pygerber.gerberx3.tokenizer.tokens.macro.expressions.binary.BinaryOperator","title":"BinaryOperator","text":"<p>             Bases: <code>MacroExpressionToken</code></p> <p>Operation with two operands.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/expressions/binary.py</code> <pre><code>class BinaryOperator(MacroExpressionToken):\n    \"\"\"Operation with two operands.\"\"\"\n\n    def __init__(\n        self,\n        string: str,\n        location: int,\n        left: MacroExpressionToken,\n        right: MacroExpressionToken,\n    ) -&gt; None:\n        super().__init__(string, location)\n        self.left = left\n        self.right = right\n        self.operator: Callable[[Any, Any], Any] = add\n        self.sign = \"+\"\n\n    @classmethod\n    def new(\n        cls,\n        string: str,\n        location: int,\n        tokens: ParseResults,\n    ) -&gt; Self:\n        \"\"\"Create instance of this class.\n\n        Created to be used as callback in `ParserElement.set_parse_action()`.\n        \"\"\"\n        left, right = tokens[0]\n        return cls(\n            string,\n            location,\n            MacroExpressionToken.ensure_type(left),\n            MacroExpressionToken.ensure_type(right),\n        )\n\n    def to_parser2_expression(self, context: Parser2Context) -&gt; Expression2:\n        \"\"\"Convert to `Expression2` descendant class.\"\"\"\n        raise NotImplementedError\n\n    def evaluate_numeric(self, macro_context: MacroContext, state: State) -&gt; Offset:\n        \"\"\"Evaluate numeric value of this macro expression.\"\"\"\n        left = self.left.evaluate_numeric(macro_context, state)\n        right = self.right.evaluate_numeric(macro_context, state)\n        output = self.operator(left, right)\n\n        if not isinstance(output, Offset):\n            raise InvalidArithmeticExpressionError\n\n        return output\n\n    def get_gerber_code(\n        self,\n        indent: str = \"\",\n        endline: str = \"\\n\",\n    ) -&gt; str:\n        \"\"\"Get gerber code from iterable of tokens.\"\"\"\n        return (\n            f\"{self.left.get_gerber_code(indent=indent, endline=endline)}{self.sign}\"\n            f\"{self.right.get_gerber_code(indent=indent, endline=endline)}\"\n        )\n\n    def __str__(self) -&gt; str:\n        return f\"{super().__str__()}::[{self.left}, {self.right}]\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/expressions/binary.html#pygerber.gerberx3.tokenizer.tokens.macro.expressions.binary.BinaryOperator.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(\n    string: str, location: int, tokens: ParseResults\n) -&gt; Self\n</code></pre> <p>Create instance of this class.</p> <p>Created to be used as callback in <code>ParserElement.set_parse_action()</code>.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/expressions/binary.py</code> <pre><code>@classmethod\ndef new(\n    cls,\n    string: str,\n    location: int,\n    tokens: ParseResults,\n) -&gt; Self:\n    \"\"\"Create instance of this class.\n\n    Created to be used as callback in `ParserElement.set_parse_action()`.\n    \"\"\"\n    left, right = tokens[0]\n    return cls(\n        string,\n        location,\n        MacroExpressionToken.ensure_type(left),\n        MacroExpressionToken.ensure_type(right),\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/expressions/binary.html#pygerber.gerberx3.tokenizer.tokens.macro.expressions.binary.BinaryOperator.to_parser2_expression","title":"to_parser2_expression","text":"<pre><code>to_parser2_expression(\n    context: Parser2Context,\n) -&gt; Expression2\n</code></pre> <p>Convert to <code>Expression2</code> descendant class.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/expressions/binary.py</code> <pre><code>def to_parser2_expression(self, context: Parser2Context) -&gt; Expression2:\n    \"\"\"Convert to `Expression2` descendant class.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/expressions/binary.html#pygerber.gerberx3.tokenizer.tokens.macro.expressions.binary.BinaryOperator.evaluate_numeric","title":"evaluate_numeric","text":"<pre><code>evaluate_numeric(\n    macro_context: MacroContext, state: State\n) -&gt; Offset\n</code></pre> <p>Evaluate numeric value of this macro expression.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/expressions/binary.py</code> <pre><code>def evaluate_numeric(self, macro_context: MacroContext, state: State) -&gt; Offset:\n    \"\"\"Evaluate numeric value of this macro expression.\"\"\"\n    left = self.left.evaluate_numeric(macro_context, state)\n    right = self.right.evaluate_numeric(macro_context, state)\n    output = self.operator(left, right)\n\n    if not isinstance(output, Offset):\n        raise InvalidArithmeticExpressionError\n\n    return output\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/expressions/binary.html#pygerber.gerberx3.tokenizer.tokens.macro.expressions.binary.BinaryOperator.get_gerber_code","title":"get_gerber_code","text":"<pre><code>get_gerber_code(\n    indent: str = \"\", endline: str = \"\\n\"\n) -&gt; str\n</code></pre> <p>Get gerber code from iterable of tokens.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/expressions/binary.py</code> <pre><code>def get_gerber_code(\n    self,\n    indent: str = \"\",\n    endline: str = \"\\n\",\n) -&gt; str:\n    \"\"\"Get gerber code from iterable of tokens.\"\"\"\n    return (\n        f\"{self.left.get_gerber_code(indent=indent, endline=endline)}{self.sign}\"\n        f\"{self.right.get_gerber_code(indent=indent, endline=endline)}\"\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/expressions/binary.html#pygerber.gerberx3.tokenizer.tokens.macro.expressions.binary.MultiplicationOperator","title":"MultiplicationOperator","text":"<p>             Bases: <code>BinaryOperator</code></p> <p>Operation with two operands.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/expressions/binary.py</code> <pre><code>class MultiplicationOperator(BinaryOperator):\n    \"\"\"Operation with two operands.\"\"\"\n\n    def __init__(\n        self,\n        string: str,\n        location: int,\n        left: MacroExpressionToken,\n        right: MacroExpressionToken,\n    ) -&gt; None:\n        super().__init__(string, location, left, right)\n        self.operator: Callable[[Any, Any], Any] = mul\n        self.sign = \"x\"\n\n    def to_parser2_expression(self, context: Parser2Context) -&gt; Expression2:\n        \"\"\"Convert to `Expression2` descendant class.\"\"\"\n        return context.macro_expressions.multiplication(\n            lhs=self.left.to_parser2_expression(context),\n            rhs=self.right.to_parser2_expression(context),\n        )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/expressions/binary.html#pygerber.gerberx3.tokenizer.tokens.macro.expressions.binary.MultiplicationOperator.to_parser2_expression","title":"to_parser2_expression","text":"<pre><code>to_parser2_expression(\n    context: Parser2Context,\n) -&gt; Expression2\n</code></pre> <p>Convert to <code>Expression2</code> descendant class.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/expressions/binary.py</code> <pre><code>def to_parser2_expression(self, context: Parser2Context) -&gt; Expression2:\n    \"\"\"Convert to `Expression2` descendant class.\"\"\"\n    return context.macro_expressions.multiplication(\n        lhs=self.left.to_parser2_expression(context),\n        rhs=self.right.to_parser2_expression(context),\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/expressions/binary.html#pygerber.gerberx3.tokenizer.tokens.macro.expressions.binary.DivisionOperator","title":"DivisionOperator","text":"<p>             Bases: <code>BinaryOperator</code></p> <p>Operation with two operands.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/expressions/binary.py</code> <pre><code>class DivisionOperator(BinaryOperator):\n    \"\"\"Operation with two operands.\"\"\"\n\n    def __init__(\n        self,\n        string: str,\n        location: int,\n        left: MacroExpressionToken,\n        right: MacroExpressionToken,\n    ) -&gt; None:\n        super().__init__(string, location, left, right)\n        self.operator: Callable[[Any, Any], Any] = truediv\n        self.sign = \"/\"\n\n    def to_parser2_expression(self, context: Parser2Context) -&gt; Expression2:\n        \"\"\"Convert to `Expression2` descendant class.\"\"\"\n        return context.macro_expressions.division(\n            lhs=self.left.to_parser2_expression(context),\n            rhs=self.right.to_parser2_expression(context),\n        )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/expressions/binary.html#pygerber.gerberx3.tokenizer.tokens.macro.expressions.binary.DivisionOperator.to_parser2_expression","title":"to_parser2_expression","text":"<pre><code>to_parser2_expression(\n    context: Parser2Context,\n) -&gt; Expression2\n</code></pre> <p>Convert to <code>Expression2</code> descendant class.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/expressions/binary.py</code> <pre><code>def to_parser2_expression(self, context: Parser2Context) -&gt; Expression2:\n    \"\"\"Convert to `Expression2` descendant class.\"\"\"\n    return context.macro_expressions.division(\n        lhs=self.left.to_parser2_expression(context),\n        rhs=self.right.to_parser2_expression(context),\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/expressions/binary.html#pygerber.gerberx3.tokenizer.tokens.macro.expressions.binary.AdditionOperator","title":"AdditionOperator","text":"<p>             Bases: <code>BinaryOperator</code></p> <p>Operation with two operands.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/expressions/binary.py</code> <pre><code>class AdditionOperator(BinaryOperator):\n    \"\"\"Operation with two operands.\"\"\"\n\n    def __init__(\n        self,\n        string: str,\n        location: int,\n        left: MacroExpressionToken,\n        right: MacroExpressionToken,\n    ) -&gt; None:\n        super().__init__(string, location, left, right)\n        self.operator: Callable[[Any, Any], Any] = add\n        self.sign = \"+\"\n\n    def to_parser2_expression(self, context: Parser2Context) -&gt; Expression2:\n        \"\"\"Convert to `Expression2` descendant class.\"\"\"\n        return context.macro_expressions.addition(\n            lhs=self.left.to_parser2_expression(context),\n            rhs=self.right.to_parser2_expression(context),\n        )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/expressions/binary.html#pygerber.gerberx3.tokenizer.tokens.macro.expressions.binary.AdditionOperator.to_parser2_expression","title":"to_parser2_expression","text":"<pre><code>to_parser2_expression(\n    context: Parser2Context,\n) -&gt; Expression2\n</code></pre> <p>Convert to <code>Expression2</code> descendant class.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/expressions/binary.py</code> <pre><code>def to_parser2_expression(self, context: Parser2Context) -&gt; Expression2:\n    \"\"\"Convert to `Expression2` descendant class.\"\"\"\n    return context.macro_expressions.addition(\n        lhs=self.left.to_parser2_expression(context),\n        rhs=self.right.to_parser2_expression(context),\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/expressions/binary.html#pygerber.gerberx3.tokenizer.tokens.macro.expressions.binary.SubtractionOperator","title":"SubtractionOperator","text":"<p>             Bases: <code>BinaryOperator</code></p> <p>Operation with two operands.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/expressions/binary.py</code> <pre><code>class SubtractionOperator(BinaryOperator):\n    \"\"\"Operation with two operands.\"\"\"\n\n    def __init__(\n        self,\n        string: str,\n        location: int,\n        left: MacroExpressionToken,\n        right: MacroExpressionToken,\n    ) -&gt; None:\n        super().__init__(string, location, left, right)\n        self.operator: Callable[[Any, Any], Any] = sub\n        self.sign = \"-\"\n\n    def to_parser2_expression(self, context: Parser2Context) -&gt; Expression2:\n        \"\"\"Convert to `Expression2` descendant class.\"\"\"\n        return context.macro_expressions.subtraction(\n            lhs=self.left.to_parser2_expression(context),\n            rhs=self.right.to_parser2_expression(context),\n        )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/expressions/binary.html#pygerber.gerberx3.tokenizer.tokens.macro.expressions.binary.SubtractionOperator.to_parser2_expression","title":"to_parser2_expression","text":"<pre><code>to_parser2_expression(\n    context: Parser2Context,\n) -&gt; Expression2\n</code></pre> <p>Convert to <code>Expression2</code> descendant class.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/expressions/binary.py</code> <pre><code>def to_parser2_expression(self, context: Parser2Context) -&gt; Expression2:\n    \"\"\"Convert to `Expression2` descendant class.\"\"\"\n    return context.macro_expressions.subtraction(\n        lhs=self.left.to_parser2_expression(context),\n        rhs=self.right.to_parser2_expression(context),\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/expressions/errors.html","title":"errors","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/expressions/errors.html#pygerber.gerberx3.tokenizer.tokens.macro.expressions.errors","title":"errors","text":"<p>Arithmetic expression token.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/expressions/errors.html#pygerber.gerberx3.tokenizer.tokens.macro.expressions.errors.InvalidArithmeticExpressionError","title":"InvalidArithmeticExpressionError","text":"<p>             Bases: <code>TokenizerError</code></p> <p>Raised when it's not possible to construct valid arithmetic expression.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/expressions/errors.py</code> <pre><code>class InvalidArithmeticExpressionError(TokenizerError):\n    \"\"\"Raised when it's not possible to construct valid arithmetic expression.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/expressions/macro_expression.html","title":"macro_expression","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/expressions/macro_expression.html#pygerber.gerberx3.tokenizer.tokens.macro.expressions.macro_expression","title":"macro_expression","text":"<p>In-macro numeric expression token.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/expressions/macro_expression.html#pygerber.gerberx3.tokenizer.tokens.macro.expressions.macro_expression.MacroExpressionToken","title":"MacroExpressionToken","text":"<p>             Bases: <code>Token</code></p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/expressions/macro_expression.html#pygerber.gerberx3.tokenizer.tokens.macro.expressions.macro_expression.MacroExpressionToken--4542-arithmetic-expressions","title":"4.5.4.2 Arithmetic Expressions.","text":"<p>A parameter value can also be defined by an arithmetic expression consisting of integer and decimal constants, other variables, arithmetic operators and the brackets \"(\" and \")\". The standard arithmetic precedence rules apply. The following arithmetic operators are available:</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/expressions/macro_expression.html#pygerber.gerberx3.tokenizer.tokens.macro.expressions.macro_expression.MacroExpressionToken--example","title":"Example","text":"<pre><code>%AMRect*\n21,1,$1,$2-2x$3,-$4,-$5+$2,0*%\n</code></pre> <p>The corresponding AD command could be:</p> <pre><code>%ADD146Rect,0.0807087X0.1023622X0.0118110X0.5000000X0.3000000*%\n</code></pre> <p>See section 4.5.4.2 of The Gerber Layer Format Specification</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/expressions/macro_expression.py</code> <pre><code>class MacroExpressionToken(Token):\n    \"\"\"## 4.5.4.2 Arithmetic Expressions.\n\n    A parameter value can also be defined by an arithmetic expression consisting of integer and\n    decimal constants, other variables, arithmetic operators and the brackets \"(\" and \")\". The\n    standard arithmetic precedence rules apply. The following arithmetic operators are available:\n\n    ---\n\n    ## Example\n\n    ```gerber\n    %AMRect*\n    21,1,$1,$2-2x$3,-$4,-$5+$2,0*%\n    ```\n\n    The corresponding AD command could be:\n\n    ```gerber\n    %ADD146Rect,0.0807087X0.1023622X0.0118110X0.5000000X0.3000000*%\n    ```\n\n    ---\n\n    See section 4.5.4.2 of [The Gerber Layer Format Specification](https://www.ucamco.com/files/downloads/file_en/456/gerber-layer-format-specification-revision-2023-08_en.pdf#page=70)\n\n    \"\"\"  # noqa: E501\n\n    def to_parser2_expression(self, context: Parser2Context) -&gt; Expression2:\n        \"\"\"Convert to `Expression2` descendant class.\"\"\"\n        raise NotImplementedError\n\n    def evaluate_numeric(\n        self,\n        _macro_context: MacroContext,\n        state: State,\n        /,\n    ) -&gt; Offset:\n        \"\"\"Evaluate numeric value of this macro expression.\"\"\"\n        return Offset.new(value=\"0.0\", unit=state.get_units())\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/expressions/macro_expression.html#pygerber.gerberx3.tokenizer.tokens.macro.expressions.macro_expression.MacroExpressionToken.to_parser2_expression","title":"to_parser2_expression","text":"<pre><code>to_parser2_expression(\n    context: Parser2Context,\n) -&gt; Expression2\n</code></pre> <p>Convert to <code>Expression2</code> descendant class.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/expressions/macro_expression.py</code> <pre><code>def to_parser2_expression(self, context: Parser2Context) -&gt; Expression2:\n    \"\"\"Convert to `Expression2` descendant class.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/expressions/macro_expression.html#pygerber.gerberx3.tokenizer.tokens.macro.expressions.macro_expression.MacroExpressionToken.evaluate_numeric","title":"evaluate_numeric","text":"<pre><code>evaluate_numeric(\n    _macro_context: MacroContext, state: State\n) -&gt; Offset\n</code></pre> <p>Evaluate numeric value of this macro expression.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/expressions/macro_expression.py</code> <pre><code>def evaluate_numeric(\n    self,\n    _macro_context: MacroContext,\n    state: State,\n    /,\n) -&gt; Offset:\n    \"\"\"Evaluate numeric value of this macro expression.\"\"\"\n    return Offset.new(value=\"0.0\", unit=state.get_units())\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/expressions/numeric_constant.html","title":"numeric_constant","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/expressions/numeric_constant.html#pygerber.gerberx3.tokenizer.tokens.macro.expressions.numeric_constant","title":"numeric_constant","text":"<p>Arithmetic expression token.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/expressions/numeric_constant.html#pygerber.gerberx3.tokenizer.tokens.macro.expressions.numeric_constant.NumericConstant","title":"NumericConstant","text":"<p>             Bases: <code>MacroExpressionToken</code></p> <p>Wrapper around numeric constant expression token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/expressions/numeric_constant.py</code> <pre><code>class NumericConstant(MacroExpressionToken):\n    \"\"\"Wrapper around numeric constant expression token.\"\"\"\n\n    def __init__(\n        self,\n        string: str,\n        location: int,\n        value: Decimal,\n    ) -&gt; None:\n        super().__init__(string, location)\n        self.value = value\n\n    @classmethod\n    def new(cls, string: str, location: int, tokens: ParseResults) -&gt; Self:\n        \"\"\"Create instance of this class.\n\n        Created to be used as callback in `ParserElement.set_parse_action()`.\n        \"\"\"\n        value = Decimal(str(tokens[\"numeric_constant_value\"]))\n\n        return cls(\n            string=string,\n            location=location,\n            value=value,\n        )\n\n    def to_parser2_expression(self, context: Parser2Context) -&gt; Expression2:\n        \"\"\"Convert to `Expression2` descendant class.\"\"\"\n        return context.macro_expressions.constant(\n            value=self.value,\n        )\n\n    def evaluate_numeric(self, _macro_context: MacroContext, state: State) -&gt; Offset:\n        \"\"\"Evaluate numeric value of this macro expression.\"\"\"\n        return Offset.new(value=self.value, unit=state.get_units())\n\n    def get_gerber_code(\n        self,\n        indent: str = \"\",  # noqa: ARG002\n        endline: str = \"\\n\",  # noqa: ARG002\n    ) -&gt; str:\n        \"\"\"Get gerber code from iterable of tokens.\"\"\"\n        return f\"{self.value}\"\n\n    def __str__(self) -&gt; str:\n        return f\"{super().__str__()}::[{self.value}]\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/expressions/numeric_constant.html#pygerber.gerberx3.tokenizer.tokens.macro.expressions.numeric_constant.NumericConstant.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(\n    string: str, location: int, tokens: ParseResults\n) -&gt; Self\n</code></pre> <p>Create instance of this class.</p> <p>Created to be used as callback in <code>ParserElement.set_parse_action()</code>.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/expressions/numeric_constant.py</code> <pre><code>@classmethod\ndef new(cls, string: str, location: int, tokens: ParseResults) -&gt; Self:\n    \"\"\"Create instance of this class.\n\n    Created to be used as callback in `ParserElement.set_parse_action()`.\n    \"\"\"\n    value = Decimal(str(tokens[\"numeric_constant_value\"]))\n\n    return cls(\n        string=string,\n        location=location,\n        value=value,\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/expressions/numeric_constant.html#pygerber.gerberx3.tokenizer.tokens.macro.expressions.numeric_constant.NumericConstant.to_parser2_expression","title":"to_parser2_expression","text":"<pre><code>to_parser2_expression(\n    context: Parser2Context,\n) -&gt; Expression2\n</code></pre> <p>Convert to <code>Expression2</code> descendant class.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/expressions/numeric_constant.py</code> <pre><code>def to_parser2_expression(self, context: Parser2Context) -&gt; Expression2:\n    \"\"\"Convert to `Expression2` descendant class.\"\"\"\n    return context.macro_expressions.constant(\n        value=self.value,\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/expressions/numeric_constant.html#pygerber.gerberx3.tokenizer.tokens.macro.expressions.numeric_constant.NumericConstant.evaluate_numeric","title":"evaluate_numeric","text":"<pre><code>evaluate_numeric(\n    _macro_context: MacroContext, state: State\n) -&gt; Offset\n</code></pre> <p>Evaluate numeric value of this macro expression.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/expressions/numeric_constant.py</code> <pre><code>def evaluate_numeric(self, _macro_context: MacroContext, state: State) -&gt; Offset:\n    \"\"\"Evaluate numeric value of this macro expression.\"\"\"\n    return Offset.new(value=self.value, unit=state.get_units())\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/expressions/numeric_constant.html#pygerber.gerberx3.tokenizer.tokens.macro.expressions.numeric_constant.NumericConstant.get_gerber_code","title":"get_gerber_code","text":"<pre><code>get_gerber_code(\n    indent: str = \"\", endline: str = \"\\n\"\n) -&gt; str\n</code></pre> <p>Get gerber code from iterable of tokens.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/expressions/numeric_constant.py</code> <pre><code>def get_gerber_code(\n    self,\n    indent: str = \"\",  # noqa: ARG002\n    endline: str = \"\\n\",  # noqa: ARG002\n) -&gt; str:\n    \"\"\"Get gerber code from iterable of tokens.\"\"\"\n    return f\"{self.value}\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/expressions/unary.html","title":"unary","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/expressions/unary.html#pygerber.gerberx3.tokenizer.tokens.macro.expressions.unary","title":"unary","text":"<p>Arithmetic expression token.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/expressions/unary.html#pygerber.gerberx3.tokenizer.tokens.macro.expressions.unary.UnaryOperator","title":"UnaryOperator","text":"<p>             Bases: <code>MacroExpressionToken</code></p> <p>Operator with one operand.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/expressions/unary.py</code> <pre><code>class UnaryOperator(MacroExpressionToken):\n    \"\"\"Operator with one operand.\"\"\"\n\n    def __init__(\n        self,\n        string: str,\n        location: int,\n        operand: MacroExpressionToken,\n    ) -&gt; None:\n        super().__init__(string, location)\n        self.operand = operand\n        self.operator: Callable[[Any], Any] = neg\n        self.sign = \"-\"\n\n    @classmethod\n    def new(\n        cls,\n        string: str,\n        location: int,\n        tokens: ParseResults,\n    ) -&gt; Self:\n        \"\"\"Create instance of this class.\n\n        Created to be used as callback in `ParserElement.set_parse_action()`.\n        \"\"\"\n        operand, *_ = tokens.as_list()[0]\n\n        if not isinstance(operand, MacroExpressionToken):\n            raise TypeError(operand)\n\n        return cls(string, location, operand)\n\n    def to_parser2_expression(self, context: Parser2Context) -&gt; Expression2:\n        \"\"\"Convert to `Expression2` descendant class.\"\"\"\n        raise NotImplementedError\n\n    def evaluate_numeric(self, macro_context: MacroContext, state: State) -&gt; Offset:\n        \"\"\"Evaluate numeric value of this macro expression.\"\"\"\n        operand = self.operand.evaluate_numeric(macro_context, state)\n        output = self.operator(operand)\n\n        if not isinstance(output, Offset):\n            raise InvalidArithmeticExpressionError\n\n        return output\n\n    def get_gerber_code(\n        self,\n        indent: str = \"\",\n        endline: str = \"\\n\",\n    ) -&gt; str:\n        \"\"\"Get gerber code from iterable of tokens.\"\"\"\n        return (\n            f\"{self.sign}{self.operand.get_gerber_code(indent=indent, endline=endline)}\"\n        )\n\n    def __str__(self) -&gt; str:\n        return f\"{super().__str__()}::[{self.operand}]\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/expressions/unary.html#pygerber.gerberx3.tokenizer.tokens.macro.expressions.unary.UnaryOperator.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(\n    string: str, location: int, tokens: ParseResults\n) -&gt; Self\n</code></pre> <p>Create instance of this class.</p> <p>Created to be used as callback in <code>ParserElement.set_parse_action()</code>.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/expressions/unary.py</code> <pre><code>@classmethod\ndef new(\n    cls,\n    string: str,\n    location: int,\n    tokens: ParseResults,\n) -&gt; Self:\n    \"\"\"Create instance of this class.\n\n    Created to be used as callback in `ParserElement.set_parse_action()`.\n    \"\"\"\n    operand, *_ = tokens.as_list()[0]\n\n    if not isinstance(operand, MacroExpressionToken):\n        raise TypeError(operand)\n\n    return cls(string, location, operand)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/expressions/unary.html#pygerber.gerberx3.tokenizer.tokens.macro.expressions.unary.UnaryOperator.to_parser2_expression","title":"to_parser2_expression","text":"<pre><code>to_parser2_expression(\n    context: Parser2Context,\n) -&gt; Expression2\n</code></pre> <p>Convert to <code>Expression2</code> descendant class.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/expressions/unary.py</code> <pre><code>def to_parser2_expression(self, context: Parser2Context) -&gt; Expression2:\n    \"\"\"Convert to `Expression2` descendant class.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/expressions/unary.html#pygerber.gerberx3.tokenizer.tokens.macro.expressions.unary.UnaryOperator.evaluate_numeric","title":"evaluate_numeric","text":"<pre><code>evaluate_numeric(\n    macro_context: MacroContext, state: State\n) -&gt; Offset\n</code></pre> <p>Evaluate numeric value of this macro expression.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/expressions/unary.py</code> <pre><code>def evaluate_numeric(self, macro_context: MacroContext, state: State) -&gt; Offset:\n    \"\"\"Evaluate numeric value of this macro expression.\"\"\"\n    operand = self.operand.evaluate_numeric(macro_context, state)\n    output = self.operator(operand)\n\n    if not isinstance(output, Offset):\n        raise InvalidArithmeticExpressionError\n\n    return output\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/expressions/unary.html#pygerber.gerberx3.tokenizer.tokens.macro.expressions.unary.UnaryOperator.get_gerber_code","title":"get_gerber_code","text":"<pre><code>get_gerber_code(\n    indent: str = \"\", endline: str = \"\\n\"\n) -&gt; str\n</code></pre> <p>Get gerber code from iterable of tokens.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/expressions/unary.py</code> <pre><code>def get_gerber_code(\n    self,\n    indent: str = \"\",\n    endline: str = \"\\n\",\n) -&gt; str:\n    \"\"\"Get gerber code from iterable of tokens.\"\"\"\n    return (\n        f\"{self.sign}{self.operand.get_gerber_code(indent=indent, endline=endline)}\"\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/expressions/unary.html#pygerber.gerberx3.tokenizer.tokens.macro.expressions.unary.NegationOperator","title":"NegationOperator","text":"<p>             Bases: <code>UnaryOperator</code></p> <p>Negation operation.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/expressions/unary.py</code> <pre><code>class NegationOperator(UnaryOperator):\n    \"\"\"Negation operation.\"\"\"\n\n    def __init__(\n        self,\n        string: str,\n        location: int,\n        operand: MacroExpressionToken,\n    ) -&gt; None:\n        super().__init__(string, location, operand)\n        self.operator = neg\n        self.sign = \"-\"\n\n    def to_parser2_expression(self, context: Parser2Context) -&gt; Expression2:\n        \"\"\"Convert to `UnaryMinusExpression2`.\"\"\"\n        return context.macro_expressions.negation(\n            op=self.operand.to_parser2_expression(context),\n        )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/expressions/unary.html#pygerber.gerberx3.tokenizer.tokens.macro.expressions.unary.NegationOperator.to_parser2_expression","title":"to_parser2_expression","text":"<pre><code>to_parser2_expression(\n    context: Parser2Context,\n) -&gt; Expression2\n</code></pre> <p>Convert to <code>UnaryMinusExpression2</code>.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/expressions/unary.py</code> <pre><code>def to_parser2_expression(self, context: Parser2Context) -&gt; Expression2:\n    \"\"\"Convert to `UnaryMinusExpression2`.\"\"\"\n    return context.macro_expressions.negation(\n        op=self.operand.to_parser2_expression(context),\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/expressions/unary.html#pygerber.gerberx3.tokenizer.tokens.macro.expressions.unary.PositiveOperator","title":"PositiveOperator","text":"<p>             Bases: <code>UnaryOperator</code></p> <p>Negation operation.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/expressions/unary.py</code> <pre><code>class PositiveOperator(UnaryOperator):\n    \"\"\"Negation operation.\"\"\"\n\n    def __init__(\n        self,\n        string: str,\n        location: int,\n        operand: MacroExpressionToken,\n    ) -&gt; None:\n        super().__init__(string, location, operand)\n        self.operator = pos\n        self.sign = \"+\"\n\n    def to_parser2_expression(self, context: Parser2Context) -&gt; Expression2:\n        \"\"\"Convert to `UnaryPlusExpression2`.\"\"\"\n        return context.macro_expressions.positive(\n            op=self.operand.to_parser2_expression(context),\n        )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/expressions/unary.html#pygerber.gerberx3.tokenizer.tokens.macro.expressions.unary.PositiveOperator.to_parser2_expression","title":"to_parser2_expression","text":"<pre><code>to_parser2_expression(\n    context: Parser2Context,\n) -&gt; Expression2\n</code></pre> <p>Convert to <code>UnaryPlusExpression2</code>.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/expressions/unary.py</code> <pre><code>def to_parser2_expression(self, context: Parser2Context) -&gt; Expression2:\n    \"\"\"Convert to `UnaryPlusExpression2`.\"\"\"\n    return context.macro_expressions.positive(\n        op=self.operand.to_parser2_expression(context),\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/expressions/variable_name.html","title":"variable_name","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/expressions/variable_name.html#pygerber.gerberx3.tokenizer.tokens.macro.expressions.variable_name","title":"variable_name","text":"<p>Macro variable use token.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/expressions/variable_name.html#pygerber.gerberx3.tokenizer.tokens.macro.expressions.variable_name.MacroVariableName","title":"MacroVariableName","text":"<p>             Bases: <code>MacroExpressionToken</code></p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/expressions/variable_name.html#pygerber.gerberx3.tokenizer.tokens.macro.expressions.variable_name.MacroVariableName--4541-variable-values-from-the-ad-command","title":"4.5.4.1 Variable Values from the AD Command.","text":"<p>description</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/expressions/variable_name.html#pygerber.gerberx3.tokenizer.tokens.macro.expressions.variable_name.MacroVariableName--example","title":"Example","text":"<p><pre><code>%AMDONUTVAR*1,1,$1,$2,$3*1,0,$4,$2,$3*%\n</code></pre> <code>$1</code>, <code>$2</code>, <code>$3</code> and <code>$4</code> are macro variables. With the following calling AD.</p> <pre><code>%ADD34DONUTVAR,0.100X0X0X0.080*%\n</code></pre> <p>the variables take the following values:</p> <pre><code>$1 = 0.100\n$2 = 0\n$3 = 0\n$4 = 0.080\n</code></pre> <p>See section 4.5.4.1 of The Gerber Layer Format Specification</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/expressions/variable_name.py</code> <pre><code>class MacroVariableName(MacroExpressionToken):\n    \"\"\"## 4.5.4.1 Variable Values from the AD Command.\n\n    description\n\n    ---\n\n    ## Example\n\n    ```gerber\n    %AMDONUTVAR*1,1,$1,$2,$3*1,0,$4,$2,$3*%\n    ```\n    `$1`, `$2`, `$3` and `$4` are macro variables. With the following calling AD.\n\n    ```gerber\n    %ADD34DONUTVAR,0.100X0X0X0.080*%\n    ```\n\n    the variables take the following values:\n\n    ```yaml\n    $1 = 0.100\n    $2 = 0\n    $3 = 0\n    $4 = 0.080\n    ```\n\n    ---\n\n    See section 4.5.4.1 of [The Gerber Layer Format Specification](https://www.ucamco.com/files/downloads/file_en/456/gerber-layer-format-specification-revision-2023-08_en.pdf#page=70)\n\n    \"\"\"\n\n    def __init__(self, string: str, location: int, name: str) -&gt; None:\n        super().__init__(string, location)\n        self.name = name\n\n    @classmethod\n    def new(cls, string: str, location: int, tokens: ParseResults) -&gt; Self:\n        \"\"\"Create instance of this class.\n\n        Created to be used as callback in `ParserElement.set_parse_action()`.\n        \"\"\"\n        name = str(tokens[\"macro_variable_name\"])\n        return cls(string=string, location=location, name=name)\n\n    def to_parser2_expression(self, context: Parser2Context) -&gt; Expression2:\n        \"\"\"Convert to `Expression2` descendant class.\"\"\"\n        return context.macro_expressions.variable_name(name=self.name)\n\n    def evaluate_numeric(self, macro_context: MacroContext, _state: State) -&gt; Offset:\n        \"\"\"Evaluate numeric value of this macro expression.\"\"\"\n        return macro_context.variables[self.name]\n\n    def get_gerber_code(\n        self,\n        indent: str = \"\",  # noqa: ARG002\n        endline: str = \"\\n\",  # noqa: ARG002\n    ) -&gt; str:\n        \"\"\"Get gerber code represented by this token.\"\"\"\n        return self.name\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/expressions/variable_name.html#pygerber.gerberx3.tokenizer.tokens.macro.expressions.variable_name.MacroVariableName.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(\n    string: str, location: int, tokens: ParseResults\n) -&gt; Self\n</code></pre> <p>Create instance of this class.</p> <p>Created to be used as callback in <code>ParserElement.set_parse_action()</code>.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/expressions/variable_name.py</code> <pre><code>@classmethod\ndef new(cls, string: str, location: int, tokens: ParseResults) -&gt; Self:\n    \"\"\"Create instance of this class.\n\n    Created to be used as callback in `ParserElement.set_parse_action()`.\n    \"\"\"\n    name = str(tokens[\"macro_variable_name\"])\n    return cls(string=string, location=location, name=name)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/expressions/variable_name.html#pygerber.gerberx3.tokenizer.tokens.macro.expressions.variable_name.MacroVariableName.to_parser2_expression","title":"to_parser2_expression","text":"<pre><code>to_parser2_expression(\n    context: Parser2Context,\n) -&gt; Expression2\n</code></pre> <p>Convert to <code>Expression2</code> descendant class.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/expressions/variable_name.py</code> <pre><code>def to_parser2_expression(self, context: Parser2Context) -&gt; Expression2:\n    \"\"\"Convert to `Expression2` descendant class.\"\"\"\n    return context.macro_expressions.variable_name(name=self.name)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/expressions/variable_name.html#pygerber.gerberx3.tokenizer.tokens.macro.expressions.variable_name.MacroVariableName.evaluate_numeric","title":"evaluate_numeric","text":"<pre><code>evaluate_numeric(\n    macro_context: MacroContext, _state: State\n) -&gt; Offset\n</code></pre> <p>Evaluate numeric value of this macro expression.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/expressions/variable_name.py</code> <pre><code>def evaluate_numeric(self, macro_context: MacroContext, _state: State) -&gt; Offset:\n    \"\"\"Evaluate numeric value of this macro expression.\"\"\"\n    return macro_context.variables[self.name]\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/expressions/variable_name.html#pygerber.gerberx3.tokenizer.tokens.macro.expressions.variable_name.MacroVariableName.get_gerber_code","title":"get_gerber_code","text":"<pre><code>get_gerber_code(\n    indent: str = \"\", endline: str = \"\\n\"\n) -&gt; str\n</code></pre> <p>Get gerber code represented by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/expressions/variable_name.py</code> <pre><code>def get_gerber_code(\n    self,\n    indent: str = \"\",  # noqa: ARG002\n    endline: str = \"\\n\",  # noqa: ARG002\n) -&gt; str:\n    \"\"\"Get gerber code represented by this token.\"\"\"\n    return self.name\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/statements/__init__.html","title":"init","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/statements/__init__.html#pygerber.gerberx3.tokenizer.tokens.macro.statements","title":"statements","text":"<p><code>statements</code> package contains macro statement tokens.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_1_circle.html","title":"code_1_circle","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_1_circle.html#pygerber.gerberx3.tokenizer.tokens.macro.statements.code_1_circle","title":"code_1_circle","text":"<p>Macro primitives tokens.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_1_circle.html#pygerber.gerberx3.tokenizer.tokens.macro.statements.code_1_circle.Code1CircleToken","title":"Code1CircleToken","text":"<p>             Bases: <code>MacroPrimitiveToken</code></p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_1_circle.html#pygerber.gerberx3.tokenizer.tokens.macro.statements.code_1_circle.Code1CircleToken--4513-circle-code-1","title":"4.5.1.3 Circle, Code 1.","text":"<p>A circle primitive is defined by its center point and diameter.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_1_circle.html#pygerber.gerberx3.tokenizer.tokens.macro.statements.code_1_circle.Code1CircleToken--example","title":"Example","text":"<pre><code>%AMCircle*\n1,1,1.5,0,0,0*%\n</code></pre> <p>See section 4.5.1.3 of The Gerber Layer Format Specification</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_1_circle.py</code> <pre><code>class Code1CircleToken(MacroPrimitiveToken):\n    \"\"\"## 4.5.1.3 Circle, Code 1.\n\n    A circle primitive is defined by its center point and diameter.\n\n    ---\n\n    ## Example\n\n    ```gerber\n    %AMCircle*\n    1,1,1.5,0,0,0*%\n    ```\n\n    ---\n\n    See section 4.5.1.3 of [The Gerber Layer Format Specification](https://www.ucamco.com/files/downloads/file_en/456/gerber-layer-format-specification-revision-2023-08_en.pdf#page=60)\n\n    \"\"\"\n\n    symbol: ClassVar[str] = \"1\"\n\n    def __init__(\n        self,\n        string: str,\n        location: int,\n        exposure: MacroExpressionToken,\n        diameter: MacroExpressionToken,\n        center_x: MacroExpressionToken,\n        center_y: MacroExpressionToken,\n        rotation: MacroExpressionToken,\n    ) -&gt; None:\n        super().__init__(string, location)\n        self.exposure = exposure\n        self.diameter = diameter\n        self.center_x = center_x\n        self.center_y = center_y\n        self.rotation = rotation\n\n    @classmethod\n    def new(cls, string: str, location: int, tokens: ParseResults) -&gt; Self:\n        \"\"\"Create instance of this class.\n\n        Created to be used as callback in `ParserElement.set_parse_action()`.\n        \"\"\"\n        exposure = MacroExpressionToken.ensure_type(tokens[\"exposure\"])\n        diameter = MacroExpressionToken.ensure_type(tokens[\"diameter\"])\n        center_x = MacroExpressionToken.ensure_type(tokens[\"center_x\"])\n        center_y = MacroExpressionToken.ensure_type(tokens[\"center_y\"])\n\n        r = tokens.get(\"rotation\")\n        rotation: Optional[MacroExpressionToken] = (\n            MacroExpressionToken.ensure_type(r) if r is not None else None\n        )\n        if rotation is None:\n            rotation = NumericConstant(string, location, value=Decimal(\"0.0\"))\n\n        return cls(\n            string=string,\n            location=location,\n            exposure=exposure,\n            diameter=diameter,\n            center_x=center_x,\n            center_y=center_y,\n            rotation=rotation,\n        )\n\n    def evaluate(\n        self,\n        macro_context: MacroContext,\n        state: State,\n        handle: PrivateApertureHandle,\n    ) -&gt; None:\n        \"\"\"Evaluate macro expression.\"\"\"\n        self.exposure.evaluate_numeric(macro_context, state)\n        self.diameter.evaluate_numeric(macro_context, state)\n        self.center_x.evaluate_numeric(macro_context, state)\n        self.center_y.evaluate_numeric(macro_context, state)\n        self.rotation.evaluate_numeric(macro_context, state)\n\n        return super().evaluate(macro_context, state, handle)\n\n    def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n        \"\"\"Perform actions on the context implicated by this token.\"\"\"\n        context.get_hooks().macro_code_1_circle.pre_parser_visit_token(\n            self,\n            context,\n        )\n        context.get_hooks().macro_code_1_circle.on_parser_visit_token(\n            self,\n            context,\n        )\n        context.get_hooks().macro_code_1_circle.post_parser_visit_token(\n            self,\n            context,\n        )\n\n    def get_gerber_code(\n        self,\n        indent: str = \"\",\n        endline: str = \"\\n\",\n    ) -&gt; str:\n        \"\"\"Get gerber code represented by this token.\"\"\"\n        string = self.symbol\n\n        string += f\",{self.exposure.get_gerber_code(indent, endline)}\"\n        string += f\",{self.diameter.get_gerber_code(indent, endline)}\"\n        string += f\",{self.center_x.get_gerber_code(indent, endline)}\"\n        string += f\",{self.center_y.get_gerber_code(indent, endline)}\"\n\n        if self.rotation is not None:\n            string += f\",{self.rotation.get_gerber_code(indent, endline)}\"\n\n        return indent + string\n\n    def __str__(self) -&gt; str:\n        string = super().__str__()\n\n        string += f\"\\n  {self.exposure}\"\n        string += f\"\\n  {self.diameter}\"\n        string += f\"\\n  {self.center_x}\"\n        string += f\"\\n  {self.center_y}\"\n\n        if self.rotation is not None:\n            string += f\"\\n  {self.rotation}\"\n\n        return string\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_1_circle.html#pygerber.gerberx3.tokenizer.tokens.macro.statements.code_1_circle.Code1CircleToken.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(\n    string: str, location: int, tokens: ParseResults\n) -&gt; Self\n</code></pre> <p>Create instance of this class.</p> <p>Created to be used as callback in <code>ParserElement.set_parse_action()</code>.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_1_circle.py</code> <pre><code>@classmethod\ndef new(cls, string: str, location: int, tokens: ParseResults) -&gt; Self:\n    \"\"\"Create instance of this class.\n\n    Created to be used as callback in `ParserElement.set_parse_action()`.\n    \"\"\"\n    exposure = MacroExpressionToken.ensure_type(tokens[\"exposure\"])\n    diameter = MacroExpressionToken.ensure_type(tokens[\"diameter\"])\n    center_x = MacroExpressionToken.ensure_type(tokens[\"center_x\"])\n    center_y = MacroExpressionToken.ensure_type(tokens[\"center_y\"])\n\n    r = tokens.get(\"rotation\")\n    rotation: Optional[MacroExpressionToken] = (\n        MacroExpressionToken.ensure_type(r) if r is not None else None\n    )\n    if rotation is None:\n        rotation = NumericConstant(string, location, value=Decimal(\"0.0\"))\n\n    return cls(\n        string=string,\n        location=location,\n        exposure=exposure,\n        diameter=diameter,\n        center_x=center_x,\n        center_y=center_y,\n        rotation=rotation,\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_1_circle.html#pygerber.gerberx3.tokenizer.tokens.macro.statements.code_1_circle.Code1CircleToken.evaluate","title":"evaluate","text":"<pre><code>evaluate(\n    macro_context: MacroContext,\n    state: State,\n    handle: PrivateApertureHandle,\n) -&gt; None\n</code></pre> <p>Evaluate macro expression.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_1_circle.py</code> <pre><code>def evaluate(\n    self,\n    macro_context: MacroContext,\n    state: State,\n    handle: PrivateApertureHandle,\n) -&gt; None:\n    \"\"\"Evaluate macro expression.\"\"\"\n    self.exposure.evaluate_numeric(macro_context, state)\n    self.diameter.evaluate_numeric(macro_context, state)\n    self.center_x.evaluate_numeric(macro_context, state)\n    self.center_y.evaluate_numeric(macro_context, state)\n    self.rotation.evaluate_numeric(macro_context, state)\n\n    return super().evaluate(macro_context, state, handle)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_1_circle.html#pygerber.gerberx3.tokenizer.tokens.macro.statements.code_1_circle.Code1CircleToken.parser2_visit_token","title":"parser2_visit_token","text":"<pre><code>parser2_visit_token(context: Parser2Context) -&gt; None\n</code></pre> <p>Perform actions on the context implicated by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_1_circle.py</code> <pre><code>def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n    \"\"\"Perform actions on the context implicated by this token.\"\"\"\n    context.get_hooks().macro_code_1_circle.pre_parser_visit_token(\n        self,\n        context,\n    )\n    context.get_hooks().macro_code_1_circle.on_parser_visit_token(\n        self,\n        context,\n    )\n    context.get_hooks().macro_code_1_circle.post_parser_visit_token(\n        self,\n        context,\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_1_circle.html#pygerber.gerberx3.tokenizer.tokens.macro.statements.code_1_circle.Code1CircleToken.get_gerber_code","title":"get_gerber_code","text":"<pre><code>get_gerber_code(\n    indent: str = \"\", endline: str = \"\\n\"\n) -&gt; str\n</code></pre> <p>Get gerber code represented by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_1_circle.py</code> <pre><code>def get_gerber_code(\n    self,\n    indent: str = \"\",\n    endline: str = \"\\n\",\n) -&gt; str:\n    \"\"\"Get gerber code represented by this token.\"\"\"\n    string = self.symbol\n\n    string += f\",{self.exposure.get_gerber_code(indent, endline)}\"\n    string += f\",{self.diameter.get_gerber_code(indent, endline)}\"\n    string += f\",{self.center_x.get_gerber_code(indent, endline)}\"\n    string += f\",{self.center_y.get_gerber_code(indent, endline)}\"\n\n    if self.rotation is not None:\n        string += f\",{self.rotation.get_gerber_code(indent, endline)}\"\n\n    return indent + string\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_20_vector_line.html","title":"code_20_vector_line","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_20_vector_line.html#pygerber.gerberx3.tokenizer.tokens.macro.statements.code_20_vector_line","title":"code_20_vector_line","text":"<p>Macro primitive vector line.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_20_vector_line.html#pygerber.gerberx3.tokenizer.tokens.macro.statements.code_20_vector_line.Code20VectorLineToken","title":"Code20VectorLineToken","text":"<p>             Bases: <code>MacroPrimitiveToken</code></p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_20_vector_line.html#pygerber.gerberx3.tokenizer.tokens.macro.statements.code_20_vector_line.Code20VectorLineToken--4514-vector-line-code-20","title":"4.5.1.4 Vector Line, Code 20.","text":"<p>A vector line is a rectangle defined by its line width, start and end points. The line ends are rectangular.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_20_vector_line.html#pygerber.gerberx3.tokenizer.tokens.macro.statements.code_20_vector_line.Code20VectorLineToken--example","title":"Example","text":"<pre><code>%AMLine*\n20,1,0.9,0,0.45,12,0.45,0*\n%\n</code></pre> <p>See section 4.5.1.4 of The Gerber Layer Format Specification</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_20_vector_line.py</code> <pre><code>class Code20VectorLineToken(MacroPrimitiveToken):\n    \"\"\"## 4.5.1.4 Vector Line, Code 20.\n\n    A vector line is a rectangle defined by its line width, start and end points. The\n    line ends are rectangular.\n\n    ---\n\n    ## Example\n\n    ```gerber\n    %AMLine*\n    20,1,0.9,0,0.45,12,0.45,0*\n    %\n    ```\n\n    ---\n\n    See section 4.5.1.4 of [The Gerber Layer Format Specification](https://www.ucamco.com/files/downloads/file_en/456/gerber-layer-format-specification-revision-2023-08_en.pdf#page=61)\n\n    \"\"\"\n\n    symbol: ClassVar[str] = \"20\"\n\n    def __init__(  # noqa: PLR0913\n        self,\n        string: str,\n        location: int,\n        exposure: MacroExpressionToken,\n        width: MacroExpressionToken,\n        start_x: MacroExpressionToken,\n        start_y: MacroExpressionToken,\n        end_x: MacroExpressionToken,\n        end_y: MacroExpressionToken,\n        rotation: MacroExpressionToken,\n    ) -&gt; None:\n        super().__init__(string, location)\n        self.exposure = exposure\n        self.width = width\n        self.start_x = start_x\n        self.start_y = start_y\n        self.end_x = end_x\n        self.end_y = end_y\n        self.rotation = rotation\n\n    @classmethod\n    def new(cls, string: str, location: int, tokens: ParseResults) -&gt; Self:\n        \"\"\"Create instance of this class.\n\n        Created to be used as callback in `ParserElement.set_parse_action()`.\n        \"\"\"\n        exposure = MacroExpressionToken.ensure_type(tokens[\"exposure\"])\n        width = MacroExpressionToken.ensure_type(tokens[\"width\"])\n        start_x = MacroExpressionToken.ensure_type(tokens[\"start_x\"])\n        start_y = MacroExpressionToken.ensure_type(tokens[\"start_y\"])\n        end_x = MacroExpressionToken.ensure_type(tokens[\"end_x\"])\n        end_y = MacroExpressionToken.ensure_type(tokens[\"end_y\"])\n        rotation = MacroExpressionToken.ensure_type(tokens[\"rotation\"])\n\n        return cls(\n            string=string,\n            location=location,\n            exposure=exposure,\n            width=width,\n            start_x=start_x,\n            start_y=start_y,\n            end_x=end_x,\n            end_y=end_y,\n            rotation=rotation,\n        )\n\n    def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n        \"\"\"Perform actions on the context implicated by this token.\"\"\"\n        context.get_hooks().macro_code_20_vector_line.pre_parser_visit_token(\n            self,\n            context,\n        )\n        context.get_hooks().macro_code_20_vector_line.on_parser_visit_token(\n            self,\n            context,\n        )\n        context.get_hooks().macro_code_20_vector_line.post_parser_visit_token(\n            self,\n            context,\n        )\n\n    def get_gerber_code(\n        self,\n        indent: str = \"\",\n        endline: str = \"\\n\",\n    ) -&gt; str:\n        \"\"\"Get gerber code represented by this token.\"\"\"\n        string = self.symbol\n\n        string += f\",{self.exposure.get_gerber_code(indent, endline)}\"\n        string += f\",{self.width.get_gerber_code(indent, endline)}\"\n        string += f\",{self.start_x.get_gerber_code(indent, endline)}\"\n        string += f\",{self.start_y.get_gerber_code(indent, endline)}\"\n        string += f\",{self.end_x.get_gerber_code(indent, endline)}\"\n        string += f\",{self.end_y.get_gerber_code(indent, endline)}\"\n        string += f\",{self.rotation.get_gerber_code(indent, endline)}\"\n\n        return indent + string\n\n    def __str__(self) -&gt; str:\n        string = super().__str__()\n\n        string += f\"\\n  {self.exposure}\"\n        string += f\"\\n  {self.width}\"\n        string += f\"\\n  {self.start_x}\"\n        string += f\"\\n  {self.start_y}\"\n        string += f\"\\n  {self.end_x}\"\n        string += f\"\\n  {self.end_y}\"\n        string += f\"\\n  {self.rotation}\"\n\n        return string\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_20_vector_line.html#pygerber.gerberx3.tokenizer.tokens.macro.statements.code_20_vector_line.Code20VectorLineToken.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(\n    string: str, location: int, tokens: ParseResults\n) -&gt; Self\n</code></pre> <p>Create instance of this class.</p> <p>Created to be used as callback in <code>ParserElement.set_parse_action()</code>.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_20_vector_line.py</code> <pre><code>@classmethod\ndef new(cls, string: str, location: int, tokens: ParseResults) -&gt; Self:\n    \"\"\"Create instance of this class.\n\n    Created to be used as callback in `ParserElement.set_parse_action()`.\n    \"\"\"\n    exposure = MacroExpressionToken.ensure_type(tokens[\"exposure\"])\n    width = MacroExpressionToken.ensure_type(tokens[\"width\"])\n    start_x = MacroExpressionToken.ensure_type(tokens[\"start_x\"])\n    start_y = MacroExpressionToken.ensure_type(tokens[\"start_y\"])\n    end_x = MacroExpressionToken.ensure_type(tokens[\"end_x\"])\n    end_y = MacroExpressionToken.ensure_type(tokens[\"end_y\"])\n    rotation = MacroExpressionToken.ensure_type(tokens[\"rotation\"])\n\n    return cls(\n        string=string,\n        location=location,\n        exposure=exposure,\n        width=width,\n        start_x=start_x,\n        start_y=start_y,\n        end_x=end_x,\n        end_y=end_y,\n        rotation=rotation,\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_20_vector_line.html#pygerber.gerberx3.tokenizer.tokens.macro.statements.code_20_vector_line.Code20VectorLineToken.parser2_visit_token","title":"parser2_visit_token","text":"<pre><code>parser2_visit_token(context: Parser2Context) -&gt; None\n</code></pre> <p>Perform actions on the context implicated by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_20_vector_line.py</code> <pre><code>def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n    \"\"\"Perform actions on the context implicated by this token.\"\"\"\n    context.get_hooks().macro_code_20_vector_line.pre_parser_visit_token(\n        self,\n        context,\n    )\n    context.get_hooks().macro_code_20_vector_line.on_parser_visit_token(\n        self,\n        context,\n    )\n    context.get_hooks().macro_code_20_vector_line.post_parser_visit_token(\n        self,\n        context,\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_20_vector_line.html#pygerber.gerberx3.tokenizer.tokens.macro.statements.code_20_vector_line.Code20VectorLineToken.get_gerber_code","title":"get_gerber_code","text":"<pre><code>get_gerber_code(\n    indent: str = \"\", endline: str = \"\\n\"\n) -&gt; str\n</code></pre> <p>Get gerber code represented by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_20_vector_line.py</code> <pre><code>def get_gerber_code(\n    self,\n    indent: str = \"\",\n    endline: str = \"\\n\",\n) -&gt; str:\n    \"\"\"Get gerber code represented by this token.\"\"\"\n    string = self.symbol\n\n    string += f\",{self.exposure.get_gerber_code(indent, endline)}\"\n    string += f\",{self.width.get_gerber_code(indent, endline)}\"\n    string += f\",{self.start_x.get_gerber_code(indent, endline)}\"\n    string += f\",{self.start_y.get_gerber_code(indent, endline)}\"\n    string += f\",{self.end_x.get_gerber_code(indent, endline)}\"\n    string += f\",{self.end_y.get_gerber_code(indent, endline)}\"\n    string += f\",{self.rotation.get_gerber_code(indent, endline)}\"\n\n    return indent + string\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_21_center_line.html","title":"code_21_center_line","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_21_center_line.html#pygerber.gerberx3.tokenizer.tokens.macro.statements.code_21_center_line","title":"code_21_center_line","text":"<p>Macro primitive center line.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_21_center_line.html#pygerber.gerberx3.tokenizer.tokens.macro.statements.code_21_center_line.Code21CenterLineToken","title":"Code21CenterLineToken","text":"<p>             Bases: <code>MacroPrimitiveToken</code></p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_21_center_line.html#pygerber.gerberx3.tokenizer.tokens.macro.statements.code_21_center_line.Code21CenterLineToken--4515-center-line-code-21","title":"4.5.1.5 Center Line, Code 21.","text":"<p>A center line primitive is a rectangle defined by its width, height, and center point.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_21_center_line.html#pygerber.gerberx3.tokenizer.tokens.macro.statements.code_21_center_line.Code21CenterLineToken--example","title":"Example","text":"<pre><code>%AMRECTANGLE*\n21,1,6.8,1.2,3.4,0.6,30*%\n</code></pre> <p>See section 4.5.1.5 of The Gerber Layer Format Specification</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_21_center_line.py</code> <pre><code>class Code21CenterLineToken(MacroPrimitiveToken):\n    \"\"\"## 4.5.1.5 Center Line, Code 21.\n\n    A center line primitive is a rectangle defined by its width, height, and center\n    point.\n\n    ---\n\n    ## Example\n\n    ```gerber\n    %AMRECTANGLE*\n    21,1,6.8,1.2,3.4,0.6,30*%\n    ```\n\n    ---\n\n    See section 4.5.1.5 of [The Gerber Layer Format Specification](https://www.ucamco.com/files/downloads/file_en/456/gerber-layer-format-specification-revision-2023-08_en.pdf#page=62)\n\n    \"\"\"\n\n    symbol: ClassVar[str] = \"21\"\n\n    def __init__(  # noqa: PLR0913\n        self,\n        string: str,\n        location: int,\n        exposure: MacroExpressionToken,\n        width: MacroExpressionToken,\n        height: MacroExpressionToken,\n        center_x: MacroExpressionToken,\n        center_y: MacroExpressionToken,\n        rotation: MacroExpressionToken,\n    ) -&gt; None:\n        super().__init__(string, location)\n        self.exposure = exposure\n        self.width = width\n        self.height = height\n        self.center_x = center_x\n        self.center_y = center_y\n        self.rotation = rotation\n\n    @classmethod\n    def new(cls, string: str, location: int, tokens: ParseResults) -&gt; Self:\n        \"\"\"Create instance of this class.\n\n        Created to be used as callback in `ParserElement.set_parse_action()`.\n        \"\"\"\n        exposure = MacroExpressionToken.ensure_type(tokens[\"exposure\"])\n        width = MacroExpressionToken.ensure_type(tokens[\"width\"])\n        height = MacroExpressionToken.ensure_type(tokens[\"height\"])\n        center_x = MacroExpressionToken.ensure_type(tokens[\"center_x\"])\n        center_y = MacroExpressionToken.ensure_type(tokens[\"center_y\"])\n        rotation = MacroExpressionToken.ensure_type(tokens[\"rotation\"])\n\n        return cls(\n            string=string,\n            location=location,\n            exposure=exposure,\n            width=width,\n            height=height,\n            center_x=center_x,\n            center_y=center_y,\n            rotation=rotation,\n        )\n\n    def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n        \"\"\"Perform actions on the context implicated by this token.\"\"\"\n        context.get_hooks().macro_code_21_center_line.pre_parser_visit_token(\n            self,\n            context,\n        )\n        context.get_hooks().macro_code_21_center_line.on_parser_visit_token(\n            self,\n            context,\n        )\n        context.get_hooks().macro_code_21_center_line.post_parser_visit_token(\n            self,\n            context,\n        )\n\n    def get_gerber_code(\n        self,\n        indent: str = \"\",\n        endline: str = \"\\n\",\n    ) -&gt; str:\n        \"\"\"Get gerber code represented by this token.\"\"\"\n        string = self.symbol\n\n        string += f\",{self.exposure.get_gerber_code(indent, endline)}\"\n        string += f\",{self.width.get_gerber_code(indent, endline)}\"\n        string += f\",{self.height.get_gerber_code(indent, endline)}\"\n        string += f\",{self.center_x.get_gerber_code(indent, endline)}\"\n        string += f\",{self.center_y.get_gerber_code(indent, endline)}\"\n        string += f\",{self.rotation.get_gerber_code(indent, endline)}\"\n\n        return indent + string\n\n    def __str__(self) -&gt; str:\n        string = super().__str__()\n\n        string += f\"\\n  {self.exposure}\"\n        string += f\"\\n  {self.width}\"\n        string += f\"\\n  {self.height}\"\n        string += f\"\\n  {self.center_x}\"\n        string += f\"\\n  {self.center_y}\"\n        string += f\"\\n  {self.rotation}\"\n\n        return string\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_21_center_line.html#pygerber.gerberx3.tokenizer.tokens.macro.statements.code_21_center_line.Code21CenterLineToken.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(\n    string: str, location: int, tokens: ParseResults\n) -&gt; Self\n</code></pre> <p>Create instance of this class.</p> <p>Created to be used as callback in <code>ParserElement.set_parse_action()</code>.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_21_center_line.py</code> <pre><code>@classmethod\ndef new(cls, string: str, location: int, tokens: ParseResults) -&gt; Self:\n    \"\"\"Create instance of this class.\n\n    Created to be used as callback in `ParserElement.set_parse_action()`.\n    \"\"\"\n    exposure = MacroExpressionToken.ensure_type(tokens[\"exposure\"])\n    width = MacroExpressionToken.ensure_type(tokens[\"width\"])\n    height = MacroExpressionToken.ensure_type(tokens[\"height\"])\n    center_x = MacroExpressionToken.ensure_type(tokens[\"center_x\"])\n    center_y = MacroExpressionToken.ensure_type(tokens[\"center_y\"])\n    rotation = MacroExpressionToken.ensure_type(tokens[\"rotation\"])\n\n    return cls(\n        string=string,\n        location=location,\n        exposure=exposure,\n        width=width,\n        height=height,\n        center_x=center_x,\n        center_y=center_y,\n        rotation=rotation,\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_21_center_line.html#pygerber.gerberx3.tokenizer.tokens.macro.statements.code_21_center_line.Code21CenterLineToken.parser2_visit_token","title":"parser2_visit_token","text":"<pre><code>parser2_visit_token(context: Parser2Context) -&gt; None\n</code></pre> <p>Perform actions on the context implicated by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_21_center_line.py</code> <pre><code>def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n    \"\"\"Perform actions on the context implicated by this token.\"\"\"\n    context.get_hooks().macro_code_21_center_line.pre_parser_visit_token(\n        self,\n        context,\n    )\n    context.get_hooks().macro_code_21_center_line.on_parser_visit_token(\n        self,\n        context,\n    )\n    context.get_hooks().macro_code_21_center_line.post_parser_visit_token(\n        self,\n        context,\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_21_center_line.html#pygerber.gerberx3.tokenizer.tokens.macro.statements.code_21_center_line.Code21CenterLineToken.get_gerber_code","title":"get_gerber_code","text":"<pre><code>get_gerber_code(\n    indent: str = \"\", endline: str = \"\\n\"\n) -&gt; str\n</code></pre> <p>Get gerber code represented by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_21_center_line.py</code> <pre><code>def get_gerber_code(\n    self,\n    indent: str = \"\",\n    endline: str = \"\\n\",\n) -&gt; str:\n    \"\"\"Get gerber code represented by this token.\"\"\"\n    string = self.symbol\n\n    string += f\",{self.exposure.get_gerber_code(indent, endline)}\"\n    string += f\",{self.width.get_gerber_code(indent, endline)}\"\n    string += f\",{self.height.get_gerber_code(indent, endline)}\"\n    string += f\",{self.center_x.get_gerber_code(indent, endline)}\"\n    string += f\",{self.center_y.get_gerber_code(indent, endline)}\"\n    string += f\",{self.rotation.get_gerber_code(indent, endline)}\"\n\n    return indent + string\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_22_lower_left_line.html","title":"code_22_lower_left_line","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_22_lower_left_line.html#pygerber.gerberx3.tokenizer.tokens.macro.statements.code_22_lower_left_line","title":"code_22_lower_left_line","text":"<p>Code 22 lower left line macro primitive.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_22_lower_left_line.html#pygerber.gerberx3.tokenizer.tokens.macro.statements.code_22_lower_left_line.Code22LowerLeftLineToken","title":"Code22LowerLeftLineToken","text":"<p>             Bases: <code>MacroPrimitiveToken</code></p> <p>Code 22 lower left line macro primitive.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_22_lower_left_line.py</code> <pre><code>class Code22LowerLeftLineToken(MacroPrimitiveToken):\n    \"\"\"Code 22 lower left line macro primitive.\"\"\"\n\n    def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n        \"\"\"Perform actions on the context implicated by this token.\"\"\"\n        context.get_hooks().macro_code_22_lower_left_line.pre_parser_visit_token(\n            self,\n            context,\n        )\n        context.get_hooks().macro_code_22_lower_left_line.on_parser_visit_token(\n            self,\n            context,\n        )\n        context.get_hooks().macro_code_22_lower_left_line.post_parser_visit_token(\n            self,\n            context,\n        )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_22_lower_left_line.html#pygerber.gerberx3.tokenizer.tokens.macro.statements.code_22_lower_left_line.Code22LowerLeftLineToken.parser2_visit_token","title":"parser2_visit_token","text":"<pre><code>parser2_visit_token(context: Parser2Context) -&gt; None\n</code></pre> <p>Perform actions on the context implicated by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_22_lower_left_line.py</code> <pre><code>def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n    \"\"\"Perform actions on the context implicated by this token.\"\"\"\n    context.get_hooks().macro_code_22_lower_left_line.pre_parser_visit_token(\n        self,\n        context,\n    )\n    context.get_hooks().macro_code_22_lower_left_line.on_parser_visit_token(\n        self,\n        context,\n    )\n    context.get_hooks().macro_code_22_lower_left_line.post_parser_visit_token(\n        self,\n        context,\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_2_vector_line.html","title":"code_2_vector_line","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_2_vector_line.html#pygerber.gerberx3.tokenizer.tokens.macro.statements.code_2_vector_line","title":"code_2_vector_line","text":"<p>Macro primitives tokens.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_2_vector_line.html#pygerber.gerberx3.tokenizer.tokens.macro.statements.code_2_vector_line.Code2VectorLineToken","title":"Code2VectorLineToken","text":"<p>             Bases: <code>MacroPrimitiveToken</code></p> <p>Vector line macro primitive.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_2_vector_line.py</code> <pre><code>class Code2VectorLineToken(MacroPrimitiveToken):\n    \"\"\"Vector line macro primitive.\"\"\"\n\n    def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n        \"\"\"Perform actions on the context implicated by this token.\"\"\"\n        context.get_hooks().macro_code_2_vector_line.pre_parser_visit_token(\n            self,\n            context,\n        )\n        context.get_hooks().macro_code_2_vector_line.on_parser_visit_token(\n            self,\n            context,\n        )\n        context.get_hooks().macro_code_2_vector_line.post_parser_visit_token(\n            self,\n            context,\n        )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_2_vector_line.html#pygerber.gerberx3.tokenizer.tokens.macro.statements.code_2_vector_line.Code2VectorLineToken.parser2_visit_token","title":"parser2_visit_token","text":"<pre><code>parser2_visit_token(context: Parser2Context) -&gt; None\n</code></pre> <p>Perform actions on the context implicated by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_2_vector_line.py</code> <pre><code>def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n    \"\"\"Perform actions on the context implicated by this token.\"\"\"\n    context.get_hooks().macro_code_2_vector_line.pre_parser_visit_token(\n        self,\n        context,\n    )\n    context.get_hooks().macro_code_2_vector_line.on_parser_visit_token(\n        self,\n        context,\n    )\n    context.get_hooks().macro_code_2_vector_line.post_parser_visit_token(\n        self,\n        context,\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_4_outline.html","title":"code_4_outline","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_4_outline.html#pygerber.gerberx3.tokenizer.tokens.macro.statements.code_4_outline","title":"code_4_outline","text":"<p>Macro primitives tokens.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_4_outline.html#pygerber.gerberx3.tokenizer.tokens.macro.statements.code_4_outline.Code4OutlineToken","title":"Code4OutlineToken","text":"<p>             Bases: <code>MacroPrimitiveToken</code></p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_4_outline.html#pygerber.gerberx3.tokenizer.tokens.macro.statements.code_4_outline.Code4OutlineToken--4516-outline-code-4","title":"4.5.1.6 Outline, Code 4.","text":"<p>An outline primitive is an area defined by its outline or contour. The outline is a polygon, consisting of linear segments only, defined by its start vertex and n subsequent vertices. The outline must be closed, i.e. the last vertex must be equal to the start vertex. The outline must comply with all the requirements of a contour according to 4.10.3.</p> <p>The maximum number of vertices is 5000. The purpose of this primitive is to create apertures to flash pads with special shapes. The purpose is not to create copper pours. Use the region statement for copper pours; see 4.10.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_4_outline.html#pygerber.gerberx3.tokenizer.tokens.macro.statements.code_4_outline.Code4OutlineToken--example","title":"Example","text":"<pre><code>%AMTriangle_30*\n4,1,3,\n1,-1,\n1,1,\n2,1,\n1,-1,\n30*\n%\n</code></pre> <p>See section 4.5.1.6 of The Gerber Layer Format Specification</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_4_outline.py</code> <pre><code>class Code4OutlineToken(MacroPrimitiveToken):\n    \"\"\"## 4.5.1.6 Outline, Code 4.\n\n    An outline primitive is an area defined by its outline or contour. The outline is a\n    polygon, consisting of linear segments only, defined by its start vertex and n\n    subsequent vertices. The outline must be closed, i.e. the last vertex must be equal\n    to the start vertex. The outline must comply with all the requirements of a contour\n    according to [4.10.3](https://www.ucamco.com/files/downloads/file_en/456/gerber-layer-format-specification-revision-2023-08_en.pdf#page=91).\n\n    The maximum number of vertices is 5000. The purpose of this primitive is to create\n    apertures to flash pads with special shapes. The purpose is not to create copper\n    pours. Use the region statement for copper pours; see\n    [4.10](https://www.ucamco.com/files/downloads/file_en/456/gerber-layer-format-specification-revision-2023-08_en.pdf#page=90).\n\n    ---\n\n    ## Example\n\n    ```gerber\n    %AMTriangle_30*\n    4,1,3,\n    1,-1,\n    1,1,\n    2,1,\n    1,-1,\n    30*\n    %\n    ```\n\n    ---\n\n    See section 4.5.1.6 of [The Gerber Layer Format Specification](https://www.ucamco.com/files/downloads/file_en/456/gerber-layer-format-specification-revision-2023-08_en.pdf#page=63)\n\n    \"\"\"\n\n    symbol: ClassVar[str] = \"4\"\n\n    def __init__(  # noqa: PLR0913\n        self,\n        string: str,\n        location: int,\n        exposure: MacroExpressionToken,\n        number_of_vertices: MacroExpressionToken,\n        start_x: MacroExpressionToken,\n        start_y: MacroExpressionToken,\n        rotation: MacroExpressionToken,\n        point: List[Point],\n    ) -&gt; None:\n        super().__init__(string, location)\n        self.exposure = exposure\n        self.number_of_vertices = number_of_vertices\n        self.start_x = start_x\n        self.start_y = start_y\n        self.rotation = rotation\n        self.point = point\n\n    @classmethod\n    def new(cls, string: str, location: int, tokens: ParseResults) -&gt; Self:\n        \"\"\"Create instance of this class.\n\n        Created to be used as callback in `ParserElement.set_parse_action()`.\n        \"\"\"\n        exposure = MacroExpressionToken.ensure_type(tokens[\"exposure\"])\n        number_of_vertices = MacroExpressionToken.ensure_type(\n            tokens[\"number_of_vertices\"],\n        )\n        start_x = MacroExpressionToken.ensure_type(tokens[\"start_x\"])\n        start_y = MacroExpressionToken.ensure_type(tokens[\"start_y\"])\n        rotation = MacroExpressionToken.ensure_type(tokens[\"rotation\"])\n\n        p = p if (p := tokens.get(\"point\")) is not None else []\n        point = [Point.ensure_type(e) for e in p]\n\n        return cls(\n            string=string,\n            location=location,\n            exposure=exposure,\n            number_of_vertices=number_of_vertices,\n            start_x=start_x,\n            start_y=start_y,\n            rotation=rotation,\n            point=point,\n        )\n\n    def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n        \"\"\"Perform actions on the context implicated by this token.\"\"\"\n        context.get_hooks().macro_code_4_outline.pre_parser_visit_token(\n            self,\n            context,\n        )\n        context.get_hooks().macro_code_4_outline.on_parser_visit_token(\n            self,\n            context,\n        )\n        context.get_hooks().macro_code_4_outline.post_parser_visit_token(\n            self,\n            context,\n        )\n\n    def get_gerber_code(\n        self,\n        indent: str = \"\",\n        endline: str = \"\\n\",\n    ) -&gt; str:\n        \"\"\"Get gerber code represented by this token.\"\"\"\n        string = self.symbol\n\n        string += f\",{self.exposure.get_gerber_code(indent, endline)}\"\n        string += f\",{self.number_of_vertices.get_gerber_code(indent, endline)}\"\n        string += f\",{self.start_x.get_gerber_code(indent, endline)}\"\n        string += f\",{self.start_y.get_gerber_code(indent, endline)}\"\n\n        for point in self.point:\n            string += f\",{point.get_gerber_code(indent, endline)}\"\n\n        string += f\",{self.rotation.get_gerber_code(indent, endline)}\"\n\n        return indent + string\n\n    def __str__(self) -&gt; str:\n        string = super().__str__()\n\n        string += f\"\\n  {self.exposure}\"\n        string += f\"\\n  {self.number_of_vertices}\"\n        string += f\"\\n  {self.start_x}\"\n        string += f\"\\n  {self.start_y}\"\n\n        for point in self.point:\n            string += f\"\\n    {point}\"\n\n        string += f\"\\n  {self.rotation}\"\n\n        return string\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_4_outline.html#pygerber.gerberx3.tokenizer.tokens.macro.statements.code_4_outline.Code4OutlineToken.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(\n    string: str, location: int, tokens: ParseResults\n) -&gt; Self\n</code></pre> <p>Create instance of this class.</p> <p>Created to be used as callback in <code>ParserElement.set_parse_action()</code>.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_4_outline.py</code> <pre><code>@classmethod\ndef new(cls, string: str, location: int, tokens: ParseResults) -&gt; Self:\n    \"\"\"Create instance of this class.\n\n    Created to be used as callback in `ParserElement.set_parse_action()`.\n    \"\"\"\n    exposure = MacroExpressionToken.ensure_type(tokens[\"exposure\"])\n    number_of_vertices = MacroExpressionToken.ensure_type(\n        tokens[\"number_of_vertices\"],\n    )\n    start_x = MacroExpressionToken.ensure_type(tokens[\"start_x\"])\n    start_y = MacroExpressionToken.ensure_type(tokens[\"start_y\"])\n    rotation = MacroExpressionToken.ensure_type(tokens[\"rotation\"])\n\n    p = p if (p := tokens.get(\"point\")) is not None else []\n    point = [Point.ensure_type(e) for e in p]\n\n    return cls(\n        string=string,\n        location=location,\n        exposure=exposure,\n        number_of_vertices=number_of_vertices,\n        start_x=start_x,\n        start_y=start_y,\n        rotation=rotation,\n        point=point,\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_4_outline.html#pygerber.gerberx3.tokenizer.tokens.macro.statements.code_4_outline.Code4OutlineToken.parser2_visit_token","title":"parser2_visit_token","text":"<pre><code>parser2_visit_token(context: Parser2Context) -&gt; None\n</code></pre> <p>Perform actions on the context implicated by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_4_outline.py</code> <pre><code>def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n    \"\"\"Perform actions on the context implicated by this token.\"\"\"\n    context.get_hooks().macro_code_4_outline.pre_parser_visit_token(\n        self,\n        context,\n    )\n    context.get_hooks().macro_code_4_outline.on_parser_visit_token(\n        self,\n        context,\n    )\n    context.get_hooks().macro_code_4_outline.post_parser_visit_token(\n        self,\n        context,\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_4_outline.html#pygerber.gerberx3.tokenizer.tokens.macro.statements.code_4_outline.Code4OutlineToken.get_gerber_code","title":"get_gerber_code","text":"<pre><code>get_gerber_code(\n    indent: str = \"\", endline: str = \"\\n\"\n) -&gt; str\n</code></pre> <p>Get gerber code represented by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_4_outline.py</code> <pre><code>def get_gerber_code(\n    self,\n    indent: str = \"\",\n    endline: str = \"\\n\",\n) -&gt; str:\n    \"\"\"Get gerber code represented by this token.\"\"\"\n    string = self.symbol\n\n    string += f\",{self.exposure.get_gerber_code(indent, endline)}\"\n    string += f\",{self.number_of_vertices.get_gerber_code(indent, endline)}\"\n    string += f\",{self.start_x.get_gerber_code(indent, endline)}\"\n    string += f\",{self.start_y.get_gerber_code(indent, endline)}\"\n\n    for point in self.point:\n        string += f\",{point.get_gerber_code(indent, endline)}\"\n\n    string += f\",{self.rotation.get_gerber_code(indent, endline)}\"\n\n    return indent + string\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_5_polygon.html","title":"code_5_polygon","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_5_polygon.html#pygerber.gerberx3.tokenizer.tokens.macro.statements.code_5_polygon","title":"code_5_polygon","text":"<p>Macro primitive polygon token.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_5_polygon.html#pygerber.gerberx3.tokenizer.tokens.macro.statements.code_5_polygon.Code5PolygonToken","title":"Code5PolygonToken","text":"<p>             Bases: <code>MacroPrimitiveToken</code></p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_5_polygon.html#pygerber.gerberx3.tokenizer.tokens.macro.statements.code_5_polygon.Code5PolygonToken--4517-polygon-code-5","title":"4.5.1.7 Polygon, Code 5.","text":"<p>A polygon primitive is a regular polygon defined by the number of vertices n, the center point and the diameter of the circumscribed circle.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_5_polygon.html#pygerber.gerberx3.tokenizer.tokens.macro.statements.code_5_polygon.Code5PolygonToken--example","title":"Example","text":"<pre><code>%AMPolygon*\n5,1,8,0,0,8,0*%\n</code></pre> <p>See section 4.5.1.7 of The Gerber Layer Format Specification</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_5_polygon.py</code> <pre><code>class Code5PolygonToken(MacroPrimitiveToken):\n    \"\"\"## 4.5.1.7 Polygon, Code 5.\n\n    A polygon primitive is a regular polygon defined by the number of vertices n, the\n    center point and the diameter of the circumscribed circle.\n\n    ---\n\n    ## Example\n\n    ```gerber\n    %AMPolygon*\n    5,1,8,0,0,8,0*%\n    ```\n\n    ---\n\n    See section 4.5.1.7 of [The Gerber Layer Format Specification](https://www.ucamco.com/files/downloads/file_en/456/gerber-layer-format-specification-revision-2023-08_en.pdf#page=65)\n\n    \"\"\"\n\n    symbol: ClassVar[str] = \"5\"\n\n    def __init__(  # noqa: PLR0913\n        self,\n        string: str,\n        location: int,\n        exposure: MacroExpressionToken,\n        number_of_vertices: MacroExpressionToken,\n        center_x: MacroExpressionToken,\n        center_y: MacroExpressionToken,\n        diameter: MacroExpressionToken,\n        rotation: MacroExpressionToken,\n    ) -&gt; None:\n        super().__init__(string, location)\n        self.exposure = exposure\n        self.number_of_vertices = number_of_vertices\n        self.center_x = center_x\n        self.center_y = center_y\n        self.diameter = diameter\n        self.rotation = rotation\n\n    @classmethod\n    def new(cls, string: str, location: int, tokens: ParseResults) -&gt; Self:\n        \"\"\"Create instance of this class.\n\n        Created to be used as callback in `ParserElement.set_parse_action()`.\n        \"\"\"\n        exposure = MacroExpressionToken.ensure_type(tokens[\"exposure\"])\n        number_of_vertices = MacroExpressionToken.ensure_type(\n            tokens[\"number_of_vertices\"],\n        )\n        center_x = MacroExpressionToken.ensure_type(tokens[\"center_x\"])\n        center_y = MacroExpressionToken.ensure_type(tokens[\"center_y\"])\n        diameter = MacroExpressionToken.ensure_type(tokens[\"diameter\"])\n        rotation = MacroExpressionToken.ensure_type(tokens[\"rotation\"])\n        return cls(\n            string=string,\n            location=location,\n            exposure=exposure,\n            number_of_vertices=number_of_vertices,\n            center_x=center_x,\n            center_y=center_y,\n            diameter=diameter,\n            rotation=rotation,\n        )\n\n    def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n        \"\"\"Perform actions on the context implicated by this token.\"\"\"\n        context.get_hooks().macro_code_5_polygon.pre_parser_visit_token(\n            self,\n            context,\n        )\n        context.get_hooks().macro_code_5_polygon.on_parser_visit_token(\n            self,\n            context,\n        )\n        context.get_hooks().macro_code_5_polygon.post_parser_visit_token(\n            self,\n            context,\n        )\n\n    def get_gerber_code(\n        self,\n        indent: str = \"\",\n        endline: str = \"\\n\",\n    ) -&gt; str:\n        \"\"\"Get gerber code represented by this token.\"\"\"\n        string = self.symbol\n\n        string += f\",{self.exposure.get_gerber_code(indent, endline)}\"\n        string += f\",{self.number_of_vertices.get_gerber_code(indent, endline)}\"\n        string += f\",{self.center_x.get_gerber_code(indent, endline)}\"\n        string += f\",{self.center_y.get_gerber_code(indent, endline)}\"\n        string += f\",{self.diameter.get_gerber_code(indent, endline)}\"\n        string += f\",{self.rotation.get_gerber_code(indent, endline)}\"\n\n        return indent + string\n\n    def __str__(self) -&gt; str:\n        string = super().__str__()\n\n        string += f\"\\n  {self.exposure}\"\n        string += f\"\\n  {self.number_of_vertices}\"\n        string += f\"\\n  {self.center_x}\"\n        string += f\"\\n  {self.center_y}\"\n        string += f\"\\n  {self.diameter}\"\n        string += f\"\\n  {self.rotation}\"\n\n        return string\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_5_polygon.html#pygerber.gerberx3.tokenizer.tokens.macro.statements.code_5_polygon.Code5PolygonToken.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(\n    string: str, location: int, tokens: ParseResults\n) -&gt; Self\n</code></pre> <p>Create instance of this class.</p> <p>Created to be used as callback in <code>ParserElement.set_parse_action()</code>.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_5_polygon.py</code> <pre><code>@classmethod\ndef new(cls, string: str, location: int, tokens: ParseResults) -&gt; Self:\n    \"\"\"Create instance of this class.\n\n    Created to be used as callback in `ParserElement.set_parse_action()`.\n    \"\"\"\n    exposure = MacroExpressionToken.ensure_type(tokens[\"exposure\"])\n    number_of_vertices = MacroExpressionToken.ensure_type(\n        tokens[\"number_of_vertices\"],\n    )\n    center_x = MacroExpressionToken.ensure_type(tokens[\"center_x\"])\n    center_y = MacroExpressionToken.ensure_type(tokens[\"center_y\"])\n    diameter = MacroExpressionToken.ensure_type(tokens[\"diameter\"])\n    rotation = MacroExpressionToken.ensure_type(tokens[\"rotation\"])\n    return cls(\n        string=string,\n        location=location,\n        exposure=exposure,\n        number_of_vertices=number_of_vertices,\n        center_x=center_x,\n        center_y=center_y,\n        diameter=diameter,\n        rotation=rotation,\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_5_polygon.html#pygerber.gerberx3.tokenizer.tokens.macro.statements.code_5_polygon.Code5PolygonToken.parser2_visit_token","title":"parser2_visit_token","text":"<pre><code>parser2_visit_token(context: Parser2Context) -&gt; None\n</code></pre> <p>Perform actions on the context implicated by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_5_polygon.py</code> <pre><code>def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n    \"\"\"Perform actions on the context implicated by this token.\"\"\"\n    context.get_hooks().macro_code_5_polygon.pre_parser_visit_token(\n        self,\n        context,\n    )\n    context.get_hooks().macro_code_5_polygon.on_parser_visit_token(\n        self,\n        context,\n    )\n    context.get_hooks().macro_code_5_polygon.post_parser_visit_token(\n        self,\n        context,\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_5_polygon.html#pygerber.gerberx3.tokenizer.tokens.macro.statements.code_5_polygon.Code5PolygonToken.get_gerber_code","title":"get_gerber_code","text":"<pre><code>get_gerber_code(\n    indent: str = \"\", endline: str = \"\\n\"\n) -&gt; str\n</code></pre> <p>Get gerber code represented by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_5_polygon.py</code> <pre><code>def get_gerber_code(\n    self,\n    indent: str = \"\",\n    endline: str = \"\\n\",\n) -&gt; str:\n    \"\"\"Get gerber code represented by this token.\"\"\"\n    string = self.symbol\n\n    string += f\",{self.exposure.get_gerber_code(indent, endline)}\"\n    string += f\",{self.number_of_vertices.get_gerber_code(indent, endline)}\"\n    string += f\",{self.center_x.get_gerber_code(indent, endline)}\"\n    string += f\",{self.center_y.get_gerber_code(indent, endline)}\"\n    string += f\",{self.diameter.get_gerber_code(indent, endline)}\"\n    string += f\",{self.rotation.get_gerber_code(indent, endline)}\"\n\n    return indent + string\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_6_moire.html","title":"code_6_moire","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_6_moire.html#pygerber.gerberx3.tokenizer.tokens.macro.statements.code_6_moire","title":"code_6_moire","text":"<p>Macro primitive Moire.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_6_moire.html#pygerber.gerberx3.tokenizer.tokens.macro.statements.code_6_moire.Code6MoireToken","title":"Code6MoireToken","text":"<p>             Bases: <code>MacroPrimitiveToken</code></p> <p>Moire macro primitive.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_6_moire.py</code> <pre><code>class Code6MoireToken(MacroPrimitiveToken):\n    \"\"\"Moire macro primitive.\"\"\"\n\n    def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n        \"\"\"Perform actions on the context implicated by this token.\"\"\"\n        context.get_hooks().macro_code_6_moire.pre_parser_visit_token(\n            self,\n            context,\n        )\n        context.get_hooks().macro_code_6_moire.on_parser_visit_token(\n            self,\n            context,\n        )\n        context.get_hooks().macro_code_6_moire.post_parser_visit_token(\n            self,\n            context,\n        )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_6_moire.html#pygerber.gerberx3.tokenizer.tokens.macro.statements.code_6_moire.Code6MoireToken.parser2_visit_token","title":"parser2_visit_token","text":"<pre><code>parser2_visit_token(context: Parser2Context) -&gt; None\n</code></pre> <p>Perform actions on the context implicated by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_6_moire.py</code> <pre><code>def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n    \"\"\"Perform actions on the context implicated by this token.\"\"\"\n    context.get_hooks().macro_code_6_moire.pre_parser_visit_token(\n        self,\n        context,\n    )\n    context.get_hooks().macro_code_6_moire.on_parser_visit_token(\n        self,\n        context,\n    )\n    context.get_hooks().macro_code_6_moire.post_parser_visit_token(\n        self,\n        context,\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_7_thermal.html","title":"code_7_thermal","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_7_thermal.html#pygerber.gerberx3.tokenizer.tokens.macro.statements.code_7_thermal","title":"code_7_thermal","text":"<p>Macro primitives tokens.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_7_thermal.html#pygerber.gerberx3.tokenizer.tokens.macro.statements.code_7_thermal.Code7ThermalToken","title":"Code7ThermalToken","text":"<p>             Bases: <code>MacroPrimitiveToken</code></p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_7_thermal.html#pygerber.gerberx3.tokenizer.tokens.macro.statements.code_7_thermal.Code7ThermalToken--4518-thermal-code-7","title":"4.5.1.8 Thermal, Code 7.","text":"<p>The thermal primitive is a ring (annulus) interrupted by four gaps. Exposure is always on.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_7_thermal.html#pygerber.gerberx3.tokenizer.tokens.macro.statements.code_7_thermal.Code7ThermalToken--example","title":"Example","text":"<pre><code>%AMThermal*\n7,0,0,0.95,0.75,0.175,0.0*%\n</code></pre> <p>See section 4.5.1.8 of The Gerber Layer Format Specification</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_7_thermal.py</code> <pre><code>class Code7ThermalToken(MacroPrimitiveToken):\n    \"\"\"## 4.5.1.8 Thermal, Code 7.\n\n    The thermal primitive is a ring (annulus) interrupted by four gaps. Exposure is\n    always on.\n\n    ---\n\n    ## Example\n\n    ```gerber\n    %AMThermal*\n    7,0,0,0.95,0.75,0.175,0.0*%\n    ```\n\n    ---\n\n    See section 4.5.1.8 of [The Gerber Layer Format Specification](https://www.ucamco.com/files/downloads/file_en/456/gerber-layer-format-specification-revision-2023-08_en.pdf#page=66)\n\n    \"\"\"\n\n    symbol: ClassVar[str] = \"7\"\n\n    def __init__(  # noqa: PLR0913\n        self,\n        string: str,\n        location: int,\n        center_x: MacroExpressionToken,\n        center_y: MacroExpressionToken,\n        outer_diameter: MacroExpressionToken,\n        inner_diameter: MacroExpressionToken,\n        gap: MacroExpressionToken,\n        rotation: MacroExpressionToken,\n    ) -&gt; None:\n        super().__init__(string, location)\n        self.center_x = center_x\n        self.center_y = center_y\n        self.outer_diameter = outer_diameter\n        self.inner_diameter = inner_diameter\n        self.gap = gap\n        self.rotation = rotation\n\n    @classmethod\n    def new(cls, string: str, location: int, tokens: ParseResults) -&gt; Self:\n        \"\"\"Initialize token object.\"\"\"\n        center_x = MacroExpressionToken.ensure_type(tokens[\"center_x\"])\n        center_y = MacroExpressionToken.ensure_type(tokens[\"center_y\"])\n        outer_diameter = MacroExpressionToken.ensure_type(tokens[\"outer_diameter\"])\n        inner_diameter = MacroExpressionToken.ensure_type(tokens[\"inner_diameter\"])\n        gap = MacroExpressionToken.ensure_type(tokens[\"gap\"])\n        rotation = MacroExpressionToken.ensure_type(tokens[\"rotation\"])\n\n        return cls(\n            string,\n            location,\n            center_x=center_x,\n            center_y=center_y,\n            outer_diameter=outer_diameter,\n            inner_diameter=inner_diameter,\n            gap=gap,\n            rotation=rotation,\n        )\n\n    def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n        \"\"\"Perform actions on the context implicated by this token.\"\"\"\n        context.get_hooks().macro_code_7_thermal.pre_parser_visit_token(\n            self,\n            context,\n        )\n        context.get_hooks().macro_code_7_thermal.on_parser_visit_token(\n            self,\n            context,\n        )\n        context.get_hooks().macro_code_7_thermal.post_parser_visit_token(\n            self,\n            context,\n        )\n\n    def get_gerber_code(\n        self,\n        indent: str = \"\",\n        endline: str = \"\\n\",\n    ) -&gt; str:\n        \"\"\"Get gerber code represented by this token.\"\"\"\n        string = self.symbol\n\n        string += f\",{self.center_x.get_gerber_code(indent, endline)}\"\n        string += f\",{self.center_y.get_gerber_code(indent, endline)}\"\n        string += f\",{self.outer_diameter.get_gerber_code(indent, endline)}\"\n        string += f\",{self.inner_diameter.get_gerber_code(indent, endline)}\"\n        string += f\",{self.gap.get_gerber_code(indent, endline)}\"\n        string += f\",{self.rotation.get_gerber_code(indent, endline)}\"\n\n        return indent + string\n\n    def __str__(self) -&gt; str:\n        string = super().__str__()\n\n        string += f\"\\n  {self.center_x}\"\n        string += f\"\\n  {self.center_y}\"\n        string += f\"\\n  {self.outer_diameter}\"\n        string += f\"\\n  {self.inner_diameter}\"\n        string += f\"\\n  {self.gap}\"\n        string += f\"\\n  {self.rotation}\"\n\n        return string\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_7_thermal.html#pygerber.gerberx3.tokenizer.tokens.macro.statements.code_7_thermal.Code7ThermalToken.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(\n    string: str, location: int, tokens: ParseResults\n) -&gt; Self\n</code></pre> <p>Initialize token object.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_7_thermal.py</code> <pre><code>@classmethod\ndef new(cls, string: str, location: int, tokens: ParseResults) -&gt; Self:\n    \"\"\"Initialize token object.\"\"\"\n    center_x = MacroExpressionToken.ensure_type(tokens[\"center_x\"])\n    center_y = MacroExpressionToken.ensure_type(tokens[\"center_y\"])\n    outer_diameter = MacroExpressionToken.ensure_type(tokens[\"outer_diameter\"])\n    inner_diameter = MacroExpressionToken.ensure_type(tokens[\"inner_diameter\"])\n    gap = MacroExpressionToken.ensure_type(tokens[\"gap\"])\n    rotation = MacroExpressionToken.ensure_type(tokens[\"rotation\"])\n\n    return cls(\n        string,\n        location,\n        center_x=center_x,\n        center_y=center_y,\n        outer_diameter=outer_diameter,\n        inner_diameter=inner_diameter,\n        gap=gap,\n        rotation=rotation,\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_7_thermal.html#pygerber.gerberx3.tokenizer.tokens.macro.statements.code_7_thermal.Code7ThermalToken.parser2_visit_token","title":"parser2_visit_token","text":"<pre><code>parser2_visit_token(context: Parser2Context) -&gt; None\n</code></pre> <p>Perform actions on the context implicated by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_7_thermal.py</code> <pre><code>def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n    \"\"\"Perform actions on the context implicated by this token.\"\"\"\n    context.get_hooks().macro_code_7_thermal.pre_parser_visit_token(\n        self,\n        context,\n    )\n    context.get_hooks().macro_code_7_thermal.on_parser_visit_token(\n        self,\n        context,\n    )\n    context.get_hooks().macro_code_7_thermal.post_parser_visit_token(\n        self,\n        context,\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_7_thermal.html#pygerber.gerberx3.tokenizer.tokens.macro.statements.code_7_thermal.Code7ThermalToken.get_gerber_code","title":"get_gerber_code","text":"<pre><code>get_gerber_code(\n    indent: str = \"\", endline: str = \"\\n\"\n) -&gt; str\n</code></pre> <p>Get gerber code represented by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/statements/code_7_thermal.py</code> <pre><code>def get_gerber_code(\n    self,\n    indent: str = \"\",\n    endline: str = \"\\n\",\n) -&gt; str:\n    \"\"\"Get gerber code represented by this token.\"\"\"\n    string = self.symbol\n\n    string += f\",{self.center_x.get_gerber_code(indent, endline)}\"\n    string += f\",{self.center_y.get_gerber_code(indent, endline)}\"\n    string += f\",{self.outer_diameter.get_gerber_code(indent, endline)}\"\n    string += f\",{self.inner_diameter.get_gerber_code(indent, endline)}\"\n    string += f\",{self.gap.get_gerber_code(indent, endline)}\"\n    string += f\",{self.rotation.get_gerber_code(indent, endline)}\"\n\n    return indent + string\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/statements/comment.html","title":"comment","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/statements/comment.html#pygerber.gerberx3.tokenizer.tokens.macro.statements.comment","title":"comment","text":"<p>Comment token.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/statements/comment.html#pygerber.gerberx3.tokenizer.tokens.macro.statements.comment.MacroComment","title":"MacroComment","text":"<p>             Bases: <code>MacroStatementToken</code></p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/statements/comment.html#pygerber.gerberx3.tokenizer.tokens.macro.statements.comment.MacroComment--4512-comment-code-0","title":"4.5.1.2 Comment, Code 0.","text":"<p>The comment primitive has no effect on the image but adds human-readable comments in an AM command. The comment primitive starts with the '0' code followed by a space and then a single-line text string. The text string follows the syntax for strings in section 3.4.3.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/statements/comment.html#pygerber.gerberx3.tokenizer.tokens.macro.statements.comment.MacroComment--example","title":"Example","text":"<pre><code>%AMBox*\n0 Rectangle with rounded corners, with rotation*\n0 The origin of the aperture is its center*\n0 $1 X-size*\n0 $2 Y-size*\n0 $3 Rounding radius*\n0 $4 Rotation angle, in degrees counterclockwise*\n0 Add two overlapping rectangle primitives as box body*\n21,1,$1, $2-$3-$3,0,0,$4\n21,1,$1-$3-$3,$2,0,0,$4*\n0 Add four circle primitives for the rounded corners*\n$5-$1/2*\n$6-$2/2*\n$7=2x$3*\n1,1, $7, $5-$3, $6-$3, $4*\n1,1, $7-$5+$3,$6-$3, $4*\n1,1, $7-$5+$3,-$6+$3, $4*\n1,1, $7, $5-$3,-$6+$3, $4*%\n</code></pre> <p>See section 4.5.1.2 of The Gerber Layer Format Specification Revision 2023.03</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/statements/comment.py</code> <pre><code>class MacroComment(MacroStatementToken):\n    \"\"\"## 4.5.1.2 Comment, Code 0.\n\n    The comment primitive has no effect on the image but adds human-readable comments\n    in an AM command. The comment primitive starts with the '0' code followed by a space\n    and then a single-line text string. The text string follows the syntax for strings\n    in section 3.4.3.\n\n    ---\n\n    ## Example\n\n    ```gerber\n    %AMBox*\n    0 Rectangle with rounded corners, with rotation*\n    0 The origin of the aperture is its center*\n    0 $1 X-size*\n    0 $2 Y-size*\n    0 $3 Rounding radius*\n    0 $4 Rotation angle, in degrees counterclockwise*\n    0 Add two overlapping rectangle primitives as box body*\n    21,1,$1, $2-$3-$3,0,0,$4\n    21,1,$1-$3-$3,$2,0,0,$4*\n    0 Add four circle primitives for the rounded corners*\n    $5-$1/2*\n    $6-$2/2*\n    $7=2x$3*\n    1,1, $7, $5-$3, $6-$3, $4*\n    1,1, $7-$5+$3,$6-$3, $4*\n    1,1, $7-$5+$3,-$6+$3, $4*\n    1,1, $7, $5-$3,-$6+$3, $4*%\n    ```\n\n    ---\n\n    See section 4.5.1.2 of [The Gerber Layer Format Specification Revision 2023.03](https://www.ucamco.com/files/downloads/file_en/456/gerber-layer-format-specification-revision-2023-03_en.pdf#page=59)\n    \"\"\"\n\n    def __init__(self, string: str, location: int, content: str) -&gt; None:\n        super().__init__(string, location)\n        self.content = content\n\n    @classmethod\n    def new(cls, string: str, location: int, tokens: ParseResults) -&gt; Self:\n        \"\"\"Create instance of this class.\n\n        Created to be used as callback in `ParserElement.set_parse_action()`.\n        \"\"\"\n        content: str = str(tokens[\"string\"])\n        return cls(string=string, location=location, content=content)\n\n    def get_gerber_code(\n        self,\n        indent: str = \"\",\n        endline: str = \"\\n\",  # noqa: ARG002\n    ) -&gt; str:\n        \"\"\"Get gerber code represented by this token.\"\"\"\n        return f\"{indent}0 {self.content}\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/statements/comment.html#pygerber.gerberx3.tokenizer.tokens.macro.statements.comment.MacroComment.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(\n    string: str, location: int, tokens: ParseResults\n) -&gt; Self\n</code></pre> <p>Create instance of this class.</p> <p>Created to be used as callback in <code>ParserElement.set_parse_action()</code>.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/statements/comment.py</code> <pre><code>@classmethod\ndef new(cls, string: str, location: int, tokens: ParseResults) -&gt; Self:\n    \"\"\"Create instance of this class.\n\n    Created to be used as callback in `ParserElement.set_parse_action()`.\n    \"\"\"\n    content: str = str(tokens[\"string\"])\n    return cls(string=string, location=location, content=content)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/statements/comment.html#pygerber.gerberx3.tokenizer.tokens.macro.statements.comment.MacroComment.get_gerber_code","title":"get_gerber_code","text":"<pre><code>get_gerber_code(\n    indent: str = \"\", endline: str = \"\\n\"\n) -&gt; str\n</code></pre> <p>Get gerber code represented by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/statements/comment.py</code> <pre><code>def get_gerber_code(\n    self,\n    indent: str = \"\",\n    endline: str = \"\\n\",  # noqa: ARG002\n) -&gt; str:\n    \"\"\"Get gerber code represented by this token.\"\"\"\n    return f\"{indent}0 {self.content}\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/statements/primitive.html","title":"primitive","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/statements/primitive.html#pygerber.gerberx3.tokenizer.tokens.macro.statements.primitive","title":"primitive","text":"<p>Macro primitives tokens.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/statements/primitive.html#pygerber.gerberx3.tokenizer.tokens.macro.statements.primitive.MacroPrimitiveToken","title":"MacroPrimitiveToken","text":"<p>             Bases: <code>MacroStatementToken</code></p> <p>Wrapper for macro primitive token, common base class for specialized tokens.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/statements/primitive.py</code> <pre><code>class MacroPrimitiveToken(MacroStatementToken):\n    \"\"\"Wrapper for macro primitive token, common base class for specialized tokens.\"\"\"\n\n    symbol: ClassVar[str] = \"X\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/statements/statement.html","title":"statement","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/statements/statement.html#pygerber.gerberx3.tokenizer.tokens.macro.statements.statement","title":"statement","text":"<p>Macro statement token.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/statements/statement.html#pygerber.gerberx3.tokenizer.tokens.macro.statements.statement.MacroStatementToken","title":"MacroStatementToken","text":"<p>             Bases: <code>CommandToken</code></p> <p>Wrapper for in-macro expression.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/statements/statement.py</code> <pre><code>class MacroStatementToken(CommandToken):\n    \"\"\"Wrapper for in-macro expression.\"\"\"\n\n    def evaluate(\n        self,\n        macro_context: MacroContext,\n        state: State,\n        handle: PrivateApertureHandle,\n        /,\n    ) -&gt; None:\n        \"\"\"Evaluate macro statement.\"\"\"\n\n    def get_gerber_code(\n        self,\n        indent: str = \"\",\n        endline: str = \"\\n\",  # noqa: ARG002\n    ) -&gt; str:\n        \"\"\"Get gerber code represented by this token.\"\"\"\n        return f\"{indent}0 {self.__class__.__qualname__} no formatting available\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/statements/statement.html#pygerber.gerberx3.tokenizer.tokens.macro.statements.statement.MacroStatementToken.evaluate","title":"evaluate","text":"<pre><code>evaluate(\n    macro_context: MacroContext,\n    state: State,\n    handle: PrivateApertureHandle,\n) -&gt; None\n</code></pre> <p>Evaluate macro statement.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/statements/statement.py</code> <pre><code>def evaluate(\n    self,\n    macro_context: MacroContext,\n    state: State,\n    handle: PrivateApertureHandle,\n    /,\n) -&gt; None:\n    \"\"\"Evaluate macro statement.\"\"\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/statements/statement.html#pygerber.gerberx3.tokenizer.tokens.macro.statements.statement.MacroStatementToken.get_gerber_code","title":"get_gerber_code","text":"<pre><code>get_gerber_code(\n    indent: str = \"\", endline: str = \"\\n\"\n) -&gt; str\n</code></pre> <p>Get gerber code represented by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/statements/statement.py</code> <pre><code>def get_gerber_code(\n    self,\n    indent: str = \"\",\n    endline: str = \"\\n\",  # noqa: ARG002\n) -&gt; str:\n    \"\"\"Get gerber code represented by this token.\"\"\"\n    return f\"{indent}0 {self.__class__.__qualname__} no formatting available\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/statements/variable_assignment.html","title":"variable_assignment","text":""},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/statements/variable_assignment.html#pygerber.gerberx3.tokenizer.tokens.macro.statements.variable_assignment","title":"variable_assignment","text":"<p>Macro variable definition token.</p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/statements/variable_assignment.html#pygerber.gerberx3.tokenizer.tokens.macro.statements.variable_assignment.MacroVariableAssignment","title":"MacroVariableAssignment","text":"<p>             Bases: <code>MacroStatementToken</code></p>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/statements/variable_assignment.html#pygerber.gerberx3.tokenizer.tokens.macro.statements.variable_assignment.MacroVariableAssignment--4543-definition-of-new-variable","title":"4.5.4.3 Definition of New Variable.","text":"<p>New variables can be defined by an assign statement as follows: <code>$4=$1x1.25-$3</code>. The right-hand side is any arithmetic expression as in the previous section.</p> <p>The variable values are determined as follows:</p> <ul> <li><code>$1</code>, <code>$2</code>, ..., <code>$n</code> take the values of the n parameters of the calling AD command.</li> <li>New variables get their value from their defining expression.</li> <li>The undefined variables are 0.</li> <li>Macro variables cannot be redefined.</li> </ul>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/statements/variable_assignment.html#pygerber.gerberx3.tokenizer.tokens.macro.statements.variable_assignment.MacroVariableAssignment--example-1","title":"Example #1","text":"<pre><code>%AMDONUTCAL*\n1,1,$1,$2,$3*\n$4=$1x1.25*\n1,0,$4,$2,$3*%\n</code></pre> <p>The AD command contains four parameters which define the first four macro variables:</p> <pre><code>$1 = 0.02\n$2 = 0\n$3 = 0\n$4 = 0.06\n</code></pre> <p>The variable <code>$5</code> is defined in the macro body and becomes</p> <pre><code>$5 = 0.06 x 0.25 = 0.015\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/statements/variable_assignment.html#pygerber.gerberx3.tokenizer.tokens.macro.statements.variable_assignment.MacroVariableAssignment--example-2","title":"Example #2","text":"<pre><code>%AMTEST1*\n1,1,$1,$2,$3*\n$4=$1x0.75*\n$5=($2+100)x1.75*\n1,0,$4,$5,$3*%\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/statements/variable_assignment.html#pygerber.gerberx3.tokenizer.tokens.macro.statements.variable_assignment.MacroVariableAssignment--example-3","title":"Example #3","text":"<pre><code>%AMTEST2*\n$4=$1x0.75*\n$5=100+$3*\n1,1,$1,$2,$3*\n1,0,$4,$2,$5*\n$6=$4x0.5*\n1,0,$6,$2,$5*%\n</code></pre> <p>See section 4.5.4.3 of The Gerber Layer Format Specification</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/statements/variable_assignment.py</code> <pre><code>class MacroVariableAssignment(MacroStatementToken):\n    \"\"\"## 4.5.4.3 Definition of New Variable.\n\n    New variables can be defined by an assign statement as follows: `$4=$1x1.25-$3`. The\n    right-hand side is any arithmetic expression as in the previous section.\n\n    The variable values are determined as follows:\n\n    - `$1`, `$2`, ..., `$n` take the values of the n parameters of the calling AD command.\n    - New variables get their value from their defining expression.\n    - The undefined variables are 0.\n    - Macro variables cannot be redefined.\n\n    ---\n\n    ## Example #1\n\n    ```gerber\n    %AMDONUTCAL*\n    1,1,$1,$2,$3*\n    $4=$1x1.25*\n    1,0,$4,$2,$3*%\n    ```\n\n    The AD command contains four parameters which define the first four macro variables:\n\n    ```yaml\n    $1 = 0.02\n    $2 = 0\n    $3 = 0\n    $4 = 0.06\n    ```\n\n    The variable `$5` is defined in the macro body and becomes\n\n    ```yaml\n    $5 = 0.06 x 0.25 = 0.015\n    ```\n\n    ## Example #2\n\n    ```gerber\n    %AMTEST1*\n    1,1,$1,$2,$3*\n    $4=$1x0.75*\n    $5=($2+100)x1.75*\n    1,0,$4,$5,$3*%\n    ```\n\n    ## Example #3\n\n    ```\n    %AMTEST2*\n    $4=$1x0.75*\n    $5=100+$3*\n    1,1,$1,$2,$3*\n    1,0,$4,$2,$5*\n    $6=$4x0.5*\n    1,0,$6,$2,$5*%\n    ```\n\n    ---\n\n    See section 4.5.4.3 of [The Gerber Layer Format Specification](https://www.ucamco.com/files/downloads/file_en/456/gerber-layer-format-specification-revision-2023-08_en.pdf#page=71)\n\n    \"\"\"  # noqa: E501\n\n    def __init__(\n        self,\n        string: str,\n        location: int,\n        variable: MacroVariableName,\n        value: MacroExpressionToken,\n    ) -&gt; None:\n        super().__init__(string, location)\n        self.variable = variable\n        self.value = value\n\n    @classmethod\n    def new(cls, string: str, location: int, tokens: ParseResults) -&gt; Self:\n        \"\"\"Create instance of this class.\n\n        Created to be used as callback in `ParserElement.set_parse_action()`.\n        \"\"\"\n        variable = MacroVariableName.ensure_type(tokens[\"macro_variable_name\"])\n        value = MacroExpressionToken.ensure_type(tokens[\"value\"])\n        return cls(\n            string=string,\n            location=location,\n            variable=variable,\n            value=value,\n        )\n\n    def evaluate(\n        self,\n        macro_context: MacroContext,\n        state: State,\n        handle: PrivateApertureHandle,\n    ) -&gt; None:\n        \"\"\"Evaluate macro expression.\"\"\"\n        name = self.variable.name\n        value = self.value.evaluate_numeric(macro_context, state)\n        macro_context.variables[name] = value\n\n        return super().evaluate(macro_context, state, handle)\n\n    def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n        \"\"\"Perform actions on the context implicated by this token.\"\"\"\n        context.get_hooks().macro_variable_assignment.pre_parser_visit_token(\n            self,\n            context,\n        )\n        context.get_hooks().macro_variable_assignment.on_parser_visit_token(\n            self,\n            context,\n        )\n        context.get_hooks().macro_variable_assignment.post_parser_visit_token(\n            self,\n            context,\n        )\n\n    def get_gerber_code(\n        self,\n        indent: str = \"\",\n        endline: str = \"\\n\",\n    ) -&gt; str:\n        \"\"\"Get gerber code represented by this token.\"\"\"\n        return (\n            f\"{indent}{self.variable.get_gerber_code(endline=endline)}=\"\n            f\"{self.value.get_gerber_code(endline=endline)}\"\n        )\n\n    def __str__(self) -&gt; str:\n        return f\"{super().__str__()}::[{self.variable} = {self.value}]\"\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/statements/variable_assignment.html#pygerber.gerberx3.tokenizer.tokens.macro.statements.variable_assignment.MacroVariableAssignment.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(\n    string: str, location: int, tokens: ParseResults\n) -&gt; Self\n</code></pre> <p>Create instance of this class.</p> <p>Created to be used as callback in <code>ParserElement.set_parse_action()</code>.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/statements/variable_assignment.py</code> <pre><code>@classmethod\ndef new(cls, string: str, location: int, tokens: ParseResults) -&gt; Self:\n    \"\"\"Create instance of this class.\n\n    Created to be used as callback in `ParserElement.set_parse_action()`.\n    \"\"\"\n    variable = MacroVariableName.ensure_type(tokens[\"macro_variable_name\"])\n    value = MacroExpressionToken.ensure_type(tokens[\"value\"])\n    return cls(\n        string=string,\n        location=location,\n        variable=variable,\n        value=value,\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/statements/variable_assignment.html#pygerber.gerberx3.tokenizer.tokens.macro.statements.variable_assignment.MacroVariableAssignment.evaluate","title":"evaluate","text":"<pre><code>evaluate(\n    macro_context: MacroContext,\n    state: State,\n    handle: PrivateApertureHandle,\n) -&gt; None\n</code></pre> <p>Evaluate macro expression.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/statements/variable_assignment.py</code> <pre><code>def evaluate(\n    self,\n    macro_context: MacroContext,\n    state: State,\n    handle: PrivateApertureHandle,\n) -&gt; None:\n    \"\"\"Evaluate macro expression.\"\"\"\n    name = self.variable.name\n    value = self.value.evaluate_numeric(macro_context, state)\n    macro_context.variables[name] = value\n\n    return super().evaluate(macro_context, state, handle)\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/statements/variable_assignment.html#pygerber.gerberx3.tokenizer.tokens.macro.statements.variable_assignment.MacroVariableAssignment.parser2_visit_token","title":"parser2_visit_token","text":"<pre><code>parser2_visit_token(context: Parser2Context) -&gt; None\n</code></pre> <p>Perform actions on the context implicated by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/statements/variable_assignment.py</code> <pre><code>def parser2_visit_token(self, context: Parser2Context) -&gt; None:\n    \"\"\"Perform actions on the context implicated by this token.\"\"\"\n    context.get_hooks().macro_variable_assignment.pre_parser_visit_token(\n        self,\n        context,\n    )\n    context.get_hooks().macro_variable_assignment.on_parser_visit_token(\n        self,\n        context,\n    )\n    context.get_hooks().macro_variable_assignment.post_parser_visit_token(\n        self,\n        context,\n    )\n</code></pre>"},{"location":"reference/pygerber/gerberx3/tokenizer/tokens/macro/statements/variable_assignment.html#pygerber.gerberx3.tokenizer.tokens.macro.statements.variable_assignment.MacroVariableAssignment.get_gerber_code","title":"get_gerber_code","text":"<pre><code>get_gerber_code(\n    indent: str = \"\", endline: str = \"\\n\"\n) -&gt; str\n</code></pre> <p>Get gerber code represented by this token.</p> Source code in <code>src/pygerber/gerberx3/tokenizer/tokens/macro/statements/variable_assignment.py</code> <pre><code>def get_gerber_code(\n    self,\n    indent: str = \"\",\n    endline: str = \"\\n\",\n) -&gt; str:\n    \"\"\"Get gerber code represented by this token.\"\"\"\n    return (\n        f\"{indent}{self.variable.get_gerber_code(endline=endline)}=\"\n        f\"{self.value.get_gerber_code(endline=endline)}\"\n    )\n</code></pre>"}]}